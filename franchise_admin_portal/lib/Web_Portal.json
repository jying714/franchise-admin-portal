[
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\firebase_options.dart",
    "content": [
      "// File generated for Franchise Admin Web (Web-only project)",
      "import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;",
      "import 'package:flutter/foundation.dart' show kIsWeb;",
      "",
      "class DefaultFirebaseOptions {",
      "  static FirebaseOptions get currentPlatform {",
      "    if (!kIsWeb) {",
      "      throw UnsupportedError('This config is only for web platform.');",
      "    }",
      "    return web;",
      "  }",
      "",
      "  static const FirebaseOptions web = FirebaseOptions(",
      "    apiKey: 'AIzaSyBBlWVSua4QfPefy4TRPmOT_7ErfgAuZZ4',",
      "    appId: '1:739021537990:web:e3804e106daad32cfe0dc7',",
      "    messagingSenderId: '739021537990',",
      "    projectId: 'doughboyspizzeria-2b3d2',",
      "    authDomain: 'doughboyspizzeria-2b3d2.firebaseapp.com',",
      "    storageBucket: 'doughboyspizzeria-2b3d2.firebasestorage.app',",
      "    measurementId: 'G-SJRBLVVV5Z',",
      "  );",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 22,
      "file_size": 796,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\landing_page.dart",
    "content": [
      "import 'package:http/http.dart' as http;",
      "import 'dart:convert';",
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'config/design_tokens.dart';",
      "import 'config/branding_config.dart';",
      "import 'widgets/empty_state_widget.dart';",
      "import 'dart:ui';",
      "import 'package:franchise_admin_portal/widgets/safe_logo_image.dart';",
      "",
      "// Demo asset URLs (swap for real URLs in production)",
      "const heroScreenshot =",
      "    'https://images.unsplash.com/photo-1504674900247-0877df9cc836?fit=crop&w=900&q=80';",
      "const adminDashboardScreenshot =",
      "    'https://images.unsplash.com/photo-1464983953574-0892a716854b?fit=crop&w=900&q=80';",
      "const mobileAppScreenshot =",
      "    'https://images.unsplash.com/photo-1519125323398-675f0ddb6308?fit=crop&w=900&q=80';",
      "const menuEditorScreenshot =",
      "    'https://images.unsplash.com/photo-1526178613658-3f1622045567?fit=crop&w=900&q=80';",
      "const demoVideoUrl = ''; // e.g., 'https://www.youtube.com/watch?v=xxxx'",
      "",
      "class GlassHero extends StatelessWidget {",
      "  final bool isMobile;",
      "  const GlassHero({required this.isMobile, Key? key}) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    print('[landing_page.dart] build: Unauthenticated landing page');",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    final media = MediaQuery.of(context);",
      "",
      "    return Container(",
      "      constraints: const BoxConstraints(maxWidth: 1000),",
      "      padding: EdgeInsets.symmetric(",
      "        vertical: isMobile ? 28 : 52,",
      "        horizontal: isMobile ? 0 : 0,",
      "      ),",
      "      child: Stack(",
      "        children: [",
      "          // Glassmorphism card",
      "          ClipRRect(",
      "            borderRadius: BorderRadius.circular(40),",
      "            child: BackdropFilter(",
      "              filter: ImageFilter.blur(sigmaX: 15, sigmaY: 15),",
      "              child: Container(",
      "                width: double.infinity,",
      "                decoration: BoxDecoration(",
      "                  color: Colors.white.withOpacity(0.82),",
      "                  borderRadius: BorderRadius.circular(40),",
      "                  boxShadow: [",
      "                    BoxShadow(",
      "                      color: Colors.black.withOpacity(0.06),",
      "                      blurRadius: 24,",
      "                      offset: const Offset(0, 6),",
      "                    ),",
      "                  ],",
      "                  border: Border.all(",
      "                    color: Colors.white.withOpacity(0.22),",
      "                    width: 1.5,",
      "                  ),",
      "                ),",
      "                padding: EdgeInsets.symmetric(",
      "                  vertical: isMobile ? 34 : 52,",
      "                  horizontal: isMobile ? 20 : 44,",
      "                ),",
      "                child: isMobile",
      "                    ? _verticalContent(context)",
      "                    : Row(",
      "                        crossAxisAlignment: CrossAxisAlignment.center,",
      "                        children: [",
      "                          Expanded(child: _verticalContent(context)),",
      "                          const SizedBox(width: 32),",
      "                          // Hero Image",
      "                          ClipRRect(",
      "                            borderRadius: BorderRadius.circular(30),",
      "                            child: Image.network(",
      "                              heroScreenshot,",
      "                              width: 320,",
      "                              height: 220,",
      "                              fit: BoxFit.cover,",
      "                              errorBuilder: (_, __, ___) => Image.asset(",
      "                                BrandingConfig.bannerPlaceholder,",
      "                                width: 320,",
      "                                height: 220,",
      "                                fit: BoxFit.cover,",
      "                              ),",
      "                            ),",
      "                          ),",
      "                        ],",
      "                      ),",
      "              ),",
      "            ),",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "",
      "  Widget _verticalContent(BuildContext context) {",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    final media = MediaQuery.of(context);",
      "    final isMobile = media.size.width < 700;",
      "",
      "    return Column(",
      "      crossAxisAlignment:",
      "          isMobile ? CrossAxisAlignment.center : CrossAxisAlignment.start,",
      "      mainAxisSize: MainAxisSize.min,",
      "      children: [",
      "        Text(",
      "          \"The Modern Franchise Platform\",",
      "          style: TextStyle(",
      "            fontSize: isMobile ? 21 : 28,",
      "            color: Colors.green[700],",
      "            fontWeight: FontWeight.w500,",
      "            letterSpacing: 1,",
      "            fontFamily: DesignTokens.fontFamily,",
      "          ),",
      "        ),",
      "        const SizedBox(height: 10),",
      "        Text(",
      "          \"All-in-One SaaS for Food Service Franchises\",",
      "          style: TextStyle(",
      "            fontSize: isMobile ? 34 : 48,",
      "            fontWeight: FontWeight.bold,",
      "            color: Colors.black.withOpacity(0.94),",
      "            height: 1.14,",
      "            fontFamily: DesignTokens.fontFamily,",
      "          ),",
      "          textAlign: isMobile ? TextAlign.center : TextAlign.left,",
      "        ),",
      "        const SizedBox(height: 22),",
      "        Text(",
      "          \"Ordering • Customization • Analytics • Modular Admin Tools\\nFor Franchise, Restaurant, and Food-Service Brands\",",
      "          style: TextStyle(",
      "            fontSize: isMobile ? 16 : 20,",
      "            color: Colors.black.withOpacity(0.68),",
      "            fontWeight: FontWeight.w400,",
      "            fontFamily: DesignTokens.fontFamily,",
      "          ),",
      "          textAlign: isMobile ? TextAlign.center : TextAlign.left,",
      "        ),",
      "        const SizedBox(height: 34),",
      "        Wrap(",
      "          spacing: 18,",
      "          runSpacing: 10,",
      "          alignment: WrapAlignment.start,",
      "          children: [",
      "            ElevatedButton(",
      "              onPressed: () {",
      "                print('[landing_page.dart] Login button pressed');",
      "                Navigator.of(context).pushNamed('/sign-in');",
      "              },",
      "              style: ElevatedButton.styleFrom(",
      "                backgroundColor: Colors.green[700],",
      "                foregroundColor: Colors.white,",
      "                elevation: 2,",
      "                padding:",
      "                    const EdgeInsets.symmetric(horizontal: 38, vertical: 18),",
      "                shape: RoundedRectangleBorder(",
      "                  borderRadius: BorderRadius.circular(18),",
      "                ),",
      "                textStyle: const TextStyle(",
      "                  fontSize: 20,",
      "                  fontWeight: FontWeight.bold,",
      "                ),",
      "              ),",
      "              child: const Text(\"Login\"),",
      "            ),",
      "            OutlinedButton(",
      "              onPressed: () {",
      "                // TODO: Open contact form or demo request modal",
      "              },",
      "              style: OutlinedButton.styleFrom(",
      "                foregroundColor: Colors.green[700],",
      "                side: BorderSide(color: Colors.green[700]!, width: 2.2),",
      "                padding:",
      "                    const EdgeInsets.symmetric(horizontal: 38, vertical: 18),",
      "                shape: RoundedRectangleBorder(",
      "                  borderRadius: BorderRadius.circular(18),",
      "                ),",
      "                textStyle: const TextStyle(",
      "                  fontSize: 20,",
      "                  fontWeight: FontWeight.bold,",
      "                ),",
      "              ),",
      "              child: const Text(\"Book a Demo\"),",
      "            ),",
      "          ],",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}",
      "",
      "class LandingPage extends StatelessWidget {",
      "  const LandingPage({Key? key}) : super(key: key);",
      "",
      "  // Error logging for async widget build failures",
      "  Future<void> _logErrorToBackend(String message,",
      "      {String? stack, Map<String, dynamic>? contextData}) async {",
      "    print('[landing_page.dart] _logErrorToBackend called: $message');",
      "    final uri = Uri.parse(",
      "        'https://us-central1-doughboyspizzeria-2b3d2.cloudfunctions.net/logPublicError');",
      "    try {",
      "      await http.post(",
      "        uri,",
      "        headers: {'Content-Type': 'application/json'},",
      "        body: jsonEncode({",
      "          'message': message,",
      "          'stack': stack ?? '',",
      "          'contextData': contextData ?? {},",
      "        }),",
      "      );",
      "      print('[landing_page.dart] _logErrorToBackend: POST succeeded');",
      "    } catch (e) {",
      "      print(",
      "          '[landing_page.dart] _logErrorToBackend: Failed to send log to backend: $e');",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    final media = MediaQuery.of(context);",
      "    final isMobile = media.size.width < 700;",
      "",
      "    return Scaffold(",
      "      backgroundColor: const Color(0xFFF7FAFC),",
      "      body: SafeArea(",
      "        child: SingleChildScrollView(",
      "          child: Column(",
      "            children: [",
      "              // ==== HERO SECTION ====",
      "              Container(",
      "                width: double.infinity,",
      "                padding: EdgeInsets.symmetric(",
      "                  vertical: isMobile ? 40 : 80,",
      "                  horizontal: isMobile ? 16 : 0,",
      "                ),",
      "                decoration: const BoxDecoration(",
      "                  color: Colors.transparent,",
      "                ),",
      "                child: Center(",
      "                  child: ConstrainedBox(",
      "                    constraints: const BoxConstraints(maxWidth: 1050),",
      "                    child: Center(",
      "                      child: GlassHero(",
      "                        isMobile: isMobile,",
      "                      ),",
      "                    ),",
      "                  ),",
      "                ),",
      "              ),",
      "",
      "              // ==== ABOUT/BRAND VALUE SECTION ====",
      "              Padding(",
      "                padding:",
      "                    const EdgeInsets.symmetric(vertical: 40, horizontal: 12),",
      "                child: Center(",
      "                  child: ConstrainedBox(",
      "                    constraints: const BoxConstraints(maxWidth: 900),",
      "                    child: Card(",
      "                      elevation: 0,",
      "                      shape: RoundedRectangleBorder(",
      "                          borderRadius: BorderRadius.circular(22)),",
      "                      color: Colors.white,",
      "                      child: Padding(",
      "                        padding: const EdgeInsets.symmetric(",
      "                            vertical: 40, horizontal: 38),",
      "                        child: Column(",
      "                          children: [",
      "                            Icon(Icons.info_outline,",
      "                                color: colorScheme.primary, size: 36),",
      "                            const SizedBox(height: 10),",
      "                            Text(",
      "                              \"Why Choose FranchiseHQ?\",",
      "                              style: TextStyle(",
      "                                fontSize: 28,",
      "                                fontWeight: FontWeight.bold,",
      "                                color: colorScheme.primary,",
      "                              ),",
      "                              textAlign: TextAlign.center,",
      "                            ),",
      "                            const SizedBox(height: 14),",
      "                            Text(",
      "                              \"Empower your brand with a unified, modular cloud platform built for modern food-service franchises. Launch your own branded ordering apps, customize workflows, and manage locations, staff, analytics, and menus — all from one scalable, secure SaaS hub.\",",
      "                              style: TextStyle(",
      "                                fontSize: 18,",
      "                                color: Colors.grey[700],",
      "                              ),",
      "                              textAlign: TextAlign.center,",
      "                            ),",
      "                          ],",
      "                        ),",
      "                      ),",
      "                    ),",
      "                  ),",
      "                ),",
      "              ),",
      "",
      "              // ==== FEATURES SECTION ====",
      "              Container(",
      "                width: double.infinity,",
      "                color: colorScheme.background,",
      "                padding: const EdgeInsets.symmetric(vertical: 36),",
      "                child: Center(",
      "                  child: ConstrainedBox(",
      "                    constraints: const BoxConstraints(maxWidth: 1100),",
      "                    child: Column(",
      "                      crossAxisAlignment: CrossAxisAlignment.center,",
      "                      children: [",
      "                        Text(",
      "                          \"Key Platform Features\",",
      "                          style: TextStyle(",
      "                            fontSize: 26,",
      "                            color: colorScheme.primary,",
      "                            fontWeight: FontWeight.bold,",
      "                          ),",
      "                        ),",
      "                        const SizedBox(height: 30),",
      "                        GridView(",
      "                          shrinkWrap: true,",
      "                          physics: const NeverScrollableScrollPhysics(),",
      "                          gridDelegate:",
      "                              SliverGridDelegateWithFixedCrossAxisCount(",
      "                            crossAxisCount: isMobile ? 1 : 3,",
      "                            mainAxisSpacing: 24,",
      "                            crossAxisSpacing: 24,",
      "                            childAspectRatio: 1.8,",
      "                          ),",
      "                          children: [",
      "                            _featureCard(",
      "                                Icons.phone_android,",
      "                                \"Mobile Ordering & Branded Apps\",",
      "                                \"Launch iOS/Android/Tablet apps with your own logo & menu.\"),",
      "                            _featureCard(",
      "                                Icons.dashboard_customize,",
      "                                \"Modular Admin Tools\",",
      "                                \"Custom workflows, dashboards, permissions & brand settings.\"),",
      "                            _featureCard(",
      "                                Icons.menu_book,",
      "                                \"Live Menu Management\",",
      "                                \"Drag-n-drop builder, dayparting, images, and modifiers.\"),",
      "                            _featureCard(",
      "                                Icons.attach_money,",
      "                                \"Integrated Payments & Analytics\",",
      "                                \"Full payment support, real-time sales, location/region analytics.\"),",
      "                            _featureCard(Icons.lock, \"Role-Based Secure Access\",",
      "                                \"Owner, franchisee, and staff-level controls — multi-location ready.\"),",
      "                            _featureCard(",
      "                                Icons.support_agent,",
      "                                \"Integrated Support\",",
      "                                \"Built-in chat, ticketing, knowledge base, and feedback.\"),",
      "                          ],",
      "                        ),",
      "                      ],",
      "                    ),",
      "                  ),",
      "                ),",
      "              ),",
      "",
      "              // ==== SCREENSHOTS/GALLERY SECTION ====",
      "              Padding(",
      "                padding:",
      "                    const EdgeInsets.symmetric(vertical: 38, horizontal: 10),",
      "                child: Center(",
      "                  child: ConstrainedBox(",
      "                    constraints: const BoxConstraints(maxWidth: 1100),",
      "                    child: Column(",
      "                      crossAxisAlignment: CrossAxisAlignment.center,",
      "                      children: [",
      "                        Text(",
      "                          \"Product Showcase\",",
      "                          style: TextStyle(",
      "                            fontSize: 25,",
      "                            color: colorScheme.secondary,",
      "                            fontWeight: FontWeight.bold,",
      "                          ),",
      "                        ),",
      "                        const SizedBox(height: 26),",
      "                        GridView.count(",
      "                          crossAxisCount: isMobile ? 1 : 3,",
      "                          shrinkWrap: true,",
      "                          physics: const NeverScrollableScrollPhysics(),",
      "                          mainAxisSpacing: 16,",
      "                          crossAxisSpacing: 16,",
      "                          children: [",
      "                            _galleryCard(",
      "                                mobileAppScreenshot, \"Mobile App Experience\"),",
      "                            _galleryCard(",
      "                                adminDashboardScreenshot, \"Admin Dashboard\"),",
      "                            _galleryCard(menuEditorScreenshot,",
      "                                \"Menu Editor & Customization\"),",
      "                          ],",
      "                        ),",
      "                      ],",
      "                    ),",
      "                  ),",
      "                ),",
      "              ),",
      "",
      "              // ==== DEMO VIDEO SECTION ====",
      "              if (demoVideoUrl.isNotEmpty)",
      "                Padding(",
      "                  padding:",
      "                      const EdgeInsets.symmetric(vertical: 30, horizontal: 12),",
      "                  child: Center(",
      "                    child: ConstrainedBox(",
      "                      constraints: const BoxConstraints(maxWidth: 900),",
      "                      child: Card(",
      "                        elevation: 6,",
      "                        shape: RoundedRectangleBorder(",
      "                            borderRadius: BorderRadius.circular(18)),",
      "                        child: Padding(",
      "                          padding: const EdgeInsets.all(32),",
      "                          child: Column(",
      "                            mainAxisAlignment: MainAxisAlignment.center,",
      "                            children: [",
      "                              Icon(Icons.play_circle_fill_rounded,",
      "                                  size: 54, color: colorScheme.primary),",
      "                              const SizedBox(height: 18),",
      "                              Text(\"See It In Action\",",
      "                                  style: TextStyle(",
      "                                      fontSize: 24,",
      "                                      fontWeight: FontWeight.bold,",
      "                                      color: colorScheme.primary)),",
      "                              const SizedBox(height: 10),",
      "                              AspectRatio(",
      "                                aspectRatio: 16 / 9,",
      "                                child: Container(",
      "                                  decoration: BoxDecoration(",
      "                                    color: Colors.black,",
      "                                    borderRadius: BorderRadius.circular(16),",
      "                                  ),",
      "                                  child: Center(",
      "                                    child: Icon(",
      "                                      Icons.play_circle_outline,",
      "                                      size: 68,",
      "                                      color: Colors.white70,",
      "                                    ),",
      "                                  ),",
      "                                ),",
      "                              ),",
      "                              const SizedBox(height: 18),",
      "                              OutlinedButton.icon(",
      "                                icon: const Icon(Icons.open_in_new),",
      "                                label: const Text(\"Watch Demo Video\"),",
      "                                onPressed: () {",
      "                                  // TODO: open demo video url in new tab",
      "                                },",
      "                              ),",
      "                            ],",
      "                          ),",
      "                        ),",
      "                      ),",
      "                    ),",
      "                  ),",
      "                ),",
      "",
      "              // ==== FUTURE FEATURE / CTA ====",
      "              Padding(",
      "                padding:",
      "                    const EdgeInsets.symmetric(vertical: 30, horizontal: 12),",
      "                child: Center(",
      "                  child: ConstrainedBox(",
      "                    constraints: const BoxConstraints(maxWidth: 900),",
      "                    child: Card(",
      "                      shape: RoundedRectangleBorder(",
      "                          borderRadius: BorderRadius.circular(16)),",
      "                      elevation: 0,",
      "                      color: colorScheme.background,",
      "                      child: Padding(",
      "                        padding: const EdgeInsets.symmetric(",
      "                            vertical: 34, horizontal: 28),",
      "                        child: Column(",
      "                          children: [",
      "                            Icon(Icons.new_releases_rounded,",
      "                                color: colorScheme.secondary, size: 36),",
      "                            const SizedBox(height: 10),",
      "                            Text(",
      "                              \"White-Label, API-first. Launch Fast.\",",
      "                              style: TextStyle(",
      "                                fontSize: 21,",
      "                                fontWeight: FontWeight.bold,",
      "                                color: colorScheme.secondary,",
      "                              ),",
      "                              textAlign: TextAlign.center,",
      "                            ),",
      "                            const SizedBox(height: 10),",
      "                            Text(",
      "                              \"Talk to our team about custom integrations, multi-brand support, and migration assistance. Our modular platform grows with you.\",",
      "                              style: TextStyle(",
      "                                fontSize: 17,",
      "                                color: Colors.grey[700],",
      "                              ),",
      "                              textAlign: TextAlign.center,",
      "                            ),",
      "                          ],",
      "                        ),",
      "                      ),",
      "                    ),",
      "                  ),",
      "                ),",
      "              ),",
      "",
      "              // ==== FOOTER ====",
      "              Padding(",
      "                padding:",
      "                    const EdgeInsets.symmetric(vertical: 32, horizontal: 14),",
      "                child: Text(",
      "                  \"© ${DateTime.now().year} FranchiseHQ | Modular SaaS for Restaurants & Franchises | info@yourplatform.com\",",
      "                  style: TextStyle(",
      "                    color: Colors.grey[500],",
      "                    fontSize: 15,",
      "                    fontWeight: FontWeight.w400,",
      "                  ),",
      "                  textAlign: TextAlign.center,",
      "                ),",
      "              ),",
      "            ],",
      "          ),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  // ---- Custom UI Card Widgets ----",
      "",
      "  static Widget _featureCard(IconData icon, String title, String desc) {",
      "    return Card(",
      "      elevation: 4,",
      "      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(18)),",
      "      child: Padding(",
      "        padding: const EdgeInsets.all(26),",
      "        child: Column(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            Icon(icon, size: 34, color: Colors.redAccent),",
      "            const SizedBox(height: 16),",
      "            Text(",
      "              title,",
      "              style: const TextStyle(",
      "                fontSize: 18,",
      "                fontWeight: FontWeight.bold,",
      "                letterSpacing: 0.2,",
      "              ),",
      "            ),",
      "            const SizedBox(height: 10),",
      "            Expanded(",
      "              child: Text(",
      "                desc,",
      "                style: TextStyle(",
      "                    fontSize: 15, color: Colors.grey[700], height: 1.2),",
      "              ),",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  static Widget _galleryCard(String url, String label) {",
      "    return Card(",
      "      elevation: 2,",
      "      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),",
      "      child: Column(",
      "        crossAxisAlignment: CrossAxisAlignment.center,",
      "        children: [",
      "          ClipRRect(",
      "            borderRadius: const BorderRadius.vertical(top: Radius.circular(20)),",
      "            child: Image.network(",
      "              url,",
      "              height: 155,",
      "              width: double.infinity,",
      "              fit: BoxFit.cover,",
      "              errorBuilder: (_, __, ___) => Image.asset(",
      "                BrandingConfig.menuItemPlaceholderImage,",
      "                height: 155,",
      "                width: double.infinity,",
      "                fit: BoxFit.cover,",
      "              ),",
      "            ),",
      "          ),",
      "          const SizedBox(height: 8),",
      "          Padding(",
      "            padding: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 6),",
      "            child: Text(",
      "              label,",
      "              style: const TextStyle(fontSize: 15, fontWeight: FontWeight.w500),",
      "              textAlign: TextAlign.center,",
      "            ),",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 613,
      "file_size": 25054,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\main.dart",
    "content": [
      "// File: lib/main.dart",
      "",
      "import 'dart:async';",
      "import 'package:flutter/material.dart';",
      "import 'package:firebase_core/firebase_core.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:firebase_auth/firebase_auth.dart' as fb_auth;",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:flutter_localizations/flutter_localizations.dart';",
      "import 'package:franchise_admin_portal/admin/hq_owner/widgets/alert_list_screen.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/firebase_options.dart';",
      "import 'package:franchise_admin_portal/core/services/auth_service.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/services/analytics_service.dart';",
      "import 'package:franchise_admin_portal/core/theme_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/user_profile_notifier.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_gate.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/landing_page.dart';",
      "import 'package:franchise_admin_portal/admin/sign_in/sign_in_screen.dart';",
      "import 'package:franchise_admin_portal/widgets/profile_gate_screen.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/admin_dashboard_screen.dart';",
      "import 'package:franchise_admin_portal/admin/developer/developer_dashboard_screen.dart';",
      "import 'package:franchise_admin_portal/admin/franchise/franchise_selector_screen.dart';",
      "import 'package:franchise_admin_portal/admin/hq_owner/owner_hq_dashboard_screen.dart';",
      "import 'package:franchise_admin_portal/admin/hq_owner/screens/invoice_list_screen.dart';",
      "import 'package:franchise_admin_portal/admin/hq_owner/screens/invoice_detail_screen.dart';",
      "import 'package:franchise_admin_portal/admin/hq_owner/payout_list_screen.dart';",
      "import 'package:franchise_admin_portal/core/providers/payout_filter_provider.dart';",
      "import 'package:franchise_admin_portal/admin/owner/platform_owner_dashboard_screen.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchisee_invitation_provider.dart';",
      "import 'package:franchise_admin_portal/widgets/financials/franchisee_invitation_service.dart';",
      "import 'package:franchise_admin_portal/admin/profile/universal_profile_screen.dart';",
      "import 'package:franchise_admin_portal/admin/auth/invite_accept_screen.dart';",
      "import 'package:franchise_admin_portal/admin/profile/franchise_onboarding_screen.dart';",
      "import 'package:franchise_admin_portal/admin/owner/screens/full_platform_plans_screen.dart';",
      "import 'package:franchise_admin_portal/admin/hq_owner/screens/available_platform_plans_screen.dart';",
      "import 'package:franchise_admin_portal/core/providers/platform_plan_selection_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_subscription_provider.dart';",
      "import 'package:franchise_admin_portal/core/services/franchise_subscription_service.dart';",
      "import 'package:franchise_admin_portal/admin/owner/screens/full_franchise_subscription_list_screen.dart';",
      "import 'package:franchise_admin_portal/admin/devtools/billing/billing_subscription_tools_screen.dart';",
      "import 'package:franchise_admin_portal/admin/devtools/subscriptions/subscription_dev_tools_screen.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_info_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/onboarding_progress_provider.dart';",
      "import 'package:franchise_admin_portal/core/section_registry.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/screens/onboarding_menu_screen.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/screens/onboarding_ingredients_screen.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/screens/onboarding_ingredient_type_screen.dart';",
      "import 'package:franchise_admin_portal/core/models/dashboard_section.dart';",
      "import 'package:franchise_admin_portal/core/providers/ingredient_type_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/ingredient_metadata_provider.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/screens/onboarding_categories_screen.dart';",
      "import 'package:franchise_admin_portal/core/providers/category_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/menu_item_provider.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/screens/onboarding_menu_items_screen.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_feature_provider.dart';",
      "import 'package:franchise_admin_portal/core/services/franchise_feature_service.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/screens/onboarding_feature_setup_screen.dart';",
      "import 'package:franchise_admin_portal/core/providers/restaurant_type_provider.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/screens/menu_item_editor_screen.dart';",
      "import 'package:franchise_admin_portal/core/services/audit_log_service.dart';",
      "import 'package:franchise_admin_portal/core/providers/onboarding_review_provider.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/screens/onboarding_review_screen.dart';",
      "import 'dart:html' as html;",
      "",
      "// (Include ALL your other screen/provider/model imports here)",
      "",
      "final GlobalKey<NavigatorState> navigatorKey = GlobalKey<NavigatorState>();",
      "",
      "/// Returns initial unauth route and optional invite token, e.g. ('/invite-accept', 'abc123').",
      "Map<String, dynamic> getInitialUnauthRoute() {",
      "  final currentUser = fb_auth.FirebaseAuth.instance.currentUser;",
      "  if (currentUser != null) {",
      "    print(",
      "        '[getInitialUnauthRoute] User is signed in. Skipping invite-accept route.');",
      "    return {'route': '/', 'token': ''};",
      "  }",
      "  final hash = html.window.location.hash;",
      "  print(",
      "      '[main.dart][getInitialUnauthRoute] Current window.location.hash: $hash');",
      "  if (hash.startsWith('#/invite-accept')) {",
      "    final queryIndex = hash.indexOf('?');",
      "    String token = '';",
      "    if (queryIndex != -1) {",
      "      final queryString = hash.substring(queryIndex + 1);",
      "      print(",
      "          '[main.dart][getInitialUnauthRoute] Extracted query string: $queryString');",
      "      try {",
      "        final params = Uri.splitQueryString(queryString);",
      "        token = params['token'] ?? '';",
      "        print('[main.dart][getInitialUnauthRoute] Found token param: $token');",
      "      } catch (e, stack) {",
      "        print(",
      "            '[main.dart][getInitialUnauthRoute] Error parsing query string: $e\\n$stack');",
      "      }",
      "    } else {",
      "      print('[main.dart][getInitialUnauthRoute] No query string found after ?');",
      "    }",
      "    return {",
      "      'route': '/invite-accept',",
      "      'token': token,",
      "    };",
      "  }",
      "  print(",
      "      '[main.dart][getInitialUnauthRoute] No invite-accept hash found. Defaulting to landing.');",
      "  return {",
      "    'route': '/',",
      "    'token': '',",
      "  };",
      "}",
      "",
      "void main() {",
      "  FlutterError.onError = (FlutterErrorDetails details) {",
      "    FlutterError.presentError(details);",
      "    debugPrint('[GLOBAL ERROR] ${details.exceptionAsString()}');",
      "    debugPrintStack(stackTrace: details.stack);",
      "    ErrorWidget.builder = (FlutterErrorDetails details) {",
      "      debugPrint('ErrorWidget: ${details.exceptionAsString()}');",
      "      return Center(child: Text('Error: ${details.exceptionAsString()}'));",
      "    };",
      "  };",
      "  print('[main.dart] main(): Starting runZonedGuarded.');",
      "  runZonedGuarded(() async {",
      "    print('[main.dart] runZonedGuarded: Initializing Flutter bindings.');",
      "    WidgetsFlutterBinding.ensureInitialized();",
      "",
      "    print('[main.dart] runZonedGuarded: Initializing Firebase.');",
      "    await Firebase.initializeApp(",
      "      options: DefaultFirebaseOptions.currentPlatform,",
      "    );",
      "    await fb_auth.FirebaseAuth.instance.setPersistence(",
      "      fb_auth.Persistence.LOCAL,",
      "    );",
      "    print(",
      "        '[main.dart] runZonedGuarded: Firebase initialized and persistence set.');",
      "",
      "    FlutterError.onError = (FlutterErrorDetails details) async {",
      "      print('[main.dart] FlutterError.onError: ${details.exceptionAsString()}');",
      "      print(details.stack);",
      "      FlutterError.dumpErrorToConsole(details);",
      "      await ErrorLogger.log(",
      "        message: details.exceptionAsString(),",
      "        stack: details.stack?.toString(),",
      "        source: 'FlutterError',",
      "        severity: 'fatal',",
      "        screen: 'main',",
      "        contextData: {",
      "          'library': details.library,",
      "          'context':",
      "              details.context?.toDescription() ?? details.context.toString(),",
      "        },",
      "      );",
      "    };",
      "",
      "    final firestoreService = FirestoreService();",
      "    runApp(",
      "      MultiProvider(",
      "        providers: [",
      "          ChangeNotifierProvider(create: (_) => UserProfileNotifier()),",
      "          ChangeNotifierProvider(",
      "              create: (_) => FranchiseProvider()), // ✅ REQUIRED",
      "          ChangeNotifierProvider(create: (_) => AuthService()),",
      "          ChangeNotifierProvider(create: (_) => ThemeProvider()),",
      "          Provider<FirestoreService>.value(value: firestoreService),",
      "          Provider(create: (_) => AnalyticsService()),",
      "          StreamProvider<fb_auth.User?>.value(",
      "            value: fb_auth.FirebaseAuth.instance.authStateChanges(),",
      "            initialData: null,",
      "          ),",
      "        ],",
      "        child: const FranchiseAppRootSplit(),",
      "      ),",
      "    );",
      "  }, (Object error, StackTrace stack) async {",
      "    print('[main.dart] runZonedGuarded: Uncaught error: $error');",
      "    await ErrorLogger.log(",
      "      message: error.toString(),",
      "      stack: stack.toString(),",
      "      source: 'runZonedGuarded',",
      "      severity: 'fatal',",
      "      screen: 'main',",
      "    );",
      "  });",
      "}",
      "",
      "/// Returns a non-null themeMode for MaterialApp, with debug prints and ultra-defensive fallback.",
      "ThemeMode safeThemeMode(BuildContext context) {",
      "  try {",
      "    final themeMode =",
      "        Provider.of<ThemeProvider>(context, listen: true).themeMode;",
      "    print('[main.dart][safeThemeMode] ThemeProvider.themeMode = $themeMode');",
      "    return themeMode ?? ThemeMode.system;",
      "  } catch (e, stack) {",
      "    print(",
      "        '[main.dart][safeThemeMode] ThemeProvider not found in context: $e\\n$stack');",
      "    return ThemeMode.system;",
      "  }",
      "}",
      "",
      "/// Root widget that cleanly splits unauthenticated vs authenticated",
      "class FranchiseAppRootSplit extends StatelessWidget {",
      "  const FranchiseAppRootSplit({super.key});",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final firebaseUser = Provider.of<fb_auth.User?>(context);",
      "    print('[main.dart][FranchiseAppRootSplit] firebaseUser: $firebaseUser');",
      "",
      "    final userNotifier =",
      "        Provider.of<UserProfileNotifier>(context, listen: false);",
      "    if (firebaseUser != null &&",
      "        userNotifier.user == null &&",
      "        !userNotifier.loading) {",
      "      WidgetsBinding.instance.addPostFrameCallback((_) {",
      "        userNotifier",
      "            .loadUser(); // ✅ defer user loading until firebaseUser is available",
      "      });",
      "    }",
      "",
      "    // ==== UNAUTHENTICATED APP ====",
      "    if (firebaseUser == null) {",
      "      print(",
      "          '[main.dart][FranchiseAppRootSplit] Unauthenticated: showing public app');",
      "      return Builder(",
      "        builder: (ctx) {",
      "          final initial = getInitialUnauthRoute();",
      "          final String initialRoute = initial['route'] as String;",
      "          final String inviteToken = initial['token'] as String;",
      "          print(",
      "              '[main.dart][FranchiseAppRootSplit] Unauthed initialRoute: $initialRoute, inviteToken: $inviteToken');",
      "          debugPrint(",
      "              'AppLocalizations.supportedLocales: ${AppLocalizations.supportedLocales}');",
      "",
      "          return MaterialApp(",
      "            navigatorKey: navigatorKey,",
      "            debugShowCheckedModeBanner: false,",
      "            title: 'Franchise Admin Portal',",
      "            theme: _lightTheme,",
      "            darkTheme: _darkTheme,",
      "            themeMode:",
      "                Provider.of<ThemeProvider>(context, listen: true).themeMode ??",
      "                    ThemeMode.system,",
      "            localizationsDelegates: const [",
      "              AppLocalizations.delegate,",
      "              GlobalMaterialLocalizations.delegate,",
      "              GlobalWidgetsLocalizations.delegate,",
      "              GlobalCupertinoLocalizations.delegate,",
      "            ],",
      "            supportedLocales: AppLocalizations.supportedLocales,",
      "            initialRoute: initialRoute,",
      "            onGenerateRoute: (RouteSettings settings) {",
      "              print(",
      "                  '[DEBUG][main.dart][onGenerateRoute] [UNAUTH] route=${settings.name}, args=${settings.arguments}');",
      "              Uri uri = Uri.parse(settings.name ?? '/');",
      "              final String path = uri.path;",
      "",
      "              if (path == '/' || path == '/landing') {",
      "                return MaterialPageRoute(builder: (_) => const LandingPage());",
      "              }",
      "              if (path == '/sign-in') {",
      "                return MaterialPageRoute(builder: (_) => const SignInScreen());",
      "              }",
      "              if (path == '/invite-accept') {",
      "                String? token;",
      "                if (uri.queryParameters.containsKey('token')) {",
      "                  token = uri.queryParameters['token'];",
      "                } else if (settings.arguments is Map &&",
      "                    (settings.arguments as Map).containsKey('token')) {",
      "                  token = (settings.arguments as Map)['token'] as String?;",
      "                } else if (inviteToken.isNotEmpty) {",
      "                  token = inviteToken;",
      "                }",
      "",
      "                return MaterialPageRoute(",
      "                  builder: (_) => InviteAcceptScreen(inviteToken: token),",
      "                );",
      "              }",
      "",
      "              return MaterialPageRoute(builder: (_) => const LandingPage());",
      "            },",
      "          );",
      "        },",
      "      );",
      "    }",
      "",
      "    // ==== AUTHENTICATED APP ====",
      "    return Selector<UserProfileNotifier, bool>(",
      "      selector: (_, notifier) => notifier.user != null && !notifier.loading,",
      "      builder: (context, isUserReady, _) {",
      "        final franchiseProvider =",
      "            Provider.of<FranchiseProvider>(context, listen: false);",
      "        final userNotifier =",
      "            Provider.of<UserProfileNotifier>(context, listen: false);",
      "        final firebaseUser = Provider.of<fb_auth.User?>(context, listen: false);",
      "",
      "        final user = userNotifier.user;",
      "        final requiresFranchise = user?.isFranchiseRequired ?? true;",
      "        final fid = franchiseProvider.franchiseId;",
      "        final isFranchiseReady = !requiresFranchise ||",
      "            (fid != null && fid.isNotEmpty && fid != 'unknown');",
      "",
      "        if (!isUserReady || !isFranchiseReady) {",
      "          debugPrint('[FranchiseAppRootSplit] ⏳ Waiting for readiness...');",
      "          debugPrint('[FranchiseAppRootSplit] firebaseUser: $firebaseUser');",
      "          debugPrint('[FranchiseAppRootSplit] isUserReady = $isUserReady');",
      "          debugPrint(",
      "              '[FranchiseAppRootSplit] isFranchiseReady = $isFranchiseReady');",
      "          debugPrint('[FranchiseAppRootSplit] user = $user');",
      "          debugPrint(",
      "              '[FranchiseAppRootSplit] user loading = ${userNotifier.loading}');",
      "          debugPrint('[FranchiseAppRootSplit] franchiseId = $fid');",
      "          return const MaterialApp(",
      "            home: Scaffold(",
      "              body: Center(child: CircularProgressIndicator()),",
      "            ),",
      "          );",
      "        }",
      "",
      "        // ========= FULL BUSINESS PROVIDER TREE =========",
      "        return MultiProvider(",
      "          providers: [",
      "            ChangeNotifierProvider(create: (_) => AdminUserProvider()),",
      "            ChangeNotifierProxyProvider<FranchiseProvider,",
      "                FranchiseSubscriptionNotifier>(",
      "              create: (_) => FranchiseSubscriptionNotifier(",
      "                service: FranchiseSubscriptionService(),",
      "                franchiseId: '',",
      "              ),",
      "              update: (_, franchiseProvider, notifier) {",
      "                final fid = franchiseProvider.franchiseId;",
      "                final userNotifier =",
      "                    Provider.of<UserProfileNotifier>(_, listen: false);",
      "                final userRoles = userNotifier.user?.roles ?? [];",
      "",
      "                notifier ??= FranchiseSubscriptionNotifier(",
      "                  service: FranchiseSubscriptionService(),",
      "                  franchiseId: fid,",
      "                );",
      "",
      "                notifier.setUserRoles(userRoles);",
      "",
      "                if (franchiseProvider.hasValidFranchise &&",
      "                    fid.isNotEmpty &&",
      "                    fid != notifier.franchiseId) {",
      "                  notifier.updateFranchiseId(fid);",
      "                }",
      "",
      "                return notifier;",
      "              },",
      "            ),",
      "            ChangeNotifierProvider(",
      "                create: (_) => PlatformPlanSelectionProvider()),",
      "            Provider<FirestoreService>.value(value: FirestoreService()),",
      "            ChangeNotifierProxyProvider2<FranchiseProvider, FirestoreService,",
      "                FranchiseInfoProvider>(",
      "              create: (_) => FranchiseInfoProvider(",
      "                firestore: Provider.of<FirestoreService>(_, listen: false),",
      "                franchiseProvider:",
      "                    Provider.of<FranchiseProvider>(_, listen: false),",
      "              ),",
      "              update: (_, franchiseProvider, firestoreService, previous) {",
      "                final provider = previous ??",
      "                    FranchiseInfoProvider(",
      "                      firestore: firestoreService,",
      "                      franchiseProvider: franchiseProvider,",
      "                    );",
      "                provider.loadFranchiseInfo();",
      "                return provider;",
      "              },",
      "            ),",
      "            ChangeNotifierProxyProvider2<FranchiseProvider, FirestoreService,",
      "                FranchiseFeatureProvider>(",
      "              create: (_) => FranchiseFeatureProvider(",
      "                service: FranchiseFeatureService(),",
      "                franchiseId: '',",
      "              ),",
      "              update: (_, franchiseProvider, firestoreService, previous) {",
      "                final fid = franchiseProvider.franchiseId;",
      "                if (!franchiseProvider.hasValidFranchise) return previous!;",
      "                final provider = previous ??",
      "                    FranchiseFeatureProvider(",
      "                      service: FranchiseFeatureService(),",
      "                      franchiseId: fid,",
      "                    );",
      "                if (fid.isNotEmpty && fid != provider.currentFranchiseId) {",
      "                  provider.setFranchiseId(fid);",
      "                }",
      "                return provider;",
      "              },",
      "            ),",
      "            ChangeNotifierProxyProvider2<FirestoreService, FranchiseProvider,",
      "                OnboardingProgressProvider>(",
      "              create: (_) => OnboardingProgressProvider(",
      "                firestore: Provider.of<FirestoreService>(_, listen: false),",
      "                franchiseId: '',",
      "              ),",
      "              update: (_, firestoreService, franchiseProvider, previous) {",
      "                final fid = franchiseProvider.franchiseId ?? '';",
      "                final provider = previous ??",
      "                    OnboardingProgressProvider(",
      "                      firestore: firestoreService,",
      "                      franchiseId: fid,",
      "                    );",
      "                if (fid.isNotEmpty && fid != provider.franchiseId) {",
      "                  return OnboardingProgressProvider(",
      "                    firestore: firestoreService,",
      "                    franchiseId: fid,",
      "                  );",
      "                }",
      "                return provider;",
      "              },",
      "            ),",
      "            ChangeNotifierProxyProvider2<FirestoreService,",
      "                FranchiseInfoProvider, IngredientMetadataProvider>(",
      "              create: (_) => IngredientMetadataProvider(",
      "                firestoreService:",
      "                    Provider.of<FirestoreService>(_, listen: false),",
      "                franchiseId: '',",
      "              ),",
      "              update: (_, firestore, franchiseInfo, previous) {",
      "                final franchiseId = franchiseInfo.franchise?.id ?? '';",
      "                final provider = previous ??",
      "                    IngredientMetadataProvider(",
      "                      firestoreService: firestore,",
      "                      franchiseId: franchiseId,",
      "                    );",
      "                if (franchiseId.isNotEmpty &&",
      "                    franchiseId != provider.franchiseId &&",
      "                    franchiseId != 'unknown') {",
      "                  return IngredientMetadataProvider(",
      "                    firestoreService: firestore,",
      "                    franchiseId: franchiseId,",
      "                  )..load();",
      "                }",
      "                return provider;",
      "              },",
      "            ),",
      "            ChangeNotifierProxyProvider2<FirestoreService, FranchiseProvider,",
      "                CategoryProvider>(",
      "              create: (_) => CategoryProvider(",
      "                firestore: Provider.of<FirestoreService>(_, listen: false),",
      "                franchiseId: '',",
      "              ),",
      "              update: (_, firestore, franchiseProvider, previous) {",
      "                final fid = franchiseProvider.franchiseId;",
      "                if (!franchiseProvider.hasValidFranchise) return previous!;",
      "                final provider = previous ??",
      "                    CategoryProvider(",
      "                      firestore: firestore,",
      "                      franchiseId: fid,",
      "                    );",
      "                if (fid.isNotEmpty && fid != provider.franchiseId) {",
      "                  provider.updateFranchiseId(fid);",
      "                }",
      "                return provider;",
      "              },",
      "            ),",
      "            ChangeNotifierProxyProvider3<FirestoreService, FranchiseProvider,",
      "                FranchiseInfoProvider, MenuItemProvider>(",
      "              create: (_) => MenuItemProvider(",
      "                firestoreService:",
      "                    Provider.of<FirestoreService>(_, listen: false),",
      "                franchiseInfoProvider:",
      "                    Provider.of<FranchiseInfoProvider>(_, listen: false),",
      "              ),",
      "              update: (_, firestoreService, franchiseProvider,",
      "                  franchiseInfoProvider, previous) {",
      "                final fid = franchiseProvider.franchiseId;",
      "                if (!franchiseProvider.hasValidFranchise) return previous!;",
      "                final provider = previous ??",
      "                    MenuItemProvider(",
      "                      firestoreService: firestoreService,",
      "                      franchiseInfoProvider: franchiseInfoProvider,",
      "                    );",
      "                provider.franchiseInfoProvider = franchiseInfoProvider;",
      "                if (fid.isNotEmpty && fid != 'unknown') {",
      "                  provider.loadMenuItems(fid);",
      "                }",
      "                return provider;",
      "              },",
      "            ),",
      "            ChangeNotifierProxyProvider2<FirestoreService, FranchiseProvider,",
      "                IngredientTypeProvider>(",
      "              create: (_) => IngredientTypeProvider(),",
      "              update: (_, firestoreService, franchiseProvider, previous) {",
      "                final fid = franchiseProvider.franchiseId;",
      "                if (!franchiseProvider.hasValidFranchise) return previous!;",
      "                final provider = previous ?? IngredientTypeProvider();",
      "                if (fid.isNotEmpty && fid != provider.franchiseId) {",
      "                  provider.loadIngredientTypes(fid);",
      "                }",
      "                return provider;",
      "              },",
      "            ),",
      "            Provider(create: (_) => AnalyticsService()),",
      "            Provider<AuditLogService>.value(value: AuditLogService()),",
      "            StreamProvider<fb_auth.User?>.value(",
      "              value: fb_auth.FirebaseAuth.instance.authStateChanges(),",
      "              initialData: null,",
      "            ),",
      "            ChangeNotifierProvider(create: (_) => UserProfileNotifier()),",
      "            ChangeNotifierProvider(",
      "              create: (_) => FranchiseeInvitationProvider(",
      "                service: FranchiseeInvitationService(",
      "                  firestoreService:",
      "                      Provider.of<FirestoreService>(_, listen: false),",
      "                ),",
      "              ),",
      "            ),",
      "            ChangeNotifierProvider(create: (_) => RestaurantTypeProvider()),",
      "          ],",
      "          child: FranchiseAuthenticatedRoot(",
      "            key: ValueKey(firebaseUser?.uid),",
      "          ),",
      "        );",
      "      },",
      "    );",
      "  }",
      "}",
      "",
      "/// Authenticated app root and routing logic, with full debug tracing and robust provider effect",
      "class FranchiseAuthenticatedRoot extends StatefulWidget {",
      "  const FranchiseAuthenticatedRoot({super.key});",
      "",
      "  @override",
      "  State<FranchiseAuthenticatedRoot> createState() =>",
      "      _FranchiseAuthenticatedRootState();",
      "}",
      "",
      "class _FranchiseAuthenticatedRootState",
      "    extends State<FranchiseAuthenticatedRoot> {",
      "  String? _lastUid;",
      "  bool _initializingUser = false;",
      "",
      "  @override",
      "  void didChangeDependencies() {",
      "    super.didChangeDependencies();",
      "",
      "    WidgetsBinding.instance.addPostFrameCallback((_) async {",
      "      final fbUser = Provider.of<fb_auth.User?>(context, listen: false);",
      "      final adminUserProvider =",
      "          Provider.of<AdminUserProvider>(context, listen: false);",
      "      final firestoreService =",
      "          Provider.of<FirestoreService>(context, listen: false);",
      "      final franchiseProvider =",
      "          Provider.of<FranchiseProvider>(context, listen: false);",
      "",
      "      if (fbUser == null) {",
      "        debugPrint('[FranchiseAuthenticatedRoot] ❌ No Firebase user.');",
      "        return;",
      "      }",
      "",
      "      if (fbUser.uid == _lastUid) {",
      "        debugPrint(",
      "            '[FranchiseAuthenticatedRoot] 🔁 UID unchanged (${fbUser.uid}), skipping listenToAdminUser.');",
      "        return;",
      "      }",
      "",
      "      if (_initializingUser) {",
      "        debugPrint(",
      "            '[FranchiseAuthenticatedRoot] ⏳ Already initializing user, skipping.');",
      "        return;",
      "      }",
      "",
      "      _initializingUser = true;",
      "      _lastUid = fbUser.uid;",
      "",
      "      debugPrint(",
      "          '[FranchiseAuthenticatedRoot] ✅ Detected Firebase UID: ${fbUser.uid}');",
      "      debugPrint(",
      "          '[FranchiseAuthenticatedRoot] ⏬ Calling listenToAdminUser (post-frame)...');",
      "",
      "      adminUserProvider.listenToAdminUser(",
      "        firestoreService,",
      "        fbUser.uid,",
      "        franchiseProvider,",
      "      );",
      "",
      "      _initializingUser = false;",
      "    });",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final fbUser = Provider.of<fb_auth.User?>(context);",
      "    final adminUserProvider = Provider.of<AdminUserProvider>(context);",
      "",
      "    print('[FranchiseAuthenticatedRoot] 🔄 build() called');",
      "    print('[DEBUG] fbUser: ${fbUser?.email} (${fbUser?.uid})');",
      "    print('[DEBUG] AdminUser loading: ${adminUserProvider.loading}');",
      "    print('[DEBUG] AdminUser loaded: ${adminUserProvider.user}');",
      "",
      "    // Still loading user profile",
      "    if (adminUserProvider.loading || adminUserProvider.user == null) {",
      "      print('[FranchiseAuthenticatedRoot] ⏳ Waiting on admin user profile...');",
      "      return const MaterialApp(",
      "        home: Scaffold(",
      "          body: Center(child: CircularProgressIndicator()),",
      "        ),",
      "      );",
      "    }",
      "",
      "    // Roles missing",
      "    if (adminUserProvider.user?.roles == null) {",
      "      print('[FranchiseAuthenticatedRoot] ❌ User roles missing. Unauthorized.');",
      "      debugPrint(",
      "          'AppLocalizations.supportedLocales: ${AppLocalizations.supportedLocales}');",
      "",
      "      return MaterialApp(",
      "        home: Scaffold(",
      "          appBar: AppBar(title: const Text('Unauthorized')),",
      "          body: const Center(",
      "            child: Text(",
      "                'You are not authorized to access this portal.\\n[DEBUG] No roles property.'),",
      "          ),",
      "        ),",
      "      );",
      "    }",
      "",
      "    // ✅ Build full app",
      "    print(",
      "        '[FranchiseAuthenticatedRoot] ✅ App user loaded. Proceeding with router...');",
      "    print(",
      "        '[FranchiseAuthenticatedRoot] ✅ All data ready. Building MaterialApp with router...');",
      "    print('[DEBUG] Roles: ${adminUserProvider.user?.roles}');",
      "    return Builder(",
      "      builder: (ctx) => MaterialApp(",
      "        debugShowCheckedModeBanner: false,",
      "        title: 'Franchise Admin Portal',",
      "        theme: _lightTheme,",
      "        darkTheme: _darkTheme,",
      "        themeMode: safeThemeMode(ctx),",
      "        localizationsDelegates: const [",
      "          AppLocalizations.delegate,",
      "          GlobalMaterialLocalizations.delegate,",
      "          GlobalWidgetsLocalizations.delegate,",
      "          GlobalCupertinoLocalizations.delegate,",
      "        ],",
      "        supportedLocales: AppLocalizations.supportedLocales,",
      "        // initialRoute: '/post-login-gate',",
      "        onGenerateRoute: (RouteSettings settings) {",
      "          print('[DEBUG][onGenerateRoute] Route name: ${settings.name}');",
      "",
      "          // DEFENSIVE GATE: Block routing until user/provider is loaded!",
      "          final adminUserProvider =",
      "              Provider.of<AdminUserProvider>(ctx, listen: false);",
      "          if (adminUserProvider.loading || adminUserProvider.user == null) {",
      "            print(",
      "                '[main.dart] User or provider not loaded, showing loading spinner and blocking route processing.');",
      "            return MaterialPageRoute(",
      "              builder: (_) => const Scaffold(",
      "                body: Center(child: CircularProgressIndicator()),",
      "              ),",
      "            );",
      "          }",
      "",
      "          try {",
      "            print('-----------------------------------------------------');",
      "            print('[DEBUG][onGenerateRoute] Route name: ${settings.name}');",
      "            final uri = Uri.parse(settings.name ?? '/');",
      "            final user = adminUserProvider.user;",
      "",
      "            if (user == null) {",
      "              print('[main.dart] User is null. Blocking routing.');",
      "              return MaterialPageRoute(",
      "                builder: (_) => const Scaffold(",
      "                  body: Center(child: CircularProgressIndicator()),",
      "                ),",
      "              );",
      "            }",
      "            print('[DEBUG][onGenerateRoute] User roles: ${user.roles}');",
      "            print('[DEBUG][onGenerateRoute] User object: $user');",
      "            print(",
      "                '[DEBUG][onGenerateRoute] Route arguments: ${settings.arguments}');",
      "            if (user.isActive == false) {",
      "              print(",
      "                  '[main.dart] User is suspended or inactive. Redirecting to /unauthorized');",
      "              return MaterialPageRoute(",
      "                builder: (_) => const Scaffold(",
      "                  body: Center(",
      "                    child: Text(",
      "                        'Your account is currently suspended or inactive.'),",
      "                  ),",
      "                ),",
      "              );",
      "            }",
      "",
      "            // Role-based root/landing routing",
      "            if (uri.path == '/' ||",
      "                uri.path == '/landing' ||",
      "                settings.name == null) {",
      "              print('[DEBUG][onGenerateRoute] Root/landing route hit.');",
      "",
      "              if (user.roles.contains('platform_owner')) {",
      "                print('[main.dart] Routing to PlatformOwnerDashboardScreen');",
      "                return MaterialPageRoute(",
      "                  builder: (context) => const PlatformOwnerDashboardScreen(",
      "                    currentScreen: '/platform-owner/dashboard',",
      "                  ),",
      "                );",
      "              }",
      "",
      "              if (user.roles.contains('hq_owner')) {",
      "                print('[main.dart] Routing to OwnerHQDashboardScreen');",
      "                return MaterialPageRoute(",
      "                  builder: (context) => const FranchiseGate(",
      "                    child: OwnerHQDashboardScreen(",
      "                      currentScreen: '/hq-owner/dashboard',",
      "                    ),",
      "                  ),",
      "                );",
      "              }",
      "",
      "              if (user.roles.contains('developer')) {",
      "                print('[main.dart] Routing to DeveloperDashboardScreen');",
      "                return MaterialPageRoute(",
      "                  builder: (context) => const FranchiseGate(",
      "                    child: DeveloperDashboardScreen(",
      "                      currentScreen: '/developer/dashboard',",
      "                    ),",
      "                  ),",
      "                );",
      "              }",
      "",
      "              print('[main.dart] Routing to AdminDashboardScreen (fallback)');",
      "              return MaterialPageRoute(",
      "                builder: (context) => const FranchiseGate(",
      "                  child: AdminDashboardScreen(",
      "                    currentScreen: '/admin/dashboard',",
      "                  ),",
      "                ),",
      "              );",
      "            }",
      "",
      "            // ======= Standard Authenticated Routes =======",
      "            if (uri.path == '/post-login-gate') {",
      "              print('[main.dart] Routing to ProfileGateScreen');",
      "              return MaterialPageRoute(",
      "                  builder: (context) => const ProfileGateScreen());",
      "            }",
      "            if (uri.path == '/admin/dashboard') {",
      "              final sectionKey = uri.queryParameters['section'];",
      "              return MaterialPageRoute(",
      "                builder: (context) => FranchiseGate(",
      "                  child: AdminDashboardScreen(",
      "                      initialSectionKey: sectionKey ?? 'dashboardHome'),",
      "                ),",
      "              );",
      "            }",
      "            if (uri.path == '/developer/dashboard') {",
      "              print('[main.dart] Routing to DeveloperDashboardScreen');",
      "              return MaterialPageRoute(",
      "                builder: (context) => const FranchiseGate(",
      "                  child: DeveloperDashboardScreen(",
      "                      currentScreen: '/developer/dashboard'),",
      "                ),",
      "              );",
      "            }",
      "",
      "            if (uri.path == '/developer/select-franchise') {",
      "              print('[main.dart] Routing to FranchiseSelectorScreen');",
      "              return MaterialPageRoute(",
      "                  builder: (context) => const FranchiseSelectorScreen());",
      "            }",
      "            if (uri.path == '/hq-owner/dashboard') {",
      "              print('[main.dart] Routing to OwnerHQDashboardScreen');",
      "              return MaterialPageRoute(",
      "                builder: (context) => const FranchiseGate(",
      "                  child: OwnerHQDashboardScreen(",
      "                      currentScreen: '/hq-owner/dashboard'),",
      "                ),",
      "              );",
      "            }",
      "            if (uri.path == '/platform-owner/dashboard') {",
      "              print('[main.dart] Routing to PlatformOwnerDashboardScreen');",
      "              return MaterialPageRoute(",
      "                builder: (context) => const PlatformOwnerDashboardScreen(",
      "                    currentScreen: '/platform-owner/dashboard'),",
      "              );",
      "            }",
      "            if (uri.path == '/platform/plans') {",
      "              print('[main.dart] Routing to FullPlatformPlansScreen');",
      "              return MaterialPageRoute(",
      "                builder: (context) => const FullPlatformPlansScreen(),",
      "              );",
      "            }",
      "            if (uri.path == '/platform/subscriptions') {",
      "              print(",
      "                  '[main.dart] Routing to FullFranchiseSubscriptionListScreen');",
      "              return MaterialPageRoute(",
      "                builder: (context) =>",
      "                    const FullFranchiseSubscriptionListScreen(),",
      "              );",
      "            }",
      "            if (uri.path == '/developer/tools/billing') {",
      "              print('[main.dart] Routing to BillingSubscriptionToolsScreen');",
      "              return MaterialPageRoute(",
      "                builder: (context) => const BillingSubscriptionToolsScreen(),",
      "              );",
      "            }",
      "",
      "            if (uri.path == '/developer/tools/subscriptions') {",
      "              print('[main.dart] Routing to SubscriptionDevToolsScreen');",
      "              return MaterialPageRoute(",
      "                builder: (context) => const SubscriptionDevToolsScreen(),",
      "              );",
      "            }",
      "",
      "            if (uri.path == '/unauthorized') {",
      "              print('[main.dart] Routing to Unauthorized');",
      "              return MaterialPageRoute(",
      "                builder: (context) => Scaffold(",
      "                  appBar: AppBar(title: const Text('Unauthorized')),",
      "                  body:",
      "                      const Center(child: Text('Your account is not active.')),",
      "                ),",
      "              );",
      "            }",
      "            if (uri.path == '/alerts') {",
      "              print('[main.dart] Routing to AlertListScreen');",
      "              final franchiseId = user.defaultFranchise ??",
      "                  ((user.franchiseIds.isNotEmpty)",
      "                      ? user.franchiseIds.first",
      "                      : '');",
      "              print(",
      "                  '[DEBUG][onGenerateRoute] AlertListScreen franchiseId: $franchiseId');",
      "              return MaterialPageRoute(",
      "                builder: (context) {",
      "                  return AlertListScreen(",
      "                    franchiseId: franchiseId,",
      "                    developerMode: user.isDeveloper ?? false,",
      "                  );",
      "                },",
      "              );",
      "            }",
      "            if (uri.path == '/hq/invoices') {",
      "              print('[main.dart] Routing to InvoiceListScreen');",
      "              return MaterialPageRoute(",
      "                  builder: (context) => const InvoiceListScreen());",
      "            }",
      "            if (uri.path == '/hq/invoice_detail') {",
      "              final args = settings.arguments as String?;",
      "              print(",
      "                  '[main.dart] Routing to InvoiceDetailScreen, invoiceId=$args');",
      "              return MaterialPageRoute(",
      "                  builder: (context) =>",
      "                      InvoiceDetailScreen(invoiceId: args ?? ''));",
      "            }",
      "            if (uri.path == '/hq/payouts') {",
      "              print('[main.dart] Routing to PayoutListScreen');",
      "              return MaterialPageRoute(",
      "                builder: (context) => ChangeNotifierProvider(",
      "                  create: (context) => PayoutFilterProvider(),",
      "                  child: const PayoutListScreen(),",
      "                ),",
      "              );",
      "            }",
      "            if (uri.path == '/profile') {",
      "              print('[main.dart] Routing to UniversalProfileScreen');",
      "              return MaterialPageRoute(",
      "                  builder: (context) => const UniversalProfileScreen());",
      "            }",
      "            if (uri.path == '/onboarding/menu') {",
      "              return MaterialPageRoute(",
      "                builder: (context) => FranchiseGate(",
      "                  child:",
      "                      AdminDashboardScreen(initialSectionKey: 'onboardingMenu'),",
      "                ),",
      "              );",
      "            }",
      "            // DASHBOARD route handling (supports with/without ?section= param)",
      "            if (uri.path == '/dashboard') {",
      "              final sectionParam = uri.queryParameters['section'];",
      "",
      "              // Default to first sidebar section if no param",
      "              final targetSectionKey = sectionParam?.isNotEmpty == true",
      "                  ? sectionParam!",
      "                  : getSidebarSections().first.key;",
      "",
      "              print('[ROUTER] 📌 Requested /dashboard');",
      "              print('[ROUTER] 🔑 Target section key: \"$targetSectionKey\"');",
      "",
      "              final sectionExists =",
      "                  sectionRegistry.any((s) => s.key == targetSectionKey);",
      "              if (!sectionExists) {",
      "                print('[ROUTER] ❌ No matching section found, using default.');",
      "              }",
      "",
      "              return MaterialPageRoute(",
      "                builder: (context) {",
      "                  return FranchiseGate(",
      "                    child: Builder(",
      "                      builder: (ctx) {",
      "                        final franchiseProvider =",
      "                            Provider.of<FranchiseProvider>(ctx, listen: false);",
      "                        final franchiseId = franchiseProvider.franchiseId;",
      "",
      "                        print('[ROUTER] 🔍 franchiseId = \"$franchiseId\"');",
      "",
      "                        if (franchiseId.isEmpty || franchiseId == 'unknown') {",
      "                          print(",
      "                              '[ROUTER] ⚠️ Franchise ID loading — showing spinner.');",
      "                          return const Scaffold(",
      "                            body: Center(child: CircularProgressIndicator()),",
      "                          );",
      "                        }",
      "",
      "                        // ──────────────────────────────────────────────",
      "                        // Prerequisite data checks for onboarding sections",
      "                        // ──────────────────────────────────────────────",
      "                        return FutureBuilder<void>(",
      "                          future: () async {",
      "                            try {",
      "                              if (targetSectionKey == 'onboardingIngredients') {",
      "                                print(",
      "                                    '[ROUTER] 📦 Preloading data for Ingredients...');",
      "",
      "                                final ingredientTypesProvider =",
      "                                    ctx.read<IngredientTypeProvider>();",
      "                                final ingredientsProvider =",
      "                                    ctx.read<IngredientMetadataProvider>();",
      "",
      "                                // Ingredient Types preload",
      "                                if (ingredientTypesProvider.types.isEmpty) {",
      "                                  print(",
      "                                      '[ROUTER]    ➤ Loading Ingredient Types...');",
      "                                  await ingredientTypesProvider",
      "                                      .loadTypes(franchiseId);",
      "                                  print(",
      "                                      '[ROUTER]    ✔ Loaded Ingredient Types: count=${ingredientTypesProvider.types.length}');",
      "                                } else {",
      "                                  print(",
      "                                      '[ROUTER]    ✔ Ingredient Types already loaded: count=${ingredientTypesProvider.types.length}');",
      "                                }",
      "",
      "                                // Ingredient Metadata preload",
      "                                if (!ingredientsProvider.isInitialized) {",
      "                                  print('[ROUTER]    ➤ Loading Ingredients...');",
      "                                  await ingredientsProvider.load();",
      "                                  print(",
      "                                      '[ROUTER]    ✔ Loaded Ingredients: count=${ingredientsProvider.ingredients.length}');",
      "                                } else {",
      "                                  print(",
      "                                      '[ROUTER]    ✔ Ingredients already loaded: count=${ingredientsProvider.ingredients.length}');",
      "                                }",
      "                              } else if (targetSectionKey ==",
      "                                  'onboardingIngredientTypes') {",
      "                                print(",
      "                                    '[ROUTER] 📦 Preloading data for Ingredient Types only...');",
      "",
      "                                final ingredientTypesProvider =",
      "                                    ctx.read<IngredientTypeProvider>();",
      "",
      "                                if (ingredientTypesProvider.types.isEmpty) {",
      "                                  print(",
      "                                      '[ROUTER]    ➤ Loading Ingredient Types...');",
      "                                  await ingredientTypesProvider",
      "                                      .loadTypes(franchiseId);",
      "                                  print(",
      "                                      '[ROUTER]    ✔ Loaded Ingredient Types: count=${ingredientTypesProvider.types.length}');",
      "                                } else {",
      "                                  print(",
      "                                      '[ROUTER]    ✔ Ingredient Types already loaded: count=${ingredientTypesProvider.types.length}');",
      "                                }",
      "                              }",
      "                            } catch (e, st) {",
      "                              print(",
      "                                  '[ROUTER][ERROR] ⚠ Failed while preloading prerequisites.');",
      "                              print('    Exception: $e');",
      "                              print('    Stacktrace: $st');",
      "                            }",
      "                          }(),",
      "                          builder: (context, snapshot) {",
      "                            if (snapshot.connectionState ==",
      "                                ConnectionState.waiting) {",
      "                              return const Scaffold(",
      "                                body:",
      "                                    Center(child: CircularProgressIndicator()),",
      "                              );",
      "                            }",
      "",
      "                            // ──────────────────────────────────────────────",
      "                            // Navigate to AdminDashboardScreen",
      "                            // ──────────────────────────────────────────────",
      "                            print(",
      "                                '[ROUTER] ✅ Navigating to AdminDashboardScreen with section \"$targetSectionKey\"');",
      "                            return AdminDashboardScreen(",
      "                              key: ValueKey(",
      "                                  'AdminDashboardScreen:$targetSectionKey'),",
      "                              initialSectionKey: targetSectionKey,",
      "                            );",
      "                          },",
      "                        );",
      "                      },",
      "                    ),",
      "                  );",
      "                },",
      "                settings: settings,",
      "              );",
      "            }",
      "",
      "            if (uri.path == '/onboarding/ingredient-types') {",
      "              return MaterialPageRoute(",
      "                builder: (context) => const IngredientTypeManagementScreen(),",
      "              );",
      "            }",
      "            if (uri.path == '/onboarding/categories') {",
      "              return MaterialPageRoute(",
      "                builder: (_) => const OnboardingCategoriesScreen(),",
      "              );",
      "            }",
      "            if (uri.path == '/onboarding/menu_items') {",
      "              return MaterialPageRoute(",
      "                builder: (_) => const OnboardingMenuItemsScreen(),",
      "              );",
      "            }",
      "            if (uri.path == '/onboarding/feature_setup') {",
      "              return MaterialPageRoute(",
      "                builder: (_) => const OnboardingFeatureSetupScreen(),",
      "                settings: settings, // ← passes .arguments",
      "              );",
      "            }",
      "            if (uri.path == '/onboarding/review') {",
      "              return MaterialPageRoute(",
      "                builder: (context) =>",
      "                    ChangeNotifierProvider<OnboardingReviewProvider>(",
      "                  create: (context) => OnboardingReviewProvider(",
      "                    franchiseFeatureProvider:",
      "                        Provider.of<FranchiseFeatureProvider>(context,",
      "                            listen: false),",
      "                    ingredientTypeProvider: Provider.of<IngredientTypeProvider>(",
      "                        context,",
      "                        listen: false),",
      "                    ingredientMetadataProvider:",
      "                        Provider.of<IngredientMetadataProvider>(context,",
      "                            listen: false),",
      "                    categoryProvider:",
      "                        Provider.of<CategoryProvider>(context, listen: false),",
      "                    menuItemProvider:",
      "                        Provider.of<MenuItemProvider>(context, listen: false),",
      "                    firestoreService:",
      "                        Provider.of<FirestoreService>(context, listen: false),",
      "                    auditLogService:",
      "                        Provider.of<AuditLogService>(context, listen: false),",
      "                  ),",
      "                  child:",
      "                      OnboardingReviewScreen(), // <-- Make this widget \"dumb\" (stateless or stateful)",
      "                ),",
      "              );",
      "            }",
      "            if (uri.path == '/invite-accept') {",
      "              final args = settings.arguments as Map?;",
      "              final token = args?['token'] as String?;",
      "              print('[main.dart] Routing to InviteAcceptScreen, token=$token');",
      "              return MaterialPageRoute(",
      "                  builder: (context) => InviteAcceptScreen(inviteToken: token));",
      "            }",
      "            if (uri.path == '/franchise-onboarding') {",
      "              final args = settings.arguments as Map?;",
      "              String? token = args?['token'] as String?;",
      "              if (token == null || token.isEmpty) {",
      "                // Try to get from AuthService",
      "                token = Provider.of<AuthService>(context, listen: false)",
      "                    .getInviteToken();",
      "                print('[main.dart] Fetched token from AuthService: $token');",
      "              }",
      "              print(",
      "                  '[main.dart] Routing to FranchiseOnboardingScreen, token=$token');",
      "              if (token == null || token.isEmpty) {",
      "                print(",
      "                    '[main.dart] FranchiseOnboardingScreen: Invalid or missing token!');",
      "                return MaterialPageRoute(",
      "                  builder: (context) => Scaffold(",
      "                    appBar: AppBar(title: const Text('Invalid Invite')),",
      "                    body: const Center(",
      "                        child: Text('Invalid or missing invitation token.')),",
      "                  ),",
      "                );",
      "              }",
      "              return MaterialPageRoute(",
      "                builder: (context) =>",
      "                    FranchiseOnboardingScreen(inviteToken: token),",
      "              );",
      "            }",
      "            if (uri.path == '/hq-owner/available-plans') {",
      "              print(",
      "                  '[main.dart] Routing to AvailablePlatformPlansScreen (HQ Owner)');",
      "              return MaterialPageRoute(",
      "                builder: (context) => const AvailablePlatformPlansScreen(),",
      "              );",
      "            }",
      "            print('[main.dart] Routing to fallback LandingPage');",
      "            return MaterialPageRoute(builder: (context) => const LandingPage());",
      "          } catch (e, stack) {",
      "            print('[DEBUG][onGenerateRoute] Caught error: $e');",
      "            print(stack);",
      "            return MaterialPageRoute(",
      "              builder: (_) => Scaffold(",
      "                appBar: AppBar(title: const Text('Fatal Routing Error')),",
      "                body: SingleChildScrollView(",
      "                  child: Text(",
      "                    'Exception: $e\\n$stack',",
      "                    style: const TextStyle(color: Colors.red),",
      "                  ),",
      "                ),",
      "              ),",
      "            );",
      "          }",
      "        },",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "// ===== THEME DEFINITIONS =====",
      "",
      "final ThemeData _lightTheme = ThemeData(",
      "  fontFamily: DesignTokens.fontFamily,",
      "  primaryColor: DesignTokens.primaryColor,",
      "  scaffoldBackgroundColor: DesignTokens.backgroundColor,",
      "  colorScheme: ColorScheme(",
      "    brightness: Brightness.light,",
      "    primary: DesignTokens.primaryColor,",
      "    onPrimary: DesignTokens.foregroundColor,",
      "    secondary: DesignTokens.secondaryColor,",
      "    onSecondary: DesignTokens.foregroundColor,",
      "    error: DesignTokens.errorColor,",
      "    onError: DesignTokens.errorTextColor,",
      "    background: DesignTokens.backgroundColor,",
      "    onBackground: DesignTokens.textColor,",
      "    surface: DesignTokens.surfaceColor,",
      "    onSurface: DesignTokens.textColor,",
      "  ),",
      "  appBarTheme: AppBarTheme(",
      "    backgroundColor: DesignTokens.appBarBackgroundColor,",
      "    foregroundColor: DesignTokens.appBarForegroundColor,",
      "    iconTheme: IconThemeData(color: DesignTokens.appBarIconColor),",
      "    elevation: DesignTokens.appBarElevation,",
      "    titleTextStyle: TextStyle(",
      "      fontFamily: DesignTokens.appBarFontFamily,",
      "      fontSize: DesignTokens.appBarTitleFontSize,",
      "      fontWeight: DesignTokens.appBarTitleFontWeight,",
      "      color: DesignTokens.appBarForegroundColor,",
      "    ),",
      "  ),",
      "  textTheme: TextTheme(",
      "    bodyMedium: TextStyle(",
      "      fontFamily: DesignTokens.fontFamily,",
      "      fontSize: DesignTokens.adminBodyFontSize,",
      "      color: DesignTokens.textColor,",
      "    ),",
      "    titleLarge: TextStyle(",
      "      fontFamily: DesignTokens.fontFamily,",
      "      fontSize: DesignTokens.adminTitleFontSize,",
      "      fontWeight: DesignTokens.titleFontWeight,",
      "      color: DesignTokens.textColor,",
      "    ),",
      "    titleMedium: TextStyle(",
      "      fontFamily: DesignTokens.fontFamily,",
      "      fontSize: DesignTokens.adminCaptionFontSize,",
      "      color: DesignTokens.secondaryTextColor,",
      "    ),",
      "  ),",
      "  cardTheme: CardTheme(",
      "    color: DesignTokens.surfaceColor,",
      "    elevation: DesignTokens.adminCardElevation,",
      "    shape: RoundedRectangleBorder(",
      "      borderRadius: BorderRadius.circular(DesignTokens.adminCardRadius),",
      "    ),",
      "    margin: EdgeInsets.all(DesignTokens.adminCardSpacing),",
      "  ),",
      "  elevatedButtonTheme: ElevatedButtonThemeData(",
      "    style: ElevatedButton.styleFrom(",
      "      backgroundColor: DesignTokens.primaryColor,",
      "      foregroundColor: DesignTokens.foregroundColor,",
      "      shape: RoundedRectangleBorder(",
      "        borderRadius: BorderRadius.circular(DesignTokens.adminButtonRadius),",
      "      ),",
      "      elevation: DesignTokens.adminButtonElevation,",
      "      textStyle: TextStyle(",
      "        fontSize: DesignTokens.adminButtonFontSize,",
      "        fontFamily: DesignTokens.fontFamily,",
      "        fontWeight: DesignTokens.titleFontWeight,",
      "      ),",
      "      padding: DesignTokens.buttonPadding,",
      "    ),",
      "  ),",
      "  dialogTheme: DialogTheme(",
      "    backgroundColor: DesignTokens.surfaceColor,",
      "    shape: RoundedRectangleBorder(",
      "      borderRadius: BorderRadius.circular(DesignTokens.dialogBorderRadius),",
      "    ),",
      "    elevation: DesignTokens.adminDialogElevation,",
      "    titleTextStyle: TextStyle(",
      "      fontFamily: DesignTokens.fontFamily,",
      "      fontSize: DesignTokens.adminTitleFontSize,",
      "      fontWeight: FontWeight.bold,",
      "      color: DesignTokens.textColor,",
      "    ),",
      "    contentTextStyle: TextStyle(",
      "      fontFamily: DesignTokens.fontFamily,",
      "      fontSize: DesignTokens.adminBodyFontSize,",
      "      color: DesignTokens.textColor,",
      "    ),",
      "  ),",
      "  inputDecorationTheme: InputDecorationTheme(",
      "    border: OutlineInputBorder(",
      "      borderRadius: BorderRadius.circular(DesignTokens.formFieldRadius),",
      "    ),",
      "  ),",
      ");",
      "",
      "final ThemeData _darkTheme = ThemeData(",
      "  brightness: Brightness.dark,",
      "  fontFamily: DesignTokens.fontFamily,",
      "  primaryColor: DesignTokens.primaryColor,",
      "  scaffoldBackgroundColor: DesignTokens.backgroundColorDark,",
      "  colorScheme: ColorScheme(",
      "    brightness: Brightness.dark,",
      "    primary: DesignTokens.primaryColor,",
      "    onPrimary: DesignTokens.foregroundColorDark,",
      "    secondary: DesignTokens.secondaryColor,",
      "    onSecondary: DesignTokens.foregroundColorDark,",
      "    error: DesignTokens.errorColor,",
      "    onError: DesignTokens.errorTextColor,",
      "    background: DesignTokens.backgroundColorDark,",
      "    onBackground: DesignTokens.textColorDark,",
      "    surface: DesignTokens.surfaceColorDark,",
      "    onSurface: DesignTokens.textColorDark,",
      "  ),",
      "  appBarTheme: AppBarTheme(",
      "    backgroundColor: DesignTokens.appBarBackgroundColorDark,",
      "    foregroundColor: DesignTokens.appBarForegroundColorDark,",
      "    iconTheme: IconThemeData(color: DesignTokens.appBarForegroundColorDark),",
      "    elevation: DesignTokens.appBarElevation,",
      "    titleTextStyle: TextStyle(",
      "      fontFamily: DesignTokens.appBarFontFamily,",
      "      fontSize: DesignTokens.appBarTitleFontSize,",
      "      fontWeight: DesignTokens.appBarTitleFontWeight,",
      "      color: DesignTokens.appBarForegroundColorDark,",
      "    ),",
      "  ),",
      "  drawerTheme: DrawerThemeData(",
      "    backgroundColor: DesignTokens.backgroundColorDark,",
      "    scrimColor: Colors.black.withOpacity(0.5),",
      "  ),",
      "  textTheme: TextTheme(",
      "    bodyMedium: TextStyle(",
      "      fontFamily: DesignTokens.fontFamily,",
      "      fontSize: DesignTokens.adminBodyFontSize,",
      "      color: DesignTokens.textColorDark,",
      "    ),",
      "    titleLarge: TextStyle(",
      "      fontFamily: DesignTokens.fontFamily,",
      "      fontSize: DesignTokens.adminTitleFontSize,",
      "      fontWeight: DesignTokens.titleFontWeight,",
      "      color: DesignTokens.textColorDark,",
      "    ),",
      "    titleMedium: TextStyle(",
      "      fontFamily: DesignTokens.fontFamily,",
      "      fontSize: DesignTokens.adminCaptionFontSize,",
      "      color: DesignTokens.secondaryTextColor,",
      "    ),",
      "  ),",
      "  cardTheme: CardTheme(",
      "    color: DesignTokens.surfaceColorDark,",
      "    elevation: DesignTokens.adminCardElevation,",
      "    shape: RoundedRectangleBorder(",
      "      borderRadius: BorderRadius.circular(DesignTokens.adminCardRadius),",
      "    ),",
      "    margin: EdgeInsets.all(DesignTokens.adminCardSpacing),",
      "  ),",
      "  elevatedButtonTheme: ElevatedButtonThemeData(",
      "    style: ElevatedButton.styleFrom(",
      "      backgroundColor: DesignTokens.primaryColor,",
      "      foregroundColor: DesignTokens.foregroundColorDark,",
      "      shape: RoundedRectangleBorder(",
      "        borderRadius: BorderRadius.circular(DesignTokens.adminButtonRadius),",
      "      ),",
      "      elevation: DesignTokens.adminButtonElevation,",
      "      textStyle: TextStyle(",
      "        fontSize: DesignTokens.adminButtonFontSize,",
      "        fontFamily: DesignTokens.fontFamily,",
      "        fontWeight: DesignTokens.titleFontWeight,",
      "      ),",
      "      padding: DesignTokens.buttonPadding,",
      "    ),",
      "  ),",
      "  dialogTheme: DialogTheme(",
      "    backgroundColor: DesignTokens.surfaceColorDark,",
      "    shape: RoundedRectangleBorder(",
      "      borderRadius: BorderRadius.circular(DesignTokens.dialogBorderRadius),",
      "    ),",
      "    elevation: DesignTokens.adminDialogElevation,",
      "    titleTextStyle: TextStyle(",
      "      fontFamily: DesignTokens.fontFamily,",
      "      fontSize: DesignTokens.adminTitleFontSize,",
      "      fontWeight: FontWeight.bold,",
      "      color: DesignTokens.textColorDark,",
      "    ),",
      "    contentTextStyle: TextStyle(",
      "      fontFamily: DesignTokens.fontFamily,",
      "      fontSize: DesignTokens.adminBodyFontSize,",
      "      color: DesignTokens.textColorDark,",
      "    ),",
      "  ),",
      "  inputDecorationTheme: InputDecorationTheme(",
      "    hintStyle: TextStyle(color: DesignTokens.hintTextColorDark),",
      "    border: OutlineInputBorder(",
      "      borderRadius: BorderRadius.circular(DesignTokens.formFieldRadius),",
      "    ),",
      "  ),",
      "  dividerColor: DesignTokens.dividerColorDark,",
      "  iconTheme: IconThemeData(color: DesignTokens.textColorDark),",
      ");"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 1319,
      "file_size": 58582,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\auth\\invite_accept_screen.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:firebase_auth/firebase_auth.dart' as fb_auth;",
      "import 'package:provider/provider.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/admin/profile/franchise_onboarding_screen.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/widgets/loading_shimmer_widget.dart';",
      "import 'dart:html' as html;",
      "import 'package:franchise_admin_portal/core/services/auth_service.dart';",
      "",
      "class InviteAcceptScreen extends StatefulWidget {",
      "  final String? inviteToken;",
      "  const InviteAcceptScreen({super.key, this.inviteToken});",
      "",
      "  @override",
      "  State<InviteAcceptScreen> createState() => _InviteAcceptScreenState();",
      "}",
      "",
      "class _InviteAcceptScreenState extends State<InviteAcceptScreen> {",
      "  Map<String, dynamic>? _inviteData;",
      "  String? _error;",
      "  bool _loading = false;",
      "  bool _accepted = false;",
      "  String? _effectiveToken;",
      "  bool _didLoadToken = false;",
      "  bool _emailRegistered = false;",
      "",
      "  @override",
      "  void didChangeDependencies() {",
      "    super.didChangeDependencies();",
      "    if (_didLoadToken) return;",
      "    _didLoadToken = true;",
      "",
      "    // Priority: Constructor, then arguments, then hash",
      "    _effectiveToken = widget.inviteToken;",
      "    if (_effectiveToken == null) {",
      "      final args = (ModalRoute.of(context)?.settings.arguments as Map?) ?? {};",
      "      _effectiveToken = args['token'] as String?;",
      "    }",
      "    // As a final fallback, parse from hash for deep linking support:",
      "    if (_effectiveToken == null || _effectiveToken!.isEmpty) {",
      "      final hash = html.window.location.hash;",
      "      if (hash.isNotEmpty) {",
      "        final hashPart = hash.substring(1); // Remove leading #",
      "        final questionMarkIndex = hashPart.indexOf('?');",
      "        if (questionMarkIndex != -1 &&",
      "            questionMarkIndex < hashPart.length - 1) {",
      "          final queryString = hashPart.substring(questionMarkIndex + 1);",
      "          final params = Uri.splitQueryString(queryString);",
      "          _effectiveToken = params['token'];",
      "        }",
      "      }",
      "    }",
      "    if (_effectiveToken != null && _effectiveToken!.isNotEmpty) {",
      "      Provider.of<AuthService>(context, listen: false)",
      "          .saveInviteToken(_effectiveToken!);",
      "      _fetchInvite(_effectiveToken!);",
      "    } else {",
      "      setState(() {",
      "        _loading = false;",
      "        _error = \"No invitation token in the URL.\";",
      "      });",
      "    }",
      "  }",
      "",
      "  Future<void> _fetchInvite(String token) async {",
      "    setState(() {",
      "      _loading = true;",
      "      _error = null;",
      "      _inviteData = null;",
      "    });",
      "    try {",
      "      final doc = await Provider.of<FirestoreService>(context, listen: false)",
      "          .getFranchiseeInvitationByToken(token);",
      "      if (doc == null) {",
      "        setState(() => _error = \"Invitation not found or expired.\");",
      "        return;",
      "      }",
      "      if (doc['status'] == 'revoked') {",
      "        setState(() => _error = \"Invitation was revoked.\");",
      "        return;",
      "      }",
      "      if (doc['status'] == 'accepted') {",
      "        setState(() => _error = \"Invitation already accepted.\");",
      "        return;",
      "      }",
      "      setState(() {",
      "        _inviteData = doc;",
      "      });",
      "      final inviteEmail = (doc['email'] as String?) ?? '';",
      "      bool emailRegistered = false;",
      "      if (inviteEmail.isNotEmpty) {",
      "        try {",
      "          final methods = await fb_auth.FirebaseAuth.instance",
      "              .fetchSignInMethodsForEmail(inviteEmail);",
      "          emailRegistered = methods.isNotEmpty;",
      "        } catch (e) {",
      "          // Optionally, log error but do not block UI",
      "        }",
      "      }",
      "      setState(() {",
      "        _emailRegistered = emailRegistered;",
      "      });",
      "    } catch (e, st) {",
      "      await ErrorLogger.log(",
      "        message: 'Invite fetch failed: $e',",
      "        stack: st.toString(),",
      "        source: 'InviteAcceptScreen',",
      "        screen: 'invite_accept',",
      "        severity: 'error',",
      "        contextData: {'token': token},",
      "      );",
      "      setState(() {",
      "        _error = \"Failed to load invitation data.\";",
      "      });",
      "    } finally {",
      "      setState(() => _loading = false);",
      "    }",
      "  }",
      "",
      "  Future<void> _acceptInvite() async {",
      "    setState(() {",
      "      _loading = true;",
      "      _error = null;",
      "    });",
      "    final loc = AppLocalizations.of(context);",
      "    try {",
      "      final inviteEmail = (_inviteData?['email'] as String?) ?? '';",
      "      if (inviteEmail.isEmpty) {",
      "        setState(() {",
      "          _error = \"Invitation email missing. Cannot continue.\";",
      "          _loading = false;",
      "        });",
      "        return;",
      "      }",
      "      // Must be logged in as correct user/uid",
      "      final fb_auth.User? currentUser =",
      "          fb_auth.FirebaseAuth.instance.currentUser;",
      "      if (currentUser == null) {",
      "        setState(() {",
      "          _error = loc?.inviteMustSignIn ??",
      "              \"Please sign in with your invited email.\";",
      "          _loading = false;",
      "        });",
      "        return;",
      "      }",
      "      final inviteUid = _inviteData?['invitedUserId'];",
      "      if (inviteUid != null && currentUser.uid != inviteUid) {",
      "        setState(() {",
      "          _error =",
      "              \"Signed-in account does not match the invite. Please sign in with the correct email.\";",
      "          _loading = false;",
      "        });",
      "        return;",
      "      }",
      "",
      "      // Call cloud function to mark as accepted",
      "      await FirestoreService().callAcceptInvitationFunction(_effectiveToken!);",
      "",
      "      Navigator.of(context).pushReplacementNamed(",
      "        '/franchise-onboarding',",
      "        arguments: {'token': _effectiveToken!},",
      "      );",
      "    } catch (e, st) {",
      "      await ErrorLogger.log(",
      "        message: 'Invite accept failed: $e',",
      "        stack: st.toString(),",
      "        source: 'InviteAcceptScreen',",
      "        screen: 'invite_accept',",
      "        severity: 'error',",
      "        contextData: {'token': _effectiveToken},",
      "      );",
      "      setState(() {",
      "        _error = AppLocalizations.of(context)?.inviteAcceptFailed ??",
      "            \"Failed to accept invitation.\";",
      "      });",
      "    } finally {",
      "      setState(() => _loading = false);",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    final theme = Theme.of(context);",
      "",
      "    return Scaffold(",
      "      backgroundColor: colorScheme.background,",
      "      appBar: AppBar(",
      "        title: Text(loc?.acceptInvitation ?? \"Accept Invitation\"),",
      "        backgroundColor: colorScheme.surface,",
      "      ),",
      "      body: Center(",
      "        child: Container(",
      "          constraints: const BoxConstraints(maxWidth: 430),",
      "          padding: const EdgeInsets.symmetric(vertical: 36, horizontal: 24),",
      "          decoration: BoxDecoration(",
      "            color: colorScheme.surfaceVariant.withOpacity(0.94),",
      "            borderRadius: BorderRadius.circular(DesignTokens.radius2xl),",
      "            boxShadow: [",
      "              BoxShadow(",
      "                color: colorScheme.shadow.withOpacity(0.11),",
      "                blurRadius: 32,",
      "                offset: const Offset(0, 4),",
      "              ),",
      "            ],",
      "          ),",
      "          child: _loading",
      "              ? const LoadingShimmerWidget()",
      "              : _accepted",
      "                  ? _buildAccepted(loc, colorScheme)",
      "                  : _buildInvitePanel(loc, colorScheme, theme),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  Widget _buildInvitePanel(",
      "      AppLocalizations? loc, ColorScheme colorScheme, ThemeData theme) {",
      "    if (_error != null) {",
      "      return Column(",
      "        mainAxisSize: MainAxisSize.min,",
      "        children: [",
      "          Icon(Icons.error, color: colorScheme.error, size: 36),",
      "          const SizedBox(height: 12),",
      "          Text(",
      "            _error!,",
      "            style: (theme.textTheme.bodyMedium ?? const TextStyle()).copyWith(",
      "                color: colorScheme.error, fontWeight: FontWeight.bold),",
      "            textAlign: TextAlign.center,",
      "          ),",
      "        ],",
      "      );",
      "    }",
      "",
      "    if (_inviteData == null) {",
      "      return Column(",
      "        mainAxisSize: MainAxisSize.min,",
      "        children: [Text(loc?.loadingInvite ?? \"Loading invitation...\")],",
      "      );",
      "    }",
      "",
      "    final inviteEmail = (_inviteData?['email'] as String?) ?? 'Unknown';",
      "    final inviteFranchiseName =",
      "        (_inviteData?['franchiseName'] as String?) ?? '';",
      "",
      "    final fb_auth.User? currentUser = fb_auth.FirebaseAuth.instance.currentUser;",
      "    final inviteUid = _inviteData?['invitedUserId'];",
      "    final isLoggedIn = currentUser != null;",
      "    final isUidMatch =",
      "        isLoggedIn && inviteUid != null && currentUser!.uid == inviteUid;",
      "    final userEmailLower = (currentUser?.email ?? '').toLowerCase();",
      "    final inviteEmailLower = inviteEmail.toLowerCase();",
      "    final isEmailMatch = isLoggedIn && userEmailLower == inviteEmailLower;",
      "",
      "    return Column(",
      "      mainAxisSize: MainAxisSize.min,",
      "      children: [",
      "        Icon(Icons.mark_email_unread, color: colorScheme.primary, size: 40),",
      "        const SizedBox(height: 16),",
      "        Text(",
      "          loc?.inviteWelcome(inviteEmail) ?? \"Invitation for $inviteEmail\",",
      "          style: (theme.textTheme.titleLarge ?? const TextStyle())",
      "              .copyWith(fontWeight: FontWeight.w600),",
      "          textAlign: TextAlign.center,",
      "        ),",
      "        if (inviteFranchiseName.isNotEmpty)",
      "          Padding(",
      "            padding: const EdgeInsets.only(top: 7),",
      "            child: Text(",
      "              loc?.inviteForFranchise(inviteFranchiseName) ??",
      "                  \"For franchise: $inviteFranchiseName\",",
      "              style: (theme.textTheme.bodyMedium ?? const TextStyle())",
      "                  .copyWith(color: colorScheme.secondary),",
      "            ),",
      "          ),",
      "        const SizedBox(height: 18),",
      "        Builder(",
      "          builder: (context) {",
      "            if (_emailRegistered) {",
      "              // STEP 4: Show sign-in prompt if the invitee already registered",
      "              return Column(",
      "                children: [",
      "                  Text(",
      "                    \"Your account is already registered. Please sign in with your email to accept this invitation.\",",
      "                    style: theme.textTheme.bodyMedium ?? const TextStyle(),",
      "                    textAlign: TextAlign.center,",
      "                  ),",
      "                  const SizedBox(height: 12),",
      "                  ElevatedButton.icon(",
      "                    icon: const Icon(Icons.login),",
      "                    label: const Text(\"Sign In\"),",
      "                    onPressed: () {",
      "                      Provider.of<AuthService>(context, listen: false)",
      "                          .saveInviteToken(_effectiveToken ?? '');",
      "                      Navigator.of(context).pushNamed(",
      "                        '/sign-in',",
      "                        arguments: {'token': _effectiveToken},",
      "                      );",
      "                    },",
      "                  ),",
      "                ],",
      "              );",
      "            }",
      "",
      "            // If not registered, continue the rest of your existing logic:",
      "            if (!isLoggedIn) {",
      "              return Column(",
      "                children: [",
      "                  Text(",
      "                    \"Please sign in with your invited email to continue.\",",
      "                    style: theme.textTheme.bodyMedium ?? const TextStyle(),",
      "                    textAlign: TextAlign.center,",
      "                  ),",
      "                  const SizedBox(height: 12),",
      "                  ElevatedButton.icon(",
      "                    icon: const Icon(Icons.login),",
      "                    label: const Text(\"Sign In\"),",
      "                    onPressed: () {",
      "                      Provider.of<AuthService>(context, listen: false)",
      "                          .saveInviteToken(_effectiveToken ?? '');",
      "                      Navigator.of(context).pushNamed(",
      "                        '/sign-in',",
      "                        arguments: {'token': _effectiveToken},",
      "                      );",
      "                    },",
      "                  ),",
      "                ],",
      "              );",
      "            }",
      "            if (!isUidMatch) {",
      "              return Column(",
      "                children: [",
      "                  Text(",
      "                    \"You are signed in with a different account.\\n\"",
      "                    \"Please sign in with the invited email to accept this invite.\",",
      "                    style: theme.textTheme.bodyMedium ?? const TextStyle(),",
      "                    textAlign: TextAlign.center,",
      "                  ),",
      "                  const SizedBox(height: 12),",
      "                  ElevatedButton.icon(",
      "                    icon: const Icon(Icons.logout),",
      "                    label: const Text(\"Switch Account\"),",
      "                    onPressed: () async {",
      "                      await fb_auth.FirebaseAuth.instance.signOut();",
      "                      Provider.of<AuthService>(context, listen: false)",
      "                          .saveInviteToken(_effectiveToken ?? '');",
      "                      Navigator.of(context).pushNamed(",
      "                        '/sign-in',",
      "                        arguments: {'token': _effectiveToken},",
      "                      );",
      "                    },",
      "                  ),",
      "                ],",
      "              );",
      "            }",
      "            // All good (not registered, signed in with correct user)",
      "            return Column(",
      "              children: [",
      "                Text(",
      "                  \"You are signed in as the invited user. Click below to accept.\",",
      "                  style: theme.textTheme.bodyMedium ?? const TextStyle(),",
      "                  textAlign: TextAlign.center,",
      "                ),",
      "                const SizedBox(height: 20),",
      "                ElevatedButton.icon(",
      "                  onPressed: _acceptInvite,",
      "                  icon: const Icon(Icons.check_circle),",
      "                  label: Text(loc?.acceptInvitation ?? \"Accept Invitation\"),",
      "                ),",
      "              ],",
      "            );",
      "          },",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "",
      "  Widget _buildAccepted(AppLocalizations? loc, ColorScheme colorScheme) {",
      "    return Column(",
      "      mainAxisSize: MainAxisSize.min,",
      "      children: [",
      "        Icon(Icons.verified, color: colorScheme.primary, size: 44),",
      "        const SizedBox(height: 14),",
      "        Text(",
      "          loc?.inviteAcceptedTitle ?? \"Invitation Accepted\",",
      "          style: TextStyle(",
      "              fontWeight: FontWeight.bold,",
      "              color: colorScheme.primary,",
      "              fontSize: 20),",
      "        ),",
      "        const SizedBox(height: 7),",
      "        Text(",
      "          loc?.inviteAcceptedDesc ?? \"Your invitation has been accepted.\",",
      "          style: TextStyle(",
      "            color: colorScheme.onSurfaceVariant,",
      "            fontSize: 15,",
      "          ),",
      "          textAlign: TextAlign.center,",
      "        ),",
      "        const SizedBox(height: 20),",
      "        ElevatedButton.icon(",
      "          icon: const Icon(Icons.dashboard_customize_outlined),",
      "          label: Text(loc?.goToDashboard ?? \"Go to Dashboard\"),",
      "          onPressed: () {",
      "            Navigator.of(context)",
      "                .pushNamedAndRemoveUntil('/dashboard', (route) => false);",
      "          },",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 416,
      "file_size": 15154,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\categories\\bulk_action_bar.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "",
      "class BulkActionBar extends StatelessWidget {",
      "  final int selectedCount;",
      "  final VoidCallback? onBulkDelete;",
      "  final VoidCallback? onBulkExport;",
      "  final VoidCallback? onBulkEdit; // (Optional)",
      "  final VoidCallback? onClearSelection;",
      "",
      "  const BulkActionBar({",
      "    Key? key,",
      "    required this.selectedCount,",
      "    this.onBulkDelete,",
      "    this.onBulkExport,",
      "    this.onBulkEdit,",
      "    this.onClearSelection,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "",
      "    if (selectedCount == 0) return const SizedBox.shrink();",
      "",
      "    return Material(",
      "      elevation: 6,",
      "      color: colorScheme.secondary.withOpacity(0.09),",
      "      borderRadius: BorderRadius.circular(DesignTokens.adminCardRadius),",
      "      child: Padding(",
      "        padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 10),",
      "        child: Row(",
      "          children: [",
      "            Icon(Icons.select_all, color: colorScheme.secondary, size: 24),",
      "            const SizedBox(width: 12),",
      "            Text(",
      "              loc.selectedCount(selectedCount),",
      "              style: Theme.of(context).textTheme.bodyMedium?.copyWith(",
      "                    fontWeight: FontWeight.w500,",
      "                    fontSize: 15,",
      "                    color: colorScheme.onSurface,",
      "                  ),",
      "            ),",
      "            const SizedBox(width: 28),",
      "            ElevatedButton.icon(",
      "              icon: Icon(Icons.delete_outline, color: colorScheme.onError),",
      "              label: Text(loc.delete),",
      "              style: ElevatedButton.styleFrom(",
      "                backgroundColor: colorScheme.error.withOpacity(0.88),",
      "                foregroundColor: colorScheme.onError,",
      "                elevation: DesignTokens.adminButtonElevation,",
      "                shape: RoundedRectangleBorder(",
      "                  borderRadius:",
      "                      BorderRadius.circular(DesignTokens.adminButtonRadius),",
      "                ),",
      "              ),",
      "              onPressed: onBulkDelete,",
      "            ),",
      "            const SizedBox(width: 10),",
      "            ElevatedButton.icon(",
      "              icon: Icon(Icons.file_download, color: colorScheme.onSecondary),",
      "              label: Text(loc.export),",
      "              style: ElevatedButton.styleFrom(",
      "                backgroundColor: colorScheme.secondary.withOpacity(0.92),",
      "                foregroundColor: colorScheme.onSecondary,",
      "                elevation: DesignTokens.adminButtonElevation,",
      "                shape: RoundedRectangleBorder(",
      "                  borderRadius:",
      "                      BorderRadius.circular(DesignTokens.adminButtonRadius),",
      "                ),",
      "              ),",
      "              onPressed: onBulkExport,",
      "            ),",
      "            if (onBulkEdit != null) ...[",
      "              const SizedBox(width: 10),",
      "              ElevatedButton.icon(",
      "                icon: Icon(Icons.edit, color: colorScheme.onSecondary),",
      "                label: Text(loc.edit),",
      "                style: ElevatedButton.styleFrom(",
      "                  backgroundColor: colorScheme.secondary.withOpacity(0.7),",
      "                  foregroundColor: colorScheme.onSecondary,",
      "                  elevation: DesignTokens.adminButtonElevation,",
      "                  shape: RoundedRectangleBorder(",
      "                    borderRadius:",
      "                        BorderRadius.circular(DesignTokens.adminButtonRadius),",
      "                  ),",
      "                ),",
      "                onPressed: onBulkEdit,",
      "              ),",
      "            ],",
      "            const Spacer(),",
      "            OutlinedButton.icon(",
      "              icon: Icon(Icons.clear, color: colorScheme.outline),",
      "              label: Text(loc.clearSelection),",
      "              style: OutlinedButton.styleFrom(",
      "                side: BorderSide(color: colorScheme.outline, width: 1),",
      "                foregroundColor: colorScheme.outline,",
      "                shape: RoundedRectangleBorder(",
      "                  borderRadius:",
      "                      BorderRadius.circular(DesignTokens.adminButtonRadius),",
      "                ),",
      "              ),",
      "              onPressed: onClearSelection,",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 119,
      "file_size": 4622,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\categories\\bulk_upload_dialog.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/models/category.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "// Optionally for user id:",
      "import 'package:franchise_admin_portal/core/providers/user_profile_notifier.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class BulkUploadDialog extends StatefulWidget {",
      "  final String franchiseId;",
      "",
      "  const BulkUploadDialog({",
      "    super.key,",
      "    required this.franchiseId,",
      "  });",
      "",
      "  @override",
      "  State<BulkUploadDialog> createState() => _BulkUploadDialogState();",
      "}",
      "",
      "class _BulkUploadDialogState extends State<BulkUploadDialog> {",
      "  final _controller = TextEditingController();",
      "  bool _isUploading = false;",
      "  String? _uploadResult;",
      "",
      "  Future<void> _showErrorDialog(BuildContext context, String message) async {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[YourWidget] loc is null! Localization not available for this context.');",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(content: Text('Localization missing! [debug]')),",
      "      );",
      "      return;",
      "    }",
      "    await showDialog(",
      "      context: context,",
      "      builder: (_) => AlertDialog(",
      "        title: Text(loc.error),",
      "        content: Text(message),",
      "        actions: [",
      "          TextButton(",
      "            onPressed: () => Navigator.pop(context),",
      "            child: Text(loc.ok),",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final franchiseId = widget.franchiseId;",
      "",
      "    final firestoreService =",
      "        Provider.of<FirestoreService>(context, listen: false);",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    // Optionally get userId for logging:",
      "    final userId =",
      "        Provider.of<UserProfileNotifier?>(context, listen: false)?.user?.id;",
      "",
      "    return AlertDialog(",
      "      title: Text(loc.bulkUploadCategories),",
      "      content: Column(",
      "        mainAxisSize: MainAxisSize.min,",
      "        children: [",
      "          Text(loc.bulkUploadInstructions),",
      "          const SizedBox(height: 8),",
      "          TextField(",
      "            controller: _controller,",
      "            minLines: 3,",
      "            maxLines: 10,",
      "            decoration: InputDecoration(",
      "              labelText: loc.bulkUploadPasteCsv,",
      "              hintText:",
      "                  'name,image,description\\nPizza,https://...,Delicious...',",
      "            ),",
      "            enabled: !_isUploading,",
      "          ),",
      "          if (_uploadResult != null)",
      "            Padding(",
      "              padding: const EdgeInsets.only(top: 8.0),",
      "              child: Text(",
      "                _uploadResult!,",
      "                style: TextStyle(",
      "                  color: _uploadResult!.toLowerCase().contains('success')",
      "                      ? Colors.green",
      "                      : Colors.red,",
      "                ),",
      "              ),",
      "            ),",
      "        ],",
      "      ),",
      "      actions: [",
      "        TextButton(",
      "          onPressed: _isUploading ? null : () => Navigator.pop(context),",
      "          child: Text(loc.cancel),",
      "        ),",
      "        ElevatedButton(",
      "          onPressed: _isUploading",
      "              ? null",
      "              : () async {",
      "                  setState(() => _isUploading = true);",
      "                  try {",
      "                    final lines = _controller.text.split('\\n');",
      "                    final List<Category> cats = [];",
      "                    for (var line in lines.skip(1)) {",
      "                      if (line.trim().isEmpty) continue;",
      "                      final cols = line.split(',');",
      "                      if (cols.isEmpty || cols[0].trim().isEmpty) continue;",
      "                      cats.add(Category(",
      "                        id: UniqueKey().toString(),",
      "                        name: cols[0].trim(),",
      "                        image: cols.length > 1 ? cols[1].trim() : null,",
      "                        description: cols.length > 2 ? cols[2].trim() : null,",
      "                      ));",
      "                    }",
      "                    for (final cat in cats) {",
      "                      await firestoreService.addCategory(",
      "                        franchiseId: franchiseId,",
      "                        category: cat,",
      "                      );",
      "                    }",
      "                    setState(() {",
      "                      _uploadResult =",
      "                          '${cats.length} ${loc.bulkUploadSuccess.toLowerCase()}';",
      "                    });",
      "                  } catch (e, stack) {",
      "                    // Remote error logging",
      "                    try {",
      "                      await ErrorLogger.log(",
      "                        message: e.toString(),",
      "                        source: 'bulk_upload_dialog',",
      "                        screen: 'BulkUploadDialog',",
      "                        stack: stack.toString(),",
      "                        severity: 'error',",
      "                        contextData: {",
      "                          'franchiseId': franchiseId,",
      "                          'userId': userId,",
      "                          'errorType': e.runtimeType.toString(),",
      "                          'csvText': _controller.text,",
      "                        },",
      "                      );",
      "                    } catch (_) {}",
      "                    setState(() => _uploadResult = loc.bulkUploadError);",
      "                    await _showErrorDialog(context, loc.bulkUploadError);",
      "                  } finally {",
      "                    setState(() => _isUploading = false);",
      "                  }",
      "                },",
      "          child: _isUploading",
      "              ? const SizedBox(",
      "                  height: 18,",
      "                  width: 18,",
      "                  child: CircularProgressIndicator(strokeWidth: 2))",
      "              : Text(loc.upload),",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 170,
      "file_size": 6182,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\categories\\category_form_dialog.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/models/category.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "// Optionally: If your user profile notifier/provider is named differently, update this import.",
      "import 'package:franchise_admin_portal/core/providers/user_profile_notifier.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class CategoryFormDialog extends StatefulWidget {",
      "  final String franchiseId;",
      "  final Category? category;",
      "  final Future<void> Function(Category category) onSaved;",
      "",
      "  const CategoryFormDialog({",
      "    super.key,",
      "    required this.franchiseId,",
      "    this.category,",
      "    required this.onSaved,",
      "  });",
      "",
      "  @override",
      "  State<CategoryFormDialog> createState() => _CategoryFormDialogState();",
      "}",
      "",
      "class _CategoryFormDialogState extends State<CategoryFormDialog> {",
      "  final _formKey = GlobalKey<FormState>();",
      "  late String _name;",
      "  String? _image;",
      "  String? _description;",
      "  bool _saving = false;",
      "",
      "  final _nameFocus = FocusNode();",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _name = widget.category?.name ?? '';",
      "    _image = widget.category?.image;",
      "    _description = widget.category?.description;",
      "    WidgetsBinding.instance.addPostFrameCallback((_) {",
      "      _nameFocus.requestFocus();",
      "    });",
      "  }",
      "",
      "  @override",
      "  void dispose() {",
      "    _nameFocus.dispose();",
      "    super.dispose();",
      "  }",
      "",
      "  Future<void> _showErrorDialog(BuildContext context, String message) async {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[YourWidget] loc is null! Localization not available for this context.');",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(content: Text('Localization missing! [debug]')),",
      "      );",
      "      return;",
      "    }",
      "    await showDialog(",
      "      context: context,",
      "      builder: (_) => AlertDialog(",
      "        title: Text(loc.error),",
      "        content: Text(message),",
      "        actions: [",
      "          TextButton(",
      "            onPressed: () => Navigator.pop(context),",
      "            child: Text(loc.ok),",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final franchiseId = widget.franchiseId;",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "",
      "    return AlertDialog(",
      "      title: Text(widget.category == null ? loc.addCategory : loc.editCategory),",
      "      content: SingleChildScrollView(",
      "        child: Form(",
      "          key: _formKey,",
      "          child: AutofillGroup(",
      "            child: Column(",
      "              mainAxisSize: MainAxisSize.min,",
      "              children: [",
      "                // Name field (required, autofocus)",
      "                TextFormField(",
      "                  initialValue: _name,",
      "                  focusNode: _nameFocus,",
      "                  decoration: InputDecoration(",
      "                    labelText: loc.categoryName,",
      "                  ),",
      "                  validator: (val) => (val == null || val.trim().isEmpty)",
      "                      ? loc.requiredField",
      "                      : null,",
      "                  onSaved: (val) => _name = val!.trim(),",
      "                  enabled: !_saving,",
      "                  textInputAction: TextInputAction.next,",
      "                  autofillHints: const [AutofillHints.name],",
      "                ),",
      "                const SizedBox(height: 12),",
      "                // Image URL field",
      "                TextFormField(",
      "                  initialValue: _image,",
      "                  decoration: InputDecoration(",
      "                    labelText: loc.categoryImageUrl,",
      "                  ),",
      "                  onSaved: (val) => _image = val?.trim(),",
      "                  enabled: !_saving,",
      "                  textInputAction: TextInputAction.next,",
      "                  autofillHints: const [AutofillHints.url],",
      "                ),",
      "                const SizedBox(height: 12),",
      "                // Description field",
      "                TextFormField(",
      "                  initialValue: _description,",
      "                  decoration: InputDecoration(",
      "                    labelText: loc.categoryDescription,",
      "                  ),",
      "                  onSaved: (val) => _description = val?.trim(),",
      "                  minLines: 1,",
      "                  maxLines: 3,",
      "                  enabled: !_saving,",
      "                  textInputAction: TextInputAction.done,",
      "                ),",
      "                // --- Placeholder for future custom fields here ---",
      "              ],",
      "            ),",
      "          ),",
      "        ),",
      "      ),",
      "      actions: [",
      "        TextButton(",
      "          onPressed: _saving ? null : () => Navigator.pop(context),",
      "          child: Text(loc.cancel),",
      "        ),",
      "        ElevatedButton(",
      "          style: ElevatedButton.styleFrom(",
      "            backgroundColor: DesignTokens.primaryColor,",
      "            foregroundColor: DesignTokens.foregroundColor,",
      "          ),",
      "          onPressed: _saving",
      "              ? null",
      "              : () async {",
      "                  if (_formKey.currentState?.validate() ?? false) {",
      "                    _formKey.currentState?.save();",
      "                    setState(() => _saving = true);",
      "                    final category = Category(",
      "                      id: widget.category?.id ?? UniqueKey().toString(),",
      "                      name: _name,",
      "                      image: _image,",
      "                      description: _description,",
      "                    );",
      "                    try {",
      "                      await widget.onSaved(category);",
      "                      if (context.mounted) Navigator.pop(context);",
      "                    } catch (e, stack) {",
      "                      // --- Remote error logging to Firestore ---",
      "                      try {",
      "                        final userId = Provider.of<UserProfileNotifier>(context,",
      "                                listen: false)",
      "                            .user",
      "                            ?.id;",
      "                        await ErrorLogger.log(",
      "                          message: e.toString(),",
      "                          source: 'category_form_dialog',",
      "                          screen: 'CategoryFormDialog',",
      "                          stack: stack.toString(),",
      "                          severity: 'error',",
      "                          contextData: {",
      "                            'franchiseId': franchiseId,",
      "                            'userId': userId,",
      "                            'errorType': e.runtimeType.toString(),",
      "                            'categoryId': widget.category?.id ?? 'new',",
      "                            'name': _name,",
      "                            'image': _image,",
      "                            'description': _description,",
      "                          },",
      "                        );",
      "                      } catch (_) {",
      "                        // If even logging fails, continue to show error to user.",
      "                      }",
      "                      if (context.mounted) {",
      "                        await _showErrorDialog(",
      "                          context,",
      "                          AppLocalizations.of(context)!.failedToSaveCategory,",
      "                        );",
      "                      }",
      "                    } finally {",
      "                      if (mounted) setState(() => _saving = false);",
      "                    }",
      "                  }",
      "                },",
      "          child: _saving",
      "              ? const SizedBox(",
      "                  width: 24,",
      "                  height: 24,",
      "                  child: CircularProgressIndicator(strokeWidth: 2),",
      "                )",
      "              : Text(loc.save),",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 220,
      "file_size": 8108,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\categories\\category_management_screen.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/models/category.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/config/branding_config.dart';",
      "import 'package:franchise_admin_portal/widgets/empty_state_widget.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/user_profile_notifier.dart';",
      "import 'package:franchise_admin_portal/core/utils/user_permissions.dart';",
      "import 'package:franchise_admin_portal/core/providers/role_guard.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/widgets/subscription_access_guard.dart';",
      "import 'package:franchise_admin_portal/admin/hq_owner/widgets/active_plan_banner.dart';",
      "import 'package:franchise_admin_portal/widgets/subscription/grace_period_banner.dart';",
      "import 'category_form_dialog.dart';",
      "import 'bulk_upload_dialog.dart';",
      "import 'category_search_bar.dart';",
      "import 'bulk_action_bar.dart';",
      "import 'unauthorized_widget.dart';",
      "import 'undo_snackbar.dart';",
      "",
      "const categoryColumns = [",
      "  {\"key\": \"select\", \"width\": 40.0, \"header\": \"\"},",
      "  {\"key\": \"image\", \"width\": 56.0, \"header\": \"\"},",
      "  {\"key\": \"name\", \"flex\": 3, \"header\": \"Category Name\"},",
      "  {\"key\": \"description\", \"flex\": 5, \"header\": \"Description (optional)\"},",
      "  {\"key\": \"actions\", \"width\": 96.0, \"header\": \"\"},",
      "];",
      "",
      "class CategoryManagementScreen extends StatelessWidget {",
      "  const CategoryManagementScreen({super.key});",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return RoleGuard(",
      "      requireAnyRole: [",
      "        'platform_owner',",
      "        'hq_owner',",
      "        'manager',",
      "        'developer',",
      "        'admin',",
      "      ],",
      "      featureName: 'category_management_screen',",
      "      screen: 'CategoryManagementScreen',",
      "      child: const CategoryManagementScreenContent(),",
      "    );",
      "  }",
      "}",
      "",
      "class CategoryManagementScreenContent extends StatefulWidget {",
      "  const CategoryManagementScreenContent({super.key});",
      "",
      "  @override",
      "  State<CategoryManagementScreenContent> createState() =>",
      "      _CategoryManagementScreenContentState();",
      "}",
      "",
      "class _CategoryManagementScreenContentState",
      "    extends State<CategoryManagementScreenContent> {",
      "  late FirestoreService firestoreService;",
      "  List<Category> _allCategories = [];",
      "  List<Category> _filteredCategories = [];",
      "  Set<String> _selectedIds = {};",
      "  String _searchQuery = '';",
      "  String _sortKey = 'name';",
      "  bool _sortAsc = true;",
      "  bool _isLoading = false;",
      "  bool _bulkLoading = false;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    firestoreService = Provider.of<FirestoreService>(context, listen: false);",
      "  }",
      "",
      "  bool get _canManage {",
      "    final user = Provider.of<UserProfileNotifier>(context, listen: false).user;",
      "    return UserPermissions.canManageCategories(user);",
      "  }",
      "",
      "  void _onCategorySelect(String id, bool selected) {",
      "    setState(() {",
      "      selected ? _selectedIds.add(id) : _selectedIds.remove(id);",
      "    });",
      "  }",
      "",
      "  void _onSelectAll(bool? checked) {",
      "    setState(() {",
      "      _selectedIds =",
      "          checked == true ? _filteredCategories.map((c) => c.id).toSet() : {};",
      "    });",
      "  }",
      "",
      "  Future<void> _openCategoryDialog({Category? category}) async {",
      "    final franchiseId = context.read<FranchiseProvider>().franchiseId;",
      "    if (!_canManage || _isLoading || _bulkLoading) return;",
      "",
      "    await showDialog<Category>(",
      "      context: context,",
      "      builder: (_) => CategoryFormDialog(",
      "        franchiseId: franchiseId, // ✅ REQUIRED FIX",
      "        category: category,",
      "        onSaved: (Category saved) async {",
      "          setState(() => _isLoading = true);",
      "          final userId =",
      "              Provider.of<UserProfileNotifier?>(context, listen: false)",
      "                  ?.user",
      "                  ?.id;",
      "          try {",
      "            if (category == null) {",
      "              await firestoreService.addCategory(",
      "                franchiseId: franchiseId,",
      "                category: saved,",
      "              );",
      "              ScaffoldMessenger.of(context).showSnackBar(",
      "                SnackBar(",
      "                    content: Text(AppLocalizations.of(context)!.categoryAdded)),",
      "              );",
      "            } else {",
      "              await firestoreService.updateCategory(franchiseId, saved);",
      "              ScaffoldMessenger.of(context).showSnackBar(",
      "                SnackBar(",
      "                    content:",
      "                        Text(AppLocalizations.of(context)!.categoryUpdated)),",
      "              );",
      "            }",
      "          } catch (e, stack) {",
      "            await ErrorLogger.log(",
      "              message: e.toString(),",
      "              stack: stack.toString(),",
      "              source: 'category_management_screen',",
      "              screen: 'CategoryManagementScreen',",
      "              contextData: {",
      "                'franchiseId': franchiseId,",
      "                'userId': userId,",
      "                'categoryId': category?.id ?? 'new',",
      "                'name': saved.name,",
      "                'image': saved.image,",
      "                'description': saved.description,",
      "                'operation': category == null ? 'add' : 'update',",
      "              },",
      "            );",
      "            ScaffoldMessenger.of(context).showSnackBar(",
      "              SnackBar(",
      "                  content:",
      "                      Text(AppLocalizations.of(context)!.failedToSaveCategory)),",
      "            );",
      "          } finally {",
      "            setState(() => _isLoading = false);",
      "          }",
      "        },",
      "      ),",
      "    );",
      "  }",
      "",
      "  Future<void> _deleteCategory(Category category,",
      "      {bool showUndo = true}) async {",
      "    final franchiseId = context.watch<FranchiseProvider>().franchiseId;",
      "    if (!_canManage || _isLoading || _bulkLoading) return;",
      "    final loc = AppLocalizations.of(context)!;",
      "    final userId =",
      "        Provider.of<UserProfileNotifier?>(context, listen: false)?.user?.id;",
      "",
      "    final confirm = await showDialog<bool>(",
      "      context: context,",
      "      builder: (ctx) => AlertDialog(",
      "        title: Text(loc.deleteCategory),",
      "        content: Text(loc.deleteCategoryConfirm(category.name)),",
      "        actions: [",
      "          TextButton(",
      "              onPressed: () => Navigator.pop(ctx, false),",
      "              child: Text(loc.cancel)),",
      "          ElevatedButton(",
      "            onPressed: () => Navigator.pop(ctx, true),",
      "            style: ElevatedButton.styleFrom(",
      "              backgroundColor: DesignTokens.errorColor,",
      "              foregroundColor: Colors.white,",
      "            ),",
      "            child: Text(loc.delete),",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "",
      "    if (confirm == true) {",
      "      setState(() => _isLoading = true);",
      "      try {",
      "        await firestoreService.deleteCategory(",
      "          franchiseId: franchiseId,",
      "          categoryId: category.id,",
      "        );",
      "      } catch (e, stack) {",
      "        await ErrorLogger.log(",
      "          message: e.toString(),",
      "          stack: stack.toString(),",
      "          source: 'category_management_screen',",
      "          screen: 'CategoryManagementScreen',",
      "          contextData: {",
      "            'franchiseId': franchiseId,",
      "            'userId': userId,",
      "            'categoryId': category.id,",
      "            'name': category.name,",
      "            'operation': 'delete',",
      "          },",
      "        );",
      "",
      "        ScaffoldMessenger.of(context)",
      "            .showSnackBar(SnackBar(content: Text(loc.failedToDeleteCategory)));",
      "      }",
      "      setState(() => _isLoading = false);",
      "      if (showUndo) {",
      "        UndoSnackbar.show(",
      "          context,",
      "          message: loc.categoryDeleted,",
      "          onUndo: () async {",
      "            setState(() => _isLoading = true);",
      "            try {",
      "              await firestoreService.addCategory(",
      "                franchiseId: franchiseId,",
      "                category: category,",
      "              );",
      "            } catch (e, stack) {",
      "              await ErrorLogger.log(",
      "                message: e.toString(),",
      "                stack: stack.toString(),",
      "                source: 'category_management_screen',",
      "                screen: 'CategoryManagementScreen',",
      "                contextData: {",
      "                  'franchiseId': franchiseId,",
      "                  'userId': userId,",
      "                  'categoryId': category.id,",
      "                  'name': category.name,",
      "                  'operation': 'undo_restore',",
      "                },",
      "              );",
      "              ScaffoldMessenger.of(context).showSnackBar(",
      "                  SnackBar(content: Text(loc.failedToRestoreCategory)));",
      "            }",
      "            setState(() => _isLoading = false);",
      "          },",
      "        );",
      "      } else {",
      "        ScaffoldMessenger.of(context)",
      "            .showSnackBar(SnackBar(content: Text(loc.categoryDeleted)));",
      "      }",
      "    }",
      "  }",
      "",
      "  void _showBulkUploadDialog() async {",
      "    if (!_canManage || _isLoading || _bulkLoading) return;",
      "    final franchiseId = context.read<FranchiseProvider>().franchiseId;",
      "",
      "    final uploaded = await showDialog<bool>(",
      "      context: context,",
      "      builder: (_) => BulkUploadDialog(franchiseId: franchiseId),",
      "    );",
      "    if (uploaded == true) {",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(",
      "            content: Text(AppLocalizations.of(context)!.bulkUploadSuccess)),",
      "      );",
      "    }",
      "  }",
      "",
      "  void _onSearch(String query) {",
      "    setState(() {",
      "      _searchQuery = query;",
      "      _filteredCategories = _allCategories",
      "          .where((c) => c.name.toLowerCase().contains(query.toLowerCase()))",
      "          .toList();",
      "      _selectedIds",
      "          .removeWhere((id) => !_filteredCategories.any((c) => c.id == id));",
      "    });",
      "  }",
      "",
      "  void _onSort(String key, bool ascending) {",
      "    setState(() {",
      "      _sortKey = key;",
      "      _sortAsc = ascending;",
      "      _filteredCategories.sort((a, b) {",
      "        final cmp = switch (key) {",
      "          'name' => a.name.compareTo(b.name),",
      "          'description' => (a.description ?? '').compareTo(b.description ?? ''),",
      "          _ => 0,",
      "        };",
      "        return ascending ? cmp : -cmp;",
      "      });",
      "    });",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final franchiseId = context.watch<FranchiseProvider>().franchiseId;",
      "    final loc = AppLocalizations.of(context)!;",
      "    final isMobile = MediaQuery.of(context).size.width < 600;",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "",
      "    return Stack(",
      "      children: [",
      "        SubscriptionAccessGuard(",
      "          child: Scaffold(",
      "            backgroundColor: colorScheme.background,",
      "            body: Row(",
      "              crossAxisAlignment: CrossAxisAlignment.start,",
      "              children: [",
      "                Expanded(",
      "                  flex: 11,",
      "                  child: Padding(",
      "                    padding: const EdgeInsets.all(24.0),",
      "                    child: Column(",
      "                      crossAxisAlignment: CrossAxisAlignment.start,",
      "                      children: [",
      "                        const GracePeriodBanner(),",
      "                        Row(",
      "                          children: [",
      "                            Text(",
      "                              loc.adminCategoryManagement,",
      "                              style: TextStyle(",
      "                                color: colorScheme.onBackground,",
      "                                fontWeight: FontWeight.bold,",
      "                                fontSize: 22,",
      "                              ),",
      "                            ),",
      "                            const Spacer(),",
      "                            IconButton(",
      "                              icon: Icon(Icons.upload_file,",
      "                                  color: colorScheme.onBackground),",
      "                              tooltip: loc.bulkUploadCategories,",
      "                              onPressed: _isLoading || _bulkLoading",
      "                                  ? null",
      "                                  : _showBulkUploadDialog,",
      "                            ),",
      "                            IconButton(",
      "                              icon: Icon(Icons.add,",
      "                                  color: colorScheme.onBackground),",
      "                              tooltip: loc.addCategory,",
      "                              onPressed: _isLoading || _bulkLoading",
      "                                  ? null",
      "                                  : () => _openCategoryDialog(),",
      "                            ),",
      "                          ],",
      "                        ),",
      "                        const SizedBox(height: 12),",
      "                        CategorySearchBar(",
      "                          onChanged: _onSearch,",
      "                          onSortChanged: (sortKey) =>",
      "                              _onSort(sortKey ?? _sortKey, _sortAsc),",
      "                          currentSort: _sortKey,",
      "                          ascending: _sortAsc,",
      "                          onSortDirectionToggle: () =>",
      "                              _onSort(_sortKey, !_sortAsc),",
      "                        ),",
      "                        if (!isMobile && _selectedIds.isNotEmpty)",
      "                          Padding(",
      "                            padding: const EdgeInsets.only(top: 8.0),",
      "                            child: BulkActionBar(",
      "                              selectedCount: _selectedIds.length,",
      "                              onBulkDelete: () {},",
      "                              onClearSelection: () =>",
      "                                  setState(() => _selectedIds.clear()),",
      "                            ),",
      "                          ),",
      "                        const SizedBox(height: 12),",
      "                        Expanded(",
      "                          child: StreamBuilder<List<Category>>(",
      "                            stream: firestoreService.getCategories(franchiseId),",
      "                            builder: (context, snapshot) {",
      "                              if (snapshot.hasError) {",
      "                                return EmptyStateWidget(",
      "                                  title: loc.errorLoadingCategories,",
      "                                  message: loc.pleaseTryAgain,",
      "                                  imageAsset: BrandingConfig.bannerPlaceholder,",
      "                                  onRetry: () => setState(() {}),",
      "                                  buttonText: loc.retry,",
      "                                );",
      "                              }",
      "                              _allCategories = snapshot.data ?? [];",
      "                              _filteredCategories = _searchQuery.isEmpty",
      "                                  ? _allCategories",
      "                                  : _allCategories",
      "                                      .where((c) => c.name",
      "                                          .toLowerCase()",
      "                                          .contains(_searchQuery.toLowerCase()))",
      "                                      .toList();",
      "                              _selectedIds.removeWhere((id) =>",
      "                                  !_filteredCategories.any((c) => c.id == id));",
      "",
      "                              if (_filteredCategories.isEmpty) {",
      "                                return EmptyStateWidget(",
      "                                  title: loc.noCategoriesFound,",
      "                                  message: loc.noCategoriesMessage,",
      "                                  imageAsset: BrandingConfig.bannerPlaceholder,",
      "                                );",
      "                              }",
      "",
      "                              return isMobile",
      "                                  ? ListView.separated(",
      "                                      itemCount: _filteredCategories.length,",
      "                                      separatorBuilder: (_, __) =>",
      "                                          const Divider(height: 1),",
      "                                      itemBuilder: (ctx, idx) {",
      "                                        final category =",
      "                                            _filteredCategories[idx];",
      "                                        return ListTile(",
      "                                          leading: (category",
      "                                                      .image?.isNotEmpty ??",
      "                                                  false)",
      "                                              ? CircleAvatar(",
      "                                                  backgroundImage: NetworkImage(",
      "                                                      category.image!),",
      "                                                  radius: 24,",
      "                                                )",
      "                                              : CircleAvatar(",
      "                                                  backgroundImage: AssetImage(",
      "                                                      BrandingConfig",
      "                                                          .defaultCategoryIcon),",
      "                                                  radius: 24,",
      "                                                ),",
      "                                          title: Text(category.name),",
      "                                          subtitle: (category.description",
      "                                                      ?.isNotEmpty ??",
      "                                                  false)",
      "                                              ? Text(category.description!)",
      "                                              : null,",
      "                                          trailing: Row(",
      "                                            mainAxisSize: MainAxisSize.min,",
      "                                            children: [",
      "                                              IconButton(",
      "                                                icon: Icon(Icons.edit,",
      "                                                    color:",
      "                                                        colorScheme.secondary),",
      "                                                tooltip: loc.edit,",
      "                                                onPressed: _isLoading ||",
      "                                                        _bulkLoading",
      "                                                    ? null",
      "                                                    : () => _openCategoryDialog(",
      "                                                        category: category),",
      "                                              ),",
      "                                              IconButton(",
      "                                                icon: Icon(Icons.delete,",
      "                                                    color: colorScheme.error),",
      "                                                tooltip: loc.delete,",
      "                                                onPressed:",
      "                                                    _isLoading || _bulkLoading",
      "                                                        ? null",
      "                                                        : () => _deleteCategory(",
      "                                                            category),",
      "                                              ),",
      "                                            ],",
      "                                          ),",
      "                                        );",
      "                                      },",
      "                                    )",
      "                                  : Column(",
      "                                      children: [",
      "                                        buildCategoryHeaderRow(context, true),",
      "                                        const Divider(height: 1),",
      "                                        Expanded(",
      "                                          child: ListView.separated(",
      "                                            itemCount:",
      "                                                _filteredCategories.length,",
      "                                            separatorBuilder: (_, __) =>",
      "                                                const Divider(height: 1),",
      "                                            itemBuilder: (ctx, idx) =>",
      "                                                buildCategoryDataRow(",
      "                                                    ctx,",
      "                                                    _filteredCategories[idx],",
      "                                                    true),",
      "                                          ),",
      "                                        ),",
      "                                      ],",
      "                                    );",
      "                            },",
      "                          ),",
      "                        ),",
      "                      ],",
      "                    ),",
      "                  ),",
      "                ),",
      "                Expanded(flex: 9, child: Container()),",
      "              ],",
      "            ),",
      "          ),",
      "        ),",
      "        if (_isLoading || _bulkLoading)",
      "          Container(",
      "            color: Colors.black.withOpacity(0.22),",
      "            child: const Center(child: CircularProgressIndicator()),",
      "          ),",
      "      ],",
      "    );",
      "  }",
      "",
      "  Widget buildCategoryHeaderRow(BuildContext context, bool isDesktop) {",
      "    return Padding(",
      "      padding: const EdgeInsets.symmetric(vertical: 8.0),",
      "      child: Row(",
      "        children: categoryColumns.map((col) {",
      "          if (col[\"key\"] == \"select\" && isDesktop) {",
      "            return SizedBox(",
      "              width: col[\"width\"] as double,",
      "              child: Checkbox(",
      "                value: _filteredCategories.isNotEmpty &&",
      "                    _selectedIds.length == _filteredCategories.length,",
      "                onChanged: (checked) => _onSelectAll(checked),",
      "                semanticLabel: AppLocalizations.of(context)!.bulkSelection,",
      "              ),",
      "            );",
      "          } else if (col.containsKey(\"width\")) {",
      "            return SizedBox(",
      "              width: col[\"width\"] as double,",
      "              child: Center(",
      "                child: Text(col[\"header\"] as String? ?? \"\",",
      "                    style: const TextStyle(fontWeight: FontWeight.bold)),",
      "              ),",
      "            );",
      "          } else {",
      "            return Expanded(",
      "              flex: col[\"flex\"] as int,",
      "              child: Text(col[\"header\"] as String? ?? \"\",",
      "                  style: const TextStyle(fontWeight: FontWeight.bold)),",
      "            );",
      "          }",
      "        }).toList(),",
      "      ),",
      "    );",
      "  }",
      "",
      "  Widget buildCategoryDataRow(",
      "      BuildContext context, Category category, bool isDesktop) {",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    return Row(",
      "      children: categoryColumns.map((col) {",
      "        switch (col[\"key\"]) {",
      "          case \"select\":",
      "            if (!isDesktop) return const SizedBox(width: 0);",
      "            return SizedBox(",
      "              width: col[\"width\"] as double,",
      "              child: Checkbox(",
      "                value: _selectedIds.contains(category.id),",
      "                onChanged: (checked) =>",
      "                    _onCategorySelect(category.id, checked ?? false),",
      "              ),",
      "            );",
      "          case \"image\":",
      "            return SizedBox(",
      "              width: col[\"width\"] as double,",
      "              child: Center(",
      "                child: category.image != null && category.image!.isNotEmpty",
      "                    ? CircleAvatar(",
      "                        backgroundImage: NetworkImage(category.image!),",
      "                        radius: 20)",
      "                    : CircleAvatar(",
      "                        backgroundImage:",
      "                            AssetImage(BrandingConfig.defaultCategoryIcon),",
      "                        radius: 20),",
      "              ),",
      "            );",
      "          case \"name\":",
      "            return Expanded(",
      "              flex: col[\"flex\"] as int,",
      "              child: Padding(",
      "                padding:",
      "                    const EdgeInsets.symmetric(vertical: 14.0, horizontal: 8.0),",
      "                child: Text(category.name),",
      "              ),",
      "            );",
      "          case \"description\":",
      "            return Expanded(",
      "              flex: col[\"flex\"] as int,",
      "              child: Padding(",
      "                padding:",
      "                    const EdgeInsets.symmetric(vertical: 14.0, horizontal: 8.0),",
      "                child: Text(category.description ?? ''),",
      "              ),",
      "            );",
      "          case \"actions\":",
      "            return SizedBox(",
      "              width: col[\"width\"] as double,",
      "              child: Row(",
      "                mainAxisAlignment: MainAxisAlignment.center,",
      "                children: [",
      "                  IconButton(",
      "                    icon: Icon(Icons.edit, color: colorScheme.secondary),",
      "                    tooltip: AppLocalizations.of(context)!.edit,",
      "                    onPressed: _isLoading || _bulkLoading",
      "                        ? null",
      "                        : () => _openCategoryDialog(category: category),",
      "                  ),",
      "                  IconButton(",
      "                    icon: Icon(Icons.delete, color: colorScheme.error),",
      "                    tooltip: AppLocalizations.of(context)!.delete,",
      "                    onPressed: _isLoading || _bulkLoading",
      "                        ? null",
      "                        : () => _deleteCategory(category),",
      "                  ),",
      "                ],",
      "              ),",
      "            );",
      "          default:",
      "            return const SizedBox.shrink();",
      "        }",
      "      }).toList(),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 608,
      "file_size": 25225,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\categories\\category_search_bar.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "",
      "class CategorySearchBar extends StatelessWidget {",
      "  final void Function(String) onChanged;",
      "  final void Function(String?)? onSortChanged;",
      "  final String? currentSort;",
      "  final bool ascending;",
      "  final VoidCallback? onSortDirectionToggle;",
      "",
      "  const CategorySearchBar({",
      "    super.key,",
      "    required this.onChanged,",
      "    this.onSortChanged,",
      "    this.currentSort,",
      "    this.ascending = true,",
      "    this.onSortDirectionToggle,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "",
      "    return Padding(",
      "      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),",
      "      child: Row(",
      "        children: [",
      "          Expanded(",
      "            child: TextField(",
      "              onChanged: onChanged,",
      "              decoration: InputDecoration(",
      "                hintText: loc.searchCategories,",
      "                prefixIcon: const Icon(Icons.search),",
      "                border: OutlineInputBorder(",
      "                  borderRadius: BorderRadius.circular(12),",
      "                ),",
      "                isDense: true,",
      "              ),",
      "            ),",
      "          ),",
      "          const SizedBox(width: 12),",
      "          DropdownButton<String>(",
      "            value: currentSort ?? 'name',",
      "            items: [",
      "              DropdownMenuItem(value: 'name', child: Text(loc.sortByName)),",
      "              DropdownMenuItem(",
      "                  value: 'description', child: Text(loc.sortByDescription)),",
      "              // Add more sort options here as needed",
      "            ],",
      "            onChanged: onSortChanged,",
      "            underline: const SizedBox(),",
      "            style: Theme.of(context).textTheme.bodyMedium,",
      "            icon: const Icon(Icons.sort),",
      "            dropdownColor: colorScheme.surface,",
      "          ),",
      "          if (onSortDirectionToggle != null) ...[",
      "            const SizedBox(width: 8),",
      "            IconButton(",
      "              tooltip: ascending ? loc.sortAscending : loc.sortDescending,",
      "              onPressed: onSortDirectionToggle,",
      "              icon: Icon(",
      "                ascending",
      "                    ? Icons.arrow_upward_rounded",
      "                    : Icons.arrow_downward_rounded,",
      "                color: colorScheme.secondary,",
      "              ),",
      "              visualDensity: VisualDensity.compact,",
      "            ),",
      "          ],",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 82,
      "file_size": 2742,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\categories\\unauthorized_widget.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/config/branding_config.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "",
      "class UnauthorizedWidget extends StatelessWidget {",
      "  final String? message;",
      "  final VoidCallback? onHome;",
      "  final String? actionLabel;",
      "",
      "  const UnauthorizedWidget({",
      "    Key? key,",
      "    this.message,",
      "    this.onHome,",
      "    this.actionLabel,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    final isDark = Theme.of(context).brightness == Brightness.dark;",
      "",
      "    return Center(",
      "      child: Padding(",
      "        padding: const EdgeInsets.all(32),",
      "        child: Card(",
      "          color: colorScheme.surface,",
      "          elevation: DesignTokens.adminCardElevation,",
      "          shape: RoundedRectangleBorder(",
      "            borderRadius: BorderRadius.circular(DesignTokens.adminCardRadius),",
      "          ),",
      "          child: Padding(",
      "            padding: const EdgeInsets.symmetric(vertical: 36, horizontal: 32),",
      "            child: Column(",
      "              mainAxisSize: MainAxisSize.min,",
      "              children: [",
      "                Semantics(",
      "                  label: loc.unauthorizedAccess,",
      "                  child: CircleAvatar(",
      "                    backgroundColor: colorScheme.error.withOpacity(0.13),",
      "                    radius: 38,",
      "                    child: Icon(",
      "                      Icons.lock_outline_rounded,",
      "                      color: colorScheme.error,",
      "                      size: 48,",
      "                    ),",
      "                  ),",
      "                ),",
      "                const SizedBox(height: 22),",
      "                Text(",
      "                  loc.unauthorizedAccessTitle,",
      "                  style: Theme.of(context).textTheme.titleLarge?.copyWith(",
      "                        color: colorScheme.error,",
      "                        fontWeight: FontWeight.bold,",
      "                        fontSize: 22,",
      "                      ),",
      "                  textAlign: TextAlign.center,",
      "                ),",
      "                const SizedBox(height: 12),",
      "                Text(",
      "                  message ?? loc.unauthorizedAccessMessage,",
      "                  style: Theme.of(context).textTheme.bodyMedium?.copyWith(",
      "                        color: colorScheme.onSurface.withOpacity(0.8),",
      "                        fontSize: 16,",
      "                      ),",
      "                  textAlign: TextAlign.center,",
      "                ),",
      "                const SizedBox(height: 28),",
      "                ElevatedButton.icon(",
      "                  style: ElevatedButton.styleFrom(",
      "                    backgroundColor:",
      "                        isDark ? Colors.white : colorScheme.primary,",
      "                    foregroundColor:",
      "                        isDark ? Colors.black : colorScheme.onPrimary,",
      "                    elevation: DesignTokens.adminButtonElevation,",
      "                    shape: RoundedRectangleBorder(",
      "                      borderRadius:",
      "                          BorderRadius.circular(DesignTokens.adminButtonRadius),",
      "                    ),",
      "                    padding: const EdgeInsets.symmetric(",
      "                        horizontal: 28, vertical: 16),",
      "                  ),",
      "                  onPressed: onHome,",
      "                  icon: Icon(Icons.home_rounded,",
      "                      color: isDark ? Colors.black : colorScheme.onPrimary),",
      "                  label: Text(",
      "                    actionLabel ?? loc.returnHome,",
      "                    style: TextStyle(",
      "                      color: isDark ? Colors.black : colorScheme.onPrimary,",
      "                      fontWeight: FontWeight.w600,",
      "                      fontSize: 16,",
      "                    ),",
      "                  ),",
      "                ),",
      "                const SizedBox(height: 12),",
      "                Image.asset(",
      "                  BrandingConfig.bannerPlaceholder,",
      "                  height: 72,",
      "                  fit: BoxFit.contain,",
      "                  semanticLabel: loc.adminDashboardTitle,",
      "                ),",
      "              ],",
      "            ),",
      "          ),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 117,
      "file_size": 4465,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\categories\\undo_snackbar.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "",
      "/// Shows a snackbar with \"Undo\" action.",
      "/// Usage:",
      "///   UndoSnackbar.show(context, message: \"...\", onUndo: () { ... });",
      "class UndoSnackbar {",
      "  static void show(",
      "    BuildContext context, {",
      "    required String message,",
      "    required VoidCallback onUndo,",
      "    Duration duration = const Duration(seconds: 6),",
      "    String? undoLabel,",
      "    void Function(SnackBarClosedReason reason)? onClosed,",
      "  }) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[YourWidget] loc is null! Localization not available for this context.');",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(content: Text('Localization missing! [debug]')),",
      "      );",
      "      return;",
      "    }",
      "    final scaffold = ScaffoldMessenger.of(context);",
      "",
      "    scaffold.hideCurrentSnackBar();",
      "    scaffold",
      "        .showSnackBar(",
      "          SnackBar(",
      "            content: Text(message),",
      "            action: SnackBarAction(",
      "              label: undoLabel ?? loc.undo,",
      "              onPressed: onUndo,",
      "            ),",
      "            duration: duration,",
      "            behavior: SnackBarBehavior.floating,",
      "            shape: RoundedRectangleBorder(",
      "              borderRadius: BorderRadius.circular(12),",
      "            ),",
      "            margin: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),",
      "          ),",
      "        )",
      "        .closed",
      "        .then((reason) {",
      "      if (onClosed != null) onClosed(reason);",
      "    });",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 49,
      "file_size": 1563,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\chat\\admin_chat_detail_dialog.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/models/message.dart';",
      "",
      "class AdminChatDetailDialog extends StatefulWidget {",
      "  final String franchiseId;",
      "  final String chatId;",
      "  final String userName;",
      "  const AdminChatDetailDialog(",
      "      {super.key,",
      "      required this.franchiseId,",
      "      required this.chatId,",
      "      required this.userName});",
      "",
      "  @override",
      "  State<AdminChatDetailDialog> createState() => _AdminChatDetailDialogState();",
      "}",
      "",
      "class _AdminChatDetailDialogState extends State<AdminChatDetailDialog> {",
      "  final TextEditingController _controller = TextEditingController();",
      "  bool _sending = false;",
      "",
      "  @override",
      "  void dispose() {",
      "    _controller.dispose();",
      "    super.dispose();",
      "  }",
      "",
      "  Future<void> _sendReply() async {",
      "    final text = _controller.text.trim();",
      "    if (text.isEmpty) return;",
      "    setState(() => _sending = true);",
      "    try {",
      "      final firestore = Provider.of<FirestoreService>(context, listen: false);",
      "      final franchiseId = widget.franchiseId;",
      "      await firestore.sendSupportReply(",
      "        franchiseId: franchiseId,",
      "        chatId: widget.chatId,",
      "        senderId: \"support\",",
      "        content: text,",
      "      );",
      "      _controller.clear();",
      "    } finally {",
      "      if (mounted) setState(() => _sending = false);",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final firestore = Provider.of<FirestoreService>(context, listen: false);",
      "    return Dialog(",
      "      child: SizedBox(",
      "        width: 380,",
      "        height: 550,",
      "        child: Column(",
      "          children: [",
      "            Padding(",
      "              padding: const EdgeInsets.all(12),",
      "              child: Text(",
      "                'Chat with ${widget.userName}',",
      "                style:",
      "                    const TextStyle(fontWeight: FontWeight.bold, fontSize: 18),",
      "              ),",
      "            ),",
      "            Expanded(",
      "              child: StreamBuilder<List<Message>>(",
      "                stream: firestore.streamChatMessages(",
      "                    widget.franchiseId, widget.chatId),",
      "                builder: (context, snapshot) {",
      "                  if (snapshot.connectionState == ConnectionState.waiting) {",
      "                    return const Center(child: CircularProgressIndicator());",
      "                  }",
      "                  final messages = snapshot.data ?? [];",
      "                  if (messages.isEmpty) {",
      "                    return const Center(child: Text('No messages yet.'));",
      "                  }",
      "                  return ListView.builder(",
      "                    reverse: false,",
      "                    itemCount: messages.length,",
      "                    itemBuilder: (context, index) {",
      "                      final msg = messages[index];",
      "                      final isSupport = msg.senderId == 'support';",
      "                      return Align(",
      "                        alignment: isSupport",
      "                            ? Alignment.centerRight",
      "                            : Alignment.centerLeft,",
      "                        child: Container(",
      "                          margin: const EdgeInsets.symmetric(",
      "                              vertical: 4, horizontal: 8),",
      "                          padding: const EdgeInsets.all(12),",
      "                          decoration: BoxDecoration(",
      "                            color: isSupport",
      "                                ? DesignTokens.adminPrimaryColor",
      "                                    .withOpacity(0.12)",
      "                                : Colors.grey.shade200,",
      "                            borderRadius: BorderRadius.circular(10),",
      "                          ),",
      "                          child: Column(",
      "                            crossAxisAlignment: isSupport",
      "                                ? CrossAxisAlignment.end",
      "                                : CrossAxisAlignment.start,",
      "                            children: [",
      "                              Text(",
      "                                msg.content,",
      "                                style: const TextStyle(fontSize: 16),",
      "                              ),",
      "                              const SizedBox(height: 4),",
      "                              Text(",
      "                                \"${msg.timestamp.hour.toString().padLeft(2, '0')}:${msg.timestamp.minute.toString().padLeft(2, '0')}\",",
      "                                style: TextStyle(",
      "                                    fontSize: 10, color: Colors.grey[600]),",
      "                              ),",
      "                            ],",
      "                          ),",
      "                        ),",
      "                      );",
      "                    },",
      "                  );",
      "                },",
      "              ),",
      "            ),",
      "            Divider(height: 1),",
      "            Padding(",
      "              padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 8),",
      "              child: Row(",
      "                children: [",
      "                  Expanded(",
      "                    child: TextField(",
      "                      controller: _controller,",
      "                      enabled: !_sending,",
      "                      decoration: const InputDecoration(",
      "                        hintText: 'Type your reply...',",
      "                        border: OutlineInputBorder(),",
      "                        isDense: true,",
      "                      ),",
      "                    ),",
      "                  ),",
      "                  const SizedBox(width: 6),",
      "                  IconButton(",
      "                    icon: _sending",
      "                        ? const CircularProgressIndicator()",
      "                        : const Icon(Icons.send, color: Colors.red),",
      "                    onPressed: _sending ? null : _sendReply,",
      "                  )",
      "                ],",
      "              ),",
      "            )",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 155,
      "file_size": 5895,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\chat\\chat_management_screen.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/admin/chat/admin_chat_detail_dialog.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/widgets/loading_shimmer_widget.dart';",
      "import 'package:franchise_admin_portal/widgets/empty_state_widget.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/models/user.dart' as admin_user;",
      "import 'package:franchise_admin_portal/core/services/audit_log_service.dart';",
      "import 'package:franchise_admin_portal/core/models/chat.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/user_profile_notifier.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/core/utils/user_permissions.dart';",
      "import 'package:franchise_admin_portal/widgets/admin/admin_unauthorized_widget.dart';",
      "import 'package:franchise_admin_portal/widgets/subscription_access_guard.dart';",
      "import 'package:franchise_admin_portal/widgets/subscription/grace_period_banner.dart';",
      "import 'package:franchise_admin_portal/core/providers/role_guard.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "",
      "class ChatManagementScreen extends StatelessWidget {",
      "  const ChatManagementScreen({super.key});",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final franchiseId = context.watch<FranchiseProvider>().franchiseId;",
      "    final firestoreService =",
      "        Provider.of<FirestoreService>(context, listen: false);",
      "    final user = Provider.of<AdminUserProvider>(context, listen: false).user;",
      "    final loc = AppLocalizations.of(context)!;",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "",
      "    return RoleGuard(",
      "      allowedRoles: const [",
      "        'platform_owner',",
      "        'hq_owner',",
      "        'manager',",
      "        'developer',",
      "        'admin'",
      "      ],",
      "      featureName: 'chat_management_screen',",
      "      screen: 'ChatManagementScreen',",
      "      child: SubscriptionAccessGuard(",
      "        child: Scaffold(",
      "          backgroundColor: colorScheme.background,",
      "          body: Row(",
      "            crossAxisAlignment: CrossAxisAlignment.start,",
      "            children: [",
      "              Expanded(",
      "                flex: 11,",
      "                child: Padding(",
      "                  padding:",
      "                      const EdgeInsets.only(top: 24.0, left: 24.0, right: 24.0),",
      "                  child: Column(",
      "                    crossAxisAlignment: CrossAxisAlignment.start,",
      "                    children: [",
      "                      const GracePeriodBanner(),",
      "                      Padding(",
      "                        padding: const EdgeInsets.only(bottom: 12.0),",
      "                        child: Row(",
      "                          crossAxisAlignment: CrossAxisAlignment.center,",
      "                          children: [",
      "                            Text(",
      "                              loc.chatManagementTitle,",
      "                              style: TextStyle(",
      "                                color: colorScheme.onBackground,",
      "                                fontWeight: FontWeight.bold,",
      "                                fontSize: 22,",
      "                              ),",
      "                            ),",
      "                            const Spacer(),",
      "                          ],",
      "                        ),",
      "                      ),",
      "                      Expanded(",
      "                        child: StreamBuilder<List<Chat>>(",
      "                          stream: firestoreService.getSupportChats(franchiseId),",
      "                          builder: (context, snapshot) {",
      "                            if (snapshot.connectionState ==",
      "                                ConnectionState.waiting) {",
      "                              return const LoadingShimmerWidget();",
      "                            }",
      "                            if (!snapshot.hasData || snapshot.data!.isEmpty) {",
      "                              return EmptyStateWidget(",
      "                                title: loc.noChatsTitle,",
      "                                message: loc.noChatsMessage,",
      "                                iconData: Icons",
      "                                    .forum_outlined, // or any icon you prefer!",
      "                                isAdmin: true,",
      "                              );",
      "                            }",
      "                            final chats = snapshot.data!;",
      "                            return ListView.separated(",
      "                              itemCount: chats.length,",
      "                              separatorBuilder: (_, __) => Divider(",
      "                                color:",
      "                                    colorScheme.surfaceVariant.withOpacity(0.3),",
      "                              ),",
      "                              itemBuilder: (context, i) {",
      "                                final chat = chats[i];",
      "                                return ListTile(",
      "                                  title: Text(",
      "                                    chat.userName ?? loc.unknownUser,",
      "                                    style: TextStyle(",
      "                                      color: colorScheme.onBackground,",
      "                                      fontWeight: FontWeight.bold,",
      "                                    ),",
      "                                  ),",
      "                                  subtitle: Text(",
      "                                    chat.lastMessage,",
      "                                    style: TextStyle(",
      "                                      color: colorScheme.onBackground",
      "                                          .withOpacity(0.75),",
      "                                    ),",
      "                                  ),",
      "                                  trailing: IconButton(",
      "                                    icon: Icon(Icons.delete,",
      "                                        color: colorScheme.error),",
      "                                    tooltip: loc.deleteChatTooltip,",
      "                                    onPressed: () => _confirmDelete(",
      "                                      context,",
      "                                      firestoreService,",
      "                                      chat.id,",
      "                                      user!,",
      "                                      loc,",
      "                                      colorScheme,",
      "                                    ),",
      "                                  ),",
      "                                  onTap: () {",
      "                                    showDialog(",
      "                                      context: context,",
      "                                      builder: (_) => AdminChatDetailDialog(",
      "                                        franchiseId: franchiseId,",
      "                                        chatId: chat.id,",
      "                                        userName:",
      "                                            chat.userName ?? loc.unknownUser,",
      "                                      ),",
      "                                    );",
      "                                  },",
      "                                );",
      "                              },",
      "                            );",
      "                          },",
      "                        ),",
      "                      ),",
      "                    ],",
      "                  ),",
      "                ),",
      "              ),",
      "              const Expanded(flex: 9, child: SizedBox()),",
      "            ],",
      "          ),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  void _confirmDelete(",
      "    BuildContext context,",
      "    FirestoreService service,",
      "    String chatId,",
      "    admin_user.User user,",
      "    AppLocalizations loc,",
      "    ColorScheme colorScheme,",
      "  ) {",
      "    final franchiseId =",
      "        Provider.of<FranchiseProvider>(context, listen: false).franchiseId;",
      "    showDialog(",
      "      context: context,",
      "      builder: (_) => AlertDialog(",
      "        backgroundColor: colorScheme.background,",
      "        title: Text(",
      "          loc.deleteChatTitle,",
      "          style: TextStyle(",
      "            color: colorScheme.onBackground,",
      "            fontWeight: FontWeight.bold,",
      "          ),",
      "        ),",
      "        content: Text(",
      "          loc.deleteChatConfirmMessage,",
      "          style: TextStyle(color: colorScheme.onBackground),",
      "        ),",
      "        actions: [",
      "          TextButton(",
      "            onPressed: () => Navigator.pop(context),",
      "            child: Text(loc.cancelButton),",
      "          ),",
      "          ElevatedButton(",
      "            style: ElevatedButton.styleFrom(",
      "              backgroundColor: colorScheme.error,",
      "              foregroundColor: colorScheme.onError,",
      "            ),",
      "            onPressed: () async {",
      "              await service.deleteSupportChat(franchiseId, chatId);",
      "              await AuditLogService().addLog(",
      "                franchiseId: franchiseId,",
      "                userId: user.id,",
      "                action: 'delete_support_chat',",
      "                targetType: 'support_chat',",
      "                targetId: chatId,",
      "                details: {'message': 'Support chat thread deleted by admin.'},",
      "              );",
      "              if (context.mounted) Navigator.pop(context);",
      "            },",
      "            child: Text(loc.deleteButton),",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 212,
      "file_size": 9308,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\chat\\chat_reply_dialog.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:provider/provider.dart';",
      "",
      "class ChatReplyDialog extends StatefulWidget {",
      "  final String chatId;",
      "  final VoidCallback? onReplied;",
      "  const ChatReplyDialog({super.key, required this.chatId, this.onReplied});",
      "",
      "  @override",
      "  State<ChatReplyDialog> createState() => _ChatReplyDialogState();",
      "}",
      "",
      "class _ChatReplyDialogState extends State<ChatReplyDialog> {",
      "  final _controller = TextEditingController();",
      "  bool isSending = false;",
      "",
      "  Future<void> _sendReply() async {",
      "    final reply = _controller.text.trim();",
      "    if (reply.isEmpty) return;",
      "    setState(() => isSending = true);",
      "    final franchiseId = context.watch<FranchiseProvider>().franchiseId;",
      "    await FirestoreService().sendMessage(",
      "      franchiseId,",
      "      chatId: widget.chatId,",
      "      senderId: 'admin', // You may want to use the actual admin/staff ID",
      "      content: reply,",
      "    );",
      "    if (!mounted) return;",
      "    setState(() => isSending = false);",
      "    if (widget.onReplied != null) widget.onReplied!();",
      "    Navigator.pop(context);",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return AlertDialog(",
      "      title: const Text('Reply to Chat'),",
      "      content: TextField(",
      "        controller: _controller,",
      "        maxLines: 5,",
      "        decoration: const InputDecoration(labelText: 'Enter your reply'),",
      "      ),",
      "      actions: [",
      "        TextButton(",
      "            onPressed: () => Navigator.pop(context),",
      "            child: const Text('Cancel')),",
      "        ElevatedButton(",
      "          onPressed: isSending ? null : _sendReply,",
      "          child: isSending",
      "              ? const CircularProgressIndicator()",
      "              : const Text('Send'),",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 58,
      "file_size": 1895,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\admin_dashboard_screen.dart",
    "content": [
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/services/auth_service.dart';",
      "import 'package:franchise_admin_portal/core/models/dashboard_section.dart';",
      "import 'package:franchise_admin_portal/core/section_registry.dart';",
      "import 'package:franchise_admin_portal/widgets/dashboard/role_badge.dart';",
      "import 'package:franchise_admin_portal/widgets/dashboard/maintenance_banner.dart';",
      "import 'package:franchise_admin_portal/widgets/dashboard/notifications_panel.dart';",
      "import 'package:franchise_admin_portal/widgets/header/settings_icon_button.dart';",
      "import 'package:franchise_admin_portal/widgets/header/help_icon_button.dart';",
      "import 'package:franchise_admin_portal/widgets/header/notifications_icon_button.dart';",
      "import 'package:franchise_admin_portal/config/branding_config.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/models/user.dart' as app;",
      "import 'package:franchise_admin_portal/widgets/header/franchise_app_bar.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/providers/user_profile_notifier.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/widgets/dashboard/dashboard_switcher_dropdown.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_selector.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/providers/role_guard.dart';",
      "import 'package:franchise_admin_portal/widgets/dashboard/franchise_picker_dropdown.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "import 'package:franchise_admin_portal/widgets/profile/user_avatar_menu.dart';",
      "import 'package:franchise_admin_portal/core/providers/ingredient_type_provider.dart';",
      "",
      "class AdminDashboardScreen extends StatefulWidget {",
      "  final String? initialSectionKey;",
      "  final String currentScreen;",
      "",
      "  const AdminDashboardScreen({",
      "    Key? key,",
      "    this.initialSectionKey,",
      "    this.currentScreen = '/admin/dashboard',",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  State<AdminDashboardScreen> createState() => _AdminDashboardScreenState();",
      "}",
      "",
      "class _AdminDashboardScreenState extends State<AdminDashboardScreen> {",
      "  late final List<DashboardSection> _sections;",
      "  late final List<DashboardSection> _sidebarSections;",
      "  int _selectedIndex = 0;",
      "  bool _showMaintenanceBanner = false;",
      "  bool _initializedFromKey = false;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "",
      "    _sections = getAllDashboardSections();",
      "    _sidebarSections = getSidebarSections();",
      "",
      "    if (widget.initialSectionKey != null) {",
      "      final index =",
      "          _sections.indexWhere((s) => s.key == widget.initialSectionKey);",
      "      if (index != -1) {",
      "        _selectedIndex = index;",
      "        _initializedFromKey = true;",
      "        debugPrint(",
      "            '[DEBUG][AdminDashboardScreen] 🧭 Applied initialSectionKey: $_selectedIndex (${_sections[_selectedIndex].key})');",
      "      } else {",
      "        debugPrint(",
      "            '[WARN][AdminDashboardScreen] initialSectionKey \"${widget.initialSectionKey}\" not found in _sections');",
      "      }",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    try {",
      "      final typeProvider =",
      "          Provider.of<IngredientTypeProvider>(context, listen: false);",
      "      print(",
      "          '[AdminDashboardScreen] IngredientTypeProvider FOUND: hashCode=${typeProvider.hashCode}');",
      "    } catch (e) {",
      "      print('[AdminDashboardScreen] IngredientTypeProvider NOT FOUND: $e');",
      "    }",
      "",
      "    print(",
      "        '[DEBUG][AdminDashboardScreen][build] _selectedIndex: $_selectedIndex');",
      "    // Apply initialSectionKey safely once _sections are loaded",
      "    if (_sections.isEmpty) {",
      "      return const Scaffold(",
      "        body: Center(child: CircularProgressIndicator()),",
      "      );",
      "    }",
      "",
      "    if (_sections.isNotEmpty) {",
      "      print(",
      "          '[DEBUG][AdminDashboardScreen][build] Section at selected index: ${_sections[_selectedIndex].key}');",
      "    }",
      "    final franchiseId = context.watch<FranchiseProvider>().franchiseId;",
      "    final adminUserProvider = Provider.of<AdminUserProvider>(context);",
      "    final appUser = adminUserProvider.user;",
      "",
      "    // Sidebar grouping",
      "    final mainSidebarSections =",
      "        _sidebarSections.where((s) => !s.key.startsWith('onboarding')).toList();",
      "    final onboardingSidebarSections =",
      "        _sidebarSections.where((s) => s.key.startsWith('onboarding')).toList();",
      "",
      "    if (adminUserProvider.loading || appUser == null || appUser.roles.isEmpty) {",
      "      return const Scaffold(",
      "        body: Center(child: CircularProgressIndicator()),",
      "      );",
      "    }",
      "",
      "    final firestoreService =",
      "        Provider.of<FirestoreService>(context, listen: false);",
      "    final isMobile = MediaQuery.of(context).size.width < 800;",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    final loc = AppLocalizations.of(context);",
      "",
      "    if (loc == null) {",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "",
      "    if (_sections.isEmpty || _selectedIndex >= _sections.length) {",
      "      ErrorLogger.log(",
      "        message: \"No dashboard sections registered.\",",
      "        source: \"AdminDashboardScreen\",",
      "        screen: \"AdminDashboardScreen\",",
      "        severity: \"error\",",
      "        contextData: {},",
      "      );",
      "      return Scaffold(",
      "        appBar: AppBar(",
      "          backgroundColor: DesignTokens.primaryColor,",
      "          title: Text(\"ERROR: No sections found\"),",
      "        ),",
      "        body: Center(",
      "          child: Text(",
      "            \"No dashboard sections registered.\",",
      "            style: TextStyle(fontSize: 20, color: Colors.red),",
      "          ),",
      "        ),",
      "      );",
      "    }",
      "",
      "    // GUARD: Don't build dashboard unless franchiseId is valid and loaded",
      "    if (franchiseId == null ||",
      "        franchiseId.isEmpty ||",
      "        franchiseId == 'unknown') {",
      "      print(",
      "          '[DEBUG][AdminDashboardScreen] franchiseId missing. Prompting user to select franchise.');",
      "      // Show dashboard shell and picker, but overlay a modal or banner if you want.",
      "      // Do NOT return/loading spinner here.",
      "    }",
      "",
      "    return Scaffold(",
      "      backgroundColor: colorScheme.background,",
      "      appBar: AppBar(",
      "        elevation: 1,",
      "        automaticallyImplyLeading: false,",
      "        titleSpacing: 0,",
      "        title: Row(",
      "          children: [",
      "            const SizedBox(width: 8),",
      "            Text(",
      "              loc.adminDashboardTitle,",
      "              style: Theme.of(context).textTheme.titleLarge?.copyWith(",
      "                    fontWeight: FontWeight.bold,",
      "                    color: colorScheme.onSurface,",
      "                  ),",
      "            ),",
      "            const SizedBox(width: 20),",
      "            if (!isMobile) const Spacer(),",
      "            RoleGuard(",
      "              requireAnyRole: ['developer', 'platform_owner', 'hq_owner'],",
      "              featureName: 'franchise_picker_dropdown',",
      "              child: Padding(",
      "                padding: const EdgeInsets.only(right: 8),",
      "                child: FranchisePickerDropdown(),",
      "              ),",
      "            ),",
      "            const SizedBox(width: 8),",
      "            DashboardSwitcherDropdown(",
      "              currentScreen: widget.currentScreen,",
      "              user: appUser,",
      "            ),",
      "            const SizedBox(width: 8),",
      "            NotificationsIconButton(),",
      "            const SizedBox(width: 8),",
      "            HelpIconButton(),",
      "            const SizedBox(width: 8),",
      "            SettingsIconButton(),",
      "            const SizedBox(width: 8),",
      "            UserAvatarMenu(),",
      "            const SizedBox(width: 8),",
      "          ],",
      "        ),",
      "      ),",
      "      drawer: isMobile",
      "          ? Drawer(",
      "              child: SafeArea(",
      "                child: _buildSidebar(",
      "                  context: context,",
      "                  mainSidebarSections: mainSidebarSections,",
      "                  onboardingSidebarSections: onboardingSidebarSections,",
      "                  colorScheme: colorScheme,",
      "                ),",
      "              ),",
      "            )",
      "          : null,",
      "      body: Column(",
      "        children: [",
      "          MaintenanceBanner(",
      "            show: _showMaintenanceBanner,",
      "            message:",
      "                \"The system is in maintenance mode. Some features may be unavailable.\",",
      "          ),",
      "          Expanded(",
      "            child: Row(",
      "              children: [",
      "                if (!isMobile)",
      "                  Container(",
      "                    width: 230,",
      "                    color: colorScheme.surface.withOpacity(0.97),",
      "                    child: SafeArea(",
      "                      child: _buildSidebar(",
      "                        context: context,",
      "                        mainSidebarSections: mainSidebarSections,",
      "                        onboardingSidebarSections: onboardingSidebarSections,",
      "                        colorScheme: colorScheme,",
      "                      ),",
      "                    ),",
      "                  ),",
      "                Expanded(",
      "                  child: LayoutBuilder(",
      "                    builder: (context, constraints) {",
      "                      return ConstrainedBox(",
      "                        constraints: BoxConstraints(",
      "                          maxHeight: constraints.maxHeight,",
      "                          maxWidth: constraints.maxWidth,",
      "                        ),",
      "                        child: LayoutBuilder(",
      "                          builder: (context, constraints) {",
      "                            if (_selectedIndex >= _sections.length) {",
      "                              print(",
      "                                  '[DEBUG] Invalid _selectedIndex ($_selectedIndex) for sections length ${_sections.length}. Resetting to 0.');",
      "                              _selectedIndex = 0;",
      "                            }",
      "                            return IndexedStack(",
      "                              index: _selectedIndex,",
      "                              children: [",
      "                                for (final section in _sections)",
      "                                  Builder(",
      "                                    builder: (context) {",
      "                                      try {",
      "                                        return SizedBox(",
      "                                          width: constraints.maxWidth,",
      "                                          height: constraints.maxHeight,",
      "                                          child: section.builder(context),",
      "                                        );",
      "                                      } catch (e, stack) {",
      "                                        ErrorLogger.log(",
      "                                          message:",
      "                                              'Dashboard section error: $e',",
      "                                          source: 'AdminDashboardScreen',",
      "                                          screen: section.title,",
      "                                          stack: stack.toString(),",
      "                                          severity: 'error',",
      "                                          contextData: {",
      "                                            'franchiseId': franchiseId,",
      "                                            'sectionIndex': _selectedIndex,",
      "                                            'sectionTitle': section.title,",
      "                                            'errorType':",
      "                                                e.runtimeType.toString(),",
      "                                            'userId': appUser.id,",
      "                                          },",
      "                                        );",
      "                                        return Center(",
      "                                          child: Text(",
      "                                            'Section failed: $e',",
      "                                            style: const TextStyle(",
      "                                                color: Colors.red,",
      "                                                fontSize: 16),",
      "                                          ),",
      "                                        );",
      "                                      }",
      "                                    },",
      "                                  ),",
      "                              ],",
      "                            );",
      "                          },",
      "                        ),",
      "                      );",
      "                    },",
      "                  ),",
      "                ),",
      "              ],",
      "            ),",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "",
      "  // Sidebar builder with Franchise Onboarding group and main sections",
      "  Widget _buildSidebar({",
      "    required BuildContext context,",
      "    required List<DashboardSection> mainSidebarSections,",
      "    required List<DashboardSection> onboardingSidebarSections,",
      "    required ColorScheme colorScheme,",
      "  }) {",
      "    return ListView(",
      "      padding: EdgeInsets.zero,",
      "      children: [",
      "        // Main sidebar sections",
      "        for (final section in mainSidebarSections)",
      "          _SidebarSectionTile(",
      "            section: section,",
      "            isSelected: _selectedIndex < _sections.length &&",
      "                _sections[_selectedIndex].key == section.key,",
      "            onTap: () {",
      "              final index = _sections.indexWhere((s) => s.key == section.key);",
      "              if (index != -1 && index != _selectedIndex) {",
      "                setState(() {",
      "                  _selectedIndex = index;",
      "                });",
      "              }",
      "              if (Navigator.of(context).canPop()) {",
      "                Navigator.of(context).pop();",
      "              }",
      "            },",
      "            colorScheme: colorScheme,",
      "          ),",
      "",
      "        // Franchise Onboarding label and steps",
      "        if (onboardingSidebarSections.isNotEmpty) ...[",
      "          Padding(",
      "            padding: const EdgeInsets.only(",
      "                top: 24.0, bottom: 4.0, left: 14.0, right: 10.0),",
      "            child: Text(",
      "              'Franchise Onboarding',",
      "              style: TextStyle(",
      "                fontWeight: FontWeight.bold,",
      "                fontSize: 13,",
      "                color: colorScheme.primary,",
      "                letterSpacing: 0.7,",
      "              ),",
      "            ),",
      "          ),",
      "          for (final section in onboardingSidebarSections)",
      "            _SidebarSectionTile(",
      "              section: section,",
      "              isSelected: _selectedIndex < _sections.length &&",
      "                  _sections[_selectedIndex].key == section.key,",
      "              onTap: () {",
      "                final index = _sections.indexWhere((s) => s.key == section.key);",
      "                if (index != -1 && index != _selectedIndex) {",
      "                  setState(() {",
      "                    _selectedIndex = index;",
      "                  });",
      "                }",
      "                if (Navigator.of(context).canPop()) {",
      "                  Navigator.of(context).pop();",
      "                }",
      "              },",
      "              colorScheme: colorScheme,",
      "            ),",
      "        ],",
      "      ],",
      "    );",
      "  }",
      "}",
      "",
      "// Sidebar tile widget (icon, selection logic)",
      "class _SidebarSectionTile extends StatelessWidget {",
      "  final DashboardSection section;",
      "  final bool isSelected;",
      "  final VoidCallback onTap;",
      "  final ColorScheme colorScheme;",
      "",
      "  const _SidebarSectionTile({",
      "    required this.section,",
      "    required this.isSelected,",
      "    required this.onTap,",
      "    required this.colorScheme,",
      "    Key? key,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return ListTile(",
      "      leading: Icon(",
      "        section.icon,",
      "        color: isSelected",
      "            ? colorScheme.primary",
      "            : colorScheme.onSurface.withOpacity(0.65),",
      "      ),",
      "      title: Text(",
      "        section.title,",
      "        style: TextStyle(",
      "          color: isSelected",
      "              ? colorScheme.primary",
      "              : colorScheme.onSurface.withOpacity(0.9),",
      "          fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,",
      "        ),",
      "      ),",
      "      selected: isSelected,",
      "      selectedTileColor: colorScheme.primary.withOpacity(0.10),",
      "      onTap: onTap,",
      "      shape: RoundedRectangleBorder(",
      "        borderRadius: BorderRadius.circular(8),",
      "      ),",
      "      contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 2),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 416,
      "file_size": 16371,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\dashboard_home_screen.dart",
    "content": [
      "// File: lib/admin/dashboard/dashboard_home_screen.dart",
      "",
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_feature_provider.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/core/utils/user_permissions.dart';",
      "import 'package:franchise_admin_portal/widgets/financials/dashboard_stat_card.dart';",
      "import 'package:franchise_admin_portal/widgets/financials/revenue_stat_card.dart';",
      "import 'package:franchise_admin_portal/widgets/financials/kpi_card.dart';",
      "import 'package:franchise_admin_portal/widgets/dashboard/analytics_placeholder_card.dart';",
      "import 'package:franchise_admin_portal/widgets/dashboard/activity_feed_widget.dart';",
      "import 'package:franchise_admin_portal/widgets/dashboard/urgent_status_card.dart';",
      "import 'package:franchise_admin_portal/widgets/dashboard/notifications_panel.dart';",
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/role_guard.dart';",
      "import 'package:franchise_admin_portal/widgets/dashboard/live_operational_snapshot_widget.dart';",
      "",
      "/// ---------------------------------------------------------------------------",
      "/// 🖥️ DashboardHomeScreen",
      "/// ---------------------------------------------------------------------------",
      "/// Main admin dashboard landing page.",
      "/// Shows KPIs, revenue stats, notifications, live operational snapshot,",
      "/// analytics, urgent alerts, and activity feed.",
      "/// ---------------------------------------------------------------------------",
      "",
      "class DashboardHomeScreen extends StatefulWidget {",
      "  const DashboardHomeScreen({Key? key}) : super(key: key);",
      "",
      "  @override",
      "  State<DashboardHomeScreen> createState() => _DashboardHomeScreenState();",
      "}",
      "",
      "class _DashboardHomeScreenState extends State<DashboardHomeScreen> {",
      "  bool _expandedSnapshot = false; // Tracks expanded/collapsed state",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    debugPrint('[DashboardHomeScreen] Building dashboard UI');",
      "",
      "    final franchiseId = context.watch<FranchiseProvider>().franchiseId;",
      "    final featureProvider = context.watch<FranchiseFeatureProvider>();",
      "    final isMobile = MediaQuery.of(context).size.width < 800;",
      "    final gridColumns = isMobile ? 1 : 4;",
      "    final gap = isMobile ? 16.0 : 24.0;",
      "",
      "    if (!featureProvider.isInitialized) {",
      "      debugPrint('[DashboardHomeScreen] Waiting for featureProvider init...');",
      "      return const Center(child: CircularProgressIndicator());",
      "    }",
      "",
      "    final liveSnapshotEnabled = featureProvider.liveSnapshotEnabled;",
      "    final userCanToggle = UserPermissions.isPlatformPrivileged(",
      "          context.read<AdminUserProvider>().user,",
      "        ) ||",
      "        UserPermissions.canManageSubscriptions(",
      "          context.read<AdminUserProvider>().user,",
      "        );",
      "",
      "    return Padding(",
      "      padding: EdgeInsets.all(gap),",
      "      child: SingleChildScrollView(",
      "        child: Column(",
      "          children: [",
      "            Wrap(",
      "              spacing: gap,",
      "              runSpacing: gap,",
      "              children: [",
      "                SizedBox(",
      "                  width: isMobile ? double.infinity : 290,",
      "                  child: DashboardStatCard(",
      "                    label: 'Orders Today',",
      "                    icon: Icons.shopping_cart,",
      "                    getValue: () => context",
      "                        .read<FirestoreService>()",
      "                        .getTotalOrdersTodayCount(franchiseId: franchiseId),",
      "                    tooltip: 'Total orders placed today',",
      "                    semanticLabel: 'Total orders placed today',",
      "                  ),",
      "                ),",
      "                SizedBox(",
      "                  width: isMobile ? double.infinity : 290,",
      "                  child: RevenueStatCard(franchiseId: franchiseId),",
      "                ),",
      "                SizedBox(",
      "                  width: isMobile ? double.infinity : 290,",
      "                  child: const KpiCard(",
      "                      title: \"Active Promotions\", value: \"--\", loading: true),",
      "                ),",
      "                SizedBox(",
      "                  width: isMobile ? double.infinity : 290,",
      "                  child: const NotificationsPanel(),",
      "                ),",
      "",
      "                // 📡 Real-Time Ops Snapshot",
      "                // 📡 Real-Time Ops Snapshot",
      "                if (liveSnapshotEnabled || userCanToggle)",
      "                  Container(",
      "                    width: isMobile",
      "                        ? double.infinity",
      "                        : (_expandedSnapshot ? (290 * 2 + gap) : 290),",
      "                    height: _expandedSnapshot",
      "                        ? (3 * 120 + 2 * 12) // 3 rows + 2 gaps in expanded mode",
      "                        : null, // auto height when collapsed",
      "                    child: RoleGuard(",
      "                      requireAnyRole: ['platform_owner', 'hq_owner'],",
      "                      featureName: 'real_time_ops_snapshot',",
      "                      screen: 'dashboard_home_screen.dart',",
      "                      child: Card(",
      "                        child: Padding(",
      "                          padding: const EdgeInsets.all(16.0),",
      "                          child: Column(",
      "                            crossAxisAlignment: CrossAxisAlignment.start,",
      "                            children: [",
      "                              Row(",
      "                                mainAxisAlignment:",
      "                                    MainAxisAlignment.spaceBetween,",
      "                                children: [",
      "                                  Text(",
      "                                    'Real-Time Ops Snapshot',",
      "                                    style:",
      "                                        Theme.of(context).textTheme.titleMedium,",
      "                                  ),",
      "                                  Row(",
      "                                    children: [",
      "                                      IconButton(",
      "                                        icon: Icon(_expandedSnapshot",
      "                                            ? Icons.expand_less",
      "                                            : Icons.expand_more),",
      "                                        tooltip: _expandedSnapshot",
      "                                            ? 'Collapse view'",
      "                                            : 'Expand view',",
      "                                        onPressed: () {",
      "                                          setState(() {",
      "                                            _expandedSnapshot =",
      "                                                !_expandedSnapshot;",
      "                                          });",
      "                                        },",
      "                                      ),",
      "                                      if (userCanToggle)",
      "                                        Switch(",
      "                                          value: liveSnapshotEnabled,",
      "                                          onChanged: (value) async {",
      "                                            try {",
      "                                              featureProvider",
      "                                                  .setLiveSnapshotEnabled(",
      "                                                      value);",
      "                                              final saved =",
      "                                                  await featureProvider",
      "                                                      .persistToFirestore();",
      "                                              debugPrint(",
      "                                                  '[DashboardHomeScreen] liveSnapshotEnabled persisted: $saved');",
      "                                              if (!saved) {",
      "                                                ScaffoldMessenger.of(context)",
      "                                                    .showSnackBar(",
      "                                                  const SnackBar(",
      "                                                    content: Text(",
      "                                                        'Failed to save snapshot setting.'),",
      "                                                  ),",
      "                                                );",
      "                                              }",
      "                                            } catch (e, st) {",
      "                                              await ErrorLogger.log(",
      "                                                message:",
      "                                                    'Error updating liveSnapshotEnabled',",
      "                                                stack: st.toString(),",
      "                                                source:",
      "                                                    'DashboardHomeScreen.onChanged',",
      "                                                severity: 'error',",
      "                                                screen:",
      "                                                    'dashboard_home_screen.dart',",
      "                                                contextData: {",
      "                                                  'franchiseId': franchiseId,",
      "                                                  'newValue': value,",
      "                                                },",
      "                                              );",
      "                                            }",
      "                                          },",
      "                                        ),",
      "                                    ],",
      "                                  ),",
      "                                ],",
      "                              ),",
      "                              const SizedBox(height: 12),",
      "                              if (liveSnapshotEnabled)",
      "                                Expanded(",
      "                                  // ✅ Fill vertical space when expanded",
      "                                  child: LiveOperationalSnapshotWidget(",
      "                                    franchiseId: franchiseId,",
      "                                    expanded: _expandedSnapshot,",
      "                                  ),",
      "                                )",
      "                              else",
      "                                Text(",
      "                                  'Disabled — enable to view live operational metrics.',",
      "                                  style: Theme.of(context).textTheme.bodySmall,",
      "                                ),",
      "                            ],",
      "                          ),",
      "                        ),",
      "                      ),",
      "                    ),",
      "                  ),",
      "              ],",
      "            ),",
      "            SizedBox(height: gap),",
      "",
      "            // Second row: Analytics, Urgent, Activity Feed",
      "            SizedBox(",
      "              height: isMobile ? 780 : 270,",
      "              child: GridView.count(",
      "                crossAxisCount: gridColumns,",
      "                crossAxisSpacing: gap,",
      "                mainAxisSpacing: gap,",
      "                childAspectRatio: isMobile ? 1.8 : 2.5,",
      "                physics: const NeverScrollableScrollPhysics(),",
      "                children: const [",
      "                  AnalyticsPlaceholderCard(title: \"Orders Over Time\"),",
      "                  AnalyticsPlaceholderCard(title: \"Top Menu Items\"),",
      "                  UrgentStatusCard(),",
      "                  ActivityFeedWidget(),",
      "                ],",
      "              ),",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 233,
      "file_size": 11568,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\screens\\menu_item_editor_screen.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/models/menu_item.dart';",
      "import 'package:franchise_admin_portal/core/models/menu_item_schema_issue.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_info_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/ingredient_metadata_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/ingredient_type_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/category_provider.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/widgets/menu_items/menu_item_editor_sheet.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/widgets/menu_items/schema_issue_sidebar.dart';",
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "",
      "class MenuItemEditorScreen extends StatefulWidget {",
      "  final MenuItem? item;",
      "",
      "  const MenuItemEditorScreen({Key? key, this.item}) : super(key: key);",
      "",
      "  @override",
      "  State<MenuItemEditorScreen> createState() => _MenuItemEditorScreenState();",
      "}",
      "",
      "class _MenuItemEditorScreenState extends State<MenuItemEditorScreen> {",
      "  final GlobalKey<MenuItemEditorSheetState> _sheetKey =",
      "      GlobalKey<MenuItemEditorSheetState>();",
      "",
      "  List<MenuItemSchemaIssue> _schemaIssues = [];",
      "",
      "  void _handleSchemaIssueUpdate(List<MenuItemSchemaIssue> updated) {",
      "    print('[MenuItemEditorScreen] Schema issues updated:');",
      "    for (final issue in updated) {",
      "      print(' - ${issue.displayMessage} | resolved=${issue.resolved}');",
      "    }",
      "    WidgetsBinding.instance.addPostFrameCallback((_) {",
      "      if (mounted) {",
      "        setState(() {",
      "          _schemaIssues = updated;",
      "          debugPrint(",
      "              '[DEBUG] Schema issues updated: ${updated.length} issue(s)');",
      "        });",
      "      }",
      "    });",
      "  }",
      "",
      "  void _handleRepair(MenuItemSchemaIssue issue, String newValue) {",
      "    final sheet = _sheetKey.currentState;",
      "    WidgetsBinding.instance.addPostFrameCallback((_) {",
      "      print(",
      "          '[MenuItemEditorScreen] Repair requested for: ${issue.displayMessage}, newValue=$newValue');",
      "      sheet?.repairSchemaIssue(issue, newValue);",
      "    });",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final showSidebar = _schemaIssues.any((issue) => !issue.resolved);",
      "    print('[MenuItemEditorScreen] Sidebar visibility: $showSidebar');",
      "",
      "    final sidebarWidth = showSidebar ? 420.0 : 64.0;",
      "",
      "    // USE ONLY global/singleton context providers. No local MultiProvider.",
      "    return Row(",
      "      children: [",
      "        Expanded(",
      "          flex: 3,",
      "          child: MenuItemEditorSheet(",
      "            key: _sheetKey,",
      "            existing: widget.item,",
      "            onCancel: () => Navigator.of(context).pop(),",
      "            onSave: (item) => Navigator.of(context).pop(item),",
      "            onSchemaIssuesChanged: _handleSchemaIssueUpdate,",
      "            firestore: FirebaseFirestore.instance,",
      "            franchiseId: context.read<FranchiseProvider>().franchiseId,",
      "          ),",
      "        ),",
      "        const VerticalDivider(width: 1),",
      "        AnimatedContainer(",
      "          duration: const Duration(milliseconds: 250),",
      "          width: sidebarWidth,",
      "          child: SchemaIssueSidebar(",
      "            issues: _schemaIssues,",
      "            onRepair: _handleRepair,",
      "            onClose: () => setState(() => _schemaIssues.clear()),",
      "          ),",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 90,
      "file_size": 3611,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\screens\\onboarding_categories_screen.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/models/category.dart';",
      "import 'package:franchise_admin_portal/core/providers/category_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_info_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/onboarding_progress_provider.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/widgets/empty_state_widget.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/widgets/categories/category_list_tile.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/widgets/categories/category_form_dialog.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/widgets/categories/category_json_import_export_dialog.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/widgets/categories/categories_template_picker_dialog.dart';",
      "",
      "class OnboardingCategoriesScreen extends StatefulWidget {",
      "  const OnboardingCategoriesScreen({super.key});",
      "",
      "  @override",
      "  State<OnboardingCategoriesScreen> createState() =>",
      "      _OnboardingCategoriesScreenState();",
      "}",
      "",
      "class _OnboardingCategoriesScreenState",
      "    extends State<OnboardingCategoriesScreen> {",
      "  bool _hasInitialized = false;",
      "",
      "  // Use _stagedForDelete and _showSelectAllBanner for robust staged delete/select-all.",
      "  final Set<String> _stagedForDelete = {};",
      "  bool _showSelectAllBanner = false;",
      "",
      "  @override",
      "  void didChangeDependencies() {",
      "    super.didChangeDependencies();",
      "    if (_hasInitialized) return;",
      "",
      "    final franchiseId = context.read<FranchiseProvider>().franchiseId;",
      "",
      "    if (franchiseId.isNotEmpty && franchiseId != 'unknown') {",
      "      final provider = context.read<CategoryProvider>();",
      "",
      "      // 🔹 Force reload from Firestore to ensure UI shows latest categories",
      "      provider",
      "          .loadCategories(",
      "        franchiseId,",
      "        forceReloadFromFirestore: true,",
      "      )",
      "          .then((_) {",
      "        if (!mounted) return;",
      "        debugPrint(",
      "          '[OnboardingCategoriesScreen] ✅ Category reload complete. '",
      "          'Count=${provider.categories.length}',",
      "        );",
      "        setState(() {}); // Trigger UI refresh after load",
      "      });",
      "    } else {",
      "      debugPrint(",
      "        '[OnboardingCategoriesScreen] ⚠️ Skipping load: blank/unknown franchiseId.',",
      "      );",
      "    }",
      "",
      "    _hasInitialized = true;",
      "  }",
      "",
      "  Future<void> _openCategoryForm([Category? category]) async {",
      "    final loc = AppLocalizations.of(context)!;",
      "    final franchiseId = context.read<FranchiseProvider>().franchiseId;",
      "",
      "    final result = await CategoryFormDialog.show(",
      "      parentContext: context,",
      "      initialCategory: category,",
      "      franchiseId: franchiseId,",
      "    );",
      "",
      "    if (result != null) {",
      "      context.read<CategoryProvider>().addOrUpdateCategory(result);",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(content: Text(loc.categorySaved)),",
      "      );",
      "    }",
      "  }",
      "",
      "  Future<void> _openImportExportDialog() async {",
      "    final loc = AppLocalizations.of(context)!;",
      "    await CategoryJsonImportExportDialog.show(context);",
      "  }",
      "",
      "  Future<void> _markComplete() async {",
      "    final onboarding = context.read<OnboardingProgressProvider>();",
      "    final loc = AppLocalizations.of(context)!;",
      "",
      "    final isCompleted = onboarding.isStepComplete('categories');",
      "",
      "    try {",
      "      if (isCompleted) {",
      "        await onboarding.markStepIncomplete('categories');",
      "        if (mounted) {",
      "          ScaffoldMessenger.of(context).showSnackBar(",
      "            SnackBar(content: Text(loc.stepMarkedIncomplete)),",
      "          );",
      "        }",
      "      } else {",
      "        await onboarding.markStepComplete('categories');",
      "        if (mounted) {",
      "          ScaffoldMessenger.of(context).showSnackBar(",
      "            SnackBar(content: Text(loc.stepMarkedComplete)),",
      "          );",
      "        }",
      "      }",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'onboarding_mark_complete_toggle_failed',",
      "        source: 'onboarding_categories_screen.dart',",
      "        screen: 'onboarding_categories_screen',",
      "        severity: 'warning',",
      "        stack: stack.toString(),",
      "        contextData: {'step': 'categories'},",
      "      );",
      "      if (mounted) {",
      "        ScaffoldMessenger.of(context).showSnackBar(",
      "          SnackBar(content: Text(loc.errorGeneric)),",
      "        );",
      "      }",
      "    }",
      "  }",
      "",
      "  Future<void> _saveChanges() async {",
      "    final loc = AppLocalizations.of(context)!;",
      "    final provider = context.read<CategoryProvider>();",
      "    final onboarding = context.read<OnboardingProgressProvider>();",
      "    final franchiseId = context.read<FranchiseProvider>().franchiseId;",
      "",
      "    try {",
      "      await provider.saveCategories();",
      "      if (mounted) {",
      "        ScaffoldMessenger.of(context).showSnackBar(",
      "          SnackBar(content: Text(loc.saveSuccessful)),",
      "        );",
      "      }",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to save categories',",
      "        source: 'onboarding_categories_screen.dart',",
      "        screen: 'onboarding_categories_screen',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      if (mounted) {",
      "        ScaffoldMessenger.of(context).showSnackBar(",
      "          SnackBar(content: Text(loc.saveFailed)),",
      "        );",
      "      }",
      "    }",
      "  }",
      "",
      "  Future<void> _confirmBulkDelete() async {",
      "    final loc = AppLocalizations.of(context)!;",
      "    if (_stagedForDelete.isEmpty) return;",
      "",
      "    final confirmed = await showDialog<bool>(",
      "      context: context,",
      "      builder: (ctx) => AlertDialog(",
      "        title: Text(loc.confirmDeletion),",
      "        content: Text(loc.bulkDeleteConfirmation(_stagedForDelete.length)),",
      "        actions: [",
      "          TextButton(",
      "            onPressed: () => Navigator.of(ctx).pop(false),",
      "            child: Text(loc.cancel),",
      "          ),",
      "          ElevatedButton(",
      "            style: ElevatedButton.styleFrom(backgroundColor: Colors.red),",
      "            onPressed: () => Navigator.of(ctx).pop(true),",
      "            child: Text(loc.delete),",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "",
      "    if (confirmed == true) {",
      "      final provider = context.read<CategoryProvider>();",
      "      final deletedCount = _stagedForDelete.length;",
      "",
      "      try {",
      "        await provider",
      "            .bulkDeleteCategoriesFromFirestore(_stagedForDelete.toList());",
      "        _stagedForDelete.clear();",
      "",
      "        if (mounted) {",
      "          ScaffoldMessenger.of(context).showSnackBar(",
      "            SnackBar(content: Text(loc.bulkDeleteSuccess(deletedCount))),",
      "          );",
      "        }",
      "      } catch (e, stack) {",
      "        await ErrorLogger.log(",
      "          message: 'bulk_delete_categories_failed',",
      "          stack: stack.toString(),",
      "          source: 'OnboardingCategoriesScreen',",
      "          screen: 'onboarding_categories_screen',",
      "          severity: 'error',",
      "          contextData: {'selectedCount': deletedCount},",
      "        );",
      "        if (mounted) {",
      "          ScaffoldMessenger.of(context).showSnackBar(",
      "            SnackBar(content: Text(loc.errorGeneric)),",
      "          );",
      "        }",
      "      }",
      "      setState(() {}); // Refresh UI selection state",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context)!;",
      "    final provider = context.watch<CategoryProvider>();",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "",
      "    return Scaffold(",
      "      appBar: AppBar(",
      "        backgroundColor: theme.scaffoldBackgroundColor,",
      "        elevation: 0,",
      "        iconTheme: const IconThemeData(color: Colors.black),",
      "        title: Text(",
      "          loc.onboardingCategories,",
      "          style: theme.textTheme.titleLarge?.copyWith(",
      "            fontWeight: FontWeight.bold,",
      "            color: colorScheme.onSurface,",
      "          ),",
      "        ),",
      "        actions: [",
      "          IconButton(",
      "            icon: const Icon(Icons.data_object),",
      "            tooltip: loc.importExportCategories,",
      "            onPressed: _openImportExportDialog,",
      "          ),",
      "          IconButton(",
      "            icon: const Icon(Icons.library_add),",
      "            tooltip: loc.selectCategoryTemplate,",
      "            onPressed: () async {",
      "              await CategoriesTemplatePickerDialog.show(",
      "                  context); // this is the screen context, not the dialog's context",
      "            },",
      "          ),",
      "          IconButton(",
      "            icon: const Icon(Icons.check_circle_outline),",
      "            tooltip: loc.markAsComplete,",
      "            onPressed: _markComplete,",
      "          ),",
      "        ],",
      "      ),",
      "      floatingActionButton: FloatingActionButton.extended(",
      "        heroTag: 'onboarding_categories_fab',",
      "        onPressed: () => _openCategoryForm(),",
      "        icon: const Icon(Icons.add),",
      "        label: Text(loc.addCategory),",
      "        backgroundColor: DesignTokens.primaryColor,",
      "      ),",
      "      body: Padding(",
      "        padding: DesignTokens.gridPadding,",
      "        child: Column(",
      "          children: [",
      "            if (provider.isDirty)",
      "              Row(",
      "                children: [",
      "                  ElevatedButton(",
      "                    onPressed: _saveChanges,",
      "                    child: Text(loc.saveChanges),",
      "                  ),",
      "                  const SizedBox(width: 12),",
      "                  OutlinedButton(",
      "                    onPressed: provider.revertChanges,",
      "                    child: Text(loc.revertChanges),",
      "                  ),",
      "                ],",
      "              ),",
      "            const SizedBox(height: 12),",
      "            if (_showSelectAllBanner)",
      "              Card(",
      "                color: Colors.amber[100],",
      "                margin: const EdgeInsets.symmetric(vertical: 6),",
      "                child: Padding(",
      "                  padding:",
      "                      const EdgeInsets.symmetric(horizontal: 20, vertical: 12),",
      "                  child: Row(",
      "                    children: [",
      "                      Expanded(",
      "                        child: Text(",
      "                          loc.selectAllPrompt, // Add to .arb",
      "                          style: const TextStyle(fontWeight: FontWeight.w600),",
      "                        ),",
      "                      ),",
      "                      ElevatedButton.icon(",
      "                        icon: const Icon(Icons.select_all),",
      "                        label: Text(loc.selectAll), // Add to .arb",
      "                        onPressed: () {",
      "                          setState(() {",
      "                            _stagedForDelete.clear();",
      "                            _stagedForDelete.addAll(",
      "                              provider.categories.map((c) => c.id),",
      "                            );",
      "                            _showSelectAllBanner = false;",
      "                          });",
      "                        },",
      "                      ),",
      "                      const SizedBox(width: 8),",
      "                      TextButton(",
      "                        child: Text(loc.cancel),",
      "                        onPressed: () {",
      "                          setState(() {",
      "                            _showSelectAllBanner = false;",
      "                          });",
      "                        },",
      "                      ),",
      "                    ],",
      "                  ),",
      "                ),",
      "              ),",
      "            if (_stagedForDelete.isNotEmpty)",
      "              Row(",
      "                children: [",
      "                  ElevatedButton.icon(",
      "                    icon: const Icon(Icons.delete_forever),",
      "                    label: Text(loc.deleteSelected),",
      "                    style: ElevatedButton.styleFrom(",
      "                      backgroundColor: Colors.red,",
      "                    ),",
      "                    onPressed: _confirmBulkDelete,",
      "                  ),",
      "                  const SizedBox(width: 12),",
      "                  OutlinedButton(",
      "                    onPressed: () {",
      "                      setState(() {",
      "                        _stagedForDelete.clear();",
      "                      });",
      "                    },",
      "                    child: Text(loc.clearSelection),",
      "                  ),",
      "                  const SizedBox(width: 24),",
      "                  Text(",
      "                    '${_stagedForDelete.length} ${loc.toDelete}',",
      "                    style: const TextStyle(color: Colors.red),",
      "                  ),",
      "                ],",
      "              ),",
      "            const SizedBox(height: 12),",
      "            Expanded(",
      "              child: provider.categories.isEmpty",
      "                  ? EmptyStateWidget(",
      "                      title: loc.noCategoriesFound,",
      "                      message: loc.noCategoriesMessage,",
      "                    )",
      "                  : ReorderableListView(",
      "                      onReorder: (oldIndex, newIndex) {",
      "                        provider.reorderCategories(oldIndex, newIndex);",
      "                      },",
      "                      children: [",
      "                        for (final cat in provider.categories)",
      "                          CategoryListTile(",
      "                            key: ValueKey(cat.id),",
      "                            category: cat,",
      "                            isSelected: _stagedForDelete.contains(cat.id),",
      "                            onSelect: (checked) {",
      "                              setState(() {",
      "                                if (checked == true) {",
      "                                  _stagedForDelete.add(cat.id);",
      "                                  if (_stagedForDelete.length == 1) {",
      "                                    _showSelectAllBanner = true;",
      "                                  }",
      "                                } else {",
      "                                  _stagedForDelete.remove(cat.id);",
      "                                }",
      "                              });",
      "                            },",
      "                            onEdit: () => _openCategoryForm(cat),",
      "                            onDelete: () async {",
      "                              final provider = context.read<CategoryProvider>();",
      "                              final loc = AppLocalizations.of(context)!;",
      "                              final scaffold = ScaffoldMessenger.of(context);",
      "",
      "                              try {",
      "                                await provider.deleteCategory(cat.id);",
      "                                scaffold.showSnackBar(",
      "                                  SnackBar(content: Text(loc.categoryDeleted)),",
      "                                );",
      "                              } catch (_) {",
      "                                scaffold.showSnackBar(",
      "                                  SnackBar(content: Text(loc.errorGeneric)),",
      "                                );",
      "                              }",
      "                            },",
      "                          ),",
      "                      ],",
      "                    ),",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 404,
      "file_size": 15138,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\screens\\onboarding_feature_setup_screen.dart",
    "content": [
      "// File: lib/admin/dashboard/onboarding/screens/onboarding_feature_setup_screen.dart",
      "",
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/config/branding_config.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_feature_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_info_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/onboarding_progress_provider.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/core/models/dashboard_section.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/widgets/feature_toggle_tile.dart';",
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "",
      "class OnboardingFeatureSetupScreen extends StatefulWidget {",
      "  const OnboardingFeatureSetupScreen({super.key});",
      "",
      "  @override",
      "  State<OnboardingFeatureSetupScreen> createState() =>",
      "      _OnboardingFeatureSetupScreenState();",
      "}",
      "",
      "class _OnboardingFeatureSetupScreenState",
      "    extends State<OnboardingFeatureSetupScreen> {",
      "  bool _isSaving = false;",
      "  List<Map<String, dynamic>> _featureMetadata = [];",
      "  String?",
      "      _highlightFeatureKey; // Feature to highlight for deep-link error repair",
      "  final ScrollController _scrollController = ScrollController();",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    Future.microtask(() async {",
      "      final provider = context.read<FranchiseFeatureProvider>();",
      "      await provider.initialize();",
      "",
      "      try {",
      "        final snapshot = await FirebaseFirestore.instance",
      "            .collection('platform_features')",
      "            .orderBy('name')",
      "            .get();",
      "",
      "        _featureMetadata = snapshot.docs",
      "            .map((doc) => {'id': doc.id, ...doc.data()})",
      "            .where((f) => f['deprecated'] != true)",
      "            .toList();",
      "",
      "        debugPrint(",
      "            '[FeatureSetup] Loaded ${_featureMetadata.length} features from Firestore.');",
      "      } catch (e, st) {",
      "        await ErrorLogger.log(",
      "          message: 'Failed to fetch platform_features from Firestore',",
      "          stack: st.toString(),",
      "          source: 'onboarding_feature_setup_screen.dart',",
      "          screen: 'OnboardingFeatureSetupScreen',",
      "        );",
      "      }",
      "",
      "      if (mounted) setState(() {});",
      "    });",
      "  }",
      "",
      "  @override",
      "  void didChangeDependencies() {",
      "    super.didChangeDependencies();",
      "    // Accept navigation/focus argument from schema repair or review screen",
      "    final args = ModalRoute.of(context)?.settings.arguments;",
      "    if (args is Map && args.containsKey('featureKey')) {",
      "      _highlightFeatureKey = args['featureKey'] as String?;",
      "      // Defer scroll until after the next build/layout pass",
      "      WidgetsBinding.instance.addPostFrameCallback((_) {",
      "        _scrollToFeature(_highlightFeatureKey);",
      "      });",
      "    }",
      "  }",
      "",
      "  // Scrolls the list to the feature needing attention (for schema repair deep-link)",
      "  void _scrollToFeature(String? featureKey) {",
      "    if (featureKey == null) return;",
      "    final index =",
      "        _featureMetadata.indexWhere((meta) => meta['key'] == featureKey);",
      "    if (index != -1 && _scrollController.hasClients) {",
      "      // Each tile is roughly ~70-80px tall; tweak as needed for your UI",
      "      final scrollPos =",
      "          (index * 75.0).clamp(0.0, _scrollController.position.maxScrollExtent);",
      "      _scrollController.animateTo(",
      "        scrollPos,",
      "        duration: const Duration(milliseconds: 400),",
      "        curve: Curves.easeInOut,",
      "      );",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final localizations = AppLocalizations.of(context)!;",
      "    final theme = Theme.of(context);",
      "    final featureProvider = context.watch<FranchiseFeatureProvider>();",
      "    final isInitialized = featureProvider.isInitialized;",
      "",
      "    return Scaffold(",
      "      appBar: AppBar(",
      "        backgroundColor: Theme.of(context).scaffoldBackgroundColor,",
      "        elevation: 0,",
      "        iconTheme: const IconThemeData(color: Colors.black),",
      "        title: Text(",
      "          localizations.featureSetupTitle,",
      "          style: Theme.of(context).textTheme.titleLarge?.copyWith(",
      "                fontWeight: FontWeight.bold,",
      "                color: Colors.black,",
      "              ),",
      "        ),",
      "        actions: [",
      "          IconButton(",
      "            icon: const Icon(Icons.check_circle_outline),",
      "            tooltip: localizations.markAsComplete,",
      "            onPressed: _markComplete,",
      "          ),",
      "        ],",
      "      ),",
      "      body: isInitialized",
      "          ? Column(",
      "              crossAxisAlignment: CrossAxisAlignment.start,",
      "              children: [",
      "                Padding(",
      "                  padding: const EdgeInsets.all(16),",
      "                  child: Text(",
      "                    localizations.featureSetupDescription,",
      "                    style: theme.textTheme.bodyMedium,",
      "                  ),",
      "                ),",
      "                Expanded(",
      "                  child: ListView(",
      "                    controller: _scrollController,",
      "                    padding: const EdgeInsets.symmetric(horizontal: 16),",
      "                    children: _featureMetadata",
      "                        .where((meta) =>",
      "                            meta['deprecated'] != true &&",
      "                            meta['developerOnly'] != true)",
      "                        .map((meta) {",
      "                      final moduleKey = meta['key'];",
      "                      final title = meta['name'] ?? moduleKey;",
      "                      final description = meta['description'] ?? '';",
      "                      final isLocked = !featureProvider.hasFeature(moduleKey);",
      "                      final isHighlighted = moduleKey == _highlightFeatureKey;",
      "",
      "                      return FeatureToggleTile(",
      "                        moduleKey: moduleKey,",
      "                        featureKey: 'enabled',",
      "                        title: title,",
      "                        description: description,",
      "                        highlight:",
      "                            isHighlighted, // Visually accent this tile if deep-linked",
      "                      );",
      "                    }).toList(),",
      "                  ),",
      "                ),",
      "              ],",
      "            )",
      "          : const Center(child: CircularProgressIndicator()),",
      "      floatingActionButton: isInitialized",
      "          ? FloatingActionButton.extended(",
      "              heroTag: 'onboarding_feature_setup_fab',",
      "              onPressed: _isSaving ? null : _handleSave,",
      "              label: _isSaving",
      "                  ? Text(localizations.saving)",
      "                  : Text(localizations.save),",
      "              icon: const Icon(Icons.save),",
      "            )",
      "          : null,",
      "    );",
      "  }",
      "",
      "  /// Handles saving the current feature setup to Firestore and marking the onboarding step complete.",
      "  Future<void> _handleSave() async {",
      "    setState(() => _isSaving = true);",
      "    final featureProvider = context.read<FranchiseFeatureProvider>();",
      "    final onboarding = context.read<OnboardingProgressProvider>();",
      "    final franchiseId =",
      "        context.read<FranchiseInfoProvider>().franchise?.id ?? 'unknown';",
      "",
      "    try {",
      "      final success = await featureProvider.persistToFirestore();",
      "",
      "      if (success) {",
      "        await onboarding.markStepComplete('onboarding_feature_setup');",
      "",
      "        if (mounted) {",
      "          ScaffoldMessenger.of(context).showSnackBar(",
      "            SnackBar(",
      "              content: Text(AppLocalizations.of(context)!.saveSuccess),",
      "            ),",
      "          );",
      "          Navigator.of(context)",
      "              .maybePop(); // Go back or proceed to next onboarding step",
      "        }",
      "      } else {",
      "        showDialog(",
      "          context: context,",
      "          builder: (_) => AlertDialog(",
      "            title: Text(AppLocalizations.of(context)!.saveErrorTitle),",
      "            content: Text(AppLocalizations.of(context)!.saveErrorBody),",
      "            actions: [",
      "              TextButton(",
      "                onPressed: () => Navigator.pop(context),",
      "                child: Text(AppLocalizations.of(context)!.close),",
      "              )",
      "            ],",
      "          ),",
      "        );",
      "      }",
      "    } catch (e, st) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to save onboarding features',",
      "        stack: st.toString(),",
      "        source: 'onboarding_feature_setup_screen.dart',",
      "        screen: 'OnboardingFeatureSetupScreen',",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "",
      "      if (mounted) {",
      "        ScaffoldMessenger.of(context).showSnackBar(",
      "          SnackBar(",
      "            content: Text(AppLocalizations.of(context)!.saveErrorBody),",
      "            backgroundColor: Theme.of(context).colorScheme.error,",
      "          ),",
      "        );",
      "      }",
      "    } finally {",
      "      if (mounted) setState(() => _isSaving = false);",
      "    }",
      "  }",
      "",
      "  /// Allows toggling the onboarding step as complete/incomplete for workflow enforcement.",
      "  Future<void> _markComplete() async {",
      "    final loc = AppLocalizations.of(context)!;",
      "    final onboardingProvider =",
      "        Provider.of<OnboardingProgressProvider>(context, listen: false);",
      "",
      "    final isCompleted =",
      "        onboardingProvider.isStepComplete('onboarding_feature_setup');",
      "",
      "    try {",
      "      if (isCompleted) {",
      "        await onboardingProvider.markStepIncomplete('onboarding_feature_setup');",
      "        if (mounted) {",
      "          ScaffoldMessenger.of(context).showSnackBar(",
      "            SnackBar(content: Text(loc.stepMarkedIncomplete)),",
      "          );",
      "        }",
      "      } else {",
      "        await onboardingProvider.markStepComplete('onboarding_feature_setup');",
      "        if (mounted) {",
      "          ScaffoldMessenger.of(context).showSnackBar(",
      "            SnackBar(content: Text(loc.stepMarkedComplete)),",
      "          );",
      "        }",
      "      }",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to toggle onboarding step \"onboarding_feature_setup\"',",
      "        stack: stack.toString(),",
      "        source: 'OnboardingFeatureSetupScreen',",
      "        screen: 'onboarding_feature_setup_screen',",
      "        severity: 'error',",
      "        contextData: {'error': e.toString()},",
      "      );",
      "      if (mounted) {",
      "        ScaffoldMessenger.of(context).showSnackBar(",
      "          SnackBar(content: Text(loc.errorGeneric)),",
      "        );",
      "      }",
      "    }",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 277,
      "file_size": 10398,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\screens\\onboarding_ingredients_screen.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/widgets/ingredients/ingredient_metadata_template_picker_dialog.dart';",
      "import 'package:franchise_admin_portal/core/models/ingredient_metadata.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/core/providers/onboarding_progress_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_info_provider.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/providers/ingredient_metadata_provider.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/widgets/ingredients/ingredient_form_card.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/widgets/ingredients/ingredient_list_tile.dart';",
      "import 'package:franchise_admin_portal/widgets/empty_state_widget.dart';",
      "import 'package:franchise_admin_portal/widgets/loading_shimmer_widget.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/widgets/ingredients/ingredient_metadata_json_import_export_dialog.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/ingredient_type_provider.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/widgets/ingredients/missing_type_resolution_dialog.dart';",
      "",
      "class OnboardingIngredientsScreen extends StatefulWidget {",
      "  const OnboardingIngredientsScreen({super.key});",
      "",
      "  @override",
      "  State<OnboardingIngredientsScreen> createState() =>",
      "      _OnboardingIngredientsScreenState();",
      "}",
      "",
      "class _OnboardingIngredientsScreenState",
      "    extends State<OnboardingIngredientsScreen> {",
      "  final ScrollController _scrollController = ScrollController();",
      "  late AppLocalizations loc;",
      "  bool _hasInitialized = false;",
      "  final _listViewKey = GlobalKey();",
      "  final Set<String> _highlightedIngredients = {};",
      "",
      "  // Local-only keys for this screen instance (do NOT store in provider)",
      "  final Map<String, GlobalKey> _itemKeys = {};",
      "  final Map<String, GlobalKey> _fieldKeys =",
      "      {}; // optional, used for field highlights",
      "",
      "  // Handoff args from router → this screen",
      "  String? _focusIdFromArgs;",
      "  List<String>? _focusFieldsFromArgs;",
      "  bool _appliedFocusFromArgs = false;",
      "",
      "  void _maybeApplyInitialFocus() {",
      "    if (!mounted || _appliedFocusFromArgs != false) return;",
      "    if (_focusIdFromArgs == null) return;",
      "",
      "    final provider = context.read<IngredientMetadataProvider>();",
      "",
      "    // Only try when items are present and the target exists",
      "    if (provider.ingredients.isEmpty) return;",
      "    final exists = provider.ingredients.any((e) => e.id == _focusIdFromArgs);",
      "    if (!exists) return;",
      "",
      "    debugPrint(",
      "      '[OnboardingIngredientsScreen] Applying initial focus to '",
      "      'ingredientId=\"${_focusIdFromArgs}\" fields=${_focusFieldsFromArgs}',",
      "    );",
      "",
      "    _appliedFocusFromArgs = true; // guard: run exactly once",
      "",
      "    WidgetsBinding.instance.addPostFrameCallback((_) {",
      "      if (!mounted) return;",
      "      scrollAndHighlightIngredient(",
      "        _focusIdFromArgs!,",
      "        focusFields: _focusFieldsFromArgs,",
      "      );",
      "    });",
      "  }",
      "",
      "  void scrollAndHighlightIngredient(",
      "    String ingredientId, {",
      "    List<String>? focusFields,",
      "  }) {",
      "    // Use screen-local keys, not provider-level keys",
      "    final key = _itemKeys.putIfAbsent(ingredientId, () => GlobalKey());",
      "    final ctx = key.currentContext;",
      "",
      "    if (ctx == null || !mounted) {",
      "      debugPrint(",
      "        '[OnboardingIngredientsScreen] No visible context for $ingredientId — skipping highlight.',",
      "      );",
      "      return;",
      "    }",
      "",
      "    // Scroll tile into view",
      "    Scrollable.ensureVisible(",
      "      ctx,",
      "      duration: const Duration(milliseconds: 600),",
      "      curve: Curves.easeInOut,",
      "    );",
      "",
      "    // Tile highlight overlay",
      "    final overlay = Overlay.of(context);",
      "    final box = ctx.findRenderObject() as RenderBox?;",
      "    if (overlay != null && box != null) {",
      "      final entry = OverlayEntry(",
      "        builder: (_) => Positioned(",
      "          left: box.localToGlobal(Offset.zero).dx,",
      "          top: box.localToGlobal(Offset.zero).dy,",
      "          width: box.size.width,",
      "          height: box.size.height,",
      "          child: IgnorePointer(",
      "            child: Container(color: Colors.yellow.withOpacity(0.30)),",
      "          ),",
      "        ),",
      "      );",
      "      overlay.insert(entry);",
      "      Future.delayed(const Duration(seconds: 2), entry.remove);",
      "    }",
      "",
      "    // Optional: highlight specific fields if our screen registered them",
      "    if (focusFields != null && focusFields.isNotEmpty) {",
      "      for (final field in focusFields) {",
      "        final fKey = _fieldKeys['$ingredientId::$field'];",
      "        final fCtx = fKey?.currentContext;",
      "        if (fCtx == null) continue;",
      "        final overlay2 = Overlay.of(context);",
      "        final fBox = fCtx.findRenderObject() as RenderBox?;",
      "        if (overlay2 != null && fBox != null) {",
      "          final entry2 = OverlayEntry(",
      "            builder: (_) => Positioned(",
      "              left: fBox.localToGlobal(Offset.zero).dx,",
      "              top: fBox.localToGlobal(Offset.zero).dy,",
      "              width: fBox.size.width,",
      "              height: fBox.size.height,",
      "              child: IgnorePointer(",
      "                child: Container(color: Colors.orange.withOpacity(0.35)),",
      "              ),",
      "            ),",
      "          );",
      "          overlay2.insert(entry2);",
      "          Future.delayed(const Duration(seconds: 2), entry2.remove);",
      "        }",
      "      }",
      "    }",
      "  }",
      "",
      "  // Set to track selected ingredients for bulk actions",
      "  final Set<String> _selectedIngredientIds = {};",
      "",
      "  void _openIngredientForm([IngredientMetadata? ingredient]) {",
      "    final loc = AppLocalizations.of(context);",
      "    final provider =",
      "        Provider.of<IngredientMetadataProvider>(context, listen: false);",
      "",
      "    if (loc == null) {",
      "      print('[OnboardingIngredientsScreen] ERROR: loc is null in FAB');",
      "      return;",
      "    }",
      "",
      "    showDialog(",
      "      context: context,",
      "      builder: (dialogContext) {",
      "        // Get the providers from the parent context",
      "        final ingredientProvider =",
      "            Provider.of<IngredientMetadataProvider>(context, listen: false);",
      "        final typeProvider =",
      "            Provider.of<IngredientTypeProvider>(context, listen: false);",
      "",
      "        return MultiProvider(",
      "          providers: [",
      "            ChangeNotifierProvider<IngredientMetadataProvider>.value(",
      "                value: ingredientProvider),",
      "            ChangeNotifierProvider<IngredientTypeProvider>.value(",
      "                value: typeProvider),",
      "          ],",
      "          child: IngredientFormCard(",
      "            initialData: ingredient,",
      "            onSaved: () {",
      "              Navigator.of(dialogContext).pop();",
      "            },",
      "            loc: loc,",
      "            parentContext: context,",
      "          ),",
      "        );",
      "      },",
      "    );",
      "  }",
      "",
      "  Future<void> _markComplete() async {",
      "    final provider = context.read<IngredientMetadataProvider>();",
      "    final onboardingProvider = context.read<OnboardingProgressProvider>();",
      "",
      "    if (provider.ingredients.isEmpty) {",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(content: Text(loc.pleaseAddIngredientTypesFirst)),",
      "      );",
      "      return;",
      "    }",
      "",
      "    final isCompleted = onboardingProvider.isStepComplete('ingredients');",
      "",
      "    try {",
      "      if (isCompleted) {",
      "        await onboardingProvider.markStepIncomplete('ingredients');",
      "        if (mounted) {",
      "          ScaffoldMessenger.of(context).showSnackBar(",
      "            SnackBar(content: Text(loc.stepMarkedIncomplete)),",
      "          );",
      "        }",
      "      } else {",
      "        await onboardingProvider.markStepComplete('ingredients');",
      "        if (mounted) {",
      "          ScaffoldMessenger.of(context).showSnackBar(",
      "            SnackBar(content: Text(loc.stepMarkedComplete)),",
      "          );",
      "        }",
      "      }",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to toggle onboarding step completion',",
      "        stack: stack.toString(),",
      "        source: '_markComplete',",
      "        screen: 'onboarding_ingredients_screen',",
      "        severity: 'error',",
      "        contextData: {'ingredientsCount': provider.ingredients.length},",
      "      );",
      "      if (mounted) {",
      "        ScaffoldMessenger.of(context).showSnackBar(",
      "          SnackBar(content: Text(loc.errorGeneric)),",
      "        );",
      "      }",
      "    }",
      "  }",
      "",
      "  Future<void> _confirmBulkDelete() async {",
      "    if (_selectedIngredientIds.isEmpty) return;",
      "",
      "    final confirmed = await showDialog<bool>(",
      "      context: context,",
      "      builder: (ctx) => AlertDialog(",
      "        title: Text(loc.confirmDeletion),",
      "        content: Text(",
      "          loc.bulkDeleteConfirmation(_selectedIngredientIds.length),",
      "        ),",
      "        actions: [",
      "          TextButton(",
      "            onPressed: () => Navigator.of(ctx).pop(false),",
      "            child: Text(loc.cancel),",
      "          ),",
      "          ElevatedButton(",
      "            onPressed: () => Navigator.of(ctx).pop(true),",
      "            style: ElevatedButton.styleFrom(",
      "              backgroundColor: Colors.red,",
      "            ),",
      "            child: Text(loc.delete),",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "",
      "    if (confirmed == true) {",
      "      final provider = context.read<IngredientMetadataProvider>();",
      "      final deletedCount =",
      "          _selectedIngredientIds.length; // Capture before clearing",
      "",
      "      try {",
      "        // Delete from Firestore and reload provider data",
      "        await provider.bulkDeleteIngredientsFromFirestore(",
      "            _selectedIngredientIds.toList());",
      "",
      "        // Explicitly reload provider so UI updates",
      "        await provider.load();",
      "",
      "        // Clear selection BEFORE showing snackbar so count is accurate",
      "        _selectedIngredientIds.clear();",
      "",
      "        if (mounted) {",
      "          ScaffoldMessenger.of(context).showSnackBar(",
      "            SnackBar(",
      "              content: Text(loc.bulkDeleteSuccess(deletedCount)),",
      "            ),",
      "          );",
      "        }",
      "      } catch (e, stack) {",
      "        await ErrorLogger.log(",
      "          message: 'Bulk delete ingredients failed',",
      "          source: 'OnboardingIngredientsScreen',",
      "          screen: 'onboarding_ingredients_screen',",
      "          severity: 'error',",
      "          stack: stack.toString(),",
      "          contextData: {'selectedCount': deletedCount},",
      "        );",
      "        if (mounted) {",
      "          ScaffoldMessenger.of(context).showSnackBar(",
      "            SnackBar(content: Text(loc.errorGeneric)),",
      "          );",
      "        }",
      "      }",
      "      setState(() {}); // Refresh UI after clearing selections and loading data",
      "    }",
      "  }",
      "",
      "  void _toggleSelectAll(",
      "      List<IngredientMetadata> allIngredients, bool? checked) {",
      "    setState(() {",
      "      if (checked == true) {",
      "        _selectedIngredientIds.addAll(allIngredients.map((e) => e.id));",
      "      } else {",
      "        _selectedIngredientIds.clear();",
      "      }",
      "    });",
      "  }",
      "",
      "  void _toggleSelection(String ingredientId, bool? checked) {",
      "    setState(() {",
      "      if (checked == true) {",
      "        _selectedIngredientIds.add(ingredientId);",
      "      } else {",
      "        _selectedIngredientIds.remove(ingredientId);",
      "      }",
      "    });",
      "  }",
      "",
      "  @override",
      "  void didChangeDependencies() {",
      "    super.didChangeDependencies();",
      "    if (_hasInitialized) return;",
      "",
      "    // 1️⃣ Capture router args ONCE",
      "    final args = ModalRoute.of(context)?.settings.arguments;",
      "    if (args is Map) {",
      "      _focusIdFromArgs = (args['focusItemId'] ??",
      "          args['ingredientId'] ??",
      "          args['itemId']) as String?;",
      "      final fields = args['focusFields'];",
      "      if (fields is List) {",
      "        _focusFieldsFromArgs = fields.cast<String>();",
      "      }",
      "      debugPrint(",
      "        '[OnboardingIngredientsScreen] Router args captured: '",
      "        'focusItemId=$_focusIdFromArgs, focusFields=$_focusFieldsFromArgs',",
      "      );",
      "    } else {",
      "      debugPrint('[OnboardingIngredientsScreen] No router args provided.');",
      "    }",
      "",
      "    // 2️⃣ Ensure provider data & keys exist BEFORE attempting focus",
      "    final provider = context.read<IngredientMetadataProvider>();",
      "    provider.load(forceReloadFromFirestore: true).then((_) {",
      "      if (!mounted) return;",
      "",
      "      // 3️⃣ Try initial focus once data & keys are ready",
      "      _maybeApplyInitialFocus();",
      "",
      "      debugPrint(",
      "        '[OnboardingIngredientsScreen] ✅ Ingredient reload complete. '",
      "        'Count=${provider.ingredients.length}',",
      "      );",
      "",
      "      setState(() {}); // Force UI refresh after load",
      "    });",
      "",
      "    _hasInitialized = true;",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    print('[OnboardingIngredientsScreen] build() called');",
      "",
      "    try {",
      "      final typeProvider =",
      "          Provider.of<IngredientTypeProvider>(context, listen: false);",
      "      print(",
      "          '[OnboardingIngredientsScreen] IngredientTypeProvider FOUND: hashCode=${typeProvider.hashCode}');",
      "    } catch (e) {",
      "      print(",
      "          '[OnboardingIngredientsScreen] IngredientTypeProvider NOT FOUND: $e');",
      "    }",
      "",
      "    try {",
      "      loc = AppLocalizations.of(context)!;",
      "      final theme = Theme.of(context);",
      "      final colorScheme = theme.colorScheme;",
      "      final provider = context.watch<IngredientMetadataProvider>();",
      "      _maybeApplyInitialFocus();",
      "      print(",
      "          '[OnboardingIngredientsScreen] IngredientMetadataProvider build() provider hashCode=${provider.hashCode}');",
      "      print(",
      "          '[Screen] build: provider.ingredients.length = ${provider.ingredients.length}');",
      "",
      "      final groupedIngredients = provider.groupedIngredients;",
      "      final allIngredientsFlat = provider.ingredients;",
      "",
      "      final allSelected =",
      "          _selectedIngredientIds.length == allIngredientsFlat.length &&",
      "              allIngredientsFlat.isNotEmpty;",
      "      final someSelected = _selectedIngredientIds.isNotEmpty && !allSelected;",
      "      print(",
      "          '[OnboardingIngredientsScreen] BUILD OK! INGREDIENTS: ${provider.ingredients.length}');",
      "      try {",
      "        print('[OnboardingIngredientsScreen] Scaffold building...');",
      "        return Scaffold(",
      "          appBar: AppBar(",
      "            backgroundColor: theme.scaffoldBackgroundColor,",
      "            elevation: 0,",
      "            iconTheme: const IconThemeData(color: Colors.black),",
      "            leading: IconButton(",
      "              icon: const Icon(Icons.arrow_back),",
      "              onPressed: () => Navigator.of(context).pop(),",
      "              tooltip: loc.back,",
      "            ),",
      "            title: Text(",
      "              loc.onboardingIngredients,",
      "              style: theme.textTheme.titleLarge?.copyWith(",
      "                fontWeight: FontWeight.bold,",
      "                color: Colors.black,",
      "              ),",
      "            ),",
      "            centerTitle: false,",
      "            actions: [",
      "              Builder(",
      "                builder: (context) => IconButton(",
      "                  icon: const Icon(Icons.data_object),",
      "                  tooltip: loc.importExport,",
      "                  onPressed: () {",
      "                    final provider = Provider.of<IngredientMetadataProvider>(",
      "                        context,",
      "                        listen: false);",
      "                    IngredientMetadataJsonImportExportDialog.show(",
      "                        context, provider);",
      "                  },",
      "                ),",
      "              ),",
      "              Builder(",
      "                builder: (context) => IconButton(",
      "                  icon: const Icon(Icons.library_add),",
      "                  tooltip: loc.selectIngredientTemplate,",
      "                  onPressed: () async {",
      "                    print(",
      "                        '[OnboardingIngredientsScreen] Template import button pressed');",
      "                    final franchiseId =",
      "                        context.read<FranchiseProvider>().franchiseId;",
      "",
      "                    // 1. Let user select and load the template ingredients (returns list or null)",
      "                    final List<IngredientMetadata>? templateIngredients =",
      "                        await IngredientMetadataTemplatePickerDialog.show(",
      "                            context);",
      "",
      "                    if (templateIngredients == null ||",
      "                        templateIngredients.isEmpty) return;",
      "",
      "                    final typeProvider = context.read<IngredientTypeProvider>();",
      "                    final existingTypeIds =",
      "                        typeProvider.ingredientTypes.map((t) => t.id).toSet();",
      "",
      "                    // 2. Find all imported ingredients with missing types",
      "                    final ingredientsWithMissingTypes = templateIngredients",
      "                        .where((ing) => !existingTypeIds.contains(ing.typeId))",
      "                        .toList();",
      "",
      "                    List<IngredientMetadata> allToImport = [];",
      "",
      "                    if (ingredientsWithMissingTypes.isNotEmpty) {",
      "                      // 3. Show resolution dialog, block until all are mapped or skipped",
      "                      final resolved =",
      "                          await showDialog<List<IngredientMetadata>>(",
      "                        context: context,",
      "                        barrierDismissible: false,",
      "                        builder: (dialogContext) => MissingTypeResolutionDialog(",
      "                          ingredientsWithMissingTypes:",
      "                              ingredientsWithMissingTypes,",
      "                          availableTypes: typeProvider.ingredientTypes,",
      "                          dialogContext: dialogContext,",
      "                          onResolved: (fixed) {",
      "                            Navigator.of(dialogContext)",
      "                                .pop(fixed); // GOOD: local dialog context",
      "                          },",
      "                        ),",
      "                      );",
      "",
      "                      // Merge: valid+resolved",
      "                      allToImport = [",
      "                        ...templateIngredients.where(",
      "                            (ing) => existingTypeIds.contains(ing.typeId)),",
      "                        if (resolved != null) ...resolved,",
      "                      ];",
      "                    } else {",
      "                      allToImport = templateIngredients;",
      "                    }",
      "",
      "                    // 4. Add resolved/valid ingredients to provider",
      "                    if (allToImport.isNotEmpty) {",
      "                      final metadataProvider =",
      "                          context.read<IngredientMetadataProvider>();",
      "                      print(",
      "                          '[OnboardingIngredientsScreen] About to add ${allToImport.length} imported ingredients');",
      "                      for (final ing in allToImport) {",
      "                        print(",
      "                            '[OnboardingIngredientsScreen][DEBUG] New ingredient: id=${ing.id}, typeId=${ing.typeId}, name=${ing.name}');",
      "                        assert(ing.typeId != null && ing.typeId!.isNotEmpty,",
      "                            'ingredient typeId must not be null/empty!');",
      "                      }",
      "",
      "                      metadataProvider.addImportedIngredients(allToImport);",
      "                      print(",
      "                          '[Provider] after add, ingredients.length=${metadataProvider.ingredients.length}, staged=${metadataProvider.stagedIngredients.length}');",
      "                      for (final ing in metadataProvider.ingredients) {",
      "                        print(",
      "                            '[Provider][DEBUG] Stored ingredient: id=${ing.id}, typeId=${ing.typeId}, name=${ing.name}');",
      "                        assert(ing.typeId != null && ing.typeId!.isNotEmpty,",
      "                            'ingredient typeId must not be null/empty!');",
      "                      }",
      "                      print(",
      "                          '[OnboardingIngredientsScreen] build() after template import and dialog resolution. Ingredients: ${provider.ingredients.length}');",
      "                      WidgetsBinding.instance.addPostFrameCallback((_) {",
      "                        print(",
      "                            '[OnboardingIngredientsScreen][STACK] ModalRoute.of(context): ${ModalRoute.of(context)}');",
      "                        print(",
      "                            '[OnboardingIngredientsScreen][STACK] context.mounted: $mounted');",
      "                      });",
      "",
      "                      ScaffoldMessenger.of(context).showSnackBar(",
      "                        SnackBar(",
      "                          content:",
      "                              Text(loc.ingredientsImported(allToImport.length)),",
      "                        ),",
      "                      );",
      "                    }",
      "                  },",
      "                ),",
      "              ),",
      "              Builder(",
      "                builder: (context) => IconButton(",
      "                  icon: const Icon(Icons.check_circle_outline),",
      "                  tooltip: loc.markAsComplete,",
      "                  onPressed: _markComplete,",
      "                ),",
      "              ),",
      "            ],",
      "          ),",
      "          floatingActionButton: Builder(",
      "            builder: (context) {",
      "              final loc = AppLocalizations.of(context);",
      "              if (loc == null) {",
      "                debugPrint(",
      "                    '[OnboardingIngredientsScreen] ERROR: loc is null in FAB');",
      "                return const SizedBox.shrink(); // Prevents crash",
      "              }",
      "",
      "              return FloatingActionButton.extended(",
      "                onPressed: () => _openIngredientForm(),",
      "                icon: const Icon(Icons.add),",
      "                label: Text(loc.addIngredient),",
      "                backgroundColor: DesignTokens.primaryColor,",
      "                heroTag: 'onboarding_ingredients_fab',",
      "              );",
      "            },",
      "          ),",
      "          body: Padding(",
      "            padding: DesignTokens.gridPadding,",
      "            child: Column(",
      "              children: [",
      "                if (provider.isDirty)",
      "                  Row(",
      "                    children: [",
      "                      ElevatedButton(",
      "                        onPressed: () async {",
      "                          final franchiseId =",
      "                              context.read<FranchiseProvider>().franchiseId;",
      "                          final metadataProvider =",
      "                              context.read<IngredientMetadataProvider>();",
      "                          final onboardingProvider =",
      "                              context.read<OnboardingProgressProvider>();",
      "",
      "                          try {",
      "                            await metadataProvider.saveAllChanges(franchiseId);",
      "                            await onboardingProvider",
      "                                .markStepComplete('ingredients');",
      "",
      "                            ScaffoldMessenger.of(context).showSnackBar(",
      "                              SnackBar(content: Text(loc.saveSuccessful)),",
      "                            );",
      "                          } catch (e, stack) {",
      "                            await ErrorLogger.log(",
      "                              message: 'ingredient_save_error',",
      "                              stack: stack.toString(),",
      "                              source: 'onboarding_ingredients_screen',",
      "                              screen: 'onboarding_ingredients_screen',",
      "                              severity: 'error',",
      "                            );",
      "                            ScaffoldMessenger.of(context).showSnackBar(",
      "                              SnackBar(content: Text(loc.saveFailed)),",
      "                            );",
      "                          }",
      "                        },",
      "                        child: Text(loc.saveChanges),",
      "                      ),",
      "                      const SizedBox(width: 12),",
      "                      OutlinedButton(",
      "                        onPressed: provider.revertChanges,",
      "                        child: Text(loc.revertChanges),",
      "                      ),",
      "                    ],",
      "                  ),",
      "                const SizedBox(height: 12),",
      "",
      "                // --- Grouping & Sorting Controls ---",
      "                Row(",
      "                  children: [",
      "                    Text(loc.groupBy + ': '),",
      "                    DropdownButton<String?>(",
      "                      value: provider.groupByKey,",
      "                      items: <DropdownMenuItem<String?>>[",
      "                        const DropdownMenuItem(",
      "                            value: null, child: Text('None')),",
      "                        DropdownMenuItem(value: 'type', child: Text(loc.type)),",
      "                        DropdownMenuItem(",
      "                            value: 'typeId', child: Text(loc.typeId)),",
      "                      ],",
      "                      onChanged: (val) {",
      "                        provider.groupByKey = val;",
      "                      },",
      "                    ),",
      "                    const SizedBox(width: 24),",
      "                    Text(loc.sortBy + ': '),",
      "                    DropdownButton<String>(",
      "                      value: provider.sortKey,",
      "                      items: [",
      "                        DropdownMenuItem(value: 'name', child: Text(loc.name)),",
      "                        DropdownMenuItem(",
      "                            value: 'description', child: Text(loc.description)),",
      "                        DropdownMenuItem(value: 'type', child: Text(loc.type)),",
      "                      ],",
      "                      onChanged: (val) {",
      "                        if (val != null) {",
      "                          provider.sortKey = val;",
      "                        }",
      "                      },",
      "                    ),",
      "                    const SizedBox(width: 12),",
      "                    IconButton(",
      "                      tooltip:",
      "                          provider.ascending ? loc.ascending : loc.descending,",
      "                      icon: Icon(",
      "                        provider.ascending",
      "                            ? Icons.arrow_upward",
      "                            : Icons.arrow_downward,",
      "                      ),",
      "                      onPressed: () {",
      "                        provider.ascending = !provider.ascending;",
      "                      },",
      "                    )",
      "                  ],",
      "                ),",
      "",
      "                const SizedBox(height: 12),",
      "",
      "                if (_selectedIngredientIds.isNotEmpty)",
      "                  Row(",
      "                    children: [",
      "                      ElevatedButton.icon(",
      "                        icon: const Icon(Icons.delete_forever),",
      "                        label: Text(loc.deleteSelected),",
      "                        style: ElevatedButton.styleFrom(",
      "                          backgroundColor: Colors.red,",
      "                        ),",
      "                        onPressed: _confirmBulkDelete,",
      "                      ),",
      "                      const SizedBox(width: 12),",
      "                      OutlinedButton(",
      "                        onPressed: () {",
      "                          setState(() {",
      "                            _selectedIngredientIds.clear();",
      "                          });",
      "                        },",
      "                        child: Text(loc.clearSelection),",
      "                      ),",
      "                    ],",
      "                  ),",
      "",
      "                const SizedBox(height: 12),",
      "",
      "                Expanded(",
      "                  child: provider.ingredients.isEmpty",
      "                      ? EmptyStateWidget(",
      "                          title: loc.noIngredientsFound,",
      "                          message: loc.noIngredientsMessage,",
      "                        )",
      "                      : ListView(",
      "                          controller: _scrollController,",
      "                          children: groupedIngredients.entries.map((entry) {",
      "                            print(",
      "                                '[OnboardingIngredientsScreen] Building ingredient group: ${entry.key}');",
      "                            final groupName = entry.key ?? loc.ungrouped;",
      "                            final groupItems = entry.value;",
      "                            return Column(",
      "                              crossAxisAlignment: CrossAxisAlignment.start,",
      "                              children: [",
      "                                Padding(",
      "                                  padding: const EdgeInsets.symmetric(",
      "                                      vertical: 8.0, horizontal: 16),",
      "                                  child: Row(",
      "                                    children: [",
      "                                      Checkbox(",
      "                                        value: groupItems.every((item) =>",
      "                                            _selectedIngredientIds",
      "                                                .contains(item.id)),",
      "                                        onChanged: (checked) {",
      "                                          setState(() {",
      "                                            for (final item in groupItems) {",
      "                                              if (checked == true) {",
      "                                                _selectedIngredientIds",
      "                                                    .add(item.id);",
      "                                              } else {",
      "                                                _selectedIngredientIds",
      "                                                    .remove(item.id);",
      "                                              }",
      "                                            }",
      "                                          });",
      "                                        },",
      "                                      ),",
      "                                      Text(",
      "                                        groupName,",
      "                                        style: theme.textTheme.titleMedium",
      "                                            ?.copyWith(",
      "                                          fontWeight: FontWeight.bold,",
      "                                        ),",
      "                                      ),",
      "                                    ],",
      "                                  ),",
      "                                ),",
      "                                ...groupItems.map((item) {",
      "                                  final itemKey = _itemKeys.putIfAbsent(",
      "                                      item.id, () => GlobalKey());",
      "",
      "                                  return Container(",
      "                                    key: itemKey,",
      "                                    child: IngredientListTile(",
      "                                      ingredient: item,",
      "                                      franchiseId: provider.franchiseId,",
      "                                      onEdited: () => _openIngredientForm(item),",
      "                                      onRefresh: () => provider.load(),",
      "                                    ),",
      "                                  );",
      "                                }),",
      "                              ],",
      "                            );",
      "                          }).toList(),",
      "                        ),",
      "                ),",
      "              ],",
      "            ),",
      "          ),",
      "        );",
      "      } catch (e, stack) {",
      "        print('[OnboardingIngredientsScreen] CRITICAL BUILD ERROR: $e\\n$stack');",
      "        return Center(child: Text('Critical UI error: $e'));",
      "      }",
      "    } catch (e, stack) {",
      "      print('[OnboardingIngredientsScreen] build error: $e\\n$stack');",
      "      return Center(child: Text('An error occurred: $e'));",
      "    }",
      "  }",
      "",
      "  @override",
      "  void dispose() {",
      "    print('[OnboardingIngredientsScreen] DISPOSED');",
      "    super.dispose();",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 765,
      "file_size": 31325,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\screens\\onboarding_ingredient_type_screen.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/providers/onboarding_progress_provider.dart';",
      "import 'package:franchise_admin_portal/core/models/ingredient_type_model.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/ingredient_type_provider.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/widgets/ingredients/ingredient_type_template_picker_dialog.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/widgets/ingredients/editable_ingredient_type_row.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/widgets/ingredients/inline_add_ingredient_type_row.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/widgets/ingredients/ingredient_type_json_import_export_dialog.dart';",
      "import 'package:franchise_admin_portal/core/providers/ingredient_type_provider.dart';",
      "",
      "class IngredientTypeManagementScreen extends StatefulWidget {",
      "  const IngredientTypeManagementScreen({super.key});",
      "",
      "  @override",
      "  State<IngredientTypeManagementScreen> createState() =>",
      "      _IngredientTypeManagementScreenState();",
      "}",
      "",
      "class _IngredientTypeManagementScreenState",
      "    extends State<IngredientTypeManagementScreen> {",
      "  String? franchiseId;",
      "  bool _showSelectAllBanner = false;",
      "  bool _hasLoaded = false;",
      "  final Map<String, bool> _editingMap = {};",
      "  bool _reorderChanged = false;",
      "  List<IngredientType> _pendingReorder = [];",
      "",
      "  bool get _isEditingAny => _editingMap.values.any((v) => v == true);",
      "",
      "  @override",
      "  void didChangeDependencies() {",
      "    super.didChangeDependencies();",
      "",
      "    final newFranchiseId = context.watch<FranchiseProvider>().franchiseId;",
      "    if (newFranchiseId != franchiseId) {",
      "      franchiseId = newFranchiseId;",
      "    }",
      "",
      "    if (!_hasLoaded &&",
      "        franchiseId != null &&",
      "        franchiseId!.isNotEmpty &&",
      "        franchiseId != 'unknown') {",
      "      _hasLoaded = true;",
      "",
      "      Future.microtask(() {",
      "        final provider =",
      "            Provider.of<IngredientTypeProvider>(context, listen: false);",
      "        provider.loadTypes(franchiseId!);",
      "      });",
      "    }",
      "  }",
      "",
      "  void _showFormDialog({IngredientType? initial}) {",
      "    final loc = AppLocalizations.of(context);",
      "    final franchiseId = context.read<FranchiseProvider>().franchiseId;",
      "    final ingredientTypeProvider = context.read<IngredientTypeProvider>();",
      "",
      "    print(",
      "        '[OnboardingIngredientTypeScreen] FAB pressed – loc: $loc, franchiseId: $franchiseId');",
      "",
      "    if (loc == null) return;",
      "",
      "    showDialog(",
      "      context: context,",
      "      builder: (BuildContext dialogContext) {",
      "        return Localizations.override(",
      "          context: dialogContext,",
      "          child: Builder(",
      "            builder: (innerContext) {",
      "              return ChangeNotifierProvider.value(",
      "                value: ingredientTypeProvider,",
      "                child: IngredientTypeFormDialog(",
      "                  loc: loc,",
      "                  franchiseId: franchiseId,",
      "                  initial: initial,",
      "                ),",
      "              );",
      "            },",
      "          ),",
      "        );",
      "      },",
      "    );",
      "  }",
      "",
      "  Future<void> _markComplete() async {",
      "    final loc = AppLocalizations.of(context)!;",
      "    final onboardingProvider =",
      "        Provider.of<OnboardingProgressProvider>(context, listen: false);",
      "    final provider =",
      "        Provider.of<IngredientTypeProvider>(context, listen: false);",
      "",
      "    if (provider.types.isEmpty) {",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(content: Text(loc.pleaseAddIngredientTypesFirst)),",
      "      );",
      "      return;",
      "    }",
      "",
      "    final isCompleted = onboardingProvider.isStepComplete('ingredientTypes');",
      "",
      "    try {",
      "      if (isCompleted) {",
      "        await onboardingProvider.markStepIncomplete('ingredientTypes');",
      "        if (mounted) {",
      "          ScaffoldMessenger.of(context).showSnackBar(",
      "            SnackBar(content: Text(loc.stepMarkedIncomplete)),",
      "          );",
      "        }",
      "      } else {",
      "        await onboardingProvider.markStepComplete('ingredientTypes');",
      "        if (mounted) {",
      "          ScaffoldMessenger.of(context).showSnackBar(",
      "            SnackBar(content: Text(loc.stepMarkedComplete)),",
      "          );",
      "        }",
      "      }",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to toggle onboarding step \"ingredientTypes\"',",
      "        stack: stack.toString(),",
      "        source: 'OnboardingIngredientTypeScreen',",
      "        screen: 'onboarding_ingredient_type_screen',",
      "        severity: 'error',",
      "        contextData: {'error': e.toString()},",
      "      );",
      "      if (mounted) {",
      "        ScaffoldMessenger.of(context).showSnackBar(",
      "          SnackBar(content: Text(loc.errorGeneric)),",
      "        );",
      "      }",
      "    }",
      "  }",
      "",
      "  Future<void> _persistReorder() async {",
      "    final provider = context.read<IngredientTypeProvider>();",
      "    try {",
      "      await provider.reorderIngredientTypes(franchiseId!, _pendingReorder);",
      "      await provider.loadTypes(franchiseId!);",
      "      setState(() {",
      "        _reorderChanged = false;",
      "      });",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to persist ingredient type reorder',",
      "        source: 'IngredientTypeManagementScreen',",
      "        screen: 'ingredient_type_management_screen',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "    }",
      "  }",
      "",
      "  void _cancelReorder() {",
      "    setState(() {",
      "      _reorderChanged = false;",
      "    });",
      "    final provider = context.read<IngredientTypeProvider>();",
      "    provider.loadTypes(franchiseId!);",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context)!;",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    final provider = context.watch<IngredientTypeProvider>();",
      "    final types = provider.types;",
      "",
      "    if (franchiseId == null || franchiseId!.isEmpty) {",
      "      return Scaffold(",
      "        appBar: AppBar(title: Text(loc.ingredientTypes)),",
      "        body: Center(child: Text(loc.selectAFranchiseFirst)),",
      "      );",
      "    }",
      "",
      "    return Scaffold(",
      "      appBar: AppBar(",
      "        title: Text(",
      "          loc.ingredientTypes,",
      "          style: Theme.of(context).textTheme.titleLarge?.copyWith(",
      "                fontWeight: FontWeight.bold,",
      "                color: Colors.black,",
      "              ),",
      "        ),",
      "        actions: [",
      "          IconButton(",
      "            icon: const Icon(Icons.data_object),",
      "            tooltip: loc.importExport,",
      "            onPressed: () {",
      "              final typeProvider =",
      "                  Provider.of<IngredientTypeProvider>(context, listen: false);",
      "              IngredientTypeJsonImportExportDialog.show(context, typeProvider);",
      "            },",
      "          ),",
      "          IconButton(",
      "            icon: const Icon(Icons.library_add),",
      "            tooltip: loc.loadDefaultTypes,",
      "            onPressed: () async {",
      "              final parentLoc = AppLocalizations.of(context);",
      "              final ingredientTypeProvider =",
      "                  context.read<IngredientTypeProvider>();",
      "",
      "              print(",
      "                  '[OnboardingIngredientTypeScreen] Opening template picker dialog...');",
      "              print(",
      "                  '[OnboardingIngredientTypeScreen] AppLocalizations.of(context): $parentLoc');",
      "",
      "              if (parentLoc == null) {",
      "                print(",
      "                    '[OnboardingIngredientTypeScreen] ERROR: Localization is null on this screen!');",
      "                return;",
      "              }",
      "",
      "              await showDialog(",
      "                context: context,",
      "                builder: (BuildContext dialogContext) {",
      "                  return Localizations.override(",
      "                    context: dialogContext,",
      "                    child: Builder(",
      "                      builder: (innerContext) {",
      "                        return ScaffoldMessenger(",
      "                          child: IngredientTypeTemplatePickerDialog(",
      "                              loc: parentLoc),",
      "                        );",
      "                      },",
      "                    ),",
      "                  );",
      "                },",
      "              );",
      "",
      "              final franchiseId = context.read<FranchiseProvider>().franchiseId;",
      "              await ingredientTypeProvider.loadTypes(franchiseId);",
      "",
      "              if (context.mounted) {",
      "                ScaffoldMessenger.of(context).showSnackBar(",
      "                  SnackBar(content: Text(parentLoc.templateLoadedSuccessfully)),",
      "                );",
      "              }",
      "            },",
      "          ),",
      "          IconButton(",
      "            icon: const Icon(Icons.check_circle_outline),",
      "            tooltip: loc.markAsComplete,",
      "            onPressed: _markComplete,",
      "          ),",
      "        ],",
      "        backgroundColor: Theme.of(context).scaffoldBackgroundColor,",
      "        elevation: 0,",
      "        iconTheme: const IconThemeData(color: Colors.black),",
      "      ),",
      "      backgroundColor: colorScheme.background,",
      "      floatingActionButton: FloatingActionButton.extended(",
      "        heroTag: 'onboarding_ingredient_type_fab',",
      "        onPressed: () => _showFormDialog(),",
      "        label: Text(loc.addIngredientType),",
      "        icon: const Icon(Icons.add),",
      "        backgroundColor: DesignTokens.primaryColor,",
      "      ),",
      "      body: Padding(",
      "        padding: const EdgeInsets.all(24),",
      "        child: types.isEmpty",
      "            ? Center(child: Text(loc.noIngredientTypesFound))",
      "            : Column(",
      "                children: [",
      "                  const InlineAddIngredientTypeRow(),",
      "                  if (_showSelectAllBanner)",
      "                    Card(",
      "                      color: Colors.amber[100],",
      "                      margin: const EdgeInsets.symmetric(vertical: 6),",
      "                      child: Padding(",
      "                        padding: const EdgeInsets.symmetric(",
      "                            horizontal: 20, vertical: 12),",
      "                        child: Row(",
      "                          children: [",
      "                            Expanded(",
      "                              child: Text(",
      "                                loc.selectAllPrompt, // Add this to your .arb",
      "                                style: TextStyle(fontWeight: FontWeight.w600),",
      "                              ),",
      "                            ),",
      "                            ElevatedButton.icon(",
      "                              icon: const Icon(Icons.select_all),",
      "                              label: Text(loc.selectAll),",
      "                              onPressed: () {",
      "                                final allIds =",
      "                                    provider.types.map((t) => t.id!).toList();",
      "                                for (final id in allIds) {",
      "                                  provider.stageTypeForDelete(id);",
      "                                }",
      "                                setState(() {",
      "                                  _showSelectAllBanner = false;",
      "                                });",
      "                              },",
      "                            ),",
      "                            const SizedBox(width: 8),",
      "                            TextButton(",
      "                              child: Text(loc.cancel),",
      "                              onPressed: () {",
      "                                setState(() {",
      "                                  _showSelectAllBanner = false;",
      "                                });",
      "                              },",
      "                            ),",
      "                          ],",
      "                        ),",
      "                      ),",
      "                    ),",
      "                  const SizedBox(height: 12),",
      "                  if (provider.hasStagedDeletes)",
      "                    Row(",
      "                      children: [",
      "                        ElevatedButton(",
      "                          onPressed: () async {",
      "                            await provider.commitStagedDeletes(franchiseId!);",
      "                            setState(() {});",
      "                          },",
      "                          child: Text(loc.saveChanges),",
      "                        ),",
      "                        const SizedBox(width: 12),",
      "                        OutlinedButton(",
      "                          onPressed: () {",
      "                            provider.clearStagedDeletes();",
      "                            setState(() {});",
      "                          },",
      "                          child: Text(loc.revertChanges),",
      "                        ),",
      "                        const SizedBox(width: 24),",
      "                        Text(",
      "                          '${provider.stagedForDelete.length} ${loc.toDelete}',",
      "                          style: TextStyle(color: Colors.red),",
      "                        ),",
      "                      ],",
      "                    ),",
      "                  if (_reorderChanged)",
      "                    Row(",
      "                      children: [",
      "                        ElevatedButton(",
      "                          onPressed: _persistReorder,",
      "                          child: Text(loc.saveChanges),",
      "                        ),",
      "                        const SizedBox(width: 12),",
      "                        OutlinedButton(",
      "                          onPressed: _cancelReorder,",
      "                          child: Text(loc.revertChanges),",
      "                        ),",
      "                      ],",
      "                    ),",
      "                  const SizedBox(height: 12),",
      "                  Expanded(",
      "                    child: ReorderableListView.builder(",
      "                      buildDefaultDragHandles: false,",
      "                      onReorder: (oldIndex, newIndex) async {",
      "                        if (provider.types.isEmpty || oldIndex == newIndex)",
      "                          return;",
      "",
      "                        final updatedList =",
      "                            List<IngredientType>.from(provider.types);",
      "",
      "                        if (newIndex > oldIndex) newIndex -= 1;",
      "",
      "                        final movedItem = updatedList.removeAt(oldIndex);",
      "                        updatedList.insert(newIndex, movedItem);",
      "",
      "                        for (int i = 0; i < updatedList.length; i++) {",
      "                          updatedList[i] =",
      "                              updatedList[i].copyWith(sortOrder: i);",
      "                        }",
      "",
      "                        await provider.reorderIngredientTypes(",
      "                            franchiseId!, updatedList);",
      "",
      "                        setState(() {",
      "                          _reorderChanged = true;",
      "                          _pendingReorder = updatedList;",
      "                        });",
      "                      },",
      "                      itemCount: types.length,",
      "                      itemBuilder: (_, index) {",
      "                        final type = types[index];",
      "                        if (provider.stagedForDelete.contains(type.id)) {",
      "                          return Container(",
      "                            key: ValueKey('deleted_${type.id}'),",
      "                            color: Colors.red.withOpacity(0.07),",
      "                            padding: EdgeInsets.symmetric(",
      "                                horizontal: 12, vertical: 8),",
      "                            child: Row(",
      "                              children: [",
      "                                Icon(Icons.delete, color: Colors.red),",
      "                                const SizedBox(width: 10),",
      "                                Text(",
      "                                  type.name,",
      "                                  style: TextStyle(",
      "                                    color: Colors.red,",
      "                                    decoration: TextDecoration.lineThrough,",
      "                                  ),",
      "                                ),",
      "                                const Spacer(),",
      "                                IconButton(",
      "                                  icon: Icon(Icons.undo),",
      "                                  tooltip: loc.undo,",
      "                                  onPressed: () => setState(() {",
      "                                    provider.unstageTypeForDelete(type.id!);",
      "                                  }),",
      "                                ),",
      "                              ],",
      "                            ),",
      "                          );",
      "                        }",
      "                        return ReorderableDragStartListener(",
      "                          key: ValueKey(type.id!),",
      "                          index: index,",
      "                          enabled: !_isEditingAny,",
      "                          child: EditableIngredientTypeRow(",
      "                            type: type,",
      "                            isEditing: _editingMap[type.id!] == true,",
      "                            onEditTapped: () {",
      "                              setState(() {",
      "                                _editingMap[type.id!] = true;",
      "                              });",
      "                            },",
      "                            onDeleteTapped: () async {",
      "                              final inUse =",
      "                                  await provider.isIngredientTypeInUse(",
      "                                franchiseId: franchiseId!,",
      "                                typeId: type.id!,",
      "                              );",
      "",
      "                              if (inUse) {",
      "                                if (!context.mounted) return;",
      "                                await showDialog(",
      "                                  context: context,",
      "                                  builder: (_) => AlertDialog(",
      "                                    title: Text(loc.deletionBlocked),",
      "                                    content: Text(loc.ingredientTypeInUseError),",
      "                                    actions: [",
      "                                      TextButton(",
      "                                        onPressed: () => Navigator.pop(context),",
      "                                        child: Text(loc.ok),",
      "                                      ),",
      "                                    ],",
      "                                  ),",
      "                                );",
      "                                return;",
      "                              }",
      "",
      "                              provider.stageTypeForDelete(type.id!);",
      "                              setState(() {});",
      "                            },",
      "                            onSaveTapped: () async {",
      "                              await provider.loadTypes(franchiseId!);",
      "                              setState(() {",
      "                                _editingMap[type.id!] = false;",
      "                              });",
      "                            },",
      "                            trailing: Checkbox(",
      "                              value: provider.stagedForDelete.contains(type.id),",
      "                              onChanged: (selected) {",
      "                                if (selected == true) {",
      "                                  provider.stageTypeForDelete(type.id!);",
      "                                  // If this was the first selection, prompt for select all",
      "                                  if (provider.stagedForDelete.length == 1) {",
      "                                    setState(() {",
      "                                      _showSelectAllBanner = true;",
      "                                    });",
      "                                  }",
      "                                } else {",
      "                                  provider.unstageTypeForDelete(type.id!);",
      "                                }",
      "                                setState(() {});",
      "                              },",
      "                            ),",
      "                          ),",
      "                        );",
      "                      },",
      "                    ),",
      "                  ),",
      "                ],",
      "              ),",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "class IngredientTypeFormDialog extends StatefulWidget {",
      "  final IngredientType? initial;",
      "  final String franchiseId;",
      "  final AppLocalizations loc;",
      "",
      "  const IngredientTypeFormDialog({",
      "    Key? key,",
      "    this.initial,",
      "    required this.franchiseId,",
      "    required this.loc,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  State<IngredientTypeFormDialog> createState() =>",
      "      _IngredientTypeFormDialogState();",
      "}",
      "",
      "class _IngredientTypeFormDialogState extends State<IngredientTypeFormDialog> {",
      "  final _formKey = GlobalKey<FormState>();",
      "  late String name;",
      "  String? description;",
      "  String? systemTag;",
      "  int sortOrder = 1;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    final initial = widget.initial;",
      "    name = initial?.name ?? '';",
      "    description = initial?.description;",
      "    systemTag = initial?.systemTag;",
      "    sortOrder = initial?.sortOrder ?? 1;",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = widget.loc;",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    final provider = context.read<IngredientTypeProvider>();",
      "",
      "    return AlertDialog(",
      "      title: Text(widget.initial == null",
      "          ? widget.loc.addIngredientType",
      "          : widget.loc.editIngredientType),",
      "      content: Form(",
      "        key: _formKey,",
      "        child: SizedBox(",
      "          width: 400,",
      "          child: Column(",
      "            mainAxisSize: MainAxisSize.min,",
      "            children: [",
      "              TextFormField(",
      "                initialValue: name,",
      "                decoration: InputDecoration(labelText: widget.loc.name),",
      "                validator: (val) => (val == null || val.trim().isEmpty)",
      "                    ? widget.loc.required",
      "                    : null,",
      "                onChanged: (val) => name = val,",
      "              ),",
      "              TextFormField(",
      "                initialValue: description,",
      "                decoration: InputDecoration(labelText: widget.loc.description),",
      "                onChanged: (val) => description = val,",
      "              ),",
      "              TextFormField(",
      "                initialValue: systemTag,",
      "                decoration: InputDecoration(labelText: widget.loc.systemTag),",
      "                onChanged: (val) => systemTag = val,",
      "              ),",
      "              TextFormField(",
      "                initialValue: sortOrder.toString(),",
      "                decoration: InputDecoration(labelText: widget.loc.sortOrder),",
      "                keyboardType: TextInputType.number,",
      "                onChanged: (val) => sortOrder = int.tryParse(val) ?? sortOrder,",
      "              ),",
      "              // 💡 Future Feature Placeholder: Add visibility toggle, tag color, etc.",
      "            ],",
      "          ),",
      "        ),",
      "      ),",
      "      actions: [",
      "        TextButton(",
      "          onPressed: () => Navigator.of(context).pop(),",
      "          child: Text(widget.loc.cancel),",
      "        ),",
      "        ElevatedButton(",
      "          onPressed: () async {",
      "            if (_formKey.currentState?.validate() != true) return;",
      "",
      "            final newType = IngredientType(",
      "              id: widget.initial?.id,",
      "              name: name.trim(),",
      "              description: description?.trim(),",
      "              systemTag: systemTag?.trim(),",
      "              sortOrder: sortOrder,",
      "            );",
      "",
      "            try {",
      "              if (newType.id == null) {",
      "                await provider.addType(widget.franchiseId, newType);",
      "              } else {",
      "                await provider.updateType(widget.franchiseId, newType);",
      "              }",
      "              if (mounted) Navigator.of(context).pop();",
      "            } catch (e, stack) {",
      "              await ErrorLogger.log(",
      "                message: 'Failed to save ingredient type',",
      "                source: 'IngredientTypeFormDialog',",
      "                screen: 'ingredient_type_management_screen',",
      "                severity: 'error',",
      "                stack: stack.toString(),",
      "                contextData: {",
      "                  'franchiseId': widget.franchiseId,",
      "                  'ingredientType': newType.toMap(),",
      "                },",
      "              );",
      "            }",
      "          },",
      "          child: Text(loc.save),",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 612,
      "file_size": 23980,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\screens\\onboarding_menu_items_screen.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/menu_item_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/onboarding_progress_provider.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/widgets/empty_state_widget.dart';",
      "import 'package:franchise_admin_portal/core/utils/features/feature_guard.dart';",
      "import 'package:franchise_admin_portal/core/utils/features/feature_gate_banner.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/widgets/menu_items/menu_item_editor_sheet.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/widgets/menu_items/menu_items_list_tile.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/widgets/menu_items/menu_item_json_import_export_dialog.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/widgets/menu_items/menu_item_template_picker_dialog.dart';",
      "import 'package:franchise_admin_portal/core/models/menu_item.dart';",
      "import 'package:franchise_admin_portal/core/providers/ingredient_type_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/category_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/ingredient_metadata_provider.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/widgets/menu_items/schema_issue_sidebar.dart';",
      "import 'package:franchise_admin_portal/core/models/menu_item_schema_issue.dart';",
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "",
      "class OnboardingMenuItemsScreen extends StatefulWidget {",
      "  const OnboardingMenuItemsScreen({super.key});",
      "",
      "  @override",
      "  State<OnboardingMenuItemsScreen> createState() =>",
      "      _OnboardingMenuItemsScreenState();",
      "}",
      "",
      "class _OnboardingMenuItemsScreenState extends State<OnboardingMenuItemsScreen> {",
      "  bool _hasInitialized = false;",
      "  final Set<String> _selectedIds = {};",
      "  bool showSchemaSidebar = false;",
      "  List<MenuItemSchemaIssue> schemaIssues = [];",
      "  MenuItem? itemPendingRepair;",
      "",
      "  @override",
      "  void didChangeDependencies() {",
      "    super.didChangeDependencies();",
      "    if (_hasInitialized) return;",
      "",
      "    final franchiseId = context.read<FranchiseProvider>().franchiseId;",
      "    if (franchiseId.isNotEmpty && franchiseId != 'unknown') {",
      "      // Force reload all prerequisites so screen is always in sync",
      "      context",
      "          .read<IngredientTypeProvider>()",
      "          .loadIngredientTypes(franchiseId, forceReloadFromFirestore: true);",
      "      context",
      "          .read<IngredientMetadataProvider>()",
      "          .load(forceReloadFromFirestore: true);",
      "      context",
      "          .read<CategoryProvider>()",
      "          .loadCategories(franchiseId, forceReloadFromFirestore: true);",
      "      context",
      "          .read<MenuItemProvider>()",
      "          .loadMenuItems(franchiseId, forceReloadFromFirestore: true);",
      "    }",
      "",
      "    _hasInitialized = true;",
      "  }",
      "",
      "  Future<void> _markComplete() async {",
      "    final onboarding = context.read<OnboardingProgressProvider>();",
      "    final loc = AppLocalizations.of(context)!;",
      "",
      "    try {",
      "      await onboarding.markStepComplete('menu_items');",
      "      if (mounted) {",
      "        ScaffoldMessenger.of(context).showSnackBar(",
      "          SnackBar(content: Text(loc.menuItemMarkedAsComplete)),",
      "        );",
      "      }",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'onboarding_mark_menu_item_complete_failed',",
      "        source: 'onboarding_menu_items_screen.dart',",
      "        screen: 'onboarding_menu_items_screen',",
      "        severity: 'warning',",
      "        stack: stack.toString(),",
      "      );",
      "      if (mounted) {",
      "        ScaffoldMessenger.of(context).showSnackBar(",
      "          SnackBar(content: Text(loc.errorGeneric)),",
      "        );",
      "      }",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    print('[DEBUG][OnboardingMenuScreen] build called');",
      "    final loc = AppLocalizations.of(context)!;",
      "    final provider = context.watch<MenuItemProvider>();",
      "    provider.injectDependencies(",
      "      ingredientProvider: context.read<IngredientMetadataProvider>(),",
      "      categoryProvider: context.read<CategoryProvider>(),",
      "      typeProvider: context.read<IngredientTypeProvider>(),",
      "    );",
      "    // print(",
      "    //     '[DEBUG] MenuItems in screen: ${provider.menuItems.map((m) => m.toJson())}');",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "",
      "    // === Robust dependency checks for required onboarding steps ===",
      "    final ingredientTypes =",
      "        context.watch<IngredientTypeProvider>().ingredientTypes;",
      "    final ingredients = context.watch<IngredientMetadataProvider>().ingredients;",
      "    final categories = context.watch<CategoryProvider>().categories;",
      "",
      "    final missingSteps = <String>[];",
      "    if (ingredientTypes.isEmpty) missingSteps.add(loc.stepIngredientTypes);",
      "    if (ingredients.isEmpty) missingSteps.add(loc.stepIngredients);",
      "    if (categories.isEmpty) missingSteps.add(loc.stepCategories);",
      "",
      "// If any dependencies are missing, return a clear EmptyState UI with actionable buttons",
      "    if (missingSteps.isNotEmpty) {",
      "      print(",
      "          '[OnboardingMenuItemsScreen] Blocked: Missing dependencies: $missingSteps');",
      "      // Show a SnackBar on first build, not every frame",
      "      WidgetsBinding.instance.addPostFrameCallback((_) {",
      "        if (mounted) {",
      "          ScaffoldMessenger.of(context).removeCurrentSnackBar();",
      "          ScaffoldMessenger.of(context).showSnackBar(",
      "            SnackBar(",
      "              content: Text(",
      "                  loc.menuItemsMissingPrerequisites(missingSteps.join(', '))),",
      "              backgroundColor: colorScheme.error,",
      "            ),",
      "          );",
      "        }",
      "      });",
      "      // Return an EmptyStateWidget that lists what to do next",
      "      return Scaffold(",
      "        appBar: AppBar(",
      "          title: Text(loc.onboardingMenuItems),",
      "          backgroundColor: theme.scaffoldBackgroundColor,",
      "          elevation: 0,",
      "          iconTheme: const IconThemeData(color: Colors.black),",
      "        ),",
      "        body: Center(",
      "          child: Column(",
      "            mainAxisAlignment: MainAxisAlignment.center,",
      "            children: [",
      "              EmptyStateWidget(",
      "                iconData: Icons.warning_amber_rounded,",
      "                title: loc.missingMenuItemPrereqs,",
      "                message:",
      "                    loc.menuItemsMissingPrerequisites(missingSteps.join(', ')),",
      "              ),",
      "              const SizedBox(height: 24),",
      "              if (ingredientTypes.isEmpty)",
      "                ElevatedButton.icon(",
      "                  icon: const Icon(Icons.list_alt),",
      "                  onPressed: () => Navigator.pushNamed(",
      "                    context,",
      "                    '/dashboard?section=onboardingIngredientTypes',",
      "                  ),",
      "                  label: Text(loc.goToStep(loc.stepIngredientTypes)),",
      "                ),",
      "              if (ingredients.isEmpty)",
      "                ElevatedButton.icon(",
      "                  icon: const Icon(Icons.egg),",
      "                  onPressed: () => Navigator.pushNamed(",
      "                    context,",
      "                    '/dashboard?section=onboardingIngredients',",
      "                  ),",
      "                  label: Text(loc.goToStep(loc.stepIngredients)),",
      "                ),",
      "              if (categories.isEmpty)",
      "                ElevatedButton.icon(",
      "                  icon: const Icon(Icons.category),",
      "                  onPressed: () => Navigator.pushNamed(",
      "                    context,",
      "                    '/dashboard?section=onboardingCategories',",
      "                  ),",
      "                  label: Text(loc.goToStep(loc.stepCategories)),",
      "                ),",
      "            ],",
      "          ),",
      "        ),",
      "      );",
      "    }",
      "",
      "    // Helper to check and maybe show schema sidebar",
      "    void checkForSchemaIssues(MenuItem menuItem) {",
      "      final categories = context.read<CategoryProvider>().categories;",
      "      final ingredients =",
      "          context.read<IngredientMetadataProvider>().ingredients;",
      "      final ingredientTypes =",
      "          context.read<IngredientTypeProvider>().ingredientTypes;",
      "",
      "      // Call your schema issue detection util",
      "      schemaIssues = MenuItemSchemaIssue.detectAllIssues(",
      "        menuItem: menuItem,",
      "        categories: categories,",
      "        ingredients: ingredients,",
      "        ingredientTypes: ingredientTypes,",
      "      );",
      "      showSchemaSidebar = schemaIssues.isNotEmpty;",
      "      itemPendingRepair = showSchemaSidebar ? menuItem : null;",
      "      if (showSchemaSidebar) setState(() {}); // Redraw for the sidebar",
      "    }",
      "",
      "    // Callback for repair sidebar",
      "    void handleSidebarRepair(MenuItemSchemaIssue issue, String newValue) {",
      "      if (itemPendingRepair == null) return;",
      "",
      "      MenuItem repaired = itemPendingRepair!;",
      "",
      "      // Repair logic for each issue type",
      "      switch (issue.type) {",
      "        case MenuItemSchemaIssueType.category:",
      "          repaired = repaired.copyWith(categoryId: newValue);",
      "          break;",
      "        case MenuItemSchemaIssueType.ingredient:",
      "          final updatedIncluded =",
      "              (repaired.includedIngredients ?? []).map((ing) {",
      "            if ((ing['ingredientId'] ?? ing['id']) == issue.missingReference) {",
      "              return {...ing, 'ingredientId': newValue};",
      "            }",
      "            return ing;",
      "          }).toList();",
      "          repaired = repaired.copyWith(includedIngredients: updatedIncluded);",
      "          break;",
      "        case MenuItemSchemaIssueType.ingredientType:",
      "          // (add your logic here as needed)",
      "          break;",
      "        case MenuItemSchemaIssueType.missingField:",
      "          // Repair missing fields by field name",
      "          switch (issue.field) {",
      "            case 'name':",
      "              repaired = repaired.copyWith(name: newValue);",
      "              break;",
      "            case 'description':",
      "              repaired = repaired.copyWith(description: newValue);",
      "              break;",
      "            case 'price':",
      "              repaired =",
      "                  repaired.copyWith(price: double.tryParse(newValue) ?? 0.0);",
      "              break;",
      "            case 'categoryId':",
      "              repaired = repaired.copyWith(categoryId: newValue);",
      "              break;",
      "            // Add additional fields as needed",
      "          }",
      "          break;",
      "      }",
      "",
      "      // Re-run issue detection after repairing this field",
      "      final List<MenuItemSchemaIssue> remainingIssues =",
      "          MenuItemSchemaIssue.detectAllIssues(",
      "        menuItem: repaired,",
      "        categories: context.read<CategoryProvider>().categories,",
      "        ingredients: context.read<IngredientMetadataProvider>().allIngredients,",
      "        ingredientTypes: context.read<IngredientTypeProvider>().ingredientTypes,",
      "      );",
      "",
      "      if (remainingIssues.isEmpty) {",
      "        provider.addOrUpdateMenuItem(repaired);",
      "        setState(() {",
      "          showSchemaSidebar = false;",
      "          schemaIssues = [];",
      "          itemPendingRepair = null;",
      "        });",
      "        Navigator.of(context).pop(); // Close sidebar/modal if desired",
      "      } else {",
      "        setState(() {",
      "          schemaIssues = remainingIssues;",
      "          itemPendingRepair = repaired;",
      "        });",
      "      }",
      "    }",
      "",
      "    // Reusable openEditor with schema checking logic",
      "    void openEditor({MenuItem? item}) {",
      "      final provider = context.read<MenuItemProvider>();",
      "",
      "      showModalBottomSheet(",
      "        isScrollControlled: true,",
      "        context: context,",
      "        backgroundColor: Colors.transparent,",
      "        builder: (context) {",
      "          // locally track your issues in the sheet",
      "          List<MenuItemSchemaIssue> issues = [];",
      "",
      "          return StatefulBuilder(",
      "            builder: (context, setModalState) {",
      "              final screenWidth = MediaQuery.of(context).size.width;",
      "              final modalWidth =",
      "                  screenWidth > 1280 ? 1080.0 : screenWidth * 0.92;",
      "",
      "              return Center(",
      "                child: ConstrainedBox(",
      "                  constraints: BoxConstraints(",
      "                    maxWidth: modalWidth,",
      "                    maxHeight: MediaQuery.of(context).size.height * 0.98,",
      "                  ),",
      "                  child: Material(",
      "                    color: Colors.white,",
      "                    shape: RoundedRectangleBorder(",
      "                        borderRadius: BorderRadius.circular(8)),",
      "                    child: Row(",
      "                      children: [",
      "                        Expanded(",
      "                          flex: 3,",
      "                          child: MenuItemEditorSheet(",
      "                            existing: item,",
      "                            firestore: FirebaseFirestore.instance,",
      "                            franchiseId:",
      "                                context.read<FranchiseProvider>().franchiseId,",
      "                            onSave: (updatedItem) async {",
      "                              final provider = context.read<MenuItemProvider>();",
      "                              provider.addOrUpdateMenuItem(",
      "                                  updatedItem); // modifies local cache",
      "",
      "                              if (mounted) {",
      "                                Navigator.of(context).pop(); // dismiss sheet",
      "                                ScaffoldMessenger.of(context).showSnackBar(",
      "                                  SnackBar(content: Text('Item saved.')),",
      "                                );",
      "                              }",
      "                            },",
      "                            onCancel: () => Navigator.of(context).pop(),",
      "                            onSchemaIssuesChanged: (newIssues) {",
      "                              setModalState(() => issues = newIssues);",
      "                            },",
      "                          ),",
      "                        ),",
      "                        VerticalDivider(",
      "                          width: 1,",
      "                          thickness: 1,",
      "                          color: Colors.grey.shade300,",
      "                        ),",
      "                        AnimatedContainer(",
      "                          duration: const Duration(milliseconds: 200),",
      "                          width: issues.isEmpty ? 64 : 440,",
      "                          child: SchemaIssueSidebar(",
      "                            issues: issues,",
      "                            onRepair: handleSidebarRepair,",
      "                            onClose: () => setModalState(() => issues = []),",
      "                          ),",
      "                        ),",
      "                      ],",
      "                    ),",
      "                  ),",
      "                ),",
      "              );",
      "            },",
      "          );",
      "        },",
      "      );",
      "    }",
      "",
      "    return Stack(",
      "      children: [",
      "        Scaffold(",
      "          appBar: AppBar(",
      "            backgroundColor: theme.scaffoldBackgroundColor,",
      "            elevation: 0,",
      "            iconTheme: const IconThemeData(color: Colors.black),",
      "            title: Text(",
      "              loc.onboardingMenuItems,",
      "              style: theme.textTheme.titleLarge?.copyWith(",
      "                fontWeight: FontWeight.bold,",
      "                color: colorScheme.onSurface,",
      "              ),",
      "            ),",
      "            actions: [",
      "              IconButton(",
      "                icon: const Icon(Icons.data_object),",
      "                tooltip: loc.importExport,",
      "                onPressed: () => MenuItemJsonImportExportDialog.show(context),",
      "              ),",
      "              // IconButton(",
      "              //   icon: const Icon(Icons.library_add),",
      "              //   tooltip: loc.loadDefaultTemplates,",
      "              //   onPressed: () => MenuItemTemplatePickerDialog.show(context),",
      "              // ),",
      "              IconButton(",
      "                icon: const Icon(Icons.check_circle_outline),",
      "                tooltip: loc.markAsComplete,",
      "                onPressed: _markComplete,",
      "              ),",
      "            ],",
      "          ),",
      "          floatingActionButton: FloatingActionButton.extended(",
      "            heroTag: 'fab-onboarding-menu-items',",
      "            onPressed: () async {",
      "              print('[DEBUG][FAB] FloatingActionButton pressed.');",
      "              try {",
      "                print(",
      "                    '[DEBUG][FAB] About to navigate to /dashboard?section=menuItemEditor');",
      "",
      "                Navigator.pushNamed(",
      "                  context,",
      "                  '/dashboard?section=menuItemEditor',",
      "                ).then((result) {",
      "                  print('[DEBUG][FAB] Navigation pushNamed returned: $result');",
      "                  if (result is MenuItem) {",
      "                    context",
      "                        .read<MenuItemProvider>()",
      "                        .addOrUpdateMenuItem(result);",
      "                  }",
      "                }).catchError((err, st) async {",
      "                  print('[DEBUG][FAB] pushNamed threw error (async): $err');",
      "                  await ErrorLogger.log(",
      "                    message: 'Async error in pushNamed',",
      "                    stack: st.toString(),",
      "                    source: 'onboarding_menu_items_screen.dart',",
      "                    severity: 'error',",
      "                    screen: 'OnboardingMenuItemsScreen',",
      "                    contextData: {'exception': err.toString()},",
      "                  );",
      "                });",
      "              } catch (e, st) {",
      "                print('[DEBUG][FAB] Exception thrown in navigation: $e\\n$st');",
      "                await ErrorLogger.log(",
      "                  message: 'Failed to navigate to MenuItemEditorScreen (sync)',",
      "                  stack: st.toString(),",
      "                  source: 'onboarding_menu_items_screen.dart',",
      "                  severity: 'error',",
      "                  screen: 'OnboardingMenuItemsScreen',",
      "                  contextData: {",
      "                    'exception': e.toString(),",
      "                  },",
      "                );",
      "                ScaffoldMessenger.of(context).showSnackBar(",
      "                  const SnackBar(",
      "                    content: Text(",
      "                        'An error occurred while opening the menu item editor.'),",
      "                    backgroundColor: Colors.red,",
      "                  ),",
      "                );",
      "              }",
      "            },",
      "            icon: const Icon(Icons.add),",
      "            label: Text(loc.addMenuItem),",
      "            backgroundColor: DesignTokens.primaryColor,",
      "          ),",
      "          body: Padding(",
      "            padding: DesignTokens.gridPadding,",
      "            child: Column(",
      "              crossAxisAlignment: CrossAxisAlignment.start,",
      "              children: [",
      "                FeatureGateBanner(",
      "                  module: 'menu_item_customization',",
      "                  child: Container(",
      "                    width: double.infinity,",
      "                    height: 60,",
      "                    color: Colors.yellow.shade50,",
      "                    alignment: Alignment.center,",
      "                    child:",
      "                        Text('Menu Item Customization is a premium feature.'),",
      "                  ),",
      "                ),",
      "                if (provider.isDirty)",
      "                  Padding(",
      "                    padding: const EdgeInsets.only(bottom: 12),",
      "                    child: Row(",
      "                      children: [",
      "                        ElevatedButton(",
      "                          onPressed: () async {",
      "                            final ingredientProvider =",
      "                                context.read<IngredientMetadataProvider>();",
      "                            final categoryProvider =",
      "                                context.read<CategoryProvider>();",
      "                            final typeProvider =",
      "                                context.read<IngredientTypeProvider>();",
      "                            final menuItemProvider =",
      "                                context.read<MenuItemProvider>();",
      "",
      "                            // Inject dependencies",
      "                            menuItemProvider.injectDependencies(",
      "                              ingredientProvider: ingredientProvider,",
      "                              categoryProvider: categoryProvider,",
      "                              typeProvider: typeProvider,",
      "                            );",
      "                            print('[DEBUG] --- Staged Data Snapshot ---');",
      "                            print(",
      "                                '[DEBUG] Staged Ingredients: ${ingredientProvider.stagedIngredientCount}');",
      "                            print(",
      "                                '[DEBUG] Staged Categories: ${categoryProvider.stagedCategoryCount}');",
      "                            print(",
      "                                '[DEBUG] Staged Ingredient Types: ${typeProvider.stagedTypes.length}');",
      "",
      "                            // Call persist once deps injected",
      "                            await menuItemProvider.persistChanges();",
      "                          },",
      "                          child: Text(loc.saveChanges),",
      "                        ),",
      "                        const SizedBox(width: 12),",
      "                        OutlinedButton(",
      "                          onPressed: provider.revertChanges,",
      "                          child: Text(loc.revertChanges),",
      "                        ),",
      "                      ],",
      "                    ),",
      "                  ),",
      "                Expanded(",
      "                  child: provider.menuItems.isEmpty",
      "                      ? EmptyStateWidget(",
      "                          title: loc.noMenuItemsFound,",
      "                          message: loc.noMenuItemsMessage,",
      "                        )",
      "                      : ReorderableListView(",
      "                          onReorder: (oldIndex, newIndex) {",
      "                            final items = List.of(provider.menuItems);",
      "                            if (newIndex > oldIndex) newIndex -= 1;",
      "                            final item = items.removeAt(oldIndex);",
      "                            items.insert(newIndex, item);",
      "                            provider.reorderMenuItems(items);",
      "                          },",
      "                          children: [",
      "                            for (final item in provider.menuItems)",
      "                              MenuItemListTile(",
      "                                key: ValueKey(item.id),",
      "                                item: item,",
      "                                isSelected: _selectedIds.contains(item.id),",
      "                                onSelect: (checked) {",
      "                                  setState(() {",
      "                                    if (checked == true) {",
      "                                      _selectedIds.add(item.id);",
      "                                    } else {",
      "                                      _selectedIds.remove(item.id);",
      "                                    }",
      "                                  });",
      "                                },",
      "                                onEdit: () => openEditor(item: item),",
      "                                onDelete: () async {",
      "                                  final confirm = await showDialog<bool>(",
      "                                    context: context,",
      "                                    builder: (ctx) => AlertDialog(",
      "                                      title: Text(loc.confirmDeletion),",
      "                                      content: Text(",
      "                                          loc.deleteMenuItemConfirm(item.name)),",
      "                                      actions: [",
      "                                        TextButton(",
      "                                          onPressed: () =>",
      "                                              Navigator.pop(ctx, false),",
      "                                          child: Text(loc.cancel),",
      "                                        ),",
      "                                        ElevatedButton(",
      "                                          style: ElevatedButton.styleFrom(",
      "                                            backgroundColor: Colors.red,",
      "                                          ),",
      "                                          onPressed: () =>",
      "                                              Navigator.pop(ctx, true),",
      "                                          child: Text(loc.delete),",
      "                                        ),",
      "                                      ],",
      "                                    ),",
      "                                  );",
      "                                  if (confirm == true) {",
      "                                    await provider.deleteFromFirestore(item.id);",
      "                                    if (context.mounted) {",
      "                                      ScaffoldMessenger.of(context)",
      "                                          .showSnackBar(",
      "                                        SnackBar(",
      "                                          content: Text(loc.menuItemDeleted),",
      "                                        ),",
      "                                      );",
      "                                    }",
      "                                  }",
      "                                },",
      "                              ),",
      "                          ],",
      "                        ),",
      "                ),",
      "              ],",
      "            ),",
      "          ),",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 578,
      "file_size": 25122,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\screens\\onboarding_menu_screen.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/models/franchise_info.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/core/providers/user_profile_notifier.dart';",
      "import 'package:franchise_admin_portal/core/providers/role_guard.dart';",
      "import 'package:franchise_admin_portal/config/branding_config.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_info_provider.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/widgets/onboarding_step_card.dart';",
      "import 'package:franchise_admin_portal/core/providers/onboarding_progress_provider.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/screens/onboarding_ingredient_type_screen.dart';",
      "",
      "class OnboardingMenuScreen extends StatefulWidget {",
      "  const OnboardingMenuScreen({Key? key}) : super(key: key);",
      "",
      "  @override",
      "  State<OnboardingMenuScreen> createState() => _OnboardingMenuScreenState();",
      "}",
      "",
      "class _OnboardingMenuScreenState extends State<OnboardingMenuScreen> {",
      "  String? franchiseId;",
      "  String? _franchiseName;",
      "  bool loading = true;",
      "",
      "  final Map<String, bool> _stepCompletion = {",
      "    'ingredients': false,",
      "    'categories': false,",
      "    'menuItems': false,",
      "    'review': false,",
      "  };",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    print('[OnboardingMenuScreen] initState');",
      "  }",
      "",
      "  @override",
      "  void didChangeDependencies() {",
      "    super.didChangeDependencies();",
      "    final newFranchiseId = context.watch<FranchiseProvider>().franchiseId;",
      "    if (newFranchiseId != franchiseId) {",
      "      setState(() {",
      "        franchiseId = newFranchiseId;",
      "      });",
      "      print('[OnboardingMenuScreen] Detected new franchiseId: $franchiseId');",
      "    }",
      "  }",
      "",
      "  void _markStepComplete(String key) {",
      "    setState(() {",
      "      _stepCompletion[key] = true;",
      "    });",
      "    print('[OnboardingMenuScreen] Step marked complete: $key');",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    print('[OnboardingMenuScreen] build() called');",
      "",
      "    final loc = AppLocalizations.of(context)!;",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    final user = context.watch<UserProfileNotifier>().user;",
      "    final franchiseInfoProvider = context.watch<FranchiseInfoProvider>();",
      "    final franchise = franchiseInfoProvider.franchise;",
      "    final isLoading = franchiseInfoProvider.loading;",
      "",
      "    final onboardingProgressProvider =",
      "        context.watch<OnboardingProgressProvider>();",
      "    final progress = onboardingProgressProvider.stepStatus;",
      "",
      "    print('[OnboardingMenuScreen] progress: $progress');",
      "",
      "    if (isLoading || onboardingProgressProvider.loading) {",
      "      return const Scaffold(",
      "        body: Center(child: CircularProgressIndicator()),",
      "      );",
      "    }",
      "",
      "    if (franchise == null) {",
      "      return const Scaffold(",
      "        body: Center(child: Text('Franchise not found.')),",
      "      );",
      "    }",
      "",
      "    return Scaffold(",
      "      appBar: AppBar(",
      "        title: Text(",
      "          loc.onboardingMenuTitle,",
      "          style: Theme.of(context).textTheme.titleLarge?.copyWith(",
      "                fontWeight: FontWeight.bold,",
      "                color: colorScheme.onSurface,",
      "              ),",
      "        ),",
      "        backgroundColor: Theme.of(context).scaffoldBackgroundColor,",
      "        elevation: 0,",
      "        iconTheme: const IconThemeData(color: Colors.black),",
      "      ),",
      "      backgroundColor: colorScheme.background,",
      "      body: Padding(",
      "        padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 24),",
      "        child: Column(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            Text(",
      "              '${loc.onboardingFor}: ${franchise.name} (#${franchise.id})',",
      "              style: Theme.of(context).textTheme.titleMedium?.copyWith(",
      "                    fontWeight: FontWeight.w600,",
      "                    color: colorScheme.onSurfaceVariant,",
      "                  ),",
      "            ),",
      "            const SizedBox(height: 24),",
      "            Expanded(",
      "              child: ListView(",
      "                padding: EdgeInsets.zero,",
      "                children: [",
      "                  OnboardingStepCard(",
      "                    stepNumber: 1,",
      "                    title: loc.stepFeatureSetup,",
      "                    subtitle: loc.stepFeatureSetupDesc,",
      "                    completed: progress['feature_setup'] == true,",
      "                    onTap: () {",
      "                      print(",
      "                          '[OnboardingMenuScreen] 🛠 Navigating to onboarding_feature_setup');",
      "                      WidgetsBinding.instance.addPostFrameCallback((_) {",
      "                        Navigator.pushNamed(",
      "                          context,",
      "                          '/dashboard?section=onboarding_feature_setup',",
      "                        );",
      "                      });",
      "                    },",
      "                  ),",
      "                  OnboardingStepCard(",
      "                    stepNumber: 2,",
      "                    title: loc.stepIngredientTypes,",
      "                    subtitle: loc.stepIngredientTypesDesc,",
      "                    completed: progress['ingredientTypes'] == true,",
      "                    onTap: () {",
      "                      print(",
      "                          '[OnboardingMenuScreen] 🛠 Navigating to onboardingIngredientTypes');",
      "                      WidgetsBinding.instance.addPostFrameCallback((_) {",
      "                        Navigator.pushNamed(",
      "                          context,",
      "                          '/dashboard?section=onboardingIngredientTypes',",
      "                        );",
      "                      });",
      "                    },",
      "                  ),",
      "                  OnboardingStepCard(",
      "                    stepNumber: 3,",
      "                    title: loc.stepIngredients,",
      "                    subtitle: loc.stepIngredientsDesc,",
      "                    completed: progress['ingredients'] == true,",
      "                    onTap: () {",
      "                      print(",
      "                          '[OnboardingMenuScreen] 🛠 Navigating to onboardingIngredients');",
      "                      WidgetsBinding.instance.addPostFrameCallback((_) {",
      "                        Navigator.pushNamed(",
      "                          context,",
      "                          '/dashboard?section=onboardingIngredients',",
      "                        );",
      "                      });",
      "                    },",
      "                  ),",
      "                  OnboardingStepCard(",
      "                    stepNumber: 4,",
      "                    title: loc.stepCategories,",
      "                    subtitle: loc.stepCategoriesDesc,",
      "                    completed: progress['categories'] == true,",
      "                    onTap: () {",
      "                      print(",
      "                          '[OnboardingMenuScreen] 🛠 Navigating to onboardingCategories');",
      "                      WidgetsBinding.instance.addPostFrameCallback((_) {",
      "                        Navigator.pushNamed(",
      "                          context,",
      "                          '/dashboard?section=onboardingCategories',",
      "                        );",
      "                      });",
      "                    },",
      "                  ),",
      "                  OnboardingStepCard(",
      "                    stepNumber: 5,",
      "                    title: loc.stepMenuItems,",
      "                    subtitle: loc.stepMenuItemsDesc,",
      "                    completed: progress['menuItems'] == true,",
      "                    onTap: () {",
      "                      print(",
      "                          '[OnboardingMenuScreen] 🛠 Navigating to onboardingMenuItems');",
      "                      WidgetsBinding.instance.addPostFrameCallback((_) {",
      "                        Navigator.pushNamed(",
      "                          context,",
      "                          '/dashboard?section=onboardingMenuItems',",
      "                        );",
      "                      });",
      "                    },",
      "                  ),",
      "                  OnboardingStepCard(",
      "                    stepNumber: 6,",
      "                    title: loc.stepReview,",
      "                    subtitle: loc.stepReviewDesc,",
      "                    completed: progress['review'] == true,",
      "                    onTap: () {",
      "                      print(",
      "                          '[OnboardingMenuScreen] 🛠 Navigating to onboardingReview');",
      "                      WidgetsBinding.instance.addPostFrameCallback((_) {",
      "                        Navigator.pushNamed(",
      "                          context,",
      "                          '/dashboard?section=onboardingReview',",
      "                        );",
      "                      });",
      "                    },",
      "                  ),",
      "                  const SizedBox(height: 16),",
      "                  Text(",
      "                    loc.progressComingSoon,",
      "                    style: Theme.of(context).textTheme.bodySmall?.copyWith(",
      "                          color: colorScheme.onSurfaceVariant,",
      "                        ),",
      "                  ),",
      "                ],",
      "              ),",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 232,
      "file_size": 9280,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\screens\\onboarding_review_screen.dart",
    "content": [
      "// File: lib/admin/dashboard/onboarding/screens/onboarding_review_screen.dart",
      "",
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/providers/onboarding_review_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/ingredient_type_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/ingredient_metadata_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/category_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/menu_item_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_feature_provider.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/widgets/empty_state_widget.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/widgets/onboarding_progress_indicator.dart';",
      "import 'package:franchise_admin_portal/core/services/audit_log_service.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/user_profile_notifier.dart';",
      "// Import future widgets here as they are implemented",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/widgets/review/review_summary_table.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/widgets/review/issue_details_expansion.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/widgets/review/onboarding_data_export_button.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/widgets/review/publish_onboarding_button.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/widgets/review/onboarding_audit_trail.dart';",
      "",
      "class OnboardingReviewScreen extends StatefulWidget {",
      "  const OnboardingReviewScreen({Key? key}) : super(key: key);",
      "",
      "  @override",
      "  State<OnboardingReviewScreen> createState() => _OnboardingReviewScreenState();",
      "}",
      "",
      "class _OnboardingReviewScreenState extends State<OnboardingReviewScreen> {",
      "  OnboardingReviewProvider? _reviewProvider;",
      "  bool _providerReady = false;",
      "  bool _loading = true;",
      "  String? _error;",
      "",
      "  // Guards",
      "  bool _didKickOffValidation = false;",
      "  bool _isValidating = false;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    // Initial validation will be scheduled after dependencies resolve.",
      "  }",
      "",
      "  @override",
      "  void didChangeDependencies() {",
      "    super.didChangeDependencies();",
      "",
      "    // Only set up provider & initial validation once.",
      "    if (!_providerReady) {",
      "      try {",
      "        final franchiseFeatureProvider =",
      "            Provider.of<FranchiseFeatureProvider>(context, listen: false);",
      "        final ingredientTypeProvider =",
      "            Provider.of<IngredientTypeProvider>(context, listen: false);",
      "        final ingredientMetadataProvider =",
      "            Provider.of<IngredientMetadataProvider>(context, listen: false);",
      "        final categoryProvider =",
      "            Provider.of<CategoryProvider>(context, listen: false);",
      "        final menuItemProvider =",
      "            Provider.of<MenuItemProvider>(context, listen: false);",
      "        final firestoreService =",
      "            Provider.of<FirestoreService>(context, listen: false);",
      "        final auditLogService =",
      "            Provider.of<AuditLogService>(context, listen: false);",
      "",
      "        _reviewProvider = OnboardingReviewProvider(",
      "          franchiseFeatureProvider: franchiseFeatureProvider,",
      "          ingredientTypeProvider: ingredientTypeProvider,",
      "          ingredientMetadataProvider: ingredientMetadataProvider,",
      "          categoryProvider: categoryProvider,",
      "          menuItemProvider: menuItemProvider,",
      "          firestoreService: firestoreService,",
      "          auditLogService: auditLogService,",
      "        );",
      "",
      "        _providerReady = true;",
      "        setState(() {});",
      "",
      "        // Schedule first validation after build completes.",
      "        WidgetsBinding.instance.addPostFrameCallback((_) {",
      "          _scheduleFirstValidation();",
      "        });",
      "      } catch (e) {",
      "        setState(() {",
      "          _loading = false;",
      "          _error = e.toString();",
      "        });",
      "      }",
      "    }",
      "  }",
      "",
      "  bool _providersReady() {",
      "    final types = context.read<IngredientTypeProvider>().ingredientTypes;",
      "    final ingredients = context.read<IngredientMetadataProvider>().ingredients;",
      "    final categories = context.read<CategoryProvider>().categories;",
      "    final menuItems = context.read<MenuItemProvider>().menuItems;",
      "",
      "    return types != null &&",
      "        ingredients != null &&",
      "        categories != null &&",
      "        menuItems != null;",
      "  }",
      "",
      "  void _scheduleFirstValidation() {",
      "    if (_didKickOffValidation) return;",
      "    if (!_providersReady()) return;",
      "    if (!mounted || _reviewProvider == null) return;",
      "",
      "    _didKickOffValidation = true;",
      "    debugPrint(",
      "        '[OnboardingReviewScreen] ⏩ Triggering initial _initValidation()...');",
      "    _initValidation();",
      "  }",
      "",
      "  Future<void> _initValidation() async {",
      "    if (_isValidating) {",
      "      debugPrint(",
      "          '[OnboardingReviewScreen._initValidation] 🚫 Validation already running, skipping.');",
      "      return;",
      "    }",
      "    _isValidating = true;",
      "",
      "    try {",
      "      setState(() => _loading = true);",
      "",
      "      final franchiseId =",
      "          Provider.of<FranchiseProvider>(context, listen: false).franchiseId;",
      "",
      "      debugPrint(",
      "          '\\n[OnboardingReviewScreen._initValidation] 🚀 Starting validation for franchise \"$franchiseId\"...');",
      "",
      "      // Reload only if needed; avoids unnecessary Firestore hits",
      "      await Provider.of<IngredientMetadataProvider>(context, listen: false)",
      "          .load(forceReloadFromFirestore: false);",
      "",
      "      await Provider.of<IngredientTypeProvider>(context, listen: false)",
      "          .loadIngredientTypes(franchiseId, forceReloadFromFirestore: false);",
      "",
      "      await Provider.of<CategoryProvider>(context, listen: false)",
      "          .loadCategories(franchiseId, forceReloadFromFirestore: false);",
      "",
      "      await Provider.of<MenuItemProvider>(context, listen: false)",
      "          .loadMenuItems(franchiseId, forceReloadFromFirestore: false);",
      "",
      "      debugPrint(",
      "          '[OnboardingReviewScreen._initValidation] ✅ Providers loaded, running validateAll()...');",
      "",
      "      await _reviewProvider?.validateAll();",
      "",
      "      setState(() {",
      "        _loading = false;",
      "        _error = null;",
      "      });",
      "",
      "      final issueCount = _reviewProvider?.validationResults.length ?? 0;",
      "      debugPrint(",
      "          '[OnboardingReviewScreen._initValidation] 🎯 Validation complete. Issues found: $issueCount');",
      "    } catch (e, st) {",
      "      debugPrint('[OnboardingReviewScreen._initValidation][ERROR] ❌ $e\\n$st');",
      "      setState(() {",
      "        _loading = false;",
      "        _error = e.toString();",
      "      });",
      "    } finally {",
      "      _isValidating = false;",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context)!;",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "",
      "    // Trigger rebuild when dependent providers change",
      "    final _ = (",
      "      context.watch<IngredientTypeProvider>().ingredientTypes,",
      "      context.watch<IngredientMetadataProvider>().ingredients,",
      "      context.watch<CategoryProvider>().categories,",
      "      context.watch<MenuItemProvider>().menuItems",
      "    );",
      "",
      "    if (!_providerReady || _reviewProvider == null) {",
      "      return Scaffold(",
      "        backgroundColor: DesignTokens.backgroundColor,",
      "        appBar: AppBar(",
      "          title: Text(loc.onboardingReviewPublishTitle ?? \"Review & Publish\"),",
      "          backgroundColor: colorScheme.surface,",
      "          elevation: DesignTokens.adminCardElevation,",
      "          iconTheme: IconThemeData(color: DesignTokens.appBarIconColor),",
      "        ),",
      "        body: const Center(child: CircularProgressIndicator()),",
      "      );",
      "    }",
      "",
      "    _scheduleFirstValidation();",
      "",
      "    return ChangeNotifierProvider<OnboardingReviewProvider>.value(",
      "      value: _reviewProvider!,",
      "      child: Scaffold(",
      "        backgroundColor: DesignTokens.backgroundColor,",
      "        appBar: AppBar(",
      "          title: Text(loc.onboardingReviewPublishTitle ?? \"Review & Publish\"),",
      "          backgroundColor: colorScheme.surface,",
      "          elevation: DesignTokens.adminCardElevation,",
      "          iconTheme: IconThemeData(color: DesignTokens.appBarIconColor),",
      "        ),",
      "        body: SafeArea(",
      "          child: Column(",
      "            children: [",
      "              Padding(",
      "                padding: const EdgeInsets.only(",
      "                    top: 12.0, left: 16, right: 16, bottom: 6),",
      "                child: OnboardingProgressIndicator(",
      "                  currentStep: 6,",
      "                  totalSteps: 6,",
      "                  stepLabel: loc.onboardingStepLabel(6, 6),",
      "                ),",
      "              ),",
      "              Expanded(",
      "                child: _loading",
      "                    ? const Center(child: CircularProgressIndicator())",
      "                    : _error != null",
      "                        ? Center(",
      "                            child: EmptyStateWidget(",
      "                              iconData: Icons.error_outline,",
      "                              title:",
      "                                  loc.onboardingReviewFailed ?? \"Review Failed\",",
      "                              message: _error!,",
      "                            ),",
      "                          )",
      "                        : Padding(",
      "                            padding: const EdgeInsets.symmetric(",
      "                                horizontal: 12.0, vertical: 8.0),",
      "                            child: _OnboardingReviewContent(),",
      "                          ),",
      "              ),",
      "            ],",
      "          ),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "class _OnboardingReviewContent extends StatelessWidget {",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    final loc = AppLocalizations.of(context)!;",
      "    final reviewProvider = Provider.of<OnboardingReviewProvider>(context);",
      "    final franchiseId =",
      "        Provider.of<FranchiseProvider>(context, listen: false).franchiseId;",
      "    final userId =",
      "        Provider.of<UserProfileNotifier>(context, listen: false).user?.id ?? '';",
      "",
      "    final routeArgs = ModalRoute.of(context)?.settings.arguments;",
      "    if (routeArgs is Map<String, dynamic> && routeArgs['focusItemId'] != null) {",
      "      debugPrint(",
      "        '[OnboardingReviewScreen] Focus requested for ingredientId=\"${routeArgs['focusItemId']}\". '",
      "        'Delegating to OnboardingIngredientsScreen to handle scrolling/highlighting.',",
      "      );",
      "    }",
      "",
      "    return LayoutBuilder(",
      "      builder: (context, constraints) {",
      "        final isWide = constraints.maxWidth > 1000;",
      "",
      "        return SingleChildScrollView(",
      "          child: Padding(",
      "            padding: const EdgeInsets.symmetric(vertical: 8.0),",
      "            child: Column(",
      "              crossAxisAlignment: CrossAxisAlignment.stretch,",
      "              children: [",
      "                Padding(",
      "                  padding: const EdgeInsets.only(bottom: 10),",
      "                  child: Text(",
      "                    loc.onboardingReviewPublishTitle ?? \"Review & Publish\",",
      "                    style: TextStyle(",
      "                      fontSize: 28,",
      "                      fontWeight: FontWeight.bold,",
      "                      color: colorScheme.primary,",
      "                      letterSpacing: 0.2,",
      "                      fontFamily: DesignTokens.fontFamily,",
      "                    ),",
      "                  ),",
      "                ),",
      "                Padding(",
      "                  padding: const EdgeInsets.only(bottom: 16),",
      "                  child: Text(",
      "                    loc.onboardingReviewPublishDesc ??",
      "                        \"Check for any missing information or schema issues before going live. All critical issues must be resolved.\",",
      "                    style: TextStyle(",
      "                      fontSize: 17,",
      "                      color: colorScheme.onBackground.withOpacity(0.74),",
      "                      fontWeight: FontWeight.w400,",
      "                      fontFamily: DesignTokens.fontFamily,",
      "                    ),",
      "                  ),",
      "                ),",
      "                Flex(",
      "                  direction: isWide ? Axis.horizontal : Axis.vertical,",
      "                  crossAxisAlignment: CrossAxisAlignment.start,",
      "                  children: [",
      "                    Expanded(",
      "                      flex: 5,",
      "                      child: Card(",
      "                        elevation: DesignTokens.adminCardElevation,",
      "                        shape: RoundedRectangleBorder(",
      "                          borderRadius: BorderRadius.circular(",
      "                              DesignTokens.adminCardRadius),",
      "                        ),",
      "                        color: colorScheme.surface,",
      "                        margin: const EdgeInsets.only(bottom: 18, right: 18),",
      "                        child: Padding(",
      "                          padding: const EdgeInsets.all(22.0),",
      "                          child: Column(",
      "                            crossAxisAlignment: CrossAxisAlignment.start,",
      "                            children: [",
      "                              FocusTraversalGroup(",
      "                                policy: OrderedTraversalPolicy(),",
      "                                child: ReviewSummaryTable(),",
      "                              ),",
      "                              IssueDetailsExpansion(),",
      "                              OnboardingDataExportButton(),",
      "                              const SizedBox(height: 32),",
      "                              PublishOnboardingButton(",
      "                                franchiseId: franchiseId,",
      "                                userId: userId,",
      "                              ),",
      "                              reviewProvider.isPublishable",
      "                                  ? Padding(",
      "                                      padding: const EdgeInsets.only(top: 16.0),",
      "                                      child: Row(",
      "                                        children: [",
      "                                          Icon(Icons.check_circle,",
      "                                              color: Colors.green[700],",
      "                                              size: 22),",
      "                                          const SizedBox(width: 10),",
      "                                          Flexible(",
      "                                            child: Text(",
      "                                              loc.onboardingReviewReadyToPublish ??",
      "                                                  \"All required information is complete. Ready to publish.\",",
      "                                              style: TextStyle(",
      "                                                color: Colors.green[700],",
      "                                                fontWeight: FontWeight.w600,",
      "                                                fontSize: 16,",
      "                                              ),",
      "                                            ),",
      "                                          ),",
      "                                        ],",
      "                                      ),",
      "                                    )",
      "                                  : Padding(",
      "                                      padding: const EdgeInsets.only(top: 16.0),",
      "                                      child: Row(",
      "                                        children: [",
      "                                          Icon(Icons.warning_amber_rounded,",
      "                                              color: colorScheme.error,",
      "                                              size: 22),",
      "                                          const SizedBox(width: 10),",
      "                                          Flexible(",
      "                                            child: Text(",
      "                                              loc.onboardingReviewFixErrors ??",
      "                                                  \"Resolve all blocking issues before you can publish.\",",
      "                                              style: TextStyle(",
      "                                                color: colorScheme.error,",
      "                                                fontWeight: FontWeight.w600,",
      "                                                fontSize: 16,",
      "                                              ),",
      "                                            ),",
      "                                          ),",
      "                                        ],",
      "                                      ),",
      "                                    ),",
      "                            ],",
      "                          ),",
      "                        ),",
      "                      ),",
      "                    ),",
      "                    if (isWide)",
      "                      Expanded(",
      "                        flex: 3,",
      "                        child: Card(",
      "                          elevation: DesignTokens.adminCardElevation,",
      "                          shape: RoundedRectangleBorder(",
      "                            borderRadius: BorderRadius.circular(",
      "                                DesignTokens.adminCardRadius),",
      "                          ),",
      "                          color: colorScheme.surface,",
      "                          margin: const EdgeInsets.only(bottom: 18),",
      "                          child: Padding(",
      "                            padding: const EdgeInsets.all(22.0),",
      "                            child: Column(",
      "                              crossAxisAlignment: CrossAxisAlignment.start,",
      "                              children: [",
      "                                OnboardingAuditTrail(franchiseId: franchiseId),",
      "                              ],",
      "                            ),",
      "                          ),",
      "                        ),",
      "                      ),",
      "                  ],",
      "                ),",
      "                const SizedBox(height: 26),",
      "              ],",
      "            ),",
      "          ),",
      "        );",
      "      },",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 417,
      "file_size": 17983,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\widgets\\feature_toggle_tile.dart",
    "content": [
      "// File: lib/admin/dashboard/onboarding/widgets/feature_toggle_tile.dart",
      "",
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_feature_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_info_provider.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/config/branding_config.dart';",
      "",
      "class FeatureToggleTile extends StatelessWidget {",
      "  final String moduleKey;",
      "  final String? featureKey;",
      "  final String title;",
      "  final String description;",
      "  final bool",
      "      highlight; // <-- new, to visually focus when navigating for error repair",
      "",
      "  const FeatureToggleTile({",
      "    Key? key,",
      "    required this.moduleKey,",
      "    required this.featureKey,",
      "    required this.title,",
      "    required this.description,",
      "    this.highlight = false,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final theme = Theme.of(context);",
      "    final localizations = AppLocalizations.of(context)!;",
      "",
      "    // For animated highlight, this can later be changed to an AnimatedContainer if desired.",
      "    return Consumer2<FranchiseFeatureProvider, FranchiseInfoProvider>(",
      "      builder: (context, featureProvider, franchiseInfo, _) {",
      "        final isEnabled = (featureKey == null || featureKey == 'enabled')",
      "            ? featureProvider.isModuleEnabled(moduleKey)",
      "            : featureProvider.isSubfeatureEnabled(moduleKey, featureKey!);",
      "",
      "        final isLocked = featureProvider.isModuleLocked(moduleKey);",
      "        final franchiseId = franchiseInfo.franchise?.id ?? '';",
      "",
      "        return AnimatedContainer(",
      "          duration: const Duration(milliseconds: 280),",
      "          curve: Curves.easeInOut,",
      "          margin: const EdgeInsets.symmetric(vertical: 4, horizontal: 2),",
      "          decoration: BoxDecoration(",
      "            border: highlight",
      "                ? Border.all(",
      "                    color: theme.colorScheme.secondary,",
      "                    width: 2.6,",
      "                  )",
      "                : Border.all(",
      "                    color: theme.dividerColor.withOpacity(0.22),",
      "                    width: 1.0,",
      "                  ),",
      "            borderRadius: BorderRadius.circular(DesignTokens.radiusLg),",
      "            boxShadow: highlight",
      "                ? [",
      "                    BoxShadow(",
      "                      color: theme.colorScheme.secondary.withOpacity(0.14),",
      "                      blurRadius: 12,",
      "                      offset: const Offset(0, 4),",
      "                    ),",
      "                  ]",
      "                : [],",
      "            color: theme.colorScheme.surface,",
      "          ),",
      "          child: Padding(",
      "            padding: const EdgeInsets.symmetric(vertical: 9, horizontal: 14),",
      "            child: Row(",
      "              children: [",
      "                Icon(",
      "                  isLocked ? Icons.lock_outline : Icons.toggle_on_outlined,",
      "                  color: isLocked",
      "                      ? theme.disabledColor",
      "                      : (isEnabled",
      "                          ? theme.colorScheme.primary",
      "                          : theme.colorScheme.onSurfaceVariant),",
      "                ),",
      "                const SizedBox(width: 14),",
      "                Expanded(",
      "                  child: Column(",
      "                    crossAxisAlignment: CrossAxisAlignment.start,",
      "                    children: [",
      "                      Text(",
      "                        title,",
      "                        style: theme.textTheme.titleMedium?.copyWith(",
      "                          color: isLocked",
      "                              ? theme.disabledColor",
      "                              : theme.colorScheme.onSurface,",
      "                          fontWeight: FontWeight.w600,",
      "                          fontFamily: DesignTokens.fontFamily,",
      "                        ),",
      "                      ),",
      "                      const SizedBox(height: 3),",
      "                      Text(",
      "                        description,",
      "                        style: theme.textTheme.bodySmall?.copyWith(",
      "                          color: theme.textTheme.bodySmall?.color",
      "                              ?.withOpacity(0.74),",
      "                          fontFamily: DesignTokens.fontFamily,",
      "                        ),",
      "                      ),",
      "                    ],",
      "                  ),",
      "                ),",
      "                const SizedBox(width: 14),",
      "                Switch(",
      "                  value: isEnabled,",
      "                  onChanged: isLocked",
      "                      ? null",
      "                      : (newValue) {",
      "                          if (featureKey == null || featureKey == 'enabled') {",
      "                            featureProvider.setModuleEnabled(",
      "                                moduleKey, newValue);",
      "                          } else {",
      "                            featureProvider.toggleSubfeature(",
      "                              moduleKey,",
      "                              featureKey!,",
      "                              newValue,",
      "                            );",
      "                          }",
      "                        },",
      "                  activeColor: theme.colorScheme.primary,",
      "                  inactiveThumbColor: theme.colorScheme.outlineVariant,",
      "                ),",
      "              ],",
      "            ),",
      "          ),",
      "        );",
      "      },",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 136,
      "file_size": 5467,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\widgets\\onboarding_progress_indicator.dart",
    "content": [
      "// File: lib/admin/dashboard/onboarding/widgets/onboarding_progress_indicator.dart",
      "",
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "",
      "/// A polished, responsive onboarding progress indicator for stepper-based flows.",
      "/// - Shows the current step number, total steps, and an optional custom label.",
      "/// - Styled to match Franchise Admin Portal's onboarding screens.",
      "class OnboardingProgressIndicator extends StatelessWidget {",
      "  /// The 1-based index of the current step (e.g., 2 for \"Step 2 of 6\").",
      "  final int currentStep;",
      "",
      "  /// The total number of steps in the onboarding flow.",
      "  final int totalSteps;",
      "",
      "  /// Optional: Custom label to display (e.g., \"Step 2 of 6\" or \"Menu Setup\").",
      "  /// If null, displays \"Step X of Y\".",
      "  final String? stepLabel;",
      "",
      "  /// Optional: List of step names for labeled indicator display.",
      "  /// If provided, highlights the current step name.",
      "  final List<String>? stepNames;",
      "",
      "  const OnboardingProgressIndicator({",
      "    Key? key,",
      "    required this.currentStep,",
      "    required this.totalSteps,",
      "    this.stepLabel,",
      "    this.stepNames,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    final effectiveStepLabel = stepLabel ?? 'Step $currentStep of $totalSteps';",
      "",
      "    final showStepNames = stepNames != null && stepNames!.length == totalSteps;",
      "",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        // Numeric progress row (\"Step 3 of 6\")",
      "        Row(",
      "          mainAxisAlignment: MainAxisAlignment.start,",
      "          children: [",
      "            // Progress circle (primary color, animated)",
      "            AnimatedContainer(",
      "              duration: const Duration(milliseconds: 220),",
      "              width: 32,",
      "              height: 32,",
      "              decoration: BoxDecoration(",
      "                color: colorScheme.primary,",
      "                shape: BoxShape.circle,",
      "                boxShadow: [",
      "                  BoxShadow(",
      "                    color: colorScheme.primary.withOpacity(0.18),",
      "                    blurRadius: 8,",
      "                    offset: const Offset(0, 3),",
      "                  ),",
      "                ],",
      "              ),",
      "              alignment: Alignment.center,",
      "              child: Text(",
      "                '$currentStep',",
      "                style: TextStyle(",
      "                  color: colorScheme.onPrimary,",
      "                  fontWeight: FontWeight.bold,",
      "                  fontSize: 17,",
      "                  fontFamily: DesignTokens.fontFamily,",
      "                  letterSpacing: 0.1,",
      "                ),",
      "              ),",
      "            ),",
      "            const SizedBox(width: 14),",
      "            // Step label (\"Step X of Y\")",
      "            Text(",
      "              effectiveStepLabel,",
      "              style: TextStyle(",
      "                color: colorScheme.primary,",
      "                fontWeight: FontWeight.w600,",
      "                fontSize: 18,",
      "                fontFamily: DesignTokens.fontFamily,",
      "                letterSpacing: 0.2,",
      "              ),",
      "            ),",
      "            const SizedBox(width: 10),",
      "            // Progress bar, if enough width",
      "            Expanded(",
      "              child: Padding(",
      "                padding: const EdgeInsets.symmetric(horizontal: 10),",
      "                child: LinearProgressIndicator(",
      "                  value: currentStep / totalSteps,",
      "                  backgroundColor: colorScheme.surface.withOpacity(0.21),",
      "                  valueColor:",
      "                      AlwaysStoppedAnimation<Color>(colorScheme.primary),",
      "                  minHeight: 5,",
      "                  borderRadius: BorderRadius.circular(DesignTokens.radiusLg),",
      "                ),",
      "              ),",
      "            ),",
      "          ],",
      "        ),",
      "        // Optional: Step name row (e.g. [\"Features\", \"Ingredient Types\", ...])",
      "        if (showStepNames) ...[",
      "          const SizedBox(height: 10),",
      "          SizedBox(",
      "            height: 32,",
      "            child: ListView.separated(",
      "              scrollDirection: Axis.horizontal,",
      "              physics: const NeverScrollableScrollPhysics(),",
      "              itemCount: stepNames!.length,",
      "              separatorBuilder: (_, __) => const SizedBox(width: 18),",
      "              itemBuilder: (context, i) {",
      "                final isCurrent = (i + 1) == currentStep;",
      "                return AnimatedContainer(",
      "                  duration: const Duration(milliseconds: 180),",
      "                  padding:",
      "                      const EdgeInsets.symmetric(horizontal: 16, vertical: 6),",
      "                  decoration: BoxDecoration(",
      "                    color: isCurrent",
      "                        ? colorScheme.primary.withOpacity(0.12)",
      "                        : Colors.transparent,",
      "                    borderRadius: BorderRadius.circular(18),",
      "                  ),",
      "                  child: Text(",
      "                    stepNames![i],",
      "                    style: TextStyle(",
      "                      fontSize: 16,",
      "                      fontWeight: isCurrent ? FontWeight.bold : FontWeight.w500,",
      "                      color: isCurrent",
      "                          ? colorScheme.primary",
      "                          : colorScheme.onSurface.withOpacity(0.67),",
      "                      letterSpacing: 0.15,",
      "                      fontFamily: DesignTokens.fontFamily,",
      "                    ),",
      "                  ),",
      "                );",
      "              },",
      "            ),",
      "          ),",
      "        ],",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 145,
      "file_size": 5504,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\widgets\\onboarding_sidebar_group.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/core/models/dashboard_section.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "",
      "class OnboardingSidebarGroup extends StatefulWidget {",
      "  final List<DashboardSection> steps;",
      "  final int selectedIndex;",
      "  final ValueChanged<int> onSelect;",
      "  final String label;",
      "  final IconData icon;",
      "  final int startIndexOffset;",
      "",
      "  const OnboardingSidebarGroup({",
      "    super.key,",
      "    required this.steps,",
      "    required this.selectedIndex,",
      "    required this.onSelect,",
      "    this.label = 'Franchise Onboarding',",
      "    this.icon = Icons.assignment_turned_in_outlined,",
      "    this.startIndexOffset = 0,",
      "  });",
      "",
      "  @override",
      "  State<OnboardingSidebarGroup> createState() => _OnboardingSidebarGroupState();",
      "}",
      "",
      "class _OnboardingSidebarGroupState extends State<OnboardingSidebarGroup> {",
      "  bool _expanded = true;",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "    final isSelectedGroup = widget.steps.any((section) =>",
      "        widget.selectedIndex == section.sidebarOrder + widget.startIndexOffset);",
      "",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        ListTile(",
      "          contentPadding: const EdgeInsets.symmetric(horizontal: 16),",
      "          leading: Icon(",
      "            widget.icon,",
      "            color: isSelectedGroup",
      "                ? colorScheme.primary",
      "                : colorScheme.onSurfaceVariant,",
      "          ),",
      "          title: Text(",
      "            widget.label,",
      "            style: theme.textTheme.titleSmall?.copyWith(",
      "              fontWeight: FontWeight.w600,",
      "              color:",
      "                  isSelectedGroup ? colorScheme.primary : colorScheme.onSurface,",
      "            ),",
      "          ),",
      "          trailing: Icon(",
      "            _expanded ? Icons.expand_less : Icons.expand_more,",
      "            color: colorScheme.onSurfaceVariant,",
      "            size: 20,",
      "          ),",
      "          onTap: () => setState(() => _expanded = !_expanded),",
      "        ),",
      "        if (_expanded)",
      "          Padding(",
      "            padding: const EdgeInsets.only(left: 12),",
      "            child: Column(",
      "              children: [",
      "                ...widget.steps.map((section) {",
      "                  final sidebarIndex =",
      "                      section.sidebarOrder + widget.startIndexOffset;",
      "                  final selected = sidebarIndex == widget.selectedIndex;",
      "",
      "                  return Padding(",
      "                    padding: const EdgeInsets.only(bottom: 4),",
      "                    child: Material(",
      "                      color: selected",
      "                          ? colorScheme.primaryContainer.withOpacity(0.15)",
      "                          : Colors.transparent,",
      "                      borderRadius: BorderRadius.circular(8),",
      "                      child: InkWell(",
      "                        borderRadius: BorderRadius.circular(8),",
      "                        onTap: () => widget.onSelect(sidebarIndex),",
      "                        child: Container(",
      "                          padding: const EdgeInsets.symmetric(",
      "                              horizontal: 12, vertical: 10),",
      "                          child: Row(",
      "                            children: [",
      "                              Icon(",
      "                                section.icon,",
      "                                size: 20,",
      "                                color: selected",
      "                                    ? colorScheme.primary",
      "                                    : colorScheme.onSurfaceVariant,",
      "                              ),",
      "                              const SizedBox(width: 12),",
      "                              Expanded(",
      "                                child: Text(",
      "                                  section.title,",
      "                                  style: theme.textTheme.bodySmall?.copyWith(",
      "                                    fontWeight: selected",
      "                                        ? FontWeight.bold",
      "                                        : FontWeight.normal,",
      "                                    color: selected",
      "                                        ? colorScheme.primary",
      "                                        : colorScheme.onSurface,",
      "                                  ),",
      "                                ),",
      "                              ),",
      "                            ],",
      "                          ),",
      "                        ),",
      "                      ),",
      "                    ),",
      "                  );",
      "                }),",
      "              ],",
      "            ),",
      "          ),",
      "        const SizedBox(height: 12),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 123,
      "file_size": 4649,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\widgets\\onboarding_step_card.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "",
      "class OnboardingStepCard extends StatelessWidget {",
      "  final int stepNumber;",
      "  final String title;",
      "  final String subtitle;",
      "  final bool completed;",
      "  final VoidCallback onTap;",
      "",
      "  const OnboardingStepCard({",
      "    super.key,",
      "    required this.stepNumber,",
      "    required this.title,",
      "    required this.subtitle,",
      "    required this.completed,",
      "    required this.onTap,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    print(",
      "        '[OnboardingStepCard] building: title=\"$title\", subtitle=\"$subtitle\", completed=$completed');",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "    final loc = AppLocalizations.of(context)!;",
      "",
      "    return Padding(",
      "      padding: const EdgeInsets.symmetric(vertical: 8),",
      "      child: Material(",
      "        color: colorScheme.surface,",
      "        elevation: 1,",
      "        borderRadius: BorderRadius.circular(12),",
      "        child: InkWell(",
      "          borderRadius: BorderRadius.circular(12),",
      "          onTap: onTap,",
      "          child: Container(",
      "            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 18),",
      "            child: Row(",
      "              crossAxisAlignment: CrossAxisAlignment.start,",
      "              children: [",
      "                _buildStepNumberBadge(context),",
      "                const SizedBox(width: 16),",
      "                Expanded(",
      "                  child: Column(",
      "                    crossAxisAlignment: CrossAxisAlignment.start,",
      "                    children: [",
      "                      Text(",
      "                        title,",
      "                        style: theme.textTheme.titleMedium?.copyWith(",
      "                          fontWeight: FontWeight.w600,",
      "                          color: colorScheme.onSurface,",
      "                        ),",
      "                      ),",
      "                      const SizedBox(height: 4),",
      "                      Text(",
      "                        subtitle,",
      "                        style: theme.textTheme.bodySmall?.copyWith(",
      "                          color: colorScheme.onSurfaceVariant,",
      "                        ),",
      "                      ),",
      "                    ],",
      "                  ),",
      "                ),",
      "                const SizedBox(width: 12),",
      "                completed",
      "                    ? Icon(Icons.check_circle_rounded,",
      "                        color: colorScheme.primary, size: 24)",
      "                    : Icon(Icons.chevron_right_rounded,",
      "                        color: colorScheme.onSurfaceVariant, size: 24),",
      "              ],",
      "            ),",
      "          ),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  Widget _buildStepNumberBadge(BuildContext context) {",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    return CircleAvatar(",
      "      radius: 16,",
      "      backgroundColor: completed",
      "          ? colorScheme.primary.withOpacity(0.85)",
      "          : colorScheme.surfaceVariant,",
      "      child: Text(",
      "        '$stepNumber',",
      "        style: TextStyle(",
      "          fontSize: 14,",
      "          fontWeight: FontWeight.bold,",
      "          color:",
      "              completed ? colorScheme.onPrimary : colorScheme.onSurfaceVariant,",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 98,
      "file_size": 3270,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\widgets\\onboarding_summary_panel.dart",
    "content": [],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 0,
      "file_size": 0,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\widgets\\categories\\categories_template_picker_dialog.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/category_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "",
      "class CategoriesTemplatePickerDialog extends StatefulWidget {",
      "  final AppLocalizations loc;",
      "  final BuildContext parentContext;",
      "",
      "  const CategoriesTemplatePickerDialog({",
      "    super.key,",
      "    required this.loc,",
      "    required this.parentContext, // <-- required param",
      "  });",
      "",
      "  static Future<void> show(BuildContext parentContext) {",
      "    final loc = AppLocalizations.of(parentContext)!;",
      "    final provider =",
      "        Provider.of<CategoryProvider>(parentContext, listen: false);",
      "",
      "    return showDialog(",
      "      context: parentContext,",
      "      builder: (dialogContext) =>",
      "          ChangeNotifierProvider<CategoryProvider>.value(",
      "        value: provider,",
      "        child: CategoriesTemplatePickerDialog(",
      "            loc: loc, parentContext: parentContext), // add param",
      "      ),",
      "    );",
      "  }",
      "",
      "  @override",
      "  State<CategoriesTemplatePickerDialog> createState() =>",
      "      _CategoriesTemplatePickerDialogState();",
      "}",
      "",
      "class _CategoriesTemplatePickerDialogState",
      "    extends State<CategoriesTemplatePickerDialog> {",
      "  bool _loading = false;",
      "",
      "  Future<void> _loadTemplate(String templateId) async {",
      "    final loc = widget.loc;",
      "    final provider = context.read<CategoryProvider>();",
      "    final franchiseId = context.read<FranchiseProvider>().franchiseId;",
      "",
      "    if (franchiseId.isEmpty || franchiseId == 'unknown') {",
      "      if (widget.parentContext.mounted) {",
      "        ScaffoldMessenger.of(widget.parentContext).showSnackBar(",
      "          SnackBar(content: Text(loc.selectAFranchiseFirst)),",
      "        );",
      "      }",
      "      return;",
      "    }",
      "",
      "    setState(() => _loading = true);",
      "",
      "    try {",
      "      await provider.loadTemplate(templateId);",
      "",
      "      if (context.mounted) {",
      "        Navigator.of(context).pop();",
      "        if (widget.parentContext.mounted) {",
      "          ScaffoldMessenger.of(widget.parentContext).showSnackBar(",
      "            SnackBar(content: Text(loc.templateLoadedSuccessfully)),",
      "          );",
      "        }",
      "      }",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'category_template_load_failed',",
      "        stack: stack.toString(),",
      "        screen: 'onboarding_categories_screen',",
      "        source: 'CategoriesTemplatePickerDialog',",
      "        severity: 'error',",
      "        contextData: {",
      "          'templateId': templateId,",
      "          'franchiseId': franchiseId,",
      "        },",
      "      );",
      "      if (widget.parentContext.mounted) {",
      "        ScaffoldMessenger.of(widget.parentContext).showSnackBar(",
      "          SnackBar(content: Text(loc.errorGeneric)),",
      "        );",
      "      }",
      "    } finally {",
      "      if (mounted) setState(() => _loading = false);",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = widget.loc;",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "",
      "    return AlertDialog(",
      "      backgroundColor: DesignTokens.surfaceColor,",
      "      titlePadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),",
      "      title: Row(",
      "        children: [",
      "          Icon(Icons.library_add, color: colorScheme.primary),",
      "          const SizedBox(width: 8),",
      "          Text(",
      "            loc.selectCategoryTemplate,",
      "            style: theme.textTheme.titleMedium?.copyWith(",
      "              color: colorScheme.onSurface,",
      "              fontWeight: FontWeight.w600,",
      "            ),",
      "          ),",
      "        ],",
      "      ),",
      "      contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),",
      "      content: _loading",
      "          ? const Center(child: CircularProgressIndicator())",
      "          : Column(",
      "              mainAxisSize: MainAxisSize.min,",
      "              children: [",
      "                _buildTemplateTile(",
      "                  id: 'pizzeria',",
      "                  icon: '🍕',",
      "                  label: loc.pizzaShopTemplateLabel,",
      "                  subtitle: loc.pizzaShopTemplateSubtitle,",
      "                ),",
      "                const SizedBox(height: 12),",
      "                _buildTemplateTile(",
      "                  id: 'wing_bar',",
      "                  icon: '🍗',",
      "                  label: loc.wingBarTemplateLabel,",
      "                  subtitle: loc.wingBarTemplateSubtitle,",
      "                  enabled: false, // Reserved for future",
      "                ),",
      "              ],",
      "            ),",
      "      actions: [",
      "        TextButton(",
      "          onPressed: () => Navigator.of(context).pop(),",
      "          child: Text(loc.cancel),",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "",
      "  Widget _buildTemplateTile({",
      "    required String id,",
      "    required String icon,",
      "    required String label,",
      "    required String subtitle,",
      "    bool enabled = true,",
      "  }) {",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "",
      "    return ListTile(",
      "      enabled: enabled,",
      "      tileColor: enabled",
      "          ? colorScheme.surfaceVariant.withOpacity(0.2)",
      "          : Colors.grey.withOpacity(0.1),",
      "      leading: Text(",
      "        icon,",
      "        style: const TextStyle(fontSize: 28),",
      "      ),",
      "      title: Text(",
      "        label,",
      "        style: theme.textTheme.titleSmall?.copyWith(",
      "          fontWeight: FontWeight.w600,",
      "        ),",
      "      ),",
      "      subtitle: Text(",
      "        subtitle,",
      "        style: theme.textTheme.bodySmall,",
      "      ),",
      "      onTap: enabled ? () => _loadTemplate(id) : null,",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 178,
      "file_size": 5644,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\widgets\\categories\\category_form_dialog.dart",
    "content": [
      "// lib/admin/dashboard/onboarding/widgets/categories/category_form_dialog.dart",
      "",
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/models/category.dart';",
      "import 'package:franchise_admin_portal/core/providers/category_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class CategoryFormDialog extends StatefulWidget {",
      "  final Category? initialCategory;",
      "  final String franchiseId;",
      "  final AppLocalizations loc;",
      "",
      "  const CategoryFormDialog({",
      "    super.key,",
      "    this.initialCategory,",
      "    required this.franchiseId,",
      "    required this.loc,",
      "  });",
      "",
      "  static Future<Category?> show({",
      "    required BuildContext parentContext,",
      "    Category? initialCategory,",
      "    required String franchiseId,",
      "  }) {",
      "    final loc = AppLocalizations.of(parentContext)!;",
      "    final categoryProvider =",
      "        Provider.of<CategoryProvider>(parentContext, listen: false);",
      "    final franchiseProvider =",
      "        Provider.of<FranchiseProvider>(parentContext, listen: false);",
      "",
      "    return showDialog<Category>(",
      "      context: parentContext,",
      "      builder: (dialogContext) =>",
      "          ChangeNotifierProvider<FranchiseProvider>.value(",
      "        value: franchiseProvider,",
      "        child: ChangeNotifierProvider<CategoryProvider>.value(",
      "          value: categoryProvider,",
      "          child: CategoryFormDialog(",
      "            initialCategory: initialCategory,",
      "            franchiseId: franchiseId,",
      "            loc: loc,",
      "          ),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  @override",
      "  State<CategoryFormDialog> createState() => _CategoryFormDialogState();",
      "}",
      "",
      "class _CategoryFormDialogState extends State<CategoryFormDialog> {",
      "  final _formKey = GlobalKey<FormState>();",
      "  late TextEditingController _nameController;",
      "  late TextEditingController _descriptionController;",
      "  bool _loading = false;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _nameController =",
      "        TextEditingController(text: widget.initialCategory?.name ?? '');",
      "    _descriptionController =",
      "        TextEditingController(text: widget.initialCategory?.description ?? '');",
      "  }",
      "",
      "  @override",
      "  void dispose() {",
      "    _nameController.dispose();",
      "    _descriptionController.dispose();",
      "    super.dispose();",
      "  }",
      "",
      "  Future<void> _submitForm() async {",
      "    final loc = widget.loc;",
      "    if (!_formKey.currentState!.validate()) return;",
      "",
      "    setState(() => _loading = true);",
      "    final franchiseId = context.read<FranchiseProvider>().franchiseId;",
      "    final firestore = context.read<FirestoreService>();",
      "    final categoryProvider = context.read<CategoryProvider>();",
      "",
      "    final isEdit = widget.initialCategory != null;",
      "    final id = widget.initialCategory?.id ?? UniqueKey().toString();",
      "    final category = Category(",
      "      id: id,",
      "      name: _nameController.text.trim(),",
      "      description: _descriptionController.text.trim(),",
      "      sortOrder: widget.initialCategory?.sortOrder ??",
      "          categoryProvider.categories.length,",
      "    );",
      "",
      "    try {",
      "      if (context.mounted) Navigator.of(context).pop(category);",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to save category',",
      "        stack: stack.toString(),",
      "        source: 'CategoryFormDialog',",
      "        screen: 'onboarding_categories_screen',",
      "        severity: 'error',",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "          'categoryId': id,",
      "          'name': _nameController.text.trim(),",
      "          'operation': isEdit ? 'update' : 'create',",
      "        },",
      "      );",
      "",
      "      if (context.mounted) {",
      "        ScaffoldMessenger.of(context).showSnackBar(",
      "          SnackBar(content: Text(loc.errorGeneric)),",
      "        );",
      "      }",
      "    } finally {",
      "      if (mounted) setState(() => _loading = false);",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = widget.loc;",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "",
      "    return Dialog(",
      "      shape: RoundedRectangleBorder(",
      "        borderRadius: BorderRadius.circular(DesignTokens.dialogBorderRadius),",
      "      ),",
      "      child: ConstrainedBox(",
      "        constraints: const BoxConstraints(maxWidth: 480),",
      "        child: Padding(",
      "          padding: const EdgeInsets.all(24.0),",
      "          child: Column(",
      "            mainAxisSize: MainAxisSize.min,",
      "            crossAxisAlignment: CrossAxisAlignment.start,",
      "            children: [",
      "              Text(",
      "                widget.initialCategory == null",
      "                    ? loc.addCategoryTitle",
      "                    : loc.editCategoryTitle,",
      "                style: theme.textTheme.titleLarge?.copyWith(",
      "                  fontWeight: FontWeight.bold,",
      "                  color: colorScheme.onSurface,",
      "                ),",
      "              ),",
      "              const SizedBox(height: 24),",
      "              Form(",
      "                key: _formKey,",
      "                child: Column(",
      "                  children: [",
      "                    TextFormField(",
      "                      controller: _nameController,",
      "                      decoration:",
      "                          InputDecoration(labelText: loc.categoryNameLabel),",
      "                      validator: (value) =>",
      "                          value == null || value.trim().isEmpty",
      "                              ? loc.requiredField",
      "                              : null,",
      "                    ),",
      "                    const SizedBox(height: 16),",
      "                    TextFormField(",
      "                      controller: _descriptionController,",
      "                      decoration: InputDecoration(",
      "                          labelText: loc.categoryDescriptionLabel),",
      "                      maxLines: 2,",
      "                    ),",
      "                  ],",
      "                ),",
      "              ),",
      "              const SizedBox(height: 24),",
      "              Align(",
      "                alignment: Alignment.centerRight,",
      "                child: Row(",
      "                  mainAxisSize: MainAxisSize.min,",
      "                  children: [",
      "                    TextButton(",
      "                      onPressed: () => Navigator.of(context).pop(),",
      "                      child: Text(loc.cancel),",
      "                    ),",
      "                    const SizedBox(width: 16),",
      "                    ElevatedButton(",
      "                      onPressed: _loading ? null : _submitForm,",
      "                      style: ElevatedButton.styleFrom(",
      "                        backgroundColor: DesignTokens.primaryColor,",
      "                      ),",
      "                      child: _loading",
      "                          ? const SizedBox(",
      "                              width: 16,",
      "                              height: 16,",
      "                              child: CircularProgressIndicator(strokeWidth: 2),",
      "                            )",
      "                          : Text(loc.save),",
      "                    ),",
      "                  ],",
      "                ),",
      "              ),",
      "            ],",
      "          ),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 209,
      "file_size": 7263,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\widgets\\categories\\category_json_import_export_dialog.dart",
    "content": [
      "import 'dart:convert';",
      "",
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/config/branding_config.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_info_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/onboarding_progress_provider.dart';",
      "import 'package:franchise_admin_portal/core/models/category.dart';",
      "import 'package:franchise_admin_portal/core/utils/schema_templates.dart';",
      "import 'package:franchise_admin_portal/core/providers/category_provider.dart';",
      "",
      "class CategoryJsonImportExportDialog extends StatefulWidget {",
      "  final AppLocalizations loc;",
      "  final BuildContext parentContext; // <-- add this line",
      "",
      "  const CategoryJsonImportExportDialog({",
      "    super.key,",
      "    required this.loc,",
      "    required this.parentContext, // <-- add this line",
      "  });",
      "",
      "  static Future<void> show(BuildContext parentContext) {",
      "    final loc = AppLocalizations.of(parentContext)!;",
      "    final categoryProvider =",
      "        Provider.of<CategoryProvider>(parentContext, listen: false);",
      "    final onboardingProvider =",
      "        Provider.of<OnboardingProgressProvider>(parentContext, listen: false);",
      "",
      "    return showDialog(",
      "      context: parentContext,",
      "      builder: (dialogContext) =>",
      "          ChangeNotifierProvider<OnboardingProgressProvider>.value(",
      "        value: onboardingProvider,",
      "        child: ChangeNotifierProvider<CategoryProvider>.value(",
      "          value: categoryProvider,",
      "          child: CategoryJsonImportExportDialog(",
      "            loc: loc,",
      "            parentContext: parentContext,",
      "          ),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  @override",
      "  State<CategoryJsonImportExportDialog> createState() =>",
      "      _CategoryJsonImportExportDialogState();",
      "}",
      "",
      "class _CategoryJsonImportExportDialogState",
      "    extends State<CategoryJsonImportExportDialog> {",
      "  late TextEditingController _controller;",
      "  bool _isImporting = false;",
      "  String? _message;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    final template = pizzaShopCategoriesTemplate;",
      "    final jsonStr = const JsonEncoder.withIndent('  ').convert(template);",
      "    _controller = TextEditingController(text: jsonStr);",
      "  }",
      "",
      "  @override",
      "  void dispose() {",
      "    _controller.dispose();",
      "    super.dispose();",
      "  }",
      "",
      "  Future<void> _importCategories() async {",
      "    final loc = widget.loc;",
      "    final franchiseId = context.read<FranchiseProvider>().franchiseId;",
      "    final firestore = context.read<FirestoreService>();",
      "    final onboardingProgress =",
      "        context.read<OnboardingProgressProvider>().stepStatus;",
      "",
      "    setState(() {",
      "      _isImporting = true;",
      "      _message = null;",
      "    });",
      "",
      "    try {",
      "      final List<dynamic> decoded = json.decode(_controller.text);",
      "      final categories = decoded.map((e) => Category.fromMap(e)).toList();",
      "",
      "      for (final cat in categories) {",
      "        await firestore.addCategory(",
      "          franchiseId: franchiseId,",
      "          category: cat,",
      "        );",
      "      }",
      "",
      "      if (onboardingProgress['categories'] != true) {",
      "        await context",
      "            .read<OnboardingProgressProvider>()",
      "            .markStepComplete('categories');",
      "      }",
      "",
      "      setState(() {",
      "        _message = loc.importSuccess;",
      "      });",
      "",
      "      // --- Success SnackBar (optional) ---",
      "      if (widget.parentContext.mounted) {",
      "        ScaffoldMessenger.of(widget.parentContext).showSnackBar(",
      "          SnackBar(content: Text(loc.importSuccess)),",
      "        );",
      "      }",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'category_json_import_error',",
      "        source: 'CategoryJsonImportExportDialog',",
      "        screen: 'onboarding_categories_screen',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "        contextData: {'franchiseId': franchiseId, 'raw': _controller.text},",
      "      );",
      "",
      "      setState(() {",
      "        _message = loc.importError;",
      "      });",
      "",
      "      // --- Error SnackBar ---",
      "      if (widget.parentContext.mounted) {",
      "        ScaffoldMessenger.of(widget.parentContext).showSnackBar(",
      "          SnackBar(content: Text(loc.importError)),",
      "        );",
      "      }",
      "    } finally {",
      "      setState(() {",
      "        _isImporting = false;",
      "      });",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = widget.loc;",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "",
      "    return AlertDialog(",
      "      title: Text(loc.importExportCategories),",
      "      content: ConstrainedBox(",
      "        constraints: const BoxConstraints(maxWidth: 600),",
      "        child: Column(",
      "          mainAxisSize: MainAxisSize.min,",
      "          children: [",
      "            Text(loc.importExportInstruction),",
      "            const SizedBox(height: 12),",
      "            TextField(",
      "              controller: _controller,",
      "              maxLines: 14,",
      "              minLines: 10,",
      "              style: theme.textTheme.bodyMedium?.copyWith(",
      "                fontFamily: 'monospace',",
      "                fontSize: 13,",
      "              ),",
      "              decoration: InputDecoration(",
      "                labelText: loc.jsonData,",
      "                border: OutlineInputBorder(",
      "                  borderSide: BorderSide(color: colorScheme.primary),",
      "                ),",
      "              ),",
      "            ),",
      "            if (_message != null) ...[",
      "              const SizedBox(height: 12),",
      "              Text(",
      "                _message!,",
      "                style: TextStyle(",
      "                  color: _message == loc.importSuccess",
      "                      ? Colors.green",
      "                      : colorScheme.error,",
      "                ),",
      "              )",
      "            ]",
      "          ],",
      "        ),",
      "      ),",
      "      actions: [",
      "        TextButton(",
      "          onPressed: _isImporting ? null : () => Navigator.pop(context),",
      "          child: Text(loc.cancel),",
      "        ),",
      "        ElevatedButton.icon(",
      "          style: ElevatedButton.styleFrom(",
      "            backgroundColor: DesignTokens.primaryColor,",
      "            foregroundColor: DesignTokens.foregroundColor,",
      "          ),",
      "          icon: _isImporting",
      "              ? const SizedBox(",
      "                  height: 16,",
      "                  width: 16,",
      "                  child: CircularProgressIndicator(strokeWidth: 2),",
      "                )",
      "              : const Icon(Icons.upload_file),",
      "          onPressed: _isImporting ? null : _importCategories,",
      "          label: Text(loc.import),",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 208,
      "file_size": 6806,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\widgets\\categories\\category_list_tile.dart",
    "content": [
      "// lib/admin/dashboard/onboarding/widgets/categories/category_list_tile.dart",
      "",
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/models/category.dart';",
      "import 'package:franchise_admin_portal/core/providers/category_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "",
      "class CategoryListTile extends StatelessWidget {",
      "  final Category category;",
      "  final VoidCallback onEdit;",
      "  final VoidCallback onDelete;",
      "  final bool isSelected;",
      "  final ValueChanged<bool?> onSelect;",
      "",
      "  const CategoryListTile({",
      "    super.key,",
      "    required this.category,",
      "    required this.onEdit,",
      "    required this.onDelete,",
      "    required this.isSelected,",
      "    required this.onSelect,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context)!;",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "",
      "    return Card(",
      "      margin: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),",
      "      elevation: 1,",
      "      shape: RoundedRectangleBorder(",
      "        borderRadius: BorderRadius.circular(DesignTokens.radiusMd),",
      "      ),",
      "      child: ListTile(",
      "        contentPadding: const EdgeInsets.symmetric(horizontal: 16),",
      "        leading: ReorderableDragStartListener(",
      "          index: category.sortOrder ?? 0,",
      "          child: const Icon(Icons.drag_handle),",
      "        ),",
      "        title: Text(",
      "          category.name,",
      "          style: theme.textTheme.titleMedium,",
      "        ),",
      "        subtitle:",
      "            category.description != null && category.description!.isNotEmpty",
      "                ? Text(",
      "                    category.description!,",
      "                    style: theme.textTheme.bodySmall,",
      "                  )",
      "                : null,",
      "        trailing: Wrap(",
      "          spacing: 8,",
      "          crossAxisAlignment: WrapCrossAlignment.center,",
      "          children: [",
      "            Checkbox(",
      "              value: isSelected,",
      "              onChanged: onSelect,",
      "            ),",
      "            IconButton(",
      "              icon: const Icon(Icons.edit),",
      "              tooltip: loc.edit,",
      "              onPressed: onEdit,",
      "            ),",
      "            IconButton(",
      "              icon: const Icon(Icons.delete_outline),",
      "              tooltip: loc.delete,",
      "              onPressed: () async {",
      "                final confirmed = await showDialog<bool>(",
      "                  context: context,",
      "                  builder: (ctx) => AlertDialog(",
      "                    title: Text(loc.confirmDeletion),",
      "                    content:",
      "                        Text('${loc.confirmDeleteCategory} ${category.name}?'),",
      "                    actions: [",
      "                      TextButton(",
      "                        onPressed: () => Navigator.of(ctx).pop(false),",
      "                        child: Text(loc.cancel),",
      "                      ),",
      "                      ElevatedButton(",
      "                        onPressed: () => Navigator.of(ctx).pop(true),",
      "                        style: ElevatedButton.styleFrom(",
      "                          backgroundColor: Colors.red,",
      "                        ),",
      "                        child: Text(loc.delete),",
      "                      ),",
      "                    ],",
      "                  ),",
      "                );",
      "",
      "                if (confirmed == true) {",
      "                  final provider = context.read<CategoryProvider>();",
      "                  final franchiseId =",
      "                      context.read<FranchiseProvider>().franchiseId;",
      "",
      "                  try {",
      "                    await context.read<FirestoreService>().deleteCategory(",
      "                          franchiseId: franchiseId,",
      "                          categoryId: category.id,",
      "                        );",
      "                    ScaffoldMessenger.of(context).showSnackBar(",
      "                      SnackBar(content: Text(loc.deleteSuccess)),",
      "                    );",
      "                  } catch (e, stack) {",
      "                    await ErrorLogger.log(",
      "                      message: 'Failed to delete category',",
      "                      source: 'CategoryListTile',",
      "                      screen: 'onboarding_categories_screen',",
      "                      severity: 'error',",
      "                      stack: stack.toString(),",
      "                      contextData: {",
      "                        'franchiseId': franchiseId,",
      "                        'categoryId': category.id,",
      "                      },",
      "                    );",
      "",
      "                    ScaffoldMessenger.of(context).showSnackBar(",
      "                      SnackBar(content: Text(loc.errorGeneric)),",
      "                    );",
      "                  }",
      "                }",
      "              },",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 135,
      "file_size": 5017,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\widgets\\ingredients\\editable_ingredient_type_row.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:provider/provider.dart';",
      "",
      "import 'package:franchise_admin_portal/core/models/ingredient_type_model.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/ingredient_type_provider.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "",
      "class EditableIngredientTypeRow extends StatefulWidget {",
      "  final IngredientType type;",
      "  final bool isEditing;",
      "  final VoidCallback onEditTapped;",
      "  final VoidCallback onDeleteTapped;",
      "  final VoidCallback onSaveTapped;",
      "  final Widget? trailing; // <-- Added trailing param",
      "",
      "  const EditableIngredientTypeRow({",
      "    super.key,",
      "    required this.type,",
      "    required this.isEditing,",
      "    required this.onEditTapped,",
      "    required this.onDeleteTapped,",
      "    required this.onSaveTapped,",
      "    this.trailing, // <-- Added trailing param",
      "  });",
      "",
      "  @override",
      "  State<EditableIngredientTypeRow> createState() =>",
      "      _EditableIngredientTypeRowState();",
      "}",
      "",
      "class _EditableIngredientTypeRowState extends State<EditableIngredientTypeRow> {",
      "  late TextEditingController _nameController;",
      "  late TextEditingController _sortOrderController;",
      "  bool _updating = false;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _nameController = TextEditingController(text: widget.type.name);",
      "    _sortOrderController =",
      "        TextEditingController(text: widget.type.sortOrder.toString());",
      "  }",
      "",
      "  @override",
      "  void didUpdateWidget(covariant EditableIngredientTypeRow oldWidget) {",
      "    super.didUpdateWidget(oldWidget);",
      "",
      "    final updated = widget.type;",
      "",
      "    if (oldWidget.type.name != updated.name ||",
      "        oldWidget.type.sortOrder != updated.sortOrder ||",
      "        oldWidget.type.id != updated.id) {",
      "      _nameController.text = updated.name;",
      "      _sortOrderController.text = updated.sortOrder.toString();",
      "    }",
      "",
      "    if (oldWidget.isEditing != widget.isEditing && widget.isEditing) {",
      "      _nameController.text = updated.name;",
      "      _sortOrderController.text = updated.sortOrder.toString();",
      "    }",
      "  }",
      "",
      "  @override",
      "  void dispose() {",
      "    _nameController.dispose();",
      "    _sortOrderController.dispose();",
      "    super.dispose();",
      "  }",
      "",
      "  Future<void> _updateField() async {",
      "    final loc = AppLocalizations.of(context)!;",
      "    final provider = context.read<IngredientTypeProvider>();",
      "    final franchiseId = context.read<FranchiseProvider>().franchiseId;",
      "",
      "    final updated = widget.type.copyWith(",
      "      name: _nameController.text.trim(),",
      "      sortOrder: int.tryParse(_sortOrderController.text.trim()) ??",
      "          widget.type.sortOrder,",
      "    );",
      "",
      "    if (updated == widget.type) {",
      "      widget.onSaveTapped();",
      "      return;",
      "    }",
      "",
      "    setState(() => _updating = true);",
      "",
      "    try {",
      "      await provider.updateType(franchiseId, updated);",
      "      widget.onSaveTapped();",
      "      if (mounted) {",
      "        ScaffoldMessenger.of(context).showSnackBar(",
      "          SnackBar(",
      "              content: Text('${loc.ingredientTypeUpdated}: ${updated.name}')),",
      "        );",
      "      }",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to update ingredient type inline',",
      "        stack: stack.toString(),",
      "        severity: 'error',",
      "        source: 'EditableIngredientTypeRow',",
      "        screen: 'ingredient_type_management_screen',",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "          'typeId': widget.type.id,",
      "          'attemptedName': updated.name,",
      "          'attemptedSortOrder': updated.sortOrder,",
      "        },",
      "      );",
      "      if (mounted) {",
      "        ScaffoldMessenger.of(context).showSnackBar(",
      "          SnackBar(content: Text(loc.errorGeneric)),",
      "        );",
      "      }",
      "    } finally {",
      "      if (mounted) setState(() => _updating = false);",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context)!;",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "",
      "    return Card(",
      "      margin: const EdgeInsets.symmetric(horizontal: 8, vertical: 6),",
      "      shape: RoundedRectangleBorder(",
      "        borderRadius: BorderRadius.circular(DesignTokens.cardRadius),",
      "        side: BorderSide(color: DesignTokens.cardBorderColor),",
      "      ),",
      "      color: DesignTokens.surfaceColor,",
      "      child: Padding(",
      "        padding: const EdgeInsets.all(12.0),",
      "        child: Row(",
      "          children: [",
      "            widget.isEditing",
      "                ? Expanded(",
      "                    child: TextFormField(",
      "                      controller: _nameController,",
      "                      decoration: InputDecoration(",
      "                        labelText: loc.ingredientTypeName,",
      "                        border: const OutlineInputBorder(),",
      "                      ),",
      "                      onFieldSubmitted: (_) => _updateField(),",
      "                    ),",
      "                  )",
      "                : Expanded(",
      "                    child: Text(",
      "                      widget.type.name,",
      "                      style: theme.textTheme.bodyLarge,",
      "                    ),",
      "                  ),",
      "            const SizedBox(width: 12),",
      "            widget.isEditing",
      "                ? SizedBox(",
      "                    width: 80,",
      "                    child: TextFormField(",
      "                      controller: _sortOrderController,",
      "                      keyboardType: TextInputType.number,",
      "                      decoration: InputDecoration(",
      "                        labelText: loc.sortOrder,",
      "                        border: const OutlineInputBorder(),",
      "                      ),",
      "                      onFieldSubmitted: (_) => _updateField(),",
      "                    ),",
      "                  )",
      "                : SizedBox(",
      "                    width: 80,",
      "                    child: Text(",
      "                      widget.type.sortOrder.toString(),",
      "                      textAlign: TextAlign.center,",
      "                    ),",
      "                  ),",
      "            const SizedBox(width: 12),",
      "            if (_updating)",
      "              const SizedBox(",
      "                width: 24,",
      "                height: 24,",
      "                child: CircularProgressIndicator(strokeWidth: 2),",
      "              )",
      "            else if (widget.isEditing)",
      "              IconButton(",
      "                tooltip: loc.save,",
      "                icon: const Icon(Icons.check),",
      "                color: colorScheme.primary,",
      "                onPressed: _updateField,",
      "              )",
      "            else",
      "              IconButton(",
      "                tooltip: loc.edit,",
      "                icon: const Icon(Icons.edit),",
      "                onPressed: widget.onEditTapped,",
      "              ),",
      "            IconButton(",
      "              tooltip: loc.delete,",
      "              icon: const Icon(Icons.delete_outline),",
      "              onPressed: widget.onDeleteTapped,",
      "            ),",
      "            if (widget.trailing != null) ...[",
      "              const SizedBox(width: 8),",
      "              widget.trailing!,",
      "            ],",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 213,
      "file_size": 7154,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\widgets\\ingredients\\ingredient_form_card.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/models/ingredient_metadata.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/ingredient_metadata_provider.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/widgets/ingredients/ingredient_tag_selector.dart';",
      "import 'package:franchise_admin_portal/core/providers/ingredient_type_provider.dart';",
      "import 'package:franchise_admin_portal/core/models/ingredient_type_model.dart';",
      "",
      "class IngredientFormCard extends StatefulWidget {",
      "  final IngredientMetadata? initialData;",
      "  final VoidCallback? onSaved;",
      "  final AppLocalizations loc;",
      "  final BuildContext parentContext;",
      "",
      "  const IngredientFormCard({",
      "    Key? key,",
      "    this.initialData,",
      "    this.onSaved,",
      "    required this.loc,",
      "    required this.parentContext,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  State<IngredientFormCard> createState() => _IngredientFormCardState();",
      "}",
      "",
      "class _IngredientFormCardState extends State<IngredientFormCard> {",
      "  String? _selectedTypeId;",
      "  final _formKey = GlobalKey<FormState>();",
      "  final _nameController = TextEditingController();",
      "  final _typeController = TextEditingController();",
      "  final _notesController = TextEditingController();",
      "  List<String> _allergens = [];",
      "",
      "  bool _removable = true;",
      "  bool _supportsExtra = false;",
      "  bool _sidesAllowed = false;",
      "  bool _outOfStock = false;",
      "",
      "  bool _isSaving = false;",
      "",
      "  late final String _id;",
      "",
      "  final GlobalKey _formRootKey = GlobalKey();",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "",
      "    final data = widget.initialData;",
      "    final provider = context.read<IngredientMetadataProvider>();",
      "",
      "    // Stable ID for highlight mapping",
      "    _id = data?.id ?? '_new_${DateTime.now().millisecondsSinceEpoch}';",
      "",
      "    // 🔹 Register card-level key for section-level focus",
      "    provider.itemGlobalKeys[_id] ??= GlobalKey();",
      "",
      "    // Register highlight keys (only once)",
      "    provider.fieldGlobalKeys['$_id::name'] ??= GlobalKey();",
      "    provider.fieldGlobalKeys['$_id::typeId'] ??= GlobalKey();",
      "    provider.fieldGlobalKeys['$_id::notes'] ??= GlobalKey();",
      "    provider.fieldGlobalKeys['$_id::allergens'] ??= GlobalKey();",
      "",
      "    if (data != null) {",
      "      _nameController.text = data.name;",
      "      _typeController.text = data.type;",
      "      _selectedTypeId = data.typeId;",
      "      _notesController.text = data.notes ?? '';",
      "      _allergens = List.from(data.allergens);",
      "      _removable = data.removable;",
      "      _supportsExtra = data.supportsExtra;",
      "      _sidesAllowed = data.sidesAllowed;",
      "      _outOfStock = data.outOfStock;",
      "    }",
      "  }",
      "",
      "  @override",
      "  void dispose() {",
      "    _nameController.dispose();",
      "    _typeController.dispose();",
      "    _notesController.dispose();",
      "    super.dispose();",
      "  }",
      "",
      "  Future<void> _saveIngredient() async {",
      "    if (!_formKey.currentState!.validate()) return;",
      "",
      "    final ingredient = IngredientMetadata(",
      "      id: widget.initialData?.id ??",
      "          _nameController.text.trim().toLowerCase().replaceAll(' ', '_'),",
      "      name: _nameController.text.trim(),",
      "      type: _typeController.text.trim(),",
      "      notes: _notesController.text.trim().isEmpty",
      "          ? null",
      "          : _notesController.text.trim(),",
      "      allergens: _allergens,",
      "      removable: _removable,",
      "      supportsExtra: _supportsExtra,",
      "      sidesAllowed: _sidesAllowed,",
      "      outOfStock: _outOfStock,",
      "      upcharge: null,",
      "      imageUrl: null,",
      "      amountSelectable: false,",
      "      amountOptions: null,",
      "      typeId: _selectedTypeId,",
      "    );",
      "",
      "    try {",
      "      setState(() => _isSaving = true);",
      "",
      "      context.read<IngredientMetadataProvider>().updateIngredient(ingredient);",
      "",
      "      if (widget.onSaved != null) {",
      "        widget.onSaved!();",
      "      } else if (context.mounted) {",
      "        Navigator.of(context).pop();",
      "      }",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to update ingredient (local only): $e',",
      "        stack: stack.toString(),",
      "        source: 'IngredientFormCard',",
      "        screen: 'OnboardingIngredientsScreen',",
      "        severity: 'error',",
      "        contextData: {'ingredientName': ingredient.name},",
      "      );",
      "",
      "      if (widget.parentContext.mounted) {",
      "        ScaffoldMessenger.of(widget.parentContext).showSnackBar(",
      "          SnackBar(content: Text(widget.loc.errorSavingIngredient)),",
      "        );",
      "      }",
      "    } finally {",
      "      if (mounted) setState(() => _isSaving = false);",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final theme = Theme.of(context);",
      "    final loc = widget.loc;",
      "    final colorScheme = theme.colorScheme;",
      "    final ingredientTypes =",
      "        context.watch<IngredientTypeProvider>().ingredientTypes;",
      "    final provider = context.read<IngredientMetadataProvider>();",
      "",
      "    if (_selectedTypeId == null && ingredientTypes.isNotEmpty) {",
      "      _selectedTypeId = ingredientTypes.first.id;",
      "      _typeController.text = ingredientTypes.first.name;",
      "    }",
      "",
      "    return KeyedSubtree(",
      "        key: _formRootKey,",
      "        child: Dialog(",
      "          insetPadding:",
      "              const EdgeInsets.symmetric(horizontal: 40, vertical: 24),",
      "          shape:",
      "              RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),",
      "          child: ConstrainedBox(",
      "            constraints: const BoxConstraints(",
      "              maxWidth: 500,",
      "              maxHeight: 725,",
      "            ),",
      "            child: SingleChildScrollView(",
      "              padding: const EdgeInsets.all(16.0),",
      "              child: Form(",
      "                key: _formKey,",
      "                child: Column(",
      "                  mainAxisSize: MainAxisSize.min,",
      "                  children: [",
      "                    TextFormField(",
      "                      key: provider.fieldGlobalKeys['$_id::name'],",
      "                      controller: _nameController,",
      "                      decoration: InputDecoration(",
      "                        labelText: loc.ingredientName,",
      "                        border: const OutlineInputBorder(),",
      "                      ),",
      "                      validator: (value) => (value == null || value.isEmpty)",
      "                          ? loc.requiredField",
      "                          : null,",
      "                    ),",
      "                    const SizedBox(height: 12),",
      "                    DropdownButtonFormField<String>(",
      "                      key: provider.fieldGlobalKeys['$_id::typeId'],",
      "                      value: _selectedTypeId,",
      "                      isExpanded: true,",
      "                      decoration: InputDecoration(",
      "                        labelText: loc.ingredientType,",
      "                        border: const OutlineInputBorder(),",
      "                      ),",
      "                      items: ingredientTypes.map((type) {",
      "                        return DropdownMenuItem(",
      "                          value: type.id,",
      "                          child: Text(type.name),",
      "                        );",
      "                      }).toList(),",
      "                      validator: (val) =>",
      "                          val == null ? loc.requiredField : null,",
      "                      onChanged: (val) {",
      "                        setState(() {",
      "                          _selectedTypeId = val;",
      "                          final type = ingredientTypes.firstWhere(",
      "                            (t) => t.id == val,",
      "                            orElse: () => IngredientType(id: '', name: ''),",
      "                          );",
      "                          _typeController.text = type.name;",
      "                        });",
      "                      },",
      "                    ),",
      "                    const SizedBox(height: 12),",
      "                    IngredientTagSelector(",
      "                      key: provider.fieldGlobalKeys['$_id::allergens'],",
      "                      selectedTags: _allergens,",
      "                      onChanged: (tags) => setState(() => _allergens = tags),",
      "                      loc: loc,",
      "                    ),",
      "                    const SizedBox(height: 12),",
      "                    TextFormField(",
      "                      key: provider.fieldGlobalKeys['$_id::notes'],",
      "                      controller: _notesController,",
      "                      maxLines: 3,",
      "                      decoration: InputDecoration(",
      "                        labelText: loc.ingredientDescription,",
      "                        border: const OutlineInputBorder(),",
      "                      ),",
      "                    ),",
      "                    const SizedBox(height: 16),",
      "                    Wrap(",
      "                      spacing: 12,",
      "                      runSpacing: 8,",
      "                      children: [",
      "                        CheckboxListTile(",
      "                          value: _removable,",
      "                          onChanged: (v) =>",
      "                              setState(() => _removable = v ?? true),",
      "                          title: Text(loc.removable),",
      "                        ),",
      "                        CheckboxListTile(",
      "                          value: _supportsExtra,",
      "                          onChanged: (v) =>",
      "                              setState(() => _supportsExtra = v ?? false),",
      "                          title: Text(loc.supportsExtra),",
      "                        ),",
      "                        CheckboxListTile(",
      "                          value: _sidesAllowed,",
      "                          onChanged: (v) =>",
      "                              setState(() => _sidesAllowed = v ?? false),",
      "                          title: Text(loc.sidesAllowed),",
      "                        ),",
      "                        CheckboxListTile(",
      "                          value: _outOfStock,",
      "                          onChanged: (v) =>",
      "                              setState(() => _outOfStock = v ?? false),",
      "                          title: Text(loc.outOfStock),",
      "                        ),",
      "                      ],",
      "                    ),",
      "                    const SizedBox(height: 12),",
      "                    SizedBox(",
      "                      width: double.infinity,",
      "                      child: ElevatedButton(",
      "                        onPressed: _isSaving ? null : _saveIngredient,",
      "                        style: ElevatedButton.styleFrom(",
      "                          backgroundColor: DesignTokens.primaryColor,",
      "                          foregroundColor: Colors.white,",
      "                          padding: const EdgeInsets.symmetric(vertical: 12),",
      "                        ),",
      "                        child: _isSaving",
      "                            ? const CircularProgressIndicator(strokeWidth: 2)",
      "                            : Text(loc.saveIngredient),",
      "                      ),",
      "                    ),",
      "                  ],",
      "                ),",
      "              ),",
      "            ),",
      "          ),",
      "        ));",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 284,
      "file_size": 10891,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\widgets\\ingredients\\ingredient_list_tile.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/config/branding_config.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/models/ingredient_metadata.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/widgets/network_image_widget.dart';",
      "import 'ingredient_form_card.dart';",
      "",
      "class IngredientListTile extends StatelessWidget {",
      "  final IngredientMetadata ingredient;",
      "  final String franchiseId;",
      "  final VoidCallback onRefresh;",
      "  final VoidCallback? onEdited;",
      "",
      "  // New parameters for bulk select",
      "  final bool isSelectable;",
      "  final bool isSelected;",
      "  final ValueChanged<bool?>? onSelectChanged;",
      "",
      "  const IngredientListTile({",
      "    super.key,",
      "    required this.ingredient,",
      "    required this.franchiseId,",
      "    required this.onRefresh,",
      "    this.onEdited,",
      "    this.isSelectable = false,",
      "    this.isSelected = false,",
      "    this.onSelectChanged,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    try {",
      "      final theme = Theme.of(context);",
      "      final t = AppLocalizations.of(context)!;",
      "      final colorScheme = theme.colorScheme;",
      "      final firestore = context.read<FirestoreService>();",
      "",
      "      return Card(",
      "        elevation: 1,",
      "        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),",
      "        child: Padding(",
      "          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 10),",
      "          child: Row(",
      "            crossAxisAlignment: CrossAxisAlignment.center,",
      "            children: [",
      "              if (isSelectable)",
      "                Checkbox(",
      "                  value: isSelected,",
      "                  onChanged: onSelectChanged,",
      "                ),",
      "              ClipRRect(",
      "                borderRadius: BorderRadius.circular(8),",
      "                child: SizedBox(",
      "                  width: 64,",
      "                  height: 64,",
      "                  child: ingredient.imageUrl != null",
      "                      ? NetworkImageWidget(",
      "                          imageUrl: ingredient.imageUrl ?? '',",
      "                          fallbackAsset: BrandingConfig.defaultPizzaIcon,",
      "                          width: 64,",
      "                          height: 64,",
      "                        )",
      "                      : const Icon(Icons.fastfood,",
      "                          size: 28, color: Colors.grey),",
      "                ),",
      "              ),",
      "              const SizedBox(width: 12),",
      "              Expanded(",
      "                child: Column(",
      "                  crossAxisAlignment: CrossAxisAlignment.start,",
      "                  children: [",
      "                    Text(",
      "                      ingredient.name,",
      "                      style: theme.textTheme.bodyLarge?.copyWith(",
      "                        fontWeight: FontWeight.w600,",
      "                      ),",
      "                    ),",
      "                    const SizedBox(height: 4),",
      "                    Row(",
      "                      children: [",
      "                        if (ingredient.outOfStock)",
      "                          Container(",
      "                            padding: const EdgeInsets.symmetric(",
      "                                horizontal: 6, vertical: 2),",
      "                            decoration: BoxDecoration(",
      "                              color: Colors.red.withOpacity(0.12),",
      "                              borderRadius: BorderRadius.circular(6),",
      "                            ),",
      "                            child: Text(",
      "                              'Out of Stock',",
      "                              style: theme.textTheme.labelSmall?.copyWith(",
      "                                color: Colors.red[800],",
      "                                fontWeight: FontWeight.w500,",
      "                              ),",
      "                            ),",
      "                          ),",
      "                        if (ingredient.allergens.isNotEmpty)",
      "                          Padding(",
      "                            padding: const EdgeInsets.only(left: 8.0),",
      "                            child: Text(",
      "                              ingredient.allergens.join(', '),",
      "                              style: theme.textTheme.labelSmall?.copyWith(",
      "                                color: colorScheme.onSurfaceVariant,",
      "                              ),",
      "                            ),",
      "                          ),",
      "                      ],",
      "                    )",
      "                  ],",
      "                ),",
      "              ),",
      "              IconButton(",
      "                icon: const Icon(Icons.edit_outlined),",
      "                tooltip: t.edit,",
      "                onPressed: () {",
      "                  final loc = AppLocalizations.of(context);",
      "                  if (loc == null) {",
      "                    debugPrint(",
      "                        '[IngredientListTile] ERROR: loc is null when opening IngredientFormCard');",
      "                    return;",
      "                  }",
      "",
      "                  showDialog(",
      "                    context: context,",
      "                    builder: (dialogContext) {",
      "                      return Localizations.override(",
      "                        context: dialogContext,",
      "                        child: Builder(",
      "                          builder: (innerContext) {",
      "                            return IngredientFormCard(",
      "                              loc: loc,",
      "                              initialData: ingredient,",
      "                              onSaved: () {",
      "                                onRefresh();",
      "                                if (onEdited != null) onEdited!();",
      "                              },",
      "                              parentContext: context,",
      "                            );",
      "                          },",
      "                        ),",
      "                      );",
      "                    },",
      "                  );",
      "                },",
      "              ),",
      "              IconButton(",
      "                icon: const Icon(Icons.delete_outline),",
      "                tooltip: t.delete,",
      "                onPressed: () async {",
      "                  final confirm = await showDialog<bool>(",
      "                    context: context,",
      "                    builder: (context) => AlertDialog(",
      "                      title: Text(t.deleteIngredient),",
      "                      content: Text(t.confirmDeleteIngredient),",
      "                      actions: [",
      "                        TextButton(",
      "                          onPressed: () => Navigator.pop(context, false),",
      "                          child: Text(t.cancel),",
      "                        ),",
      "                        ElevatedButton(",
      "                          style: ElevatedButton.styleFrom(",
      "                            backgroundColor: DesignTokens.dangerColor,",
      "                          ),",
      "                          onPressed: () => Navigator.pop(context, true),",
      "                          child: Text(t.delete),",
      "                        ),",
      "                      ],",
      "                    ),",
      "                  );",
      "",
      "                  if (confirm == true) {",
      "                    try {",
      "                      await firestore.deleteIngredient(",
      "                        franchiseId: franchiseId,",
      "                        ingredientId: ingredient.id,",
      "                      );",
      "                      onRefresh();",
      "                    } catch (e, stack) {",
      "                      ErrorLogger.log(",
      "                        message: 'Failed to delete ingredient: $e',",
      "                        stack: stack.toString(),",
      "                        screen: 'IngredientListTile',",
      "                        source: 'deleteIngredientMetadata',",
      "                        contextData: {",
      "                          'ingredientId': ingredient.id,",
      "                          'franchiseId': franchiseId,",
      "                        },",
      "                      );",
      "                      ScaffoldMessenger.of(context).showSnackBar(",
      "                        SnackBar(content: Text(t.errorDeletingIngredient)),",
      "                      );",
      "                    }",
      "                  }",
      "                },",
      "              ),",
      "            ],",
      "          ),",
      "        ),",
      "      );",
      "    } catch (e, stack) {",
      "      print('[IngredientListTile] FATAL build error: $e\\n$stack');",
      "      return Center(",
      "          child: Text('Build error in IngredientListTile: $e\\n$stack'));",
      "    }",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 210,
      "file_size": 8399,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\widgets\\ingredients\\ingredient_metadata_json_import_export_dialog.dart",
    "content": [
      "// lib/admin/dashboard/onboarding/widgets/ingredients/ingredient_metadata_json_import_export_dialog.dart",
      "",
      "import 'dart:convert';",
      "",
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/schema_templates.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/models/ingredient_metadata.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/ingredient_metadata_provider.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/widgets/scrolling_json_editor.dart';",
      "import 'package:franchise_admin_portal/core/providers/ingredient_type_provider.dart';",
      "import 'ingredient_metadata_json_preview_table.dart';",
      "",
      "class IngredientMetadataJsonImportExportDialog extends StatefulWidget {",
      "  final AppLocalizations loc;",
      "",
      "  const IngredientMetadataJsonImportExportDialog({",
      "    super.key,",
      "    required this.loc,",
      "  });",
      "",
      "  static Future<void> show(",
      "      BuildContext context, IngredientMetadataProvider provider) async {",
      "    final loc = AppLocalizations.of(context);",
      "    final typeProvider = context.read<IngredientTypeProvider>();",
      "",
      "    if (loc == null) {",
      "      debugPrint(",
      "          '[IngredientMetadataJsonImportExportDialog] ERROR: loc is null!');",
      "      return;",
      "    }",
      "",
      "    await showGeneralDialog(",
      "      context: context,",
      "      barrierDismissible: true,",
      "      barrierLabel: 'Import Export Ingredient Metadata',",
      "      transitionDuration: const Duration(milliseconds: 200),",
      "      pageBuilder: (ctx, _, __) {",
      "        return Localizations.override(",
      "          context: ctx,",
      "          child: ChangeNotifierProvider<IngredientTypeProvider>.value(",
      "            value: typeProvider,",
      "            child: ChangeNotifierProvider<IngredientMetadataProvider>.value(",
      "              value: provider,",
      "              child: Center(",
      "                child: Material(",
      "                  color: Colors.transparent,",
      "                  child: SizedBox(",
      "                    width: 1400,",
      "                    height: 680,",
      "                    child: IngredientMetadataJsonImportExportDialog(loc: loc!),",
      "                  ),",
      "                ),",
      "              ),",
      "            ),",
      "          ),",
      "        );",
      "      },",
      "    );",
      "  }",
      "",
      "  @override",
      "  State<IngredientMetadataJsonImportExportDialog> createState() =>",
      "      _IngredientMetadataJsonImportExportDialogState();",
      "}",
      "",
      "class _IngredientMetadataJsonImportExportDialogState",
      "    extends State<IngredientMetadataJsonImportExportDialog> {",
      "  late TextEditingController _jsonController;",
      "  late final ScrollController _jsonEditorScrollController;",
      "  late final ScrollController _previewTableScrollController;",
      "  String? _errorMessage;",
      "  List<IngredientMetadata>? _previewIngredients;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    final formattedJson = const JsonEncoder.withIndent('  ')",
      "        .convert(pizzaShopIngredientMetadataTemplate);",
      "    _jsonController = TextEditingController(text: formattedJson);",
      "    _jsonEditorScrollController = ScrollController();",
      "    _previewTableScrollController = ScrollController();",
      "    _parsePreview();",
      "  }",
      "",
      "  @override",
      "  void dispose() {",
      "    _jsonController.dispose();",
      "    _jsonEditorScrollController.dispose();",
      "    _previewTableScrollController.dispose();",
      "    super.dispose();",
      "  }",
      "",
      "  List<IngredientMetadata>? _tryParseJson(String val) {",
      "    try {",
      "      final decoded = json.decode(val);",
      "      if (decoded is! List) return null;",
      "      return decoded.map((e) => IngredientMetadata.fromMap(e)).toList();",
      "    } catch (e, stack) {",
      "      ErrorLogger.log(",
      "        message:",
      "            'Error parsing preview JSON in ingredient_metadata_json_import_export_dialog.dart',",
      "        source: 'ingredient_metadata_json_import_export_dialog.dart',",
      "        severity: 'warning',",
      "        screen: 'onboarding_ingredients_screen',",
      "        stack: stack.toString(),",
      "        contextData: {'input': val},",
      "      );",
      "      return null;",
      "    }",
      "  }",
      "",
      "  void _parsePreview() {",
      "    try {",
      "      setState(() {",
      "        _errorMessage = null;",
      "        final decoded = jsonDecode(_jsonController.text);",
      "        if (decoded is! List) {",
      "          _errorMessage = widget.loc.invalidJsonFormat;",
      "          _previewIngredients = null;",
      "          return;",
      "        }",
      "        _previewIngredients =",
      "            decoded.map((e) => IngredientMetadata.fromMap(e)).toList();",
      "        print(",
      "            '[Dialog] Parsed ${_previewIngredients!.length} preview ingredients');",
      "      });",
      "    } catch (e, stack) {",
      "      setState(() => _previewIngredients = null);",
      "      print('[Dialog] JSON parse error');",
      "      ErrorLogger.log(",
      "        message: 'JSON import preview parse error',",
      "        source: 'ingredient_metadata_json_import_export_dialog.dart',",
      "        severity: 'warning',",
      "        screen: 'onboarding_ingredients_screen',",
      "        stack: stack.toString(),",
      "        contextData: {'input': _jsonController.text},",
      "      );",
      "      setState(() {",
      "        _errorMessage = widget.loc.jsonParseError;",
      "      });",
      "    }",
      "  }",
      "",
      "  Future<void> _saveImport() async {",
      "    print('[Dialog] _saveImport called');",
      "    final loc = widget.loc;",
      "    final franchiseId = context.read<FranchiseProvider>().franchiseId;",
      "    print('[Dialog] got franchiseId: $franchiseId');",
      "    final provider = context.read<IngredientMetadataProvider>();",
      "    print('[Dialog] got provider hashCode: ${provider.hashCode}');",
      "",
      "    if (_previewIngredients == null || franchiseId.isEmpty) {",
      "      print('[Dialog] _saveImport exit: no preview or empty franchiseId');",
      "      return;",
      "    }",
      "",
      "    try {",
      "      final firestore = context.read<FirestoreService>();",
      "      print('[Dialog] got firestore');",
      "      final validTypeIds = await firestore.fetchIngredientTypeIds(franchiseId);",
      "      print('[Dialog] validTypeIds: $validTypeIds');",
      "",
      "      final invalidIngredients = _previewIngredients!.where((ingredient) {",
      "        return ingredient.typeId == null ||",
      "            !validTypeIds.contains(ingredient.typeId);",
      "      }).toList();",
      "      print('[Dialog] found invalid ingredients: $invalidIngredients');",
      "",
      "      if (invalidIngredients.isNotEmpty) {",
      "        final badIds = invalidIngredients.map((e) => e.id).join(', ');",
      "        // List available typeIds",
      "        final typeList = validTypeIds.isEmpty",
      "            ? '(none found for this franchise)'",
      "            : validTypeIds.join(', ');",
      "        setState(() {",
      "          _errorMessage = '${widget.loc.invalidTypeIdError}: $badIds\\n'",
      "              'Available typeIds: $typeList';",
      "        });",
      "        print('[Dialog] Exiting, invalid ingredients');",
      "        return;",
      "      }",
      "",
      "      print(",
      "          '[Dialog] Provider before calling bulkReplaceIngredientMetadata hashCode: ${provider.hashCode}');",
      "      await provider.bulkReplaceIngredientMetadata(",
      "          franchiseId, _previewIngredients!);",
      "",
      "      print('[Dialog] Called bulkReplaceIngredientMetadata');",
      "",
      "      if (mounted) {",
      "        Navigator.of(context).pop();",
      "        print('[Dialog] Navigator.pop called');",
      "      }",
      "    } catch (e, stack) {",
      "      print('[Dialog] Caught exception: $e');",
      "      await ErrorLogger.log(",
      "        message: 'Failed to save imported ingredient metadata',",
      "        source: 'ingredient_metadata_json_import_export_dialog.dart',",
      "        severity: 'error',",
      "        screen: 'onboarding_ingredients_screen',",
      "        stack: stack.toString(),",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      if (mounted) {",
      "        ScaffoldMessenger.of(context).showSnackBar(",
      "          SnackBar(content: Text(widget.loc.errorGeneric)),",
      "        );",
      "      }",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = widget.loc;",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "",
      "    return Dialog(",
      "      insetPadding: const EdgeInsets.all(24),",
      "      child: SizedBox(",
      "        width: 1400,",
      "        height: 680,",
      "        child: Column(",
      "          children: [",
      "            AppBar(",
      "              title: Text(widget.loc.importExportIngredientMetadata),",
      "              backgroundColor: colorScheme.primary,",
      "              foregroundColor: Colors.white,",
      "              automaticallyImplyLeading: false,",
      "              elevation: 0,",
      "              actions: [",
      "                IconButton(",
      "                  onPressed: () => Navigator.of(context).pop(),",
      "                  icon: const Icon(Icons.close),",
      "                ),",
      "              ],",
      "            ),",
      "            Expanded(",
      "              child: Padding(",
      "                padding: const EdgeInsets.all(24),",
      "                child: Row(",
      "                  crossAxisAlignment: CrossAxisAlignment.start,",
      "                  children: [",
      "                    // JSON Editor Column",
      "                    Expanded(",
      "                      flex: 6,",
      "                      child: Column(",
      "                        crossAxisAlignment: CrossAxisAlignment.start,",
      "                        children: [",
      "                          Text(widget.loc.editJsonBelow,",
      "                              style: theme.textTheme.titleMedium),",
      "                          const SizedBox(height: 8),",
      "                          Expanded(",
      "                            child: Scrollbar(",
      "                              controller: _jsonEditorScrollController,",
      "                              thumbVisibility: true,",
      "                              child: TextField(",
      "                                controller: _jsonController,",
      "                                scrollController: _jsonEditorScrollController,",
      "                                maxLines: null,",
      "                                style: theme.textTheme.bodyMedium,",
      "                                decoration: const InputDecoration.collapsed(",
      "                                  hintText: '{ \"key\": \"value\" }',",
      "                                ),",
      "                                onChanged: (val) {",
      "                                  setState(() {",
      "                                    _jsonController.text = val;",
      "                                    _parsePreview();",
      "                                  });",
      "                                },",
      "                              ),",
      "                            ),",
      "                          ),",
      "                          if (_errorMessage != null) ...[",
      "                            const SizedBox(height: 6),",
      "                            Text(",
      "                              _errorMessage!,",
      "                              style: theme.textTheme.bodySmall?.copyWith(",
      "                                color: colorScheme.error,",
      "                              ),",
      "                            ),",
      "                          ],",
      "                        ],",
      "                      ),",
      "                    ),",
      "                    const SizedBox(width: 24),",
      "                    // Preview Table Column",
      "                    Expanded(",
      "                      flex: 6,",
      "                      child: Column(",
      "                        crossAxisAlignment: CrossAxisAlignment.start,",
      "                        children: [",
      "                          Text(widget.loc.preview,",
      "                              style: theme.textTheme.titleMedium),",
      "                          const SizedBox(height: 8),",
      "                          Expanded(",
      "                            child: IngredientMetadataJsonPreviewTable(",
      "                              rawJson: _jsonController.text,",
      "                              previewIngredients: _previewIngredients,",
      "                              loc: widget.loc,",
      "                              scrollController: _previewTableScrollController,",
      "                            ),",
      "                          )",
      "                        ],",
      "                      ),",
      "                    ),",
      "                  ],",
      "                ),",
      "              ),",
      "            ),",
      "            Padding(",
      "              padding: const EdgeInsets.symmetric(horizontal: 24),",
      "              child: Row(",
      "                mainAxisAlignment: MainAxisAlignment.end,",
      "                children: [",
      "                  TextButton(",
      "                    onPressed: () => Navigator.of(context).pop(),",
      "                    child: Text(widget.loc.cancel),",
      "                  ),",
      "                  const SizedBox(width: 12),",
      "                  ElevatedButton(",
      "                    onPressed: _previewIngredients != null",
      "                        ? () {",
      "                            print('[Dialog] Import button pressed');",
      "                            _saveImport();",
      "                          }",
      "                        : null,",
      "                    child: Text(widget.loc.importChanges),",
      "                  ),",
      "                ],",
      "              ),",
      "            ),",
      "            const SizedBox(height: 12),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 345,
      "file_size": 13052,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\widgets\\ingredients\\ingredient_metadata_json_preview_table.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/models/ingredient_metadata.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "",
      "class IngredientMetadataJsonPreviewTable extends StatelessWidget {",
      "  final String rawJson;",
      "  final List<IngredientMetadata>? previewIngredients;",
      "  final AppLocalizations loc;",
      "  final ScrollController? scrollController;",
      "",
      "  const IngredientMetadataJsonPreviewTable({",
      "    super.key,",
      "    required this.rawJson,",
      "    required this.previewIngredients,",
      "    required this.loc,",
      "    this.scrollController,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "",
      "    if (rawJson.trim().isEmpty) {",
      "      return Center(",
      "        child: Text(",
      "          loc.noDataToPreview,",
      "          style: theme.textTheme.bodyMedium,",
      "        ),",
      "      );",
      "    }",
      "",
      "    if (previewIngredients == null) {",
      "      return Center(",
      "        child: Text(",
      "          loc.invalidJsonFormat,",
      "          style: theme.textTheme.bodyMedium?.copyWith(color: colorScheme.error),",
      "        ),",
      "      );",
      "    }",
      "",
      "    if (previewIngredients!.isEmpty) {",
      "      return Center(",
      "        child: Text(",
      "          loc.noIngredientsFound,",
      "          style: theme.textTheme.bodyMedium,",
      "        ),",
      "      );",
      "    }",
      "",
      "    return Scrollbar(",
      "      controller: scrollController,",
      "      thumbVisibility: true,",
      "      child: SingleChildScrollView(",
      "        controller: scrollController,",
      "        scrollDirection: Axis.horizontal,",
      "        child: DataTable(",
      "          columnSpacing: 24,",
      "          headingRowColor: MaterialStateProperty.all(",
      "            colorScheme.surfaceVariant.withOpacity(0.3),",
      "          ),",
      "          columns: [",
      "            DataColumn(",
      "              label: Text(",
      "                loc.ingredientName,",
      "                style: theme.textTheme.labelLarge?.copyWith(",
      "                  fontWeight: FontWeight.bold,",
      "                ),",
      "              ),",
      "            ),",
      "            DataColumn(",
      "              label: Text(",
      "                loc.ingredientType,",
      "                style: theme.textTheme.labelLarge?.copyWith(",
      "                  fontWeight: FontWeight.bold,",
      "                ),",
      "              ),",
      "            ),",
      "            DataColumn(",
      "              label: Text(",
      "                loc.allergens,",
      "                style: theme.textTheme.labelLarge?.copyWith(",
      "                  fontWeight: FontWeight.bold,",
      "                ),",
      "              ),",
      "            ),",
      "            DataColumn(",
      "              label: Text(",
      "                loc.removable,",
      "                style: theme.textTheme.labelLarge?.copyWith(",
      "                  fontWeight: FontWeight.bold,",
      "                ),",
      "              ),",
      "              numeric: false,",
      "            ),",
      "            DataColumn(",
      "              label: Text(",
      "                loc.outOfStock,",
      "                style: theme.textTheme.labelLarge?.copyWith(",
      "                  fontWeight: FontWeight.bold,",
      "                ),",
      "              ),",
      "              numeric: false,",
      "            ),",
      "          ],",
      "          rows: previewIngredients!.map((ingredient) {",
      "            final allergensStr = ingredient.allergens.isNotEmpty",
      "                ? ingredient.allergens.map((a) => a.toUpperCase()).join(', ')",
      "                : loc.none;",
      "",
      "            return DataRow(",
      "              cells: [",
      "                DataCell(Text(ingredient.name)),",
      "                DataCell(Text(ingredient.type)),",
      "                DataCell(Text(allergensStr)),",
      "                DataCell(",
      "                  Icon(",
      "                    ingredient.removable ? Icons.check_circle : Icons.cancel,",
      "                    color: ingredient.removable ? Colors.green : Colors.red,",
      "                  ),",
      "                ),",
      "                DataCell(",
      "                  Icon(",
      "                    ingredient.outOfStock ? Icons.cancel : Icons.check_circle,",
      "                    color: ingredient.outOfStock ? Colors.red : Colors.green,",
      "                  ),",
      "                ),",
      "              ],",
      "            );",
      "          }).toList(),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 136,
      "file_size": 4199,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\widgets\\ingredients\\ingredient_metadata_template_picker_dialog.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/ingredient_metadata_provider.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/onboarding_progress_provider.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/core/models/ingredient_metadata.dart';",
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "",
      "class IngredientMetadataTemplatePickerDialog extends StatefulWidget {",
      "  final AppLocalizations loc;",
      "",
      "  const IngredientMetadataTemplatePickerDialog({super.key, required this.loc});",
      "",
      "  static Future<List<IngredientMetadata>?> show(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      debugPrint(",
      "          '[IngredientMetadataTemplatePickerDialog] ERROR: loc is null!');",
      "      return Future.value();",
      "    }",
      "",
      "    return showDialog<List<IngredientMetadata>>(",
      "      context: context,",
      "      builder: (dialogContext) {",
      "        return IngredientMetadataTemplatePickerDialog(loc: loc);",
      "      },",
      "    );",
      "  }",
      "",
      "  @override",
      "  State<IngredientMetadataTemplatePickerDialog> createState() =>",
      "      _IngredientMetadataTemplatePickerDialogState();",
      "}",
      "",
      "class _IngredientMetadataTemplatePickerDialogState",
      "    extends State<IngredientMetadataTemplatePickerDialog> {",
      "  bool _loading = false;",
      "",
      "  Future<void> _loadTemplate(String templateId) async {",
      "    final loc = widget.loc;",
      "    final franchiseId = context.read<FranchiseProvider>().franchiseId;",
      "",
      "    if (franchiseId.isEmpty || franchiseId == 'unknown') {",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(content: Text(loc.selectAFranchiseFirst)),",
      "      );",
      "      return;",
      "    }",
      "",
      "    setState(() => _loading = true);",
      "",
      "    try {",
      "      // Fetch template data directly, DO NOT inject to provider here",
      "      final snapshot = await FirebaseFirestore.instance",
      "          .collection('onboarding_templates')",
      "          .doc(templateId)",
      "          .collection('ingredient_metadata')",
      "          .get();",
      "",
      "      final newItems = snapshot.docs",
      "          .map((doc) => IngredientMetadata.fromMap(doc.data()))",
      "          .toList();",
      "",
      "      if (context.mounted) {",
      "        Navigator.of(context).pop(newItems); // Return result!",
      "        ScaffoldMessenger.of(context).showSnackBar(",
      "          SnackBar(content: Text(loc.templateLoadedSuccessfully)),",
      "        );",
      "      }",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'ingredient_metadata_template_load_failed',",
      "        stack: stack.toString(),",
      "        screen: 'onboarding_ingredients_screen',",
      "        source: 'IngredientMetadataTemplatePickerDialog',",
      "        severity: 'error',",
      "        contextData: {",
      "          'templateId': templateId,",
      "          'franchiseId': franchiseId,",
      "        },",
      "      );",
      "      if (context.mounted) {",
      "        ScaffoldMessenger.of(context).showSnackBar(",
      "          SnackBar(content: Text(loc.errorGeneric)),",
      "        );",
      "      }",
      "    } finally {",
      "      if (mounted) setState(() => _loading = false);",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    try {",
      "      final p = Provider.of<IngredientMetadataProvider>(context, listen: false);",
      "      print(",
      "          '[IngredientMetadataTemplatePickerDialog] build() provider hashCode=${p.hashCode}');",
      "    } catch (e) {",
      "      print('[IngredientMetadataTemplatePickerDialog] build() NO PROVIDER: $e');",
      "    }",
      "    final loc = widget.loc;",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "",
      "    return AlertDialog(",
      "      backgroundColor: DesignTokens.surfaceColor,",
      "      titlePadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),",
      "      title: Row(",
      "        children: [",
      "          Icon(Icons.library_add, color: colorScheme.primary),",
      "          const SizedBox(width: 8),",
      "          Text(",
      "            loc.selectIngredientTemplate,",
      "            style: theme.textTheme.titleMedium?.copyWith(",
      "              color: colorScheme.onSurface,",
      "              fontWeight: FontWeight.w600,",
      "            ),",
      "          ),",
      "        ],",
      "      ),",
      "      contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),",
      "      content: _loading",
      "          ? const Center(child: CircularProgressIndicator())",
      "          : Column(",
      "              mainAxisSize: MainAxisSize.min,",
      "              children: [",
      "                _buildTemplateTile(",
      "                  id: 'pizzeria',",
      "                  icon: '🍕',",
      "                  label: loc.pizzaShopTemplateLabel,",
      "                  subtitle: loc.pizzaShopTemplateSubtitle,",
      "                ),",
      "                const SizedBox(height: 12),",
      "                _buildTemplateTile(",
      "                  id: 'wing_bar',",
      "                  icon: '🍗',",
      "                  label: loc.wingBarTemplateLabel,",
      "                  subtitle: loc.wingBarTemplateSubtitle,",
      "                  enabled: false,",
      "                ),",
      "              ],",
      "            ),",
      "      actions: [",
      "        TextButton(",
      "          onPressed: () => Navigator.of(context).pop(),",
      "          child: Text(loc.cancel),",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "",
      "  Widget _buildTemplateTile({",
      "    required String id,",
      "    required String icon,",
      "    required String label,",
      "    required String subtitle,",
      "    bool enabled = true,",
      "  }) {",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "",
      "    return ListTile(",
      "      enabled: enabled,",
      "      tileColor: enabled",
      "          ? colorScheme.surfaceVariant.withOpacity(0.2)",
      "          : Colors.grey.withOpacity(0.1),",
      "      leading: Text(icon, style: const TextStyle(fontSize: 28)),",
      "      title: Text(",
      "        label,",
      "        style: theme.textTheme.titleSmall?.copyWith(",
      "          fontWeight: FontWeight.w600,",
      "        ),",
      "      ),",
      "      subtitle: Text(subtitle, style: theme.textTheme.bodySmall),",
      "      onTap: enabled ? () => _loadTemplate(id) : null,",
      "    );",
      "  }",
      "",
      "  @override",
      "  void dispose() {",
      "    print('[Ingredient metadata template picker dialog] DISPOSED');",
      "    super.dispose();",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 188,
      "file_size": 6386,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\widgets\\ingredients\\ingredient_tag_selector.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "",
      "/// A chip selector widget for choosing ingredient tags (e.g., allergens, dietary flags).",
      "/// Used in onboarding or editing IngredientMetadata.",
      "/// Fully compatible with highlight scrolling via `fieldGlobalKeys`.",
      "class IngredientTagSelector extends StatelessWidget {",
      "  final List<String> selectedTags;",
      "  final ValueChanged<List<String>> onChanged;",
      "  final AppLocalizations loc;",
      "",
      "  const IngredientTagSelector({",
      "    Key? key,",
      "    required this.selectedTags,",
      "    required this.onChanged,",
      "    required this.loc,",
      "  }) : super(key: key);",
      "",
      "  /// Centralized master tag list for allergens/dietary markers.",
      "  /// Keep consistent with backend schema.",
      "  static const List<String> _allTags = [",
      "    'dairy',",
      "    'gluten',",
      "    'nuts',",
      "    'soy',",
      "    'eggs',",
      "    'fish',",
      "    'shellfish',",
      "    'vegan',",
      "    'vegetarian',",
      "    'halal',",
      "    'kosher',",
      "    'sugar_free',",
      "    'low_sodium',",
      "    'spicy',",
      "    'organic',",
      "  ];",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        Text(",
      "          loc.allergenTags,",
      "          style: theme.textTheme.titleSmall?.copyWith(",
      "            fontWeight: FontWeight.w600,",
      "            color: colorScheme.onSurface,",
      "          ),",
      "        ),",
      "        const SizedBox(height: 8),",
      "        Wrap(",
      "          spacing: 8,",
      "          runSpacing: 8,",
      "          children: _allTags.map((tag) {",
      "            final isSelected = selectedTags.contains(tag);",
      "            return Tooltip(",
      "              message: _localizedTagDescription(tag, loc),",
      "              waitDuration: const Duration(milliseconds: 400),",
      "              child: FilterChip(",
      "                label: Text(",
      "                  _formatTagLabel(tag),",
      "                  style: TextStyle(",
      "                    color: isSelected",
      "                        ? colorScheme.onPrimary",
      "                        : colorScheme.onSurface,",
      "                  ),",
      "                ),",
      "                selected: isSelected,",
      "                onSelected: (selected) {",
      "                  final updatedTags = List<String>.from(selectedTags);",
      "                  if (selected) {",
      "                    if (!updatedTags.contains(tag)) {",
      "                      updatedTags.add(tag);",
      "                    }",
      "                  } else {",
      "                    updatedTags.remove(tag);",
      "                  }",
      "                  onChanged(updatedTags);",
      "                },",
      "                selectedColor: DesignTokens.primaryColor,",
      "                backgroundColor: colorScheme.surfaceVariant,",
      "                shape: RoundedRectangleBorder(",
      "                  borderRadius: BorderRadius.circular(16),",
      "                ),",
      "              ),",
      "            );",
      "          }).toList(),",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "",
      "  /// Formats a tag into a human-friendly label.",
      "  String _formatTagLabel(String tag) {",
      "    return tag.replaceAll('_', ' ').toUpperCase();",
      "  }",
      "",
      "  /// Provides a localized description for tooltips, fallback to formatted label.",
      "  String _localizedTagDescription(String tag, AppLocalizations loc) {",
      "    switch (tag) {",
      "      case 'dairy':",
      "        return loc.tagDairyDescription;",
      "      case 'gluten':",
      "        return loc.tagGlutenDescription;",
      "      case 'nuts':",
      "        return loc.tagNutsDescription;",
      "      case 'soy':",
      "        return loc.tagSoyDescription;",
      "      case 'eggs':",
      "        return loc.tagEggsDescription;",
      "      case 'fish':",
      "        return loc.tagFishDescription;",
      "      case 'shellfish':",
      "        return loc.tagShellfishDescription;",
      "      case 'vegan':",
      "        return loc.tagVeganDescription;",
      "      case 'vegetarian':",
      "        return loc.tagVegetarianDescription;",
      "      case 'halal':",
      "        return loc.tagHalalDescription;",
      "      case 'kosher':",
      "        return loc.tagKosherDescription;",
      "      case 'sugar_free':",
      "        return loc.tagSugarFreeDescription;",
      "      case 'low_sodium':",
      "        return loc.tagLowSodiumDescription;",
      "      case 'spicy':",
      "        return loc.tagSpicyDescription;",
      "      case 'organic':",
      "        return loc.tagOrganicDescription;",
      "      default:",
      "        return _formatTagLabel(tag);",
      "    }",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 140,
      "file_size": 4397,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\widgets\\ingredients\\ingredient_type_json_import_export_dialog.dart",
    "content": [
      "// lib/admin/dashboard/onboarding/widgets/ingredients/ingredient_type_json_import_export_dialog.dart",
      "",
      "import 'dart:convert';",
      "",
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/models/ingredient_type_model.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/ingredient_type_provider.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/core/utils/schema_templates.dart';",
      "import 'package:franchise_admin_portal/widgets/scrolling_json_editor.dart';",
      "",
      "import 'ingredient_type_json_preview_table.dart';",
      "",
      "class IngredientTypeJsonImportExportDialog extends StatefulWidget {",
      "  final AppLocalizations loc;",
      "",
      "  const IngredientTypeJsonImportExportDialog({super.key, required this.loc});",
      "",
      "  static Future<void> show(",
      "      BuildContext context, IngredientTypeProvider provider) async {",
      "    final loc = AppLocalizations.of(context);",
      "    print(",
      "        '[IngredientTypeJsonImportExportDialog] show() called with loc: $loc');",
      "",
      "    if (loc == null) {",
      "      print(",
      "          '[IngredientTypeJsonImportExportDialog] ERROR: AppLocalizations is null!');",
      "      return;",
      "    }",
      "",
      "    await showGeneralDialog(",
      "      context: context,",
      "      barrierDismissible: true,",
      "      barrierLabel: 'Import Export Ingredient Types',",
      "      transitionDuration: const Duration(milliseconds: 200),",
      "      pageBuilder: (_, __, ___) {",
      "        return Localizations.override(",
      "          context: context,",
      "          child: ChangeNotifierProvider<IngredientTypeProvider>.value(",
      "            value: provider,",
      "            child: Builder(",
      "              builder: (innerContext) {",
      "                return Center(",
      "                  child: Material(",
      "                    color: Colors.transparent,",
      "                    child: SizedBox(",
      "                      width: 1400,",
      "                      height: 680,",
      "                      child: IngredientTypeJsonImportExportDialog(loc: loc),",
      "                    ),",
      "                  ),",
      "                );",
      "              },",
      "            ),",
      "          ),",
      "        );",
      "      },",
      "    );",
      "  }",
      "",
      "  @override",
      "  State<IngredientTypeJsonImportExportDialog> createState() =>",
      "      _IngredientTypeJsonImportExportDialogState();",
      "}",
      "",
      "class _IngredientTypeJsonImportExportDialogState",
      "    extends State<IngredientTypeJsonImportExportDialog> {",
      "  late TextEditingController _jsonController;",
      "  String? _errorMessage;",
      "  List<IngredientType>? _previewTypes;",
      "  late String _jsonInput;",
      "  List<IngredientType>? _parsedPreview;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "",
      "    // Load the hardcoded template from schema_templates.dart as JSON string",
      "    final formattedJson = const JsonEncoder.withIndent('  ')",
      "        .convert(pizzaShopIngredientTypesTemplate);",
      "",
      "    _jsonInput = formattedJson;",
      "    _jsonController = TextEditingController(text: _jsonInput);",
      "    _parsePreview();",
      "  }",
      "",
      "  List<IngredientType>? _tryParseJson(String val) {",
      "    try {",
      "      final decoded = json.decode(val);",
      "      if (decoded is! List) return null;",
      "      return decoded.map((e) => IngredientType.fromMap(e)).toList();",
      "    } catch (e, stack) {",
      "      ErrorLogger.log(",
      "        message: 'Error parsing preview JSON in dialog',",
      "        source: 'ingredient_type_json_import_export_dialog.dart',",
      "        severity: 'warning',",
      "        screen: 'ingredient_type_management_screen',",
      "        stack: stack.toString(),",
      "        contextData: {'input': val},",
      "      );",
      "      return null;",
      "    }",
      "  }",
      "",
      "  void _parsePreview() {",
      "    try {",
      "      setState(() {",
      "        _errorMessage = null;",
      "        final decoded = jsonDecode(_jsonController.text);",
      "        if (decoded is! List) {",
      "          _errorMessage = widget.loc.invalidJsonFormat;",
      "          _previewTypes = null;",
      "          return;",
      "        }",
      "        _previewTypes = decoded.map((e) => IngredientType.fromMap(e)).toList();",
      "      });",
      "    } catch (e, stack) {",
      "      setState(() => _previewTypes = null);",
      "      ErrorLogger.log(",
      "        message: 'JSON import preview parse error',",
      "        source: 'ingredient_type_json_import_export_dialog.dart',",
      "        severity: 'warning',",
      "        screen: 'ingredient_type_management_screen',",
      "        stack: stack.toString(),",
      "        contextData: {",
      "          'input': _jsonController.text,",
      "        },",
      "      );",
      "      setState(() {",
      "        _errorMessage = widget.loc.jsonParseError;",
      "      });",
      "    }",
      "  }",
      "",
      "  Future<void> _saveImport() async {",
      "    final loc = widget.loc;",
      "    final franchiseId = context.read<FranchiseProvider>().franchiseId;",
      "    final provider = context.read<IngredientTypeProvider>();",
      "",
      "    if (_previewTypes == null || franchiseId.isEmpty) return;",
      "",
      "    try {",
      "      await provider.bulkReplaceIngredientTypes(franchiseId, _previewTypes!);",
      "      if (mounted) Navigator.of(context).pop();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to save imported ingredient types',",
      "        source: 'ingredient_type_json_import_export_dialog.dart',",
      "        severity: 'error',",
      "        screen: 'ingredient_type_management_screen',",
      "        stack: stack.toString(),",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "        },",
      "      );",
      "      if (mounted) {",
      "        ScaffoldMessenger.of(context).showSnackBar(",
      "          SnackBar(content: Text(loc.errorGeneric)),",
      "        );",
      "      }",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = widget.loc;",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    final theme = Theme.of(context);",
      "",
      "    return Dialog(",
      "      insetPadding: const EdgeInsets.all(24),",
      "      child: SizedBox(",
      "        width: 1400, // Wider panel",
      "        height: 680,",
      "        child: Column(",
      "          children: [",
      "            AppBar(",
      "              title: Text(loc.importExportIngredientTypes),",
      "              backgroundColor: colorScheme.primary,",
      "              foregroundColor: Colors.white,",
      "              automaticallyImplyLeading: false,",
      "              elevation: 0,",
      "              actions: [",
      "                IconButton(",
      "                  onPressed: () => Navigator.of(context).pop(),",
      "                  icon: const Icon(Icons.close),",
      "                ),",
      "              ],",
      "            ),",
      "            Expanded(",
      "              child: Padding(",
      "                padding: const EdgeInsets.all(24),",
      "                child: Row(",
      "                  crossAxisAlignment: CrossAxisAlignment.start,",
      "                  children: [",
      "                    // JSON Editor Column",
      "                    Expanded(",
      "                      flex: 6,",
      "                      child: Column(",
      "                        crossAxisAlignment: CrossAxisAlignment.start,",
      "                        children: [",
      "                          Text(loc.editJsonBelow,",
      "                              style: theme.textTheme.titleMedium),",
      "                          const SizedBox(height: 8),",
      "                          Expanded(",
      "                            child: ScrollingJsonEditor(",
      "                              initialJson: _jsonController.text,",
      "                              onChanged: (val) {",
      "                                setState(() {",
      "                                  _jsonController.text = val;",
      "                                  _parsePreview();",
      "                                });",
      "                              },",
      "                              loc: loc,",
      "                            ),",
      "                          ),",
      "                        ],",
      "                      ),",
      "                    ),",
      "                    const SizedBox(width: 24),",
      "                    // Preview Table Column",
      "                    Expanded(",
      "                      flex: 6,",
      "                      child: Column(",
      "                        crossAxisAlignment: CrossAxisAlignment.start,",
      "                        children: [",
      "                          Text(loc.preview, style: theme.textTheme.titleMedium),",
      "                          const SizedBox(height: 8),",
      "                          Expanded(",
      "                            child: Scrollbar(",
      "                              thumbVisibility: true,",
      "                              child: SingleChildScrollView(",
      "                                child: IngredientTypeJsonPreviewTable(",
      "                                  rawJson: _jsonController.text,",
      "                                  previewTypes: _previewTypes,",
      "                                ),",
      "                              ),",
      "                            ),",
      "                          ),",
      "                        ],",
      "                      ),",
      "                    ),",
      "                  ],",
      "                ),",
      "              ),",
      "            ),",
      "            Padding(",
      "              padding: const EdgeInsets.symmetric(horizontal: 24),",
      "              child: Row(",
      "                mainAxisAlignment: MainAxisAlignment.end,",
      "                children: [",
      "                  TextButton(",
      "                    onPressed: () => Navigator.of(context).pop(),",
      "                    child: Text(loc.cancel),",
      "                  ),",
      "                  const SizedBox(width: 12),",
      "                  ElevatedButton(",
      "                    onPressed: _previewTypes != null ? _saveImport : null,",
      "                    child: Text(loc.importChanges),",
      "                  ),",
      "                ],",
      "              ),",
      "            ),",
      "            const SizedBox(height: 12),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 274,
      "file_size": 9663,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\widgets\\ingredients\\ingredient_type_json_preview_table.dart",
    "content": [
      "import 'dart:convert';",
      "",
      "import 'package:flutter/material.dart';",
      "import 'package:flutter/services.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:provider/provider.dart';",
      "",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/models/ingredient_type_model.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class IngredientTypeJsonPreviewTable extends StatelessWidget {",
      "  final String rawJson;",
      "  final List<IngredientType>? previewTypes;",
      "",
      "  const IngredientTypeJsonPreviewTable({",
      "    Key? key,",
      "    required this.rawJson,",
      "    required this.previewTypes,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context)!;",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "",
      "    List<IngredientType> parsedTypes = [];",
      "    String? errorMessage;",
      "",
      "    try {",
      "      final parsed = json.decode(rawJson);",
      "      if (parsed is List) {",
      "        parsedTypes = parsed.map((item) {",
      "          return IngredientType(",
      "            id: null,",
      "            name: item['name'] ?? '',",
      "            description: item['description'],",
      "            sortOrder: item['sortOrder'],",
      "            systemTag: item['systemTag'],",
      "            visibleInApp: item['visibleInApp'] ?? true,",
      "            createdAt: null,",
      "            updatedAt: null,",
      "          );",
      "        }).toList();",
      "      } else {",
      "        errorMessage = loc.invalidJsonFormat;",
      "      }",
      "    } catch (e, stack) {",
      "      errorMessage = loc.jsonParseError;",
      "      ErrorLogger.log(",
      "        message: 'Failed to parse ingredient type JSON preview',",
      "        source: 'ingredient_type_json_preview_table.dart',",
      "        screen: 'ingredient_type_management_screen',",
      "        severity: 'warning',",
      "        stack: stack.toString(),",
      "        contextData: {'rawInput': rawJson},",
      "      );",
      "    }",
      "",
      "    return Container(",
      "      decoration: BoxDecoration(",
      "        color: DesignTokens.surfaceColor,",
      "        border: Border.all(color: DesignTokens.cardBorderColor),",
      "        borderRadius: BorderRadius.circular(DesignTokens.cardRadius),",
      "      ),",
      "      padding: const EdgeInsets.all(16),",
      "      child: errorMessage != null",
      "          ? Text(",
      "              errorMessage,",
      "              style: TextStyle(color: colorScheme.error),",
      "            )",
      "          : parsedTypes.isEmpty",
      "              ? Text(loc.noPreviewData)",
      "              : SingleChildScrollView(",
      "                  scrollDirection: Axis.horizontal,",
      "                  child: DataTable(",
      "                    columnSpacing: 16,",
      "                    columns: [",
      "                      DataColumn(label: Text(loc.name)),",
      "                      DataColumn(label: Text(loc.description)),",
      "                      DataColumn(label: Text(loc.sortOrder)),",
      "                      DataColumn(label: Text(loc.systemTag)),",
      "                      DataColumn(label: Text(loc.visibleInApp)),",
      "                    ],",
      "                    rows: parsedTypes.map((type) {",
      "                      return DataRow(cells: [",
      "                        DataCell(Text(type.name)),",
      "                        DataCell(Text(type.description ?? '-')),",
      "                        DataCell(Text(type.sortOrder?.toString() ?? '-')),",
      "                        DataCell(Text(type.systemTag ?? '-')),",
      "                        DataCell(Icon(",
      "                          type.visibleInApp ? Icons.check : Icons.close,",
      "                          color: type.visibleInApp",
      "                              ? colorScheme.primary",
      "                              : colorScheme.error,",
      "                        )),",
      "                      ]);",
      "                    }).toList(),",
      "                  ),",
      "                ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 105,
      "file_size": 3875,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\widgets\\ingredients\\ingredient_type_template_picker_dialog.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/onboarding_progress_provider.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/providers/ingredient_type_provider.dart';",
      "",
      "class IngredientTypeTemplatePickerDialog extends StatefulWidget {",
      "  final AppLocalizations loc;",
      "",
      "  const IngredientTypeTemplatePickerDialog({super.key, required this.loc});",
      "",
      "  static Future<void> show(BuildContext context) {",
      "    return showDialog(",
      "      context: context,",
      "      builder: (BuildContext dialogContext) {",
      "        return Localizations.override(",
      "          context: dialogContext,",
      "          child: Builder(",
      "            builder: (innerContext) {",
      "              final loc = AppLocalizations.of(innerContext);",
      "              if (loc == null) {",
      "                return const AlertDialog(",
      "                  content: Text('Localization unavailable'),",
      "                );",
      "              }",
      "              return ScaffoldMessenger(",
      "                child: IngredientTypeTemplatePickerDialog(loc: loc),",
      "              );",
      "            },",
      "          ),",
      "        );",
      "      },",
      "    );",
      "  }",
      "",
      "  @override",
      "  State<IngredientTypeTemplatePickerDialog> createState() =>",
      "      _IngredientTypeTemplatePickerDialogState();",
      "}",
      "",
      "class _IngredientTypeTemplatePickerDialogState",
      "    extends State<IngredientTypeTemplatePickerDialog> {",
      "  bool _loading = false;",
      "",
      "  Future<void> _loadTemplate(String templateId) async {",
      "    final loc = widget.loc;",
      "    final franchiseId =",
      "        Provider.of<FranchiseProvider>(context, listen: false).franchiseId;",
      "",
      "    if (franchiseId.isEmpty || franchiseId == 'unknown') {",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(content: Text(loc.selectAFranchiseFirst)),",
      "      );",
      "      return;",
      "    }",
      "",
      "    setState(() => _loading = true);",
      "",
      "    try {",
      "      await FirestoreService.copyIngredientTypesFromTemplate(",
      "        franchiseId: franchiseId,",
      "        templateId: templateId,",
      "      );",
      "",
      "      // ✅ Immediately close dialog before triggering UI changes",
      "      if (context.mounted) Navigator.of(context).pop();",
      "",
      "      // ✅ Reload types after closing",
      "      await Provider.of<IngredientTypeProvider>(context, listen: false)",
      "          .loadTypes(franchiseId);",
      "",
      "      // ✅ Show snackbar after frame settles",
      "      WidgetsBinding.instance.addPostFrameCallback((_) {",
      "        ScaffoldMessenger.of(context).showSnackBar(",
      "          SnackBar(content: Text(loc.templateLoadedSuccessfully)),",
      "        );",
      "      });",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'ingredient_type_template_load_failed',",
      "        stack: stack.toString(),",
      "        screen: 'ingredient_type_management_screen',",
      "        source: 'IngredientTypeTemplatePickerDialog',",
      "        severity: 'error',",
      "        contextData: {",
      "          'templateId': templateId,",
      "          'franchiseId': franchiseId,",
      "        },",
      "      );",
      "      if (context.mounted) {",
      "        ScaffoldMessenger.of(context).showSnackBar(",
      "          SnackBar(content: Text(loc.errorGeneric)),",
      "        );",
      "      }",
      "    } finally {",
      "      if (mounted) setState(() => _loading = false);",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = widget.loc;",
      "    print('[IngredientTypeTemplatePickerDialog] build() called with loc: $loc');",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "",
      "    return AlertDialog(",
      "      backgroundColor: DesignTokens.surfaceColor,",
      "      titlePadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),",
      "      title: Row(",
      "        children: [",
      "          Icon(Icons.library_add, color: colorScheme.primary),",
      "          const SizedBox(width: 8),",
      "          Text(",
      "            loc.selectIngredientTypeTemplate,",
      "            style: theme.textTheme.titleMedium?.copyWith(",
      "              color: colorScheme.onSurface,",
      "              fontWeight: FontWeight.w600,",
      "            ),",
      "          ),",
      "        ],",
      "      ),",
      "      contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),",
      "      content: _loading",
      "          ? const Center(child: CircularProgressIndicator())",
      "          : Column(",
      "              mainAxisSize: MainAxisSize.min,",
      "              children: [",
      "                _buildTemplateTile(",
      "                  id: 'pizzeria',",
      "                  icon: '🍕',",
      "                  label: loc.pizzaShopTemplateLabel,",
      "                  subtitle: loc.pizzaShopTemplateSubtitle,",
      "                ),",
      "                const SizedBox(height: 12),",
      "                _buildTemplateTile(",
      "                  id: 'wing_bar',",
      "                  icon: '🍗',",
      "                  label: loc.wingBarTemplateLabel,",
      "                  subtitle: loc.wingBarTemplateSubtitle,",
      "                  enabled: false, // Placeholder for future",
      "                ),",
      "              ],",
      "            ),",
      "      actions: [",
      "        TextButton(",
      "          onPressed: () => Navigator.of(context).pop(),",
      "          child: Text(loc.cancel),",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "",
      "  Widget _buildTemplateTile({",
      "    required String id,",
      "    required String icon,",
      "    required String label,",
      "    required String subtitle,",
      "    bool enabled = true,",
      "  }) {",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "",
      "    return ListTile(",
      "      enabled: enabled,",
      "      tileColor: enabled",
      "          ? colorScheme.surfaceVariant.withOpacity(0.2)",
      "          : Colors.grey.withOpacity(0.1),",
      "      leading: Text(",
      "        icon,",
      "        style: const TextStyle(fontSize: 28),",
      "      ),",
      "      title: Text(",
      "        label,",
      "        style: theme.textTheme.titleSmall?.copyWith(",
      "          fontWeight: FontWeight.w600,",
      "        ),",
      "      ),",
      "      subtitle: Text(",
      "        subtitle,",
      "        style: theme.textTheme.bodySmall,",
      "      ),",
      "      onTap: enabled ? () => _loadTemplate(id) : null,",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 191,
      "file_size": 6338,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\widgets\\ingredients\\inline_add_ingredient_type_row.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:provider/provider.dart';",
      "",
      "import 'package:franchise_admin_portal/core/models/ingredient_type_model.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/ingredient_type_provider.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "",
      "class InlineAddIngredientTypeRow extends StatefulWidget {",
      "  const InlineAddIngredientTypeRow({super.key});",
      "",
      "  @override",
      "  State<InlineAddIngredientTypeRow> createState() =>",
      "      _InlineAddIngredientTypeRowState();",
      "}",
      "",
      "class _InlineAddIngredientTypeRowState",
      "    extends State<InlineAddIngredientTypeRow> {",
      "  final TextEditingController _nameController = TextEditingController();",
      "  final TextEditingController _sortOrderController = TextEditingController();",
      "  bool _submitting = false;",
      "",
      "  @override",
      "  void dispose() {",
      "    _nameController.dispose();",
      "    _sortOrderController.dispose();",
      "    super.dispose();",
      "  }",
      "",
      "  Future<void> _submit() async {",
      "    final loc = AppLocalizations.of(context)!;",
      "    final name = _nameController.text.trim();",
      "    final sortOrder = int.tryParse(_sortOrderController.text.trim()) ?? 0;",
      "",
      "    if (name.isEmpty) {",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(content: Text(loc.ingredientTypeNameRequired)),",
      "      );",
      "      return;",
      "    }",
      "",
      "    final franchiseId = context.read<FranchiseProvider>().franchiseId;",
      "    final provider = context.read<IngredientTypeProvider>();",
      "",
      "    setState(() => _submitting = true);",
      "",
      "    try {",
      "      final newType = IngredientType(",
      "        id: null,",
      "        name: name,",
      "        sortOrder: sortOrder,",
      "      );",
      "",
      "      await provider.addType(franchiseId, newType);",
      "",
      "      _nameController.clear();",
      "      _sortOrderController.clear();",
      "",
      "      if (mounted) {",
      "        ScaffoldMessenger.of(context).showSnackBar(",
      "          SnackBar(content: Text('${loc.ingredientTypeAdded}: $name')),",
      "        );",
      "      }",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to add new ingredient type inline',",
      "        stack: stack.toString(),",
      "        severity: 'error',",
      "        screen: 'ingredient_type_management_screen',",
      "        source: 'InlineAddIngredientTypeRow',",
      "        contextData: {",
      "          'nameAttempted': name,",
      "          'sortOrder': sortOrder,",
      "        },",
      "      );",
      "      if (mounted) {",
      "        ScaffoldMessenger.of(context).showSnackBar(",
      "          SnackBar(content: Text(loc.errorGeneric)),",
      "        );",
      "      }",
      "    } finally {",
      "      if (mounted) setState(() => _submitting = false);",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context)!;",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "",
      "    return Card(",
      "      margin: const EdgeInsets.symmetric(horizontal: 8, vertical: 6),",
      "      shape: RoundedRectangleBorder(",
      "        borderRadius: BorderRadius.circular(DesignTokens.cardRadius),",
      "        side: BorderSide(color: DesignTokens.cardBorderColor),",
      "      ),",
      "      color: DesignTokens.surfaceColor,",
      "      child: Padding(",
      "        padding: const EdgeInsets.all(12.0),",
      "        child: Row(",
      "          children: [",
      "            Expanded(",
      "              child: TextFormField(",
      "                controller: _nameController,",
      "                decoration: InputDecoration(",
      "                  labelText: loc.ingredientTypeName,",
      "                  hintText: loc.ingredientTypeNameHint,",
      "                  border: const OutlineInputBorder(),",
      "                ),",
      "              ),",
      "            ),",
      "            const SizedBox(width: 12),",
      "            SizedBox(",
      "              width: 80,",
      "              child: TextFormField(",
      "                controller: _sortOrderController,",
      "                keyboardType: TextInputType.number,",
      "                decoration: InputDecoration(",
      "                  labelText: loc.sortOrder,",
      "                  border: const OutlineInputBorder(),",
      "                ),",
      "              ),",
      "            ),",
      "            const SizedBox(width: 12),",
      "            _submitting",
      "                ? const SizedBox(",
      "                    width: 32,",
      "                    height: 32,",
      "                    child: CircularProgressIndicator(strokeWidth: 3),",
      "                  )",
      "                : IconButton(",
      "                    tooltip: loc.add,",
      "                    icon: const Icon(Icons.add_circle_outline),",
      "                    color: colorScheme.primary,",
      "                    onPressed: _submitting ? null : _submit,",
      "                  ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 145,
      "file_size": 4782,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\widgets\\ingredients\\missing_type_resolution_dialog.dart",
    "content": [
      "// lib/admin/dashboard/onboarding/widgets/ingredients/missing_type_resolution_dialog.dart",
      "",
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/models/ingredient_metadata.dart';",
      "import 'package:franchise_admin_portal/core/models/ingredient_type_model.dart';",
      "import 'package:franchise_admin_portal/core/providers/ingredient_type_provider.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "",
      "class MissingTypeResolutionDialog extends StatefulWidget {",
      "  /// Ingredients that reference a typeId not present in current ingredient types",
      "  final List<IngredientMetadata> ingredientsWithMissingTypes;",
      "",
      "  /// List of all available types (id, name)",
      "  final List<IngredientType> availableTypes;",
      "",
      "  /// Callback when all missing types are resolved. Receives list of resolved ingredients (with updated typeId if needed)",
      "  final void Function(List<IngredientMetadata> resolvedIngredients) onResolved;",
      "",
      "  /// Context from the dialog builder for safe pops!",
      "  final BuildContext dialogContext;",
      "",
      "  const MissingTypeResolutionDialog({",
      "    super.key,",
      "    required this.ingredientsWithMissingTypes,",
      "    required this.availableTypes,",
      "    required this.onResolved,",
      "    required this.dialogContext,",
      "  });",
      "",
      "  @override",
      "  State<MissingTypeResolutionDialog> createState() =>",
      "      _MissingTypeResolutionDialogState();",
      "}",
      "",
      "class _MissingTypeResolutionDialogState",
      "    extends State<MissingTypeResolutionDialog> {",
      "  late List<IngredientMetadata>",
      "      workingList; // Current ingredient rows (removable)",
      "  late Map<String, String?>",
      "      typeMapping; // ingredientId -> selected typeId (null if unresolved)",
      "  late List<IngredientType>",
      "      allTypes; // local, can be updated when new type added",
      "  bool _addingType = false;",
      "  final TextEditingController _newTypeNameCtrl = TextEditingController();",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    workingList = List.from(widget.ingredientsWithMissingTypes);",
      "    typeMapping = {for (final i in workingList) i.id: null};",
      "    allTypes = List.from(widget.availableTypes);",
      "  }",
      "",
      "  bool get allResolved =>",
      "      typeMapping.isNotEmpty && typeMapping.values.every((v) => v != null);",
      "",
      "  Future<void> _addNewType(BuildContext context) async {",
      "    final name = _newTypeNameCtrl.text.trim();",
      "    if (name.isEmpty) return;",
      "    setState(() => _addingType = true);",
      "",
      "    try {",
      "      final provider = context.read<IngredientTypeProvider>();",
      "      final id = name.toLowerCase().replaceAll(' ', '_');",
      "      final added = provider.stageIfNew(id: id, name: name);",
      "      if (!added) {",
      "        // Already exists, optionally warn",
      "        setState(() => _addingType = false);",
      "        if (mounted) {",
      "          ScaffoldMessenger.of(context).showSnackBar(",
      "            const SnackBar(",
      "              content: Text('Ingredient type already exists.'),",
      "              backgroundColor: Colors.orange,",
      "            ),",
      "          );",
      "        }",
      "        return;",
      "      }",
      "      final newType = provider.getById(id);",
      "",
      "      setState(() {",
      "        if (newType != null) allTypes.add(newType);",
      "        _newTypeNameCtrl.clear();",
      "        _addingType = false;",
      "      });",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to create new ingredient type',",
      "        stack: stack.toString(),",
      "        source: 'MissingTypeResolutionDialog',",
      "        screen: 'onboarding_ingredients_screen',",
      "        severity: 'error',",
      "      );",
      "      setState(() => _addingType = false);",
      "      if (mounted) {",
      "        ScaffoldMessenger.of(context).showSnackBar(",
      "          const SnackBar(",
      "            content: Text('Failed to create new ingredient type.'),",
      "            backgroundColor: Colors.red,",
      "          ),",
      "        );",
      "      }",
      "    }",
      "  }",
      "",
      "  @override",
      "  void dispose() {",
      "    _newTypeNameCtrl.dispose();",
      "    super.dispose();",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    print(",
      "        '[MissingTypeResolutionDialog] FranchiseId in context: ${context.read<FranchiseProvider>().franchiseId}');",
      "    print(",
      "        '[MissingTypeResolutionDialog] IngredientTypeProvider franchiseId: ${context.read<IngredientTypeProvider>().franchiseId}');",
      "",
      "    print('[MissingTypeResolutionDialog] build() called');",
      "    final theme = Theme.of(context);",
      "",
      "    return AlertDialog(",
      "      title: const Text('Resolve Missing Ingredient Types'),",
      "      content: SizedBox(",
      "        width: 500,",
      "        child: Column(",
      "          mainAxisSize: MainAxisSize.min,",
      "          children: [",
      "            Text(",
      "              'The following imported ingredients reference ingredient types that do not exist. '",
      "              'Please assign an existing type, create a new type, or remove the ingredient from import.',",
      "              style: theme.textTheme.bodyMedium,",
      "            ),",
      "            const SizedBox(height: 20),",
      "            SizedBox(",
      "              height: 320,",
      "              child: ListView.builder(",
      "                itemCount: workingList.length,",
      "                itemBuilder: (ctx, idx) {",
      "                  final ing = workingList[idx];",
      "                  final currentTypeId = typeMapping[ing.id];",
      "                  return Padding(",
      "                    padding: const EdgeInsets.symmetric(vertical: 8.0),",
      "                    child: Row(",
      "                      children: [",
      "                        // Ingredient name",
      "                        Expanded(",
      "                          child: Column(",
      "                            crossAxisAlignment: CrossAxisAlignment.start,",
      "                            children: [",
      "                              Text(",
      "                                ing.name,",
      "                                style: theme.textTheme.titleMedium,",
      "                              ),",
      "                              Text(",
      "                                'Missing type: \"${ing.typeId}\"',",
      "                                style: theme.textTheme.bodySmall",
      "                                    ?.copyWith(color: Colors.red),",
      "                              ),",
      "                            ],",
      "                          ),",
      "                        ),",
      "                        // Type dropdown",
      "                        DropdownButton<String>(",
      "                          value: currentTypeId,",
      "                          hint: const Text('Select type'),",
      "                          items: [",
      "                            for (final type in allTypes)",
      "                              DropdownMenuItem(",
      "                                value: type.id,",
      "                                child: Text(type.name),",
      "                              ),",
      "                          ],",
      "                          onChanged: (selected) {",
      "                            setState(() {",
      "                              typeMapping[ing.id] = selected;",
      "                            });",
      "                          },",
      "                        ),",
      "                        const SizedBox(width: 8),",
      "                        // Option to remove ingredient from import",
      "                        IconButton(",
      "                          icon: const Icon(Icons.delete_outline),",
      "                          tooltip: 'Remove ingredient from import',",
      "                          onPressed: () {",
      "                            setState(() {",
      "                              typeMapping.remove(ing.id);",
      "                              workingList.removeAt(idx);",
      "                            });",
      "                          },",
      "                        ),",
      "                      ],",
      "                    ),",
      "                  );",
      "                },",
      "              ),",
      "            ),",
      "            // Inline \"Add new type\"",
      "            Padding(",
      "              padding: const EdgeInsets.only(top: 16, bottom: 4),",
      "              child: Row(",
      "                children: [",
      "                  Expanded(",
      "                    child: TextField(",
      "                      controller: _newTypeNameCtrl,",
      "                      decoration: const InputDecoration(",
      "                        labelText: 'Add new type',",
      "                        border: OutlineInputBorder(),",
      "                      ),",
      "                      enabled: !_addingType,",
      "                      onSubmitted: (_) {",
      "                        if (!_addingType) _addNewType(context);",
      "                      },",
      "                    ),",
      "                  ),",
      "                  const SizedBox(width: 8),",
      "                  ElevatedButton(",
      "                    onPressed: _addingType",
      "                        ? null",
      "                        : () async {",
      "                            await _addNewType(context);",
      "                          },",
      "                    child: _addingType",
      "                        ? const SizedBox(",
      "                            width: 18,",
      "                            height: 18,",
      "                            child: CircularProgressIndicator(strokeWidth: 2))",
      "                        : const Text('Add'),",
      "                  ),",
      "                ],",
      "              ),",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "      actions: [",
      "        TextButton(",
      "          onPressed: () => Navigator.of(widget.dialogContext).pop(),",
      "          child: const Text('Cancel'),",
      "        ),",
      "        ElevatedButton(",
      "          onPressed: allResolved",
      "              ? () {",
      "                  final resolved = workingList.map((ing) {",
      "                    final mappedTypeId = typeMapping[ing.id];",
      "                    assert(mappedTypeId != null && mappedTypeId.isNotEmpty,",
      "                        '[MissingTypeResolutionDialog] Resolved ingredient ${ing.id} has invalid typeId');",
      "                    return ing.copyWith(typeId: mappedTypeId ?? 'Unknown');",
      "                  }).toList();",
      "",
      "                  widget.onResolved(resolved);",
      "                  // Don't double-pop! widget.onResolved will pop with data.",
      "                }",
      "              : null,",
      "          child: const Text('Proceed'),",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "",
      "  @override",
      "  void deactivate() {",
      "    print('[OnboardingIngredientsScreen] DEACTIVATE');",
      "    super.deactivate();",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 268,
      "file_size": 10139,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\widgets\\menu_items\\category_creation_dialog.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/models/category.dart';",
      "import 'package:uuid/uuid.dart';",
      "",
      "class CategoryCreationDialog extends StatefulWidget {",
      "  final AppLocalizations loc;",
      "  final String? suggestedName;",
      "",
      "  const CategoryCreationDialog({",
      "    Key? key,",
      "    required this.loc,",
      "    this.suggestedName,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  State<CategoryCreationDialog> createState() => _CategoryCreationDialogState();",
      "}",
      "",
      "class _CategoryCreationDialogState extends State<CategoryCreationDialog> {",
      "  final _formKey = GlobalKey<FormState>();",
      "  final _nameController = TextEditingController();",
      "  final _descriptionController = TextEditingController();",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _nameController.text = widget.suggestedName ?? '';",
      "  }",
      "",
      "  void _handleSubmit() {",
      "    if (_formKey.currentState?.validate() ?? false) {",
      "      final newCategory = Category(",
      "        id: const Uuid().v4(),",
      "        name: _nameController.text.trim(),",
      "        description: _descriptionController.text.trim(),",
      "        sortOrder: null,",
      "      );",
      "      Navigator.of(context).pop(newCategory);",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = widget.loc;",
      "",
      "    return AlertDialog(",
      "      title: Text(loc.createNewCategory),",
      "      content: Form(",
      "        key: _formKey,",
      "        child: Column(",
      "          mainAxisSize: MainAxisSize.min,",
      "          children: [",
      "            TextFormField(",
      "              controller: _nameController,",
      "              decoration: InputDecoration(labelText: loc.categoryName),",
      "              validator: (value) {",
      "                if (value == null || value.trim().isEmpty) {",
      "                  return loc.requiredField;",
      "                }",
      "                return null;",
      "              },",
      "            ),",
      "            const SizedBox(height: 16),",
      "            TextFormField(",
      "              controller: _descriptionController,",
      "              decoration: InputDecoration(labelText: loc.descriptionOptional),",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "      actions: [",
      "        TextButton(",
      "          onPressed: Navigator.of(context).pop,",
      "          child: Text(loc.cancel),",
      "        ),",
      "        ElevatedButton(",
      "          onPressed: _handleSubmit,",
      "          child: Text(loc.create),",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 84,
      "file_size": 2440,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\widgets\\menu_items\\customization_group_editor.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/core/models/customization_group.dart';",
      "import 'package:franchise_admin_portal/core/models/ingredient_reference.dart';",
      "import 'package:franchise_admin_portal/core/providers/ingredient_metadata_provider.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/widgets/menu_items/multi_ingredient_selector.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "",
      "/// Allows devs to define multiple customization groups (e.g. Sauce, Toppings, Bread)",
      "/// within a menu item. Each group can specify label, limit, and list of ingredients.",
      "///",
      "/// This is NOT a live schema editor. It's used to select from pre-created ingredients",
      "/// and assemble logical groups for a menu item's customization flow.",
      "class CustomizationGroupEditor extends StatefulWidget {",
      "  final List<CustomizationGroup> value;",
      "  final void Function(List<CustomizationGroup>) onChanged;",
      "",
      "  const CustomizationGroupEditor({",
      "    Key? key,",
      "    required this.value,",
      "    required this.onChanged,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  State<CustomizationGroupEditor> createState() =>",
      "      _CustomizationGroupEditorState();",
      "}",
      "",
      "class _CustomizationGroupEditorState extends State<CustomizationGroupEditor> {",
      "  late List<CustomizationGroup> _groups;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _groups = List<CustomizationGroup>.from(widget.value);",
      "  }",
      "",
      "  void _updateGroup(int index, CustomizationGroup updated) {",
      "    setState(() {",
      "      _groups[index] = updated;",
      "    });",
      "    widget.onChanged(_groups);",
      "  }",
      "",
      "  void _removeGroup(int index) {",
      "    setState(() {",
      "      _groups.removeAt(index);",
      "    });",
      "    widget.onChanged(_groups);",
      "  }",
      "",
      "  void _addGroup() {",
      "    setState(() {",
      "      _groups.add(",
      "        CustomizationGroup(",
      "          id: UniqueKey().toString(),",
      "          label: '',",
      "          selectionLimit: 1,",
      "          ingredients: [],",
      "        ),",
      "      );",
      "    });",
      "    widget.onChanged(_groups);",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context)!;",
      "    final ingredientProvider = context.read<IngredientMetadataProvider>();",
      "",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        Text(",
      "          loc.customizationGroups,",
      "          style: Theme.of(context).textTheme.titleMedium,",
      "        ),",
      "        const SizedBox(height: 8),",
      "        ..._groups.asMap().entries.map((entry) {",
      "          final index = entry.key;",
      "          final group = entry.value;",
      "",
      "          // Validation",
      "          final duplicateLabel = _groups",
      "                  .where((g) =>",
      "                      g.label.trim().toLowerCase() ==",
      "                      group.label.trim().toLowerCase())",
      "                  .length >",
      "              1;",
      "",
      "          return Card(",
      "            margin: const EdgeInsets.symmetric(vertical: 8),",
      "            elevation: 2,",
      "            child: Padding(",
      "              padding: const EdgeInsets.all(12),",
      "              child: Column(",
      "                crossAxisAlignment: CrossAxisAlignment.start,",
      "                children: [",
      "                  // 🔤 Group Label Input",
      "                  TextFormField(",
      "                    initialValue: group.label,",
      "                    decoration: InputDecoration(",
      "                      labelText: loc.customizationGroupLabel,",
      "                    ),",
      "                    onChanged: (val) => _updateGroup(",
      "                      index,",
      "                      group.copyWith(label: val),",
      "                    ),",
      "                  ),",
      "",
      "                  // Validation after label",
      "                  if (group.label.trim().isEmpty)",
      "                    Padding(",
      "                      padding: const EdgeInsets.only(top: 4, bottom: 0),",
      "                      child: Text(",
      "                        'Group label required',",
      "                        style:",
      "                            TextStyle(color: Colors.red.shade600, fontSize: 12),",
      "                      ),",
      "                    ),",
      "                  if (duplicateLabel)",
      "                    Padding(",
      "                      padding: const EdgeInsets.only(top: 4, bottom: 0),",
      "                      child: Text(",
      "                        'Duplicate group label',",
      "                        style:",
      "                            TextStyle(color: Colors.red.shade600, fontSize: 12),",
      "                      ),",
      "                    ),",
      "",
      "                  const SizedBox(height: 8),",
      "",
      "                  // 🔢 Selection Limit Input",
      "                  Row(",
      "                    children: [",
      "                      Text(loc.selectionLimit),",
      "                      const SizedBox(width: 8),",
      "                      DropdownButton<int>(",
      "                        value: group.selectionLimit,",
      "                        onChanged: (val) {",
      "                          if (val != null) {",
      "                            _updateGroup(",
      "                                index, group.copyWith(selectionLimit: val));",
      "                          }",
      "                        },",
      "                        items: List.generate(",
      "                          6,",
      "                          (i) => DropdownMenuItem(",
      "                            value: i + 1,",
      "                            child: Text('${i + 1}'),",
      "                          ),",
      "                        ),",
      "                      ),",
      "                    ],",
      "                  ),",
      "",
      "                  const SizedBox(height: 12),",
      "",
      "                  // 🧀 Ingredient Selector",
      "                  MultiIngredientSelector(",
      "                    title: group.label.isNotEmpty",
      "                        ? group.label",
      "                        : loc.customizationGroupLabel,",
      "                    selected: group.ingredients,",
      "                    onChanged: (ingredients) {",
      "                      _updateGroup(",
      "                          index, group.copyWith(ingredients: ingredients));",
      "                    },",
      "                  ),",
      "",
      "                  // Validation after ingredient selection",
      "                  if (group.ingredients.isEmpty)",
      "                    Padding(",
      "                      padding: const EdgeInsets.only(top: 4, bottom: 0),",
      "                      child: Text(",
      "                        'Select at least one ingredient',",
      "                        style:",
      "                            TextStyle(color: Colors.red.shade600, fontSize: 12),",
      "                      ),",
      "                    ),",
      "",
      "                  const SizedBox(height: 12),",
      "",
      "                  Align(",
      "                    alignment: Alignment.centerRight,",
      "                    child: TextButton.icon(",
      "                      icon: const Icon(Icons.delete_outline),",
      "                      onPressed: () => _removeGroup(index),",
      "                      label: Text(loc.removeGroup),",
      "                    ),",
      "                  ),",
      "                ],",
      "              ),",
      "            ),",
      "          );",
      "        }),",
      "        const SizedBox(height: 8),",
      "        OutlinedButton.icon(",
      "          onPressed: _addGroup,",
      "          icon: const Icon(Icons.add),",
      "          label: Text(loc.addCustomizationGroup),",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 206,
      "file_size": 7210,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\widgets\\menu_items\\image_upload_field.dart",
    "content": [
      "import 'dart:io';",
      "",
      "import 'package:flutter/material.dart';",
      "import 'package:image_picker/image_picker.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/services/firebase_storage_service.dart';",
      "",
      "/// A form field widget to allow image selection from device gallery or camera,",
      "/// then upload it to Firebase Storage and store the public URL.",
      "///",
      "/// ✅ Features:",
      "/// - Thumbnail preview",
      "/// - Clear/reset support",
      "/// - Firebase upload on selection",
      "/// - Displays validation error if required but not selected",
      "/// - Uses FranchiseProvider to scope uploads per franchise",
      "class ImageUploadField extends FormField<String?> {",
      "  ImageUploadField({",
      "    Key? key,",
      "    String? initialValue,",
      "    String? label,",
      "    bool required = false,",
      "    FormFieldSetter<String?>? onSaved,",
      "    FormFieldValidator<String?>? validator,",
      "    String uploadFolder = 'menu_items',",
      "  }) : super(",
      "          key: key,",
      "          initialValue: initialValue,",
      "          validator: validator ??",
      "              (required",
      "                  ? (value) => (value == null || value.isEmpty)",
      "                      ? 'Image is required.'",
      "                      : null",
      "                  : null),",
      "          onSaved: onSaved,",
      "          builder: (FormFieldState<String?> state) {",
      "            return Builder(builder: (context) {",
      "              final franchiseId = context.read<FranchiseProvider>().franchiseId;",
      "              final storageService = FirebaseStorageService();",
      "",
      "              return Column(",
      "                crossAxisAlignment: CrossAxisAlignment.start,",
      "                children: [",
      "                  if (label != null)",
      "                    Text(",
      "                      label,",
      "                      style: const TextStyle(fontWeight: FontWeight.bold),",
      "                    ),",
      "                  const SizedBox(height: 8),",
      "                  Row(",
      "                    children: [",
      "                      if (state.value != null && state.value!.isNotEmpty)",
      "                        Stack(",
      "                          children: [",
      "                            ClipRRect(",
      "                              borderRadius: BorderRadius.circular(8),",
      "                              child: Image.network(",
      "                                state.value!,",
      "                                width: 80,",
      "                                height: 80,",
      "                                fit: BoxFit.cover,",
      "                              ),",
      "                            ),",
      "                            Positioned(",
      "                              top: -6,",
      "                              right: -6,",
      "                              child: IconButton(",
      "                                icon: const Icon(Icons.clear, size: 20),",
      "                                onPressed: () => state.didChange(null),",
      "                                tooltip: 'Clear Image',",
      "                              ),",
      "                            ),",
      "                          ],",
      "                        )",
      "                      else",
      "                        Container(",
      "                          width: 80,",
      "                          height: 80,",
      "                          decoration: BoxDecoration(",
      "                            border: Border.all(color: Colors.grey.shade400),",
      "                            borderRadius: BorderRadius.circular(8),",
      "                          ),",
      "                          child: const Icon(Icons.image,",
      "                              size: 36, color: Colors.grey),",
      "                        ),",
      "                      const SizedBox(width: 12),",
      "                      ElevatedButton.icon(",
      "                        onPressed: () async {",
      "                          final picker = ImagePicker();",
      "                          final picked = await picker.pickImage(",
      "                              source: ImageSource.gallery);",
      "",
      "                          if (picked != null) {",
      "                            final file = File(picked.path);",
      "",
      "                            try {",
      "                              final uploadedUrl =",
      "                                  await storageService.uploadFranchiseImage(",
      "                                file: file,",
      "                                franchiseId: franchiseId,",
      "                                folder: uploadFolder,",
      "                              );",
      "                              state.didChange(uploadedUrl);",
      "                            } catch (e) {",
      "                              ScaffoldMessenger.of(context).showSnackBar(",
      "                                const SnackBar(",
      "                                  content: Text(",
      "                                      'Failed to upload image. Try again.'),",
      "                                ),",
      "                              );",
      "                            }",
      "                          }",
      "                        },",
      "                        icon: const Icon(Icons.upload_file),",
      "                        label: const Text('Select Image'),",
      "                      ),",
      "                    ],",
      "                  ),",
      "                  if (state.hasError)",
      "                    Padding(",
      "                      padding: const EdgeInsets.only(top: 6),",
      "                      child: Text(",
      "                        state.errorText ?? '',",
      "                        style: const TextStyle(color: Colors.red, fontSize: 12),",
      "                      ),",
      "                    ),",
      "                ],",
      "              );",
      "            });",
      "          },",
      "        );",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 133,
      "file_size": 5520,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\widgets\\menu_items\\ingredient_creation_dialog.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter/services.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/models/ingredient_metadata.dart';",
      "import 'package:franchise_admin_portal/core/providers/ingredient_type_provider.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:uuid/uuid.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/config/branding_config.dart';",
      "",
      "class IngredientCreationDialog extends StatefulWidget {",
      "  final String? suggestedName;",
      "  final AppLocalizations loc;",
      "",
      "  const IngredientCreationDialog({",
      "    Key? key,",
      "    this.suggestedName,",
      "    required this.loc,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  State<IngredientCreationDialog> createState() =>",
      "      _IngredientCreationDialogState();",
      "}",
      "",
      "class _IngredientCreationDialogState extends State<IngredientCreationDialog> {",
      "  final _formKey = GlobalKey<FormState>();",
      "  final _nameController = TextEditingController();",
      "  final _priceController = TextEditingController();",
      "",
      "  String? _selectedTypeId;",
      "  bool _isRemovable = true;",
      "  bool _isSubmitting = false;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    if (widget.suggestedName != null) {",
      "      _nameController.text = widget.suggestedName!;",
      "    }",
      "  }",
      "",
      "  @override",
      "  void dispose() {",
      "    _nameController.dispose();",
      "    _priceController.dispose();",
      "    super.dispose();",
      "  }",
      "",
      "  Future<void> _handleSubmit() async {",
      "    final l10n = widget.loc;",
      "    final typeProvider = context.read<IngredientTypeProvider>();",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "",
      "    if (!_formKey.currentState!.validate()) return;",
      "",
      "    setState(() => _isSubmitting = true);",
      "",
      "    try {",
      "      final uuid = const Uuid();",
      "      final id = uuid.v4();",
      "      final name = _nameController.text.trim();",
      "      final typeId = _selectedTypeId;",
      "      final priceText = _priceController.text.trim();",
      "      final price = double.tryParse(priceText);",
      "",
      "      final typeName = typeProvider.typeIdToName[typeId] ?? 'Uncategorized';",
      "",
      "      final newIngredient = IngredientMetadata(",
      "        id: id,",
      "        name: name,",
      "        typeId: typeId,",
      "        type: typeName,",
      "        allergens: [],",
      "        removable: _isRemovable,",
      "        upcharge: price != null ? {'default': price} : null,",
      "        supportsExtra: true,",
      "        sidesAllowed: true,",
      "        notes: '',",
      "        outOfStock: false,",
      "        amountSelectable: false,",
      "        amountOptions: null,",
      "        imageUrl: null,",
      "      );",
      "",
      "      Navigator.of(context).pop(newIngredient);",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'ingredient_creation_failed',",
      "        stack: stack.toString(),",
      "        source: 'IngredientCreationDialog',",
      "        screen: 'ingredient_creation_dialog.dart',",
      "        severity: 'error',",
      "        contextData: {",
      "          'name': _nameController.text,",
      "          'typeId': _selectedTypeId,",
      "        },",
      "      );",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(",
      "          content: Text(widget.loc.genericErrorMessage),",
      "          backgroundColor: colorScheme.error,",
      "        ),",
      "      );",
      "    } finally {",
      "      setState(() => _isSubmitting = false);",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final l10n = widget.loc;",
      "    final typeProvider = context.watch<IngredientTypeProvider>();",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "",
      "    return AlertDialog(",
      "      title: Text(widget.loc.createNewIngredient),",
      "      content: SingleChildScrollView(",
      "        child: Form(",
      "          key: _formKey,",
      "          child: Column(",
      "            children: [",
      "              // Name",
      "              TextFormField(",
      "                controller: _nameController,",
      "                decoration: InputDecoration(",
      "                  labelText: widget.loc.ingredientName,",
      "                  hintText: widget.loc.e_g_anchovies,",
      "                ),",
      "                validator: (value) {",
      "                  if (value == null || value.trim().isEmpty) {",
      "                    return widget.loc.fieldRequired;",
      "                  }",
      "                  return null;",
      "                },",
      "              ),",
      "              const SizedBox(height: 16),",
      "",
      "              // Type dropdown",
      "              DropdownButtonFormField<String>(",
      "                value: _selectedTypeId,",
      "                isExpanded: true,",
      "                hint: Text(widget.loc.ingredientType),",
      "                decoration:",
      "                    InputDecoration(labelText: widget.loc.ingredientType),",
      "                items: [",
      "                  for (final id in typeProvider.allTypeIds)",
      "                    DropdownMenuItem(",
      "                      value: id,",
      "                      child: Text(typeProvider.typeIdToName[id] ?? id),",
      "                    ),",
      "                ],",
      "                onChanged: (value) {",
      "                  setState(() => _selectedTypeId = value);",
      "                },",
      "                validator: (value) {",
      "                  if (value == null || value.isEmpty) {",
      "                    return widget.loc.fieldRequired;",
      "                  }",
      "                  return null;",
      "                },",
      "              ),",
      "              const SizedBox(height: 16),",
      "",
      "              // Upcharge field",
      "              TextFormField(",
      "                controller: _priceController,",
      "                keyboardType:",
      "                    const TextInputType.numberWithOptions(decimal: true),",
      "                inputFormatters: [",
      "                  FilteringTextInputFormatter.allow(RegExp(r'^\\d*\\.?\\d{0,2}'))",
      "                ],",
      "                decoration: InputDecoration(",
      "                  labelText: widget.loc.upchargeOptional,",
      "                  hintText: '1.00',",
      "                  prefixText: '\\$',",
      "                ),",
      "              ),",
      "              const SizedBox(height: 16),",
      "",
      "              // Removable toggle",
      "              SwitchListTile(",
      "                value: _isRemovable,",
      "                onChanged: (value) {",
      "                  setState(() => _isRemovable = value);",
      "                },",
      "                title: Text(widget.loc.removable),",
      "              ),",
      "            ],",
      "          ),",
      "        ),",
      "      ),",
      "      actions: [",
      "        TextButton(",
      "          onPressed: _isSubmitting ? null : () => Navigator.of(context).pop(),",
      "          child: Text(widget.loc.cancel),",
      "        ),",
      "        ElevatedButton(",
      "          onPressed: _isSubmitting ? null : _handleSubmit,",
      "          child: _isSubmitting",
      "              ? SizedBox(",
      "                  height: 20,",
      "                  width: 20,",
      "                  child: CircularProgressIndicator(strokeWidth: 2),",
      "                )",
      "              : Text(widget.loc.create),",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 212,
      "file_size": 6882,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\widgets\\menu_items\\ingredient_type_creation_dialog.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter/services.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/models/ingredient_type_model.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "",
      "class IngredientTypeCreationDialog extends StatefulWidget {",
      "  final AppLocalizations loc;",
      "  final String? suggestedName;",
      "",
      "  const IngredientTypeCreationDialog({",
      "    Key? key,",
      "    required this.loc,",
      "    this.suggestedName,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  State<IngredientTypeCreationDialog> createState() =>",
      "      _IngredientTypeCreationDialogState();",
      "}",
      "",
      "class _IngredientTypeCreationDialogState",
      "    extends State<IngredientTypeCreationDialog> {",
      "  final _formKey = GlobalKey<FormState>();",
      "  final _nameController = TextEditingController();",
      "  final _tagController = TextEditingController();",
      "  bool _saving = false;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    if (widget.suggestedName != null) {",
      "      _nameController.text = widget.suggestedName!;",
      "    }",
      "  }",
      "",
      "  Future<void> _submit() async {",
      "    if (!_formKey.currentState!.validate()) return;",
      "",
      "    setState(() => _saving = true);",
      "",
      "    try {",
      "      final id = _nameController.text.trim().toLowerCase().replaceAll(' ', '_');",
      "",
      "      final type = IngredientType(",
      "        id: id,",
      "        name: _nameController.text.trim(),",
      "        systemTag: _tagController.text.trim().isNotEmpty",
      "            ? _tagController.text.trim()",
      "            : null,",
      "        sortOrder: 999, // Default to bottom",
      "      );",
      "",
      "      Navigator.of(context).pop(type);",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'ingredient_type_creation_failed',",
      "        source: 'IngredientTypeCreationDialog',",
      "        stack: stack.toString(),",
      "        screen: 'ingredient_type_creation_dialog.dart',",
      "        severity: 'error',",
      "      );",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(",
      "          content: Text(widget.loc.genericErrorMessage),",
      "          backgroundColor: Theme.of(context).colorScheme.error,",
      "        ),",
      "      );",
      "    } finally {",
      "      if (mounted) setState(() => _saving = false);",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = widget.loc;",
      "",
      "    return AlertDialog(",
      "      title: Text(loc.createNewIngredientType),",
      "      content: Form(",
      "        key: _formKey,",
      "        child: Column(",
      "          mainAxisSize: MainAxisSize.min,",
      "          children: [",
      "            TextFormField(",
      "              controller: _nameController,",
      "              autofocus: true,",
      "              decoration: InputDecoration(",
      "                labelText: loc.typeName,",
      "              ),",
      "              validator: (val) {",
      "                if (val == null || val.trim().isEmpty) {",
      "                  return loc.fieldRequired;",
      "                }",
      "                return null;",
      "              },",
      "            ),",
      "            const SizedBox(height: 12),",
      "            TextFormField(",
      "              controller: _tagController,",
      "              inputFormatters: [",
      "                FilteringTextInputFormatter.allow(RegExp(r'[a-zA-Z0-9_-]'))",
      "              ],",
      "              decoration: InputDecoration(",
      "                labelText: loc.systemTagOptional,",
      "              ),",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "      actions: [",
      "        TextButton(",
      "          onPressed: _saving ? null : () => Navigator.of(context).pop(),",
      "          child: Text(loc.cancel),",
      "        ),",
      "        ElevatedButton(",
      "          onPressed: _saving ? null : _submit,",
      "          child: _saving",
      "              ? SizedBox(",
      "                  width: 16,",
      "                  height: 16,",
      "                  child: CircularProgressIndicator(strokeWidth: 2),",
      "                )",
      "              : Text(loc.create),",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 130,
      "file_size": 3913,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\widgets\\menu_items\\menu_items_list_tile.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:provider/provider.dart';",
      "",
      "import 'package:franchise_admin_portal/core/models/menu_item.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/providers/menu_item_provider.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class MenuItemListTile extends StatelessWidget {",
      "  final MenuItem item;",
      "  final bool isSelected;",
      "  final ValueChanged<bool?>? onSelect;",
      "  final VoidCallback onEdit;",
      "  final VoidCallback onDelete;",
      "",
      "  const MenuItemListTile({",
      "    super.key,",
      "    required this.item,",
      "    required this.isSelected,",
      "    required this.onSelect,",
      "    required this.onEdit,",
      "    required this.onDelete,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "    final loc = AppLocalizations.of(context)!;",
      "",
      "    return Card(",
      "      margin: const EdgeInsets.symmetric(vertical: 4),",
      "      child: ListTile(",
      "        contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),",
      "        leading: Checkbox(",
      "          value: isSelected,",
      "          onChanged: onSelect,",
      "        ),",
      "        title: Text(",
      "          item.name,",
      "          style: theme.textTheme.titleMedium",
      "              ?.copyWith(fontWeight: FontWeight.bold),",
      "        ),",
      "        subtitle: Column(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            if (item.description.isNotEmpty) Text(item.description),",
      "            Text('${loc.price}: \\$${item.price.toStringAsFixed(2)}'),",
      "            if (item.sizes != null && item.sizePrices != null)",
      "              Text('${loc.sizes}: ${item.sizes!.join(', ')}'),",
      "            if (item.highlightTags != null && item.highlightTags!.isNotEmpty)",
      "              Wrap(",
      "                spacing: 4,",
      "                children: item.highlightTags!",
      "                    .map((tag) => Chip(",
      "                          label: Text(tag),",
      "                          backgroundColor: colorScheme.secondaryContainer,",
      "                        ))",
      "                    .toList(),",
      "              ),",
      "          ],",
      "        ),",
      "        trailing: Wrap(",
      "          spacing: 8,",
      "          children: [",
      "            IconButton(",
      "              icon: const Icon(Icons.edit),",
      "              tooltip: loc.edit,",
      "              onPressed: onEdit,",
      "            ),",
      "            IconButton(",
      "              icon: const Icon(Icons.delete_outline),",
      "              tooltip: loc.delete,",
      "              onPressed: () async {",
      "                final confirmed = await showDialog<bool>(",
      "                  context: context,",
      "                  builder: (ctx) => AlertDialog(",
      "                    title: Text(loc.confirmDeletion),",
      "                    content: Text(loc.deleteMenuItemConfirm(item.name)),",
      "                    actions: [",
      "                      TextButton(",
      "                        onPressed: () => Navigator.of(ctx).pop(false),",
      "                        child: Text(loc.cancel),",
      "                      ),",
      "                      ElevatedButton(",
      "                        style: ElevatedButton.styleFrom(",
      "                            backgroundColor: Colors.red),",
      "                        onPressed: () => Navigator.of(ctx).pop(true),",
      "                        child: Text(loc.delete),",
      "                      ),",
      "                    ],",
      "                  ),",
      "                );",
      "",
      "                if (confirmed == true) {",
      "                  try {",
      "                    await context",
      "                        .read<MenuItemProvider>()",
      "                        .deleteFromFirestore(item.id);",
      "                    ScaffoldMessenger.of(context).showSnackBar(",
      "                      SnackBar(content: Text(loc.menuItemDeleted)),",
      "                    );",
      "                  } catch (e, stack) {",
      "                    await ErrorLogger.log(",
      "                      message: 'menu_item_delete_failed',",
      "                      source: 'MenuItemListTile',",
      "                      screen: 'menu_item_list_tile.dart',",
      "                      severity: 'error',",
      "                      stack: stack.toString(),",
      "                      contextData: {'itemId': item.id},",
      "                    );",
      "                    ScaffoldMessenger.of(context).showSnackBar(",
      "                      SnackBar(content: Text(loc.errorGeneric)),",
      "                    );",
      "                  }",
      "                }",
      "              },",
      "            )",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 126,
      "file_size": 4669,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\widgets\\menu_items\\menu_item_editor_sheet.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/widgets/menu_items/size_pricing_editor.dart';",
      "import 'package:franchise_admin_portal/core/models/menu_item.dart';",
      "import 'package:franchise_admin_portal/core/models/ingredient_reference.dart';",
      "import 'package:franchise_admin_portal/core/models/nutrition_info.dart';",
      "import 'package:franchise_admin_portal/core/providers/category_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/ingredient_metadata_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/menu_item_provider.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/core/models/customization.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/widgets/menu_items/image_upload_field.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/widgets/menu_items/multi_ingredient_selector.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/widgets/menu_items/customization_group_editor.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/widgets/menu_items/nutrition_editor_dialog.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/widgets/menu_items/preview_menu_item_card.dart';",
      "import 'package:franchise_admin_portal/widgets/empty_state_widget.dart';",
      "import 'package:franchise_admin_portal/core/models/customization_group.dart';",
      "import 'package:franchise_admin_portal/core/utils/features/feature_guard.dart';",
      "import 'package:franchise_admin_portal/core/utils/features/enum_platform_features.dart';",
      "import 'package:franchise_admin_portal/core/models/size_template.dart';",
      "import 'package:collection/collection.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_info_provider.dart';",
      "import 'package:franchise_admin_portal/core/models/franchise_info.dart';",
      "import 'package:uuid/uuid.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/widgets/menu_items/menu_item_template_dropdown.dart';",
      "import 'package:flutter/foundation.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/widgets/menu_items/schema_issue_sidebar.dart';",
      "import 'package:franchise_admin_portal/core/models/menu_item_schema_issue.dart';",
      "import 'package:franchise_admin_portal/core/providers/ingredient_type_provider.dart';",
      "// --- Utilities ---",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/widgets/menu_items/menu_item_utility.dart';",
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "import 'package:franchise_admin_portal/core/providers/ingredient_type_provider.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/models/category.dart' as app_models;",
      "",
      "class MenuItemEditorSheet extends StatefulWidget {",
      "  final MenuItem? existing;",
      "  final void Function(MenuItem item) onSave;",
      "  final VoidCallback onCancel;",
      "  final void Function(List<MenuItemSchemaIssue> issues)? onSchemaIssuesChanged;",
      "  final FirebaseFirestore firestore;",
      "  final String franchiseId;",
      "",
      "  const MenuItemEditorSheet({",
      "    Key? key,",
      "    this.existing,",
      "    required this.onCancel,",
      "    required this.onSave,",
      "    required this.onSchemaIssuesChanged,",
      "    required this.firestore,",
      "    required this.franchiseId,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  State<MenuItemEditorSheet> createState() => MenuItemEditorSheetState();",
      "}",
      "",
      "class MenuItemEditorSheetState extends State<MenuItemEditorSheet> {",
      "  late TextEditingController _nameController;",
      "  late TextEditingController _descriptionController;",
      "  late TextEditingController _priceController;",
      "  List<CustomizationGroup> customizationGroups = [];",
      "  final _formKey = GlobalKey<FormState>();",
      "  late String name;",
      "  late String description;",
      "  late double price;",
      "  String? categoryId;",
      "  bool outOfStock = false;",
      "  String imageUrl = '';",
      "  List<String> selectedTemplateRefs = [];",
      "  NutritionInfo? nutrition;",
      "  List<IngredientReference> includedIngredients = [];",
      "  List<IngredientReference> optionalAddOns = [];",
      "  List<Customization> customizations = [];",
      "  List<SizeData> sizeData = [];",
      "  String? get selectedTemplate =>",
      "      selectedTemplateRefs.isNotEmpty ? selectedTemplateRefs.first : null;",
      "",
      "  bool isDirty = false;",
      "  List<MenuItem> availableTemplates = [];",
      "  bool loadingTemplates = true;",
      "  List<MenuItemSchemaIssue> _schemaIssues = [];",
      "  bool _showSchemaSidebar = false;",
      "",
      "  // --- ADVANCED FIELDS ---",
      "  String? notes;",
      "  String? sku;",
      "  List<String> dietaryTags = [];",
      "  List<String> allergens = [];",
      "  int? prepTime;",
      "  int? sortOrder;",
      "  String taxCategory = 'standard';",
      "  String? exportId;",
      "  List<String>? crustTypes;",
      "  List<String>? cookTypes;",
      "  List<String>? cutStyles;",
      "  List<String>? sauceOptions;",
      "  List<String>? dressingOptions;",
      "  int? maxFreeToppings;",
      "  int? maxFreeSauces;",
      "  int? maxFreeDressings;",
      "  int? maxToppings;",
      "  DateTime? customizationsUpdatedAt;",
      "  DateTime? createdAt;",
      "  String? comboId;",
      "  List<String>? bundleItems;",
      "  double? bundleDiscount;",
      "  List<String>? highlightTags;",
      "  bool? allowSpecialInstructions;",
      "  bool? hideInMenu;",
      "  dynamic freeSauceCount;",
      "  double? extraSauceUpcharge;",
      "  dynamic freeDressingCount;",
      "  double? extraDressingUpcharge;",
      "  List<String>? dippingSauceOptions;",
      "  Map<String, int>? dippingSplits;",
      "  List<String>? sideDipSauceOptions;",
      "  Map<String, int>? freeDipCupCount;",
      "  Map<String, double>? sideDipUpcharge;",
      "  Map<String, dynamic>? extraCharges;",
      "  List<Map<String, dynamic>>? rawCustomizations;",
      "",
      "  @override",
      "  void initState() {",
      "    print(",
      "        '[MenuItemEditorSheet] initState: existing=${widget.existing != null}');",
      "    final item = widget.existing;",
      "",
      "    // --- Controller initialization ---",
      "    _nameController = TextEditingController(text: item?.name ?? '');",
      "    _descriptionController =",
      "        TextEditingController(text: item?.description ?? '');",
      "    _priceController =",
      "        TextEditingController(text: item?.price?.toString() ?? '');",
      "",
      "    name = item?.name ?? '';",
      "    description = item?.description ?? '';",
      "    price = item?.price ?? 0.0;",
      "    categoryId = item?.categoryId;",
      "    outOfStock = item?.outOfStock ?? false;",
      "    imageUrl = item?.imageUrl ?? '';",
      "    selectedTemplateRefs = List<String>.from(item?.templateRefs ?? []);",
      "    nutrition = item?.nutrition;",
      "    includedIngredients = List.from(item?.includedIngredients ?? []);",
      "    optionalAddOns = List.from(item?.optionalAddOns ?? []);",
      "    customizations = List.from(item?.customizations ?? []);",
      "    sizeData = List.from(item?.sizes ?? []);",
      "    customizationGroups = (item?.customizationGroups != null)",
      "        ? (item!.customizationGroups as List)",
      "            .map(",
      "                (g) => CustomizationGroup.fromMap(Map<String, dynamic>.from(g)))",
      "            .toList()",
      "        : [];",
      "    super.initState();",
      "    WidgetsBinding.instance.addPostFrameCallback((_) async {",
      "      final franchise = context.read<FranchiseInfoProvider>().franchise;",
      "      if (franchise?.restaurantType != null) {",
      "        await context",
      "            .read<MenuItemProvider>()",
      "            .loadSizeTemplates(franchise!.restaurantType!);",
      "      }",
      "      await context",
      "          .read<IngredientTypeProvider>()",
      "          .loadIngredientTypes(widget.franchiseId);",
      "    });",
      "  }",
      "",
      "  List<MenuItemSchemaIssue> validateMenuItem({",
      "    required BuildContext context,",
      "    required String menuItemId,",
      "  }) {",
      "    final categories = context.read<CategoryProvider>().categories;",
      "    final ingredients =",
      "        context.read<IngredientMetadataProvider>().allIngredients;",
      "    final ingredientTypes =",
      "        context.read<IngredientTypeProvider>().ingredientTypes;",
      "",
      "    final menuItem = constructMenuItemFromEditorFields(",
      "      id: menuItemId,",
      "      outOfStock: outOfStock,",
      "      categoryName: categoryId ?? '',",
      "      categoryId: categoryId ?? '',",
      "      name: name,",
      "      price: price,",
      "      description: description,",
      "      notes: notes,",
      "      sku: sku,",
      "      dietaryTags: dietaryTags,",
      "      allergens: allergens,",
      "      prepTime: prepTime,",
      "      sortOrder: sortOrder,",
      "      taxCategory: taxCategory,",
      "      exportId: exportId,",
      "      customizationGroups: customizationGroups,",
      "      includedIngredients: includedIngredients,",
      "      optionalAddOns: optionalAddOns,",
      "      customizations: customizations,",
      "      imageUrl: imageUrl,",
      "      nutrition: nutrition,",
      "      selectedTemplateRefs: selectedTemplateRefs,",
      "      sizeData: sizeData,",
      "      crustTypes: crustTypes,",
      "      cookTypes: cookTypes,",
      "      cutStyles: cutStyles,",
      "      sauceOptions: sauceOptions,",
      "      dressingOptions: dressingOptions,",
      "      maxFreeToppings: maxFreeToppings,",
      "      maxFreeSauces: maxFreeSauces,",
      "      maxFreeDressings: maxFreeDressings,",
      "      maxToppings: maxToppings,",
      "      customizationsUpdatedAt: customizationsUpdatedAt,",
      "      createdAt: createdAt,",
      "      comboId: comboId,",
      "      bundleItems: bundleItems,",
      "      bundleDiscount: bundleDiscount,",
      "      highlightTags: highlightTags,",
      "      allowSpecialInstructions: allowSpecialInstructions,",
      "      hideInMenu: hideInMenu,",
      "      freeSauceCount: freeSauceCount,",
      "      extraSauceUpcharge: extraSauceUpcharge,",
      "      freeDressingCount: freeDressingCount,",
      "      extraDressingUpcharge: extraDressingUpcharge,",
      "      dippingSauceOptions: dippingSauceOptions,",
      "      dippingSplits: dippingSplits,",
      "      sideDipSauceOptions: sideDipSauceOptions,",
      "      freeDipCupCount: freeDipCupCount,",
      "      sideDipUpcharge: sideDipUpcharge,",
      "      extraCharges: extraCharges,",
      "      rawCustomizations: rawCustomizations,",
      "    );",
      "",
      "    return MenuItemSchemaIssue.detectAllIssues(",
      "      menuItem: menuItem,",
      "      categories: categories,",
      "      ingredients: ingredients,",
      "      ingredientTypes: ingredientTypes,",
      "    );",
      "  }",
      "",
      "  void repairSchemaIssue(MenuItemSchemaIssue issue, String newValue) {",
      "    print(",
      "        '[MenuItemEditorSheet] repairSchemaIssue: ${issue.displayMessage}, newValue=$newValue');",
      "",
      "    final ingredientProvider = context.read<IngredientMetadataProvider>();",
      "    final typeProvider = context.read<IngredientTypeProvider>();",
      "    final categoryProvider = context.read<CategoryProvider>();",
      "",
      "    setState(() {",
      "      print('[repairSchemaIssue] Resolving issue: '",
      "          'field=${issue.field}, type=${issue.type}, '",
      "          'missingReference=${issue.missingReference}, label=${issue.label}, '",
      "          'newValue=$newValue');",
      "",
      "      switch (issue.field) {",
      "        case 'categoryId':",
      "          categoryId = newValue;",
      "          print('[repairSchemaIssue] Assigned new categoryId: $categoryId');",
      "",
      "          final alreadyExists = categoryProvider.categories",
      "                  .any((c) => c.id == newValue) ||",
      "              categoryProvider.stagedCategories.any((c) => c.id == newValue);",
      "",
      "          print('[repairSchemaIssue] Category exists=$alreadyExists');",
      "",
      "          if (!alreadyExists) {",
      "            try {",
      "              categoryProvider.stageCategory(",
      "                app_models.Category(",
      "                  id: newValue,",
      "                  name: issue.label ?? 'Unnamed Category',",
      "                  sortOrder: 999,",
      "                ),",
      "              );",
      "              print('[repairSchemaIssue] Staged new category: $newValue');",
      "            } catch (e) {",
      "              print('[ERROR] Failed to stage category: $newValue → $e');",
      "            }",
      "          }",
      "          break;",
      "",
      "        case 'price':",
      "          price = double.tryParse(newValue) ?? 0.0;",
      "          _priceController.text = price.toString();",
      "          print('[repairSchemaIssue] Updated price: $price');",
      "          break;",
      "",
      "        case 'description':",
      "          description = newValue;",
      "          _descriptionController.text = newValue;",
      "          print('[repairSchemaIssue] Updated description');",
      "          break;",
      "",
      "        case 'includedIngredients':",
      "        case 'optionalAddOns':",
      "        case 'customizationGroups':",
      "        case 'customizationGroups.options':",
      "          print('[repairSchemaIssue] Routing to _repairIngredientOrType...');",
      "          _repairIngredientOrType(issue, newValue);",
      "",
      "          // if (issue.type == MenuItemSchemaIssueType.ingredient) {",
      "          //   final alreadyExists = ingredientProvider.allIngredients",
      "          //           .any((e) => e.id == newValue) ||",
      "          //       ingredientProvider.stagedIngredients",
      "          //           .any((e) => e.id == newValue);",
      "",
      "          //   print('[repairSchemaIssue] Ingredient exists=$alreadyExists');",
      "",
      "          //   if (!alreadyExists) {",
      "          //     final staged = ingredientProvider.stageIfNew(",
      "          //       id: newValue,",
      "          //       name: issue.label ?? 'Unnamed Ingredient',",
      "          //     );",
      "          //     if (staged) {",
      "          //       print('[repairSchemaIssue] Staged new ingredient: $newValue');",
      "          //     } else {",
      "          //       print('[WARNING] Failed to stage ingredient: $newValue');",
      "          //     }",
      "          //   }",
      "          // }",
      "",
      "          // if (issue.type == MenuItemSchemaIssueType.ingredientType) {",
      "          //   final alreadyExists =",
      "          //       typeProvider.ingredientTypes.any((t) => t.id == newValue) ||",
      "          //           typeProvider.stagedTypes.any((t) => t.id == newValue);",
      "",
      "          //   print('[repairSchemaIssue] Ingredient type exists=$alreadyExists');",
      "",
      "          //   if (!alreadyExists) {",
      "          //     final staged = typeProvider.stageIfNew(",
      "          //       id: newValue,",
      "          //       name: issue.label ?? 'Unnamed Type',",
      "          //     );",
      "          //     if (staged) {",
      "          //       print(",
      "          //           '[repairSchemaIssue] Staged new ingredient type: $newValue');",
      "          //     } else {",
      "          //       print('[WARNING] Failed to stage ingredient type: $newValue');",
      "          //     }",
      "          //   }",
      "          // }",
      "          break;",
      "",
      "        default:",
      "          print('[WARNING] Unhandled schema repair field: ${issue.field}');",
      "      }",
      "    });",
      "",
      "    Future.delayed(const Duration(milliseconds: 50), () {",
      "      print('[MenuItemEditorSheet] Revalidating schema after repair...');",
      "",
      "      final freshItem = buildMenuItemForSchemaCheck(",
      "        existing: widget.existing,",
      "        name: name,",
      "        description: description,",
      "        price: price,",
      "        categoryId: categoryId,",
      "        outOfStock: outOfStock,",
      "        imageUrl: imageUrl,",
      "        customizationGroups: customizationGroups,",
      "        includedIngredients: includedIngredients,",
      "        optionalAddOns: optionalAddOns,",
      "        customizations: customizations,",
      "        nutrition: nutrition,",
      "        selectedTemplateRefs: selectedTemplateRefs,",
      "        sizeData: sizeData,",
      "        categories: categoryProvider.categories,",
      "        notes: notes,",
      "        sku: sku,",
      "        dietaryTags: dietaryTags,",
      "        allergens: allergens,",
      "        prepTime: prepTime,",
      "        sortOrder: sortOrder,",
      "        taxCategory: taxCategory,",
      "        exportId: exportId,",
      "        crustTypes: crustTypes,",
      "        cookTypes: cookTypes,",
      "        cutStyles: cutStyles,",
      "        sauceOptions: sauceOptions,",
      "        dressingOptions: dressingOptions,",
      "        maxFreeToppings: maxFreeToppings,",
      "        maxFreeSauces: maxFreeSauces,",
      "        maxFreeDressings: maxFreeDressings,",
      "        maxToppings: maxToppings,",
      "        customizationsUpdatedAt: customizationsUpdatedAt,",
      "        createdAt: createdAt,",
      "        comboId: comboId,",
      "        bundleItems: bundleItems,",
      "        bundleDiscount: bundleDiscount,",
      "        highlightTags: highlightTags,",
      "        allowSpecialInstructions: allowSpecialInstructions,",
      "        hideInMenu: hideInMenu,",
      "        freeSauceCount: freeSauceCount,",
      "        extraSauceUpcharge: extraSauceUpcharge,",
      "        freeDressingCount: freeDressingCount,",
      "        extraDressingUpcharge: extraDressingUpcharge,",
      "        dippingSauceOptions: dippingSauceOptions,",
      "        dippingSplits: dippingSplits,",
      "        sideDipSauceOptions: sideDipSauceOptions,",
      "        freeDipCupCount: freeDipCupCount,",
      "        sideDipUpcharge: sideDipUpcharge,",
      "        extraCharges: extraCharges,",
      "        rawCustomizations: rawCustomizations,",
      "      );",
      "",
      "      final freshIssues = MenuItemSchemaIssue.detectAllIssues(",
      "        menuItem: freshItem,",
      "        categories: categoryProvider.categories,",
      "        ingredients: ingredientProvider.allIngredients,",
      "        ingredientTypes: typeProvider.ingredientTypes,",
      "      );",
      "",
      "      final updatedIssues = <MenuItemSchemaIssue>[];",
      "      print(",
      "          '[repairSchemaIssue] Found ${freshIssues.length} new issues after rebuild');",
      "",
      "      for (final newIssue in freshIssues) {",
      "        final existing = _schemaIssues.firstWhere(",
      "          (e) =>",
      "              e.type == newIssue.type &&",
      "              e.missingReference == newIssue.missingReference &&",
      "              e.field == newIssue.field &&",
      "              e.context == newIssue.context,",
      "          orElse: () => newIssue,",
      "        );",
      "",
      "        final resolved = existing.resolved;",
      "        updatedIssues.add(resolved ? newIssue.markResolved(true) : newIssue);",
      "      }",
      "",
      "      for (final newIssue in freshIssues) {",
      "        if (!updatedIssues.any((i) =>",
      "            i.type == newIssue.type &&",
      "            i.missingReference == newIssue.missingReference &&",
      "            i.field == newIssue.field &&",
      "            i.context == newIssue.context)) {",
      "          updatedIssues.add(newIssue);",
      "          print(",
      "              '[repairSchemaIssue] Appended new issue: ${newIssue.displayMessage}');",
      "        }",
      "      }",
      "",
      "      print('[MenuItemEditorSheet] Updated schema issues list:');",
      "      for (final i in updatedIssues) {",
      "        print('  • ${i.displayMessage} | resolved=${i.resolved}');",
      "      }",
      "",
      "      setState(() {",
      "        _schemaIssues = updatedIssues;",
      "        _showSchemaSidebar = updatedIssues.any((i) => !i.resolved);",
      "      });",
      "",
      "      widget.onSchemaIssuesChanged?.call(updatedIssues);",
      "    });",
      "  }",
      "",
      "  void _repairIngredientOrType(MenuItemSchemaIssue issue, String newValue) {",
      "    final ingredientProvider = context.read<IngredientMetadataProvider>();",
      "    final typeProvider = context.read<IngredientTypeProvider>();",
      "",
      "    final ingredientExists = ingredientProvider.getById(newValue) != null;",
      "    final typeExists = typeProvider.getById(newValue) != null;",
      "",
      "    print('[DEBUG] Lookup results: ingredientExists=$ingredientExists, '",
      "        'typeExists=$typeExists, issueType=${issue.type}');",
      "",
      "    // Attempt to stage ingredient if missing",
      "    if (issue.type == MenuItemSchemaIssueType.ingredient && !ingredientExists) {",
      "      final stagedName = issue.label ?? newValue;",
      "      print(",
      "          '[DEBUG] Attempting to stage new ingredient: id=$newValue, name=$stagedName');",
      "      final staged = ingredientProvider.stageIfNew(",
      "        id: newValue,",
      "        name: stagedName,",
      "      );",
      "      if (staged) {",
      "        print(",
      "            '[DEBUG] Successfully staged ingredient: id=$newValue, name=$stagedName');",
      "      } else {",
      "        print(",
      "            '[WARNING] Failed to stage ingredient (already exists?): id=$newValue');",
      "      }",
      "    }",
      "",
      "    // Attempt to stage ingredient type if missing",
      "    if (issue.type == MenuItemSchemaIssueType.ingredientType && !typeExists) {",
      "      final stagedName = issue.label ?? newValue;",
      "      print(",
      "          '[DEBUG] Attempting to stage new ingredient type: id=$newValue, name=$stagedName');",
      "      final staged = typeProvider.stageIfNew(",
      "        id: newValue,",
      "        name: stagedName,",
      "      );",
      "      if (staged) {",
      "        print(",
      "            '[DEBUG] Successfully staged ingredient type: id=$newValue, name=$stagedName');",
      "      } else {",
      "        print(",
      "            '[WARNING] Failed to stage ingredient type (already exists?): id=$newValue');",
      "      }",
      "    }",
      "",
      "    IngredientReference updateEntry(IngredientReference entry) {",
      "      final matchesId =",
      "          entry.id.toLowerCase() == issue.missingReference.toLowerCase();",
      "      final matchesName = issue.label != null &&",
      "          entry.name.trim().toLowerCase() == issue.label!.trim().toLowerCase();",
      "",
      "      if (issue.type == MenuItemSchemaIssueType.ingredient &&",
      "          (matchesId || matchesName)) {",
      "        print('[repairIngredientOrType] Matching entry: '",
      "            'id=${entry.id}, name=${entry.name}, typeId=${entry.typeId}, '",
      "            'issueType=${issue.type}, field=${issue.field}');",
      "        print('[repairIngredientOrType] Updated entry → '",
      "            'oldId=${entry.id}, newId=$newValue');",
      "        return entry.copyWith(id: newValue);",
      "      }",
      "",
      "      if (issue.type == MenuItemSchemaIssueType.ingredientType &&",
      "          (matchesName || entry.typeId.isEmpty)) {",
      "        print('[repairIngredientOrType] Matching entry: '",
      "            'id=${entry.id}, name=${entry.name}, typeId=${entry.typeId}, '",
      "            'issueType=${issue.type}, field=${issue.field}');",
      "        print('[repairIngredientOrType] Updated entry → '",
      "            'oldTypeId=${entry.typeId}, newTypeId=$newValue');",
      "        return entry.copyWith(typeId: newValue);",
      "      }",
      "",
      "      return entry;",
      "    }",
      "",
      "    if (issue.field == 'includedIngredients') {",
      "      includedIngredients = includedIngredients.map(updateEntry).toList();",
      "      print('[repairIngredientOrType] Updated includedIngredients entries: '",
      "          '${includedIngredients.length}');",
      "    } else if (issue.field == 'optionalAddOns') {",
      "      optionalAddOns = optionalAddOns.map(updateEntry).toList();",
      "      print('[repairIngredientOrType] Updated optionalAddOns entries: '",
      "          '${optionalAddOns.length}');",
      "    } else if (issue.field.startsWith('customizationGroups')) {",
      "      customizationGroups = customizationGroups.map((group) {",
      "        final updated = group.ingredients.map(updateEntry).toList();",
      "        return group.copyWith(ingredients: updated);",
      "      }).toList();",
      "      print('[repairIngredientOrType] Updated customizationGroups entries: '",
      "          '${customizationGroups.length}');",
      "    }",
      "",
      "    print(",
      "        '[DEBUG] _repairIngredientOrType completed. Issue type: ${issue.type}, newValue: $newValue');",
      "  }",
      "",
      "  void _checkForSchemaIssues() {",
      "    final categories = context.read<CategoryProvider>().categories;",
      "    final ingredients =",
      "        context.read<IngredientMetadataProvider>().allIngredients;",
      "    final ingredientTypes =",
      "        context.read<IngredientTypeProvider>().ingredientTypes;",
      "",
      "    final tempItem = buildMenuItemForSchemaCheck(",
      "      existing: widget.existing,",
      "      name: name,",
      "      description: description,",
      "      price: price,",
      "      categoryId: categoryId,",
      "      outOfStock: outOfStock,",
      "      imageUrl: imageUrl,",
      "      customizationGroups: customizationGroups,",
      "      includedIngredients: includedIngredients,",
      "      optionalAddOns: optionalAddOns,",
      "      customizations: customizations,",
      "      nutrition: nutrition,",
      "      selectedTemplateRefs: selectedTemplateRefs,",
      "      sizeData: sizeData,",
      "      categories: categories,",
      "      notes: notes,",
      "      sku: sku,",
      "      dietaryTags: dietaryTags,",
      "      allergens: allergens,",
      "      prepTime: prepTime,",
      "      sortOrder: sortOrder,",
      "      taxCategory: taxCategory,",
      "      exportId: exportId,",
      "      crustTypes: crustTypes,",
      "      cookTypes: cookTypes,",
      "      cutStyles: cutStyles,",
      "      sauceOptions: sauceOptions,",
      "      dressingOptions: dressingOptions,",
      "      maxFreeToppings: maxFreeToppings,",
      "      maxFreeSauces: maxFreeSauces,",
      "      maxFreeDressings: maxFreeDressings,",
      "      maxToppings: maxToppings,",
      "      customizationsUpdatedAt: customizationsUpdatedAt,",
      "      createdAt: createdAt,",
      "      comboId: comboId,",
      "      bundleItems: bundleItems,",
      "      bundleDiscount: bundleDiscount,",
      "      highlightTags: highlightTags,",
      "      allowSpecialInstructions: allowSpecialInstructions,",
      "      hideInMenu: hideInMenu,",
      "      freeSauceCount: freeSauceCount,",
      "      extraSauceUpcharge: extraSauceUpcharge,",
      "      freeDressingCount: freeDressingCount,",
      "      extraDressingUpcharge: extraDressingUpcharge,",
      "      dippingSauceOptions: dippingSauceOptions,",
      "      dippingSplits: dippingSplits,",
      "      sideDipSauceOptions: sideDipSauceOptions,",
      "      freeDipCupCount: freeDipCupCount,",
      "      sideDipUpcharge: sideDipUpcharge,",
      "      extraCharges: extraCharges,",
      "      rawCustomizations: rawCustomizations,",
      "    );",
      "",
      "    final freshIssues = MenuItemSchemaIssue.detectAllIssues(",
      "      menuItem: tempItem,",
      "      categories: context.read<CategoryProvider>().categories,",
      "      ingredients: context.read<IngredientMetadataProvider>().allIngredients,",
      "      ingredientTypes: context.read<IngredientTypeProvider>().ingredientTypes,",
      "    );",
      "",
      "    // Preserve resolved state",
      "    final updatedIssues = <MenuItemSchemaIssue>[];",
      "",
      "    for (final newIssue in freshIssues) {",
      "      final existing = _schemaIssues.firstWhere(",
      "        (e) =>",
      "            e.type == newIssue.type &&",
      "            e.missingReference == newIssue.missingReference &&",
      "            e.field == newIssue.field &&",
      "            e.context == newIssue.context,",
      "        orElse: () => newIssue,",
      "      );",
      "",
      "      final resolved = existing.resolved;",
      "      updatedIssues.add(resolved ? newIssue.markResolved(true) : newIssue);",
      "    }",
      "",
      "// Add any new issues that weren't in the original list",
      "    for (final newIssue in freshIssues) {",
      "      if (!updatedIssues.any((i) =>",
      "          i.type == newIssue.type &&",
      "          i.missingReference == newIssue.missingReference &&",
      "          i.field == newIssue.field &&",
      "          i.context == newIssue.context)) {",
      "        updatedIssues.add(newIssue);",
      "      }",
      "    }",
      "",
      "    print(",
      "        '[MenuItemEditorSheet] _checkForSchemaIssues found ${updatedIssues.length} issue(s):');",
      "    for (final i in updatedIssues) {",
      "      print(' - ${i.displayMessage} | resolved=${i.resolved}');",
      "    }",
      "",
      "    setState(() {",
      "      _schemaIssues = updatedIssues;",
      "      _showSchemaSidebar = updatedIssues.any((e) => !e.resolved);",
      "    });",
      "",
      "    widget.onSchemaIssuesChanged?.call(_schemaIssues);",
      "  }",
      "",
      "  void _applyTemplate(MenuItem item) {",
      "    print('[MenuItemEditorSheet] _applyTemplate called with item: '",
      "        'id=${item.id}, name=${item.name}, categoryId=${item.categoryId}, '",
      "        'customizationGroups=${item.customizationGroups?.length ?? 0}');",
      "    print('[MenuItemEditorSheet] Template data dump: ${item.toJson()}');",
      "    try {",
      "      final allIngredients =",
      "          context.read<IngredientMetadataProvider>().allIngredients;",
      "      final fieldMap = extractTemplateFieldsForEditor(item, allIngredients);",
      "",
      "      // DEFER ALL STATE UPDATES TO NEXT FRAME!",
      "      WidgetsBinding.instance.addPostFrameCallback((_) {",
      "        setState(() {",
      "          // --- Update controllers for user-editable fields ---",
      "          _nameController.text = fieldMap['name'] ?? '';",
      "          name = fieldMap['name'] ?? '';",
      "",
      "          _descriptionController.text = fieldMap['description'] ?? '';",
      "          description = fieldMap['description'] ?? '';",
      "",
      "          _priceController.text = (fieldMap['price'] ?? 0.0).toString();",
      "          price = fieldMap['price'] ?? 0.0;",
      "",
      "          categoryId = fieldMap['categoryId'] ?? '';",
      "          imageUrl = fieldMap['imageUrl'] ?? '';",
      "          nutrition = fieldMap['nutrition'];",
      "          includedIngredients = List<IngredientReference>.from(",
      "              fieldMap['includedIngredients'] ?? []);",
      "          optionalAddOns =",
      "              List<IngredientReference>.from(fieldMap['optionalAddOns'] ?? []);",
      "          customizations =",
      "              List<Customization>.from(fieldMap['customizations'] ?? []);",
      "          sizeData = List<SizeData>.from(fieldMap['sizeData'] ?? []);",
      "          customizationGroups = List<CustomizationGroup>.from(",
      "              fieldMap['customizationGroups'] ?? []);",
      "          selectedTemplateRefs =",
      "              List<String>.from(fieldMap['selectedTemplateRefs'] ?? []);",
      "          notes = fieldMap['notes'];",
      "          sku = fieldMap['sku'];",
      "          dietaryTags = List<String>.from(fieldMap['dietaryTags'] ?? []);",
      "          allergens = List<String>.from(fieldMap['allergens'] ?? []);",
      "          prepTime = fieldMap['prepTime'];",
      "          sortOrder = fieldMap['sortOrder'];",
      "          taxCategory = fieldMap['taxCategory'] ?? 'standard';",
      "          exportId = fieldMap['exportId'];",
      "          crustTypes = fieldMap['crustTypes'];",
      "          cookTypes = fieldMap['cookTypes'];",
      "          cutStyles = fieldMap['cutStyles'];",
      "          sauceOptions = fieldMap['sauceOptions'];",
      "          dressingOptions = fieldMap['dressingOptions'];",
      "          maxFreeToppings = fieldMap['maxFreeToppings'];",
      "          maxFreeSauces = fieldMap['maxFreeSauces'];",
      "          maxFreeDressings = fieldMap['maxFreeDressings'];",
      "          maxToppings = fieldMap['maxToppings'];",
      "          customizationsUpdatedAt = fieldMap['customizationsUpdatedAt'];",
      "          createdAt = fieldMap['createdAt'];",
      "          comboId = fieldMap['comboId'];",
      "          bundleItems = fieldMap['bundleItems'];",
      "          bundleDiscount = fieldMap['bundleDiscount'];",
      "          highlightTags = fieldMap['highlightTags'];",
      "          allowSpecialInstructions = fieldMap['allowSpecialInstructions'];",
      "          hideInMenu = fieldMap['hideInMenu'];",
      "          freeSauceCount = fieldMap['freeSauceCount'];",
      "          extraSauceUpcharge = fieldMap['extraSauceUpcharge'];",
      "          freeDressingCount = fieldMap['freeDressingCount'];",
      "          extraDressingUpcharge = fieldMap['extraDressingUpcharge'];",
      "          dippingSauceOptions = fieldMap['dippingSauceOptions'];",
      "          dippingSplits = fieldMap['dippingSplits'];",
      "          sideDipSauceOptions = fieldMap['sideDipSauceOptions'];",
      "          freeDipCupCount = fieldMap['freeDipCupCount'];",
      "          sideDipUpcharge = fieldMap['sideDipUpcharge'];",
      "          extraCharges = fieldMap['extraCharges'];",
      "          rawCustomizations = fieldMap['rawCustomizations'];",
      "          isDirty = true;",
      "          print(",
      "              '[MenuItemEditorSheet] Template applied. Triggered schema re-check.');",
      "          _checkForSchemaIssues();",
      "        });",
      "",
      "        _formKey.currentState?.validate();",
      "      });",
      "    } catch (e, st) {",
      "      print('[MenuItemEditorSheet] ERROR applying template: $e\\n$st');",
      "      ErrorLogger.log(",
      "        message: 'Failed to apply template into editor state',",
      "        source: 'menu_item_editor_sheet.dart',",
      "        screen: 'menu_item_editor_sheet.dart',",
      "        severity: 'warning',",
      "        stack: st.toString(),",
      "        contextData: {",
      "          'templateRefs': item.templateRefs?.join(', ') ?? 'none',",
      "          'menuItemId': item.id,",
      "          'name': item.name,",
      "          'env': kReleaseMode ? 'production' : 'development',",
      "        },",
      "      );",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        const SnackBar(content: Text('Failed to apply template. See logs.')),",
      "      );",
      "    }",
      "  }",
      "",
      "  void _saveItem() {",
      "    print(",
      "        '[DEBUG] Save Button Enabled: schemaIssues=${_schemaIssues.length}, isDirty=$isDirty');",
      "",
      "    // Sync fields from controllers before checking schema",
      "    name = _nameController.text.trim();",
      "    description = _descriptionController.text.trim();",
      "    price = double.tryParse(_priceController.text.trim()) ?? 0.0;",
      "    _schemaIssues.removeWhere((issue) => issue.resolved);",
      "    _checkForSchemaIssues();",
      "    print(",
      "        '[DEBUG] Schema issues at save: ${_schemaIssues.map((e) => e.displayMessage).toList()}');",
      "",
      "    if (_schemaIssues.isNotEmpty) {",
      "      setState(() {",
      "        _showSchemaSidebar = true;",
      "      });",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        const SnackBar(",
      "          content: Text('Resolve all schema issues before saving.'),",
      "          backgroundColor: Colors.red,",
      "        ),",
      "      );",
      "      return;",
      "    }",
      "    print('[MenuItemEditorSheet] _saveItem called');",
      "    print('[MenuItemEditorSheet] Current form state: '",
      "        'name=$name, description=$description, price=$price, categoryId=$categoryId, '",
      "        'imageUrl=$imageUrl, includedIngredients=${includedIngredients.length}, '",
      "        'optionalAddOns=${optionalAddOns.length}, customizations=${customizations.length}, '",
      "        'customizationGroups=${customizationGroups.length}, sizeData=${sizeData.length}, '",
      "        'selectedTemplateRefs=$selectedTemplateRefs, nutrition=$nutrition, outOfStock=$outOfStock');",
      "    final categories = context.read<CategoryProvider>().categories;",
      "    if (!_formKey.currentState!.validate()) return;",
      "",
      "    if (categoryId == null || categoryId!.isEmpty) {",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        const SnackBar(content: Text('Please select a category')),",
      "      );",
      "      return;",
      "    }",
      "",
      "    final categoryName =",
      "        categories.firstWhere((cat) => cat.id == categoryId).name;",
      "",
      "    if (sizeData.isEmpty) {",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        const SnackBar(content: Text('Please add at least one size.')),",
      "      );",
      "      return;",
      "    }",
      "",
      "    print('[MenuItemEditorSheet] Constructing MenuItem for save...');",
      "    final item = constructMenuItemFromEditorFields(",
      "      id: widget.existing?.id ?? const Uuid().v4(),",
      "      outOfStock: outOfStock,",
      "      categoryName: categoryName,",
      "      categoryId: categoryId!,",
      "      name: name,",
      "      price: price,",
      "      description: description,",
      "      notes: notes,",
      "      sku: sku,",
      "      dietaryTags: dietaryTags,",
      "      allergens: allergens,",
      "      prepTime: prepTime,",
      "      sortOrder: sortOrder,",
      "      taxCategory: taxCategory,",
      "      exportId: exportId,",
      "      customizationGroups: customizationGroups,",
      "      includedIngredients: includedIngredients,",
      "      optionalAddOns: optionalAddOns,",
      "      customizations: customizations,",
      "      imageUrl: imageUrl,",
      "      nutrition: nutrition,",
      "      selectedTemplateRefs: selectedTemplateRefs,",
      "      sizeData: sizeData,",
      "      crustTypes: crustTypes,",
      "      cookTypes: cookTypes,",
      "      cutStyles: cutStyles,",
      "      sauceOptions: sauceOptions,",
      "      dressingOptions: dressingOptions,",
      "      maxFreeToppings: maxFreeToppings,",
      "      maxFreeSauces: maxFreeSauces,",
      "      maxFreeDressings: maxFreeDressings,",
      "      maxToppings: maxToppings,",
      "      customizationsUpdatedAt: customizationsUpdatedAt,",
      "      createdAt: createdAt,",
      "      comboId: comboId,",
      "      bundleItems: bundleItems,",
      "      bundleDiscount: bundleDiscount,",
      "      highlightTags: highlightTags,",
      "      allowSpecialInstructions: allowSpecialInstructions,",
      "      hideInMenu: hideInMenu,",
      "      freeSauceCount: freeSauceCount,",
      "      extraSauceUpcharge: extraSauceUpcharge,",
      "      freeDressingCount: freeDressingCount,",
      "      extraDressingUpcharge: extraDressingUpcharge,",
      "      dippingSauceOptions: dippingSauceOptions,",
      "      dippingSplits: dippingSplits,",
      "      sideDipSauceOptions: sideDipSauceOptions,",
      "      freeDipCupCount: freeDipCupCount,",
      "      sideDipUpcharge: sideDipUpcharge,",
      "      extraCharges: extraCharges,",
      "      rawCustomizations: rawCustomizations,",
      "    );",
      "",
      "    print('[MenuItemEditorSheet] MenuItem constructed: ${item.toJson()}');",
      "    widget.onSave(item);",
      "  }",
      "",
      "  void _editNutrition() async {",
      "    final result = await showDialog<NutritionInfo?>(",
      "      context: context,",
      "      builder: (_) => NutritionEditorDialog(initialValue: nutrition),",
      "    );",
      "",
      "    if (result != null) {",
      "      setState(() {",
      "        nutrition = result;",
      "        isDirty = true;",
      "      });",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final categories = context.watch<CategoryProvider>().categories;",
      "    final templates = context.read<MenuItemProvider>().templateRefs;",
      "    final availableTemplates = context.watch<MenuItemProvider>().sizeTemplates;",
      "    final hasCategories = categories.isNotEmpty;",
      "    final hasIngredients =",
      "        context.read<IngredientMetadataProvider>().allIngredients.isNotEmpty;",
      "",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "    final loc = AppLocalizations.of(context)!;",
      "    return Stack(",
      "      children: [",
      "        Scaffold(",
      "          appBar: AppBar(",
      "            backgroundColor: theme.scaffoldBackgroundColor,",
      "            elevation: 0,",
      "            iconTheme: const IconThemeData(color: Colors.black),",
      "            title: Text(",
      "              '${widget.existing == null ? loc.addMenuItem : loc.editMenuItem}',",
      "              style: theme.textTheme.titleLarge?.copyWith(",
      "                fontWeight: FontWeight.bold,",
      "                color: colorScheme.onSurface,",
      "              ),",
      "            ),",
      "            actions: [",
      "              // Optional save button logic can be re-enabled here",
      "              // TextButton(",
      "              //   onPressed: (!(_showSchemaSidebar && _schemaIssues.isNotEmpty) &&",
      "              //           (_schemaIssues.isEmpty || isDirty))",
      "              //       ? _saveItem",
      "              //       : null,",
      "              //   child: Text(",
      "              //     loc.save,",
      "              //     style: TextStyle(color: colorScheme.primary),",
      "              //   ),",
      "              // ),",
      "            ],",
      "          ),",
      "          body: SafeArea(",
      "            child: !hasCategories || !hasIngredients",
      "                ? EmptyStateWidget(",
      "                    title: 'No Categories or Ingredients',",
      "                    message:",
      "                        'You must create at least one category and one ingredient before adding menu items.',",
      "                    iconData: Icons.warning_amber_rounded,",
      "                    isAdmin: true,",
      "                  )",
      "                : SingleChildScrollView(",
      "                    controller: ScrollController(),",
      "                    padding: const EdgeInsets.all(16),",
      "                    child: Material(",
      "                      type: MaterialType.transparency,",
      "                      child: Form(",
      "                        key: _formKey,",
      "                        onChanged: () => setState(() => isDirty = true),",
      "                        child: Column(",
      "                          crossAxisAlignment: CrossAxisAlignment.start,",
      "                          children: [",
      "                            // Section 0: Menu Item Template Dropdown",
      "                            Row(",
      "                              crossAxisAlignment: CrossAxisAlignment.center,",
      "                              children: [",
      "                                const Text(",
      "                                  'Menu Item Template:',",
      "                                  style: TextStyle(fontWeight: FontWeight.w600),",
      "                                ),",
      "                                const SizedBox(width: 12),",
      "                                Expanded(",
      "                                  child: MenuItemTemplateDropdown(",
      "                                    selectedTemplateId: selectedTemplate,",
      "                                    onTemplateApplied: _applyTemplate,",
      "                                  ),",
      "                                ),",
      "                              ],",
      "                            ),",
      "                            const SizedBox(height: 16),",
      "",
      "                            // Section 1: Basic Info",
      "                            TextFormField(",
      "                              controller: _nameController,",
      "                              decoration:",
      "                                  const InputDecoration(labelText: 'Name'),",
      "                              onChanged: (val) => name = val,",
      "                              validator: (val) => val == null || val.isEmpty",
      "                                  ? 'Name required'",
      "                                  : null,",
      "                            ),",
      "                            TextFormField(",
      "                              controller: _descriptionController,",
      "                              decoration: const InputDecoration(",
      "                                  labelText: 'Description'),",
      "                              onChanged: (val) => description = val,",
      "                              maxLines: 2,",
      "                            ),",
      "",
      "                            Row(",
      "                              children: [",
      "                                Expanded(",
      "                                  child: TextFormField(",
      "                                    controller: _priceController,",
      "                                    keyboardType:",
      "                                        const TextInputType.numberWithOptions(",
      "                                            decimal: true),",
      "                                    decoration: const InputDecoration(",
      "                                        labelText: 'Price'),",
      "                                    onChanged: (val) =>",
      "                                        price = double.tryParse(val) ?? 0.0,",
      "                                  ),",
      "                                ),",
      "                                const SizedBox(width: 16),",
      "                                Expanded(",
      "                                  child: DropdownButtonFormField<String>(",
      "                                    value: categories",
      "                                            .any((cat) => cat.id == categoryId)",
      "                                        ? categoryId",
      "                                        : null,",
      "                                    decoration: const InputDecoration(",
      "                                        labelText: 'Category'),",
      "                                    items: categories",
      "                                        .map((cat) => DropdownMenuItem(",
      "                                              value: cat.id,",
      "                                              child: Text(cat.name),",
      "                                            ))",
      "                                        .toList(),",
      "                                    onChanged: (val) =>",
      "                                        setState(() => categoryId = val),",
      "                                  ),",
      "                                ),",
      "                              ],",
      "                            ),",
      "                            SwitchListTile(",
      "                              value: outOfStock,",
      "                              onChanged: (val) =>",
      "                                  setState(() => outOfStock = val),",
      "                              title: const Text('Out of Stock'),",
      "                            ),",
      "",
      "                            const SizedBox(height: 20),",
      "",
      "                            ExpansionTile(",
      "                              title: const Text('Advanced Fields'),",
      "                              initiallyExpanded: false,",
      "                              children: [",
      "                                TextFormField(",
      "                                  initialValue: notes ?? '',",
      "                                  decoration:",
      "                                      const InputDecoration(labelText: 'Notes'),",
      "                                  onChanged: (val) => notes = val,",
      "                                ),",
      "                                TextFormField(",
      "                                  initialValue: sku ?? '',",
      "                                  decoration:",
      "                                      const InputDecoration(labelText: 'SKU'),",
      "                                  onChanged: (val) => sku = val,",
      "                                ),",
      "                                TextFormField(",
      "                                  initialValue: taxCategory,",
      "                                  decoration: const InputDecoration(",
      "                                      labelText: 'Tax Category'),",
      "                                  onChanged: (val) => taxCategory = val,",
      "                                ),",
      "                                TextFormField(",
      "                                  initialValue: prepTime?.toString() ?? '',",
      "                                  decoration: const InputDecoration(",
      "                                      labelText: 'Prep Time (min)'),",
      "                                  keyboardType: TextInputType.number,",
      "                                  onChanged: (val) =>",
      "                                      prepTime = int.tryParse(val),",
      "                                ),",
      "                                // Add more as needed, or use ChipsInput for tags/allergens, etc.",
      "                              ],",
      "                            ),",
      "",
      "                            const SizedBox(height: 20),",
      "",
      "                            // Section 2b: Size Pricing",
      "                            SizePricingEditor(",
      "                              sizes: sizeData,",
      "                              onChanged: (val) {",
      "                                print(",
      "                                    '[MenuItemEditorSheet] sizeData changed: $val');",
      "                                setState(() {",
      "                                  sizeData = val;",
      "                                  isDirty = true;",
      "                                });",
      "                              },",
      "                              trailingTemplateDropdown:",
      "                                  DropdownButton<SizeTemplate>(",
      "                                isExpanded: true,",
      "                                value: availableTemplates.firstWhereOrNull(",
      "                                  (t) => const DeepCollectionEquality()",
      "                                      .equals(t.sizes, sizeData),",
      "                                ),",
      "                                hint: const Text('Template (optional)'),",
      "                                items: availableTemplates",
      "                                    .map((template) => DropdownMenuItem(",
      "                                          value: template,",
      "                                          child: Text(template.label),",
      "                                        ))",
      "                                    .toList(),",
      "                                onChanged: (template) {",
      "                                  if (template != null) {",
      "                                    setState(() {",
      "                                      sizeData = template.sizes;",
      "                                      isDirty = true;",
      "                                    });",
      "                                  }",
      "                                },",
      "                              ),",
      "                            ),",
      "",
      "                            const SizedBox(height: 20),",
      "",
      "                            const Divider(height: 40),",
      "",
      "                            // Section 3: Included Ingredients",
      "                            MultiIngredientSelector(",
      "                              title: 'Included Ingredients',",
      "                              selected: includedIngredients,",
      "                              onChanged: (val) =>",
      "                                  setState(() => includedIngredients = val),",
      "                            ),",
      "",
      "                            const SizedBox(height: 16),",
      "",
      "                            // Section 4: Optional Add-ons",
      "                            MultiIngredientSelector(",
      "                              title: 'Optional Add-ons',",
      "                              selected: optionalAddOns,",
      "                              onChanged: (val) =>",
      "                                  setState(() => optionalAddOns = val),",
      "                            ),",
      "",
      "                            const Divider(height: 40),",
      "",
      "                            // Section 5: Customizations",
      "                            CustomizationGroupEditor(",
      "                              value: customizationGroups,",
      "                              onChanged: (val) =>",
      "                                  setState(() => customizationGroups = val),",
      "                            ),",
      "",
      "                            const Divider(height: 40),",
      "",
      "                            // Section 6: Nutrition (FeatureGuard)",
      "                            FeatureGuard(",
      "                              module: PlatformFeature.nutritionalInfo.key,",
      "                              fallback: const SizedBox.shrink(),",
      "                              child: Column(",
      "                                crossAxisAlignment: CrossAxisAlignment.start,",
      "                                children: [",
      "                                  const Text('Nutrition Info',",
      "                                      style: TextStyle(",
      "                                          fontWeight: FontWeight.bold)),",
      "                                  TextButton(",
      "                                    onPressed: _editNutrition,",
      "                                    child: Text(nutrition == null",
      "                                        ? 'Add Nutrition'",
      "                                        : 'Edit Nutrition'),",
      "                                  ),",
      "                                  if (nutrition != null)",
      "                                    Text(",
      "                                      '${nutrition!.calories} cal | Protein: ${nutrition!.protein}g | Fat: ${nutrition!.fat}g | Carbs: ${nutrition!.carbs}g',",
      "                                      style:",
      "                                          Theme.of(context).textTheme.bodySmall,",
      "                                    ),",
      "                                ],",
      "                              ),",
      "                            ),",
      "",
      "                            const Divider(height: 40),",
      "",
      "                            // Section 7: Image Upload",
      "                            ImageUploadField(",
      "                              initialValue: imageUrl,",
      "                              onSaved: (val) => imageUrl = val ?? '',",
      "                              validator: (val) => null,",
      "                            ),",
      "",
      "                            const Divider(height: 40),",
      "",
      "                            // Preview Section",
      "                            ExpansionTile(",
      "                              title: const Text('Live Preview'),",
      "                              initiallyExpanded: false,",
      "                              children: [",
      "                                PreviewMenuItemCard(",
      "                                  menuItem: buildPreviewMenuItem(",
      "                                    existingId: widget.existing?.id,",
      "                                    outOfStock: outOfStock,",
      "                                    categoryId: categoryId,",
      "                                    name: name,",
      "                                    price: price,",
      "                                    description: description,",
      "                                    imageUrl: imageUrl,",
      "                                    nutrition: nutrition,",
      "                                    includedIngredients: includedIngredients,",
      "                                    optionalAddOns: optionalAddOns,",
      "                                    customizations: customizations,",
      "                                    selectedTemplateRefs: selectedTemplateRefs,",
      "                                  ),",
      "                                ),",
      "                              ],",
      "                            ),",
      "",
      "                            const SizedBox(height: 80),",
      "                          ],",
      "                        ),",
      "                      ),",
      "                    ),",
      "                  ),",
      "          ),",
      "          bottomNavigationBar: BottomAppBar(",
      "            child: Row(",
      "              children: [",
      "                TextButton(",
      "                  onPressed: widget.onCancel,",
      "                  child: const Text('Cancel'),",
      "                ),",
      "                const Spacer(),",
      "                ElevatedButton(",
      "                  onPressed:",
      "                      (!(_showSchemaSidebar && _schemaIssues.isNotEmpty) &&",
      "                              (_schemaIssues.isEmpty || isDirty))",
      "                          ? _saveItem",
      "                          : null,",
      "                  child: const Text('Save'),",
      "                )",
      "              ],",
      "            ),",
      "          ),",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "",
      "  @override",
      "  void dispose() {",
      "    _nameController.dispose();",
      "    _descriptionController.dispose();",
      "    _priceController.dispose();",
      "    super.dispose();",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 1236,
      "file_size": 51801,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\widgets\\menu_items\\menu_item_form_dialog.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter/services.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/models/menu_item.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class MenuItemFormDialog extends StatefulWidget {",
      "  final MenuItem? initialItem;",
      "",
      "  const MenuItemFormDialog({super.key, this.initialItem});",
      "",
      "  static Future<void> show(BuildContext context,",
      "      {MenuItem? initialItem}) async {",
      "    await showDialog(",
      "      context: context,",
      "      builder: (_) => MenuItemFormDialog(initialItem: initialItem),",
      "    );",
      "  }",
      "",
      "  @override",
      "  State<MenuItemFormDialog> createState() => _MenuItemFormDialogState();",
      "}",
      "",
      "class _MenuItemFormDialogState extends State<MenuItemFormDialog> {",
      "  final _formKey = GlobalKey<FormState>();",
      "  late TextEditingController _nameController;",
      "  late TextEditingController _descController;",
      "  late TextEditingController _priceController;",
      "  late TextEditingController _categoryIdController;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    final item = widget.initialItem;",
      "    _nameController = TextEditingController(text: item?.name ?? '');",
      "    _descController = TextEditingController(text: item?.description ?? '');",
      "    _priceController = TextEditingController(",
      "      text: item != null ? item.price.toStringAsFixed(2) : '',",
      "    );",
      "    _categoryIdController = TextEditingController(text: item?.categoryId ?? '');",
      "  }",
      "",
      "  @override",
      "  void dispose() {",
      "    _nameController.dispose();",
      "    _descController.dispose();",
      "    _priceController.dispose();",
      "    _categoryIdController.dispose();",
      "    super.dispose();",
      "  }",
      "",
      "  Future<void> _save() async {",
      "    final loc = AppLocalizations.of(context)!;",
      "    final franchiseId = context.read<FranchiseProvider>().franchiseId;",
      "",
      "    if (!_formKey.currentState!.validate()) return;",
      "",
      "    try {",
      "      final menuItem = MenuItem(",
      "        id: widget.initialItem?.id ?? UniqueKey().toString(),",
      "        available: true,",
      "        name: _nameController.text.trim(),",
      "        description: _descController.text.trim(),",
      "        price: double.tryParse(_priceController.text.trim()) ?? 0.0,",
      "        availability: true,",
      "        category: '',",
      "        categoryId: _categoryIdController.text.trim(),",
      "        taxCategory: 'default',",
      "        customizations: [],",
      "        customizationGroups: [],",
      "      );",
      "",
      "      if (!mounted) return;",
      "      Navigator.of(context).pop(menuItem);",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to create menu item',",
      "        source: 'menu_item_form_dialog',",
      "        screen: 'menu_item_form_dialog',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "        },",
      "      );",
      "      if (!mounted) return;",
      "      ScaffoldMessenger.of(context)",
      "          .showSnackBar(SnackBar(content: Text(loc.errorGeneric)));",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final theme = Theme.of(context);",
      "    final loc = AppLocalizations.of(context)!;",
      "    final colorScheme = theme.colorScheme;",
      "",
      "    return AlertDialog(",
      "      title: Text(widget.initialItem == null",
      "          ? loc.addMenuItem",
      "          : loc.editMenuItem(widget.initialItem!.name)),",
      "      content: SingleChildScrollView(",
      "        child: Form(",
      "          key: _formKey,",
      "          child: Column(",
      "            mainAxisSize: MainAxisSize.min,",
      "            children: [",
      "              TextFormField(",
      "                controller: _nameController,",
      "                decoration: InputDecoration(labelText: loc.name),",
      "                validator: (val) => val == null || val.trim().isEmpty",
      "                    ? loc.fieldRequired",
      "                    : null,",
      "              ),",
      "              TextFormField(",
      "                controller: _descController,",
      "                decoration: InputDecoration(labelText: loc.description),",
      "              ),",
      "              TextFormField(",
      "                controller: _priceController,",
      "                decoration: InputDecoration(labelText: loc.basePrice),",
      "                keyboardType:",
      "                    const TextInputType.numberWithOptions(decimal: true),",
      "                inputFormatters: [",
      "                  FilteringTextInputFormatter.allow(",
      "                      RegExp(r'^[0-9]*[.]?[0-9]*')),",
      "                ],",
      "              ),",
      "              TextFormField(",
      "                controller: _categoryIdController,",
      "                decoration: InputDecoration(labelText: loc.categoryId),",
      "              ),",
      "            ],",
      "          ),",
      "        ),",
      "      ),",
      "      actions: [",
      "        TextButton(",
      "          onPressed: () => Navigator.of(context).pop(),",
      "          child: Text(loc.cancel),",
      "        ),",
      "        ElevatedButton(",
      "          onPressed: _save,",
      "          style: ElevatedButton.styleFrom(",
      "            backgroundColor: DesignTokens.primaryColor,",
      "          ),",
      "          child: Text(loc.save),",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 155,
      "file_size": 5221,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\widgets\\menu_items\\menu_item_json_import_export_dialog.dart",
    "content": [
      "import 'dart:convert';",
      "import 'package:flutter/material.dart';",
      "import 'package:flutter/services.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/models/menu_item.dart';",
      "import 'package:franchise_admin_portal/core/providers/menu_item_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "",
      "class MenuItemJsonImportExportDialog {",
      "  static Future<void> show(BuildContext context) async {",
      "    final loc = AppLocalizations.of(context)!;",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "    final menuItemProvider = context.read<MenuItemProvider>();",
      "    final franchiseId = context.read<FranchiseProvider>().franchiseId;",
      "",
      "    final itemsJson = menuItemProvider.menuItems.map((e) {",
      "      final map = e.toMap();",
      "      map.updateAll((key, value) {",
      "        if (value is Timestamp) return value.toDate().toIso8601String();",
      "        return value;",
      "      });",
      "      return map;",
      "    }).toList();",
      "",
      "    final controller = TextEditingController(",
      "      text: const JsonEncoder.withIndent('  ').convert(itemsJson),",
      "    );",
      "",
      "    await showDialog(",
      "      context: context,",
      "      builder: (context) => AlertDialog(",
      "        scrollable: true,",
      "        backgroundColor: colorScheme.surface,",
      "        title: Text(loc.importExportJson),",
      "        content: Column(",
      "          mainAxisSize: MainAxisSize.min,",
      "          children: [",
      "            Text(",
      "              loc.pasteOrEditJson,",
      "              style: theme.textTheme.bodySmall,",
      "            ),",
      "            const SizedBox(height: 12),",
      "            SizedBox(",
      "              width: 500,",
      "              child: TextField(",
      "                controller: controller,",
      "                maxLines: 18,",
      "                minLines: 12,",
      "                keyboardType: TextInputType.multiline,",
      "                style: theme.textTheme.bodyMedium?.copyWith(",
      "                  fontFamily: 'monospace',",
      "                  fontSize: 13,",
      "                ),",
      "                decoration: InputDecoration(",
      "                  filled: true,",
      "                  fillColor: colorScheme.surfaceVariant,",
      "                  border: OutlineInputBorder(",
      "                    borderRadius: BorderRadius.circular(8),",
      "                    borderSide: BorderSide.none,",
      "                  ),",
      "                  contentPadding: const EdgeInsets.all(12),",
      "                ),",
      "              ),",
      "            ),",
      "          ],",
      "        ),",
      "        actions: [",
      "          TextButton(",
      "            onPressed: () => Navigator.pop(context),",
      "            child: Text(loc.cancel),",
      "          ),",
      "          TextButton(",
      "            onPressed: () async {",
      "              try {",
      "                final parsed = jsonDecode(controller.text);",
      "                if (parsed is! List)",
      "                  throw Exception('Invalid JSON: Not a List');",
      "                final items = parsed.map<MenuItem>((e) {",
      "                  return MenuItem.fromMap(Map<String, dynamic>.from(e));",
      "                }).toList();",
      "",
      "                await menuItemProvider.loadMenuItems(franchiseId);",
      "                for (final item in items) {",
      "                  menuItemProvider.addOrUpdateMenuItem(item);",
      "                }",
      "",
      "                Navigator.pop(context);",
      "              } catch (e, stack) {",
      "                await ErrorLogger.log(",
      "                  message: 'Invalid JSON in MenuItemJsonImportExportDialog',",
      "                  source: 'MenuItemJsonImportExportDialog',",
      "                  screen: 'onboarding_menu_items_screen.dart',",
      "                  severity: 'warning',",
      "                  stack: stack.toString(),",
      "                  contextData: {",
      "                    'franchiseId': franchiseId,",
      "                    'jsonPreview': controller.text",
      "                        .substring(0, controller.text.length.clamp(0, 200)),",
      "                  },",
      "                );",
      "                if (context.mounted) {",
      "                  ScaffoldMessenger.of(context).showSnackBar(",
      "                    SnackBar(content: Text(loc.invalidJsonFormat)),",
      "                  );",
      "                }",
      "              }",
      "            },",
      "            child: Text(loc.import),",
      "          )",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 119,
      "file_size": 4469,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\widgets\\menu_items\\menu_item_template_dropdown.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/models/menu_item.dart';",
      "import 'package:franchise_admin_portal/core/providers/menu_item_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_info_provider.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "",
      "class MenuItemTemplateDropdown extends StatefulWidget {",
      "  final void Function(MenuItem template) onTemplateApplied;",
      "  final String? selectedTemplateId;",
      "",
      "  const MenuItemTemplateDropdown({",
      "    super.key,",
      "    required this.onTemplateApplied,",
      "    this.selectedTemplateId,",
      "  });",
      "",
      "  @override",
      "  State<MenuItemTemplateDropdown> createState() =>",
      "      _MenuItemTemplateDropdownState();",
      "}",
      "",
      "class _MenuItemTemplateDropdownState extends State<MenuItemTemplateDropdown> {",
      "  String? _selectedTemplateId;",
      "  bool _isLoading = false;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _selectedTemplateId = widget.selectedTemplateId;",
      "",
      "    // Preload templateRefs if needed",
      "    WidgetsBinding.instance.addPostFrameCallback((_) async {",
      "      final provider = context.read<MenuItemProvider>();",
      "      if (provider.templateRefs.isEmpty && !provider.templateRefsLoading) {",
      "        await provider.loadTemplateRefs();",
      "      }",
      "    });",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context)!;",
      "    final templateRefs = context.watch<MenuItemProvider>().templateRefs;",
      "    final loading = context.watch<MenuItemProvider>().templateRefsLoading;",
      "",
      "    print('[DEBUG] selectedTemplateId: $_selectedTemplateId');",
      "    // print(",
      "    //     '[DEBUG] Available templateRefs: ${templateRefs.map((t) => t.id).toList()}');",
      "",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        DropdownButtonFormField<String>(",
      "          value: templateRefs.any((t) => t.id == _selectedTemplateId)",
      "              ? _selectedTemplateId",
      "              : null,",
      "          isExpanded: true,",
      "          hint: Text(loc.chooseTemplate),",
      "          decoration: InputDecoration(",
      "            labelText: loc.template,",
      "          ),",
      "          items: templateRefs",
      "              .map((t) => DropdownMenuItem(",
      "                    value: t.id,",
      "                    child: Text(t.name),",
      "                  ))",
      "              .toList(),",
      "          onChanged: (templateId) async {",
      "            setState(() {",
      "              _selectedTemplateId = templateId;",
      "              _isLoading = true;",
      "            });",
      "",
      "            try {",
      "              final restaurantType = context",
      "                  .read<FranchiseInfoProvider>()",
      "                  .franchise",
      "                  ?.restaurantType;",
      "",
      "              if (restaurantType == null || restaurantType.isEmpty) {",
      "                await ErrorLogger.log(",
      "                  message:",
      "                      'Missing or invalid restaurantType during template prefill',",
      "                  source: 'MenuItemTemplateDropdown',",
      "                  screen: 'menu_item_editor_sheet.dart',",
      "                  severity: 'error',",
      "                );",
      "                if (mounted) {",
      "                  ScaffoldMessenger.of(context).showSnackBar(",
      "                    SnackBar(content: Text(loc.errorGeneric)),",
      "                  );",
      "                }",
      "                return;",
      "              }",
      "",
      "              final template = await context",
      "                  .read<MenuItemProvider>()",
      "                  .fetchMenuItemTemplateById(",
      "                    restaurantType: restaurantType,",
      "                    templateId: templateId!,",
      "                  );",
      "",
      "              if (template != null && mounted) {",
      "                widget.onTemplateApplied(template);",
      "              } else {",
      "                ScaffoldMessenger.of(context).showSnackBar(",
      "                  SnackBar(content: Text(loc.errorGeneric)),",
      "                );",
      "              }",
      "            } catch (e, stack) {",
      "              await ErrorLogger.log(",
      "                message: 'Failed to apply template',",
      "                stack: stack.toString(),",
      "                source: 'MenuItemTemplateDropdown',",
      "                screen: 'menu_item_editor_sheet.dart',",
      "                severity: 'error',",
      "                contextData: {'templateId': templateId},",
      "              );",
      "              if (mounted) {",
      "                ScaffoldMessenger.of(context).showSnackBar(",
      "                  SnackBar(content: Text(loc.errorGeneric)),",
      "                );",
      "              }",
      "            } finally {",
      "              if (mounted) {",
      "                setState(() => _isLoading = false);",
      "              }",
      "            }",
      "          },",
      "        ),",
      "        if (_isLoading)",
      "          const Padding(",
      "            padding: EdgeInsets.only(top: 8.0),",
      "            child: LinearProgressIndicator(),",
      "          ),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 141,
      "file_size": 4941,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\widgets\\menu_items\\menu_item_template_picker_dialog.dart",
    "content": [
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/models/menu_item.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/menu_item_provider.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_info_provider.dart';",
      "",
      "class MenuItemTemplatePickerDialog extends StatelessWidget {",
      "  final AppLocalizations loc;",
      "",
      "  const MenuItemTemplatePickerDialog({super.key, required this.loc});",
      "",
      "  static Future<void> show(BuildContext context) async {",
      "    final loc = AppLocalizations.of(context);",
      "",
      "    if (loc == null) {",
      "      debugPrint('[MenuItemTemplatePickerDialog] ERROR: loc is null!');",
      "      return;",
      "    }",
      "",
      "    await showDialog(",
      "      context: context,",
      "      builder: (ctx) => MenuItemTemplatePickerDialog(loc: loc),",
      "    );",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final theme = Theme.of(context);",
      "    final franchiseId = context.read<FranchiseProvider>().franchiseId;",
      "    final franchiseInfo = context.read<FranchiseInfoProvider>().franchise;",
      "    final menuItemProvider = context.read<MenuItemProvider>();",
      "",
      "    final restaurantType = franchiseInfo?.restaurantType;",
      "",
      "    if (restaurantType == null || restaurantType.isEmpty) {",
      "      ErrorLogger.log(",
      "        message: 'Missing or invalid restaurant type',",
      "        source: 'MenuItemTemplatePickerDialog',",
      "        screen: 'onboarding_menu_items_screen.dart',",
      "        severity: 'error',",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "          'restaurantType': restaurantType,",
      "        },",
      "      );",
      "      return AlertDialog(",
      "        title: Text(loc.error),",
      "        content: Text(loc.errorGeneric),",
      "        actions: [",
      "          TextButton(",
      "            onPressed: () => Navigator.pop(context),",
      "            child: Text(loc.cancel),",
      "          ),",
      "        ],",
      "      );",
      "    }",
      "",
      "    return AlertDialog(",
      "      title: Text(loc.loadDefaultTemplates),",
      "      content: FutureBuilder<QuerySnapshot>(",
      "        future: FirebaseFirestore.instance",
      "            .collection('onboarding_templates')",
      "            .doc(restaurantType)",
      "            .collection('menu_items')",
      "            .get(),",
      "        builder: (context, snapshot) {",
      "          if (snapshot.connectionState == ConnectionState.waiting) {",
      "            return const CircularProgressIndicator();",
      "          }",
      "",
      "          if (snapshot.hasError || !snapshot.hasData) {",
      "            return Text(loc.errorGeneric);",
      "          }",
      "",
      "          final docs = snapshot.data!.docs;",
      "",
      "          if (docs.isEmpty) {",
      "            return Text(loc.noTemplatesFound);",
      "          }",
      "",
      "          return SizedBox(",
      "            width: 400,",
      "            child: ListView.builder(",
      "              shrinkWrap: true,",
      "              itemCount: docs.length,",
      "              itemBuilder: (context, index) {",
      "                final doc = docs[index];",
      "                final data = doc.data() as Map<String, dynamic>;",
      "                final name = data['name'] ?? doc.id;",
      "                return ListTile(",
      "                  title: Text(name),",
      "                  trailing: ElevatedButton(",
      "                    onPressed: () async {",
      "                      try {",
      "                        final items = (data['items'] as List<dynamic>)",
      "                            .map((e) => MenuItem.fromMap(",
      "                                  Map<String, dynamic>.from(e),",
      "                                ))",
      "                            .toList();",
      "",
      "                        for (final item in items) {",
      "                          menuItemProvider.addOrUpdateMenuItem(item);",
      "                        }",
      "",
      "                        Navigator.pop(context);",
      "                      } catch (e, stack) {",
      "                        await ErrorLogger.log(",
      "                          message: 'Failed to load menu item template',",
      "                          source: 'MenuItemTemplatePickerDialog',",
      "                          screen: 'onboarding_menu_items_screen.dart',",
      "                          severity: 'error',",
      "                          stack: stack.toString(),",
      "                          contextData: {",
      "                            'franchiseId': franchiseId,",
      "                            'templateId': doc.id,",
      "                          },",
      "                        );",
      "",
      "                        if (context.mounted) {",
      "                          ScaffoldMessenger.of(context).showSnackBar(",
      "                            SnackBar(content: Text(loc.errorGeneric)),",
      "                          );",
      "                        }",
      "                      }",
      "                    },",
      "                    style: ElevatedButton.styleFrom(",
      "                      backgroundColor: DesignTokens.primaryColor,",
      "                    ),",
      "                    child: Text(loc.import),",
      "                  ),",
      "                );",
      "              },",
      "            ),",
      "          );",
      "        },",
      "      ),",
      "      actions: [",
      "        TextButton(",
      "          onPressed: () => Navigator.pop(context),",
      "          child: Text(loc.cancel),",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 150,
      "file_size": 5389,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\widgets\\menu_items\\menu_item_utility.dart",
    "content": [
      "// lib/admin/dashboard/onboarding/widgets/menu_items/menu_item_utility.dart",
      "",
      "import 'package:franchise_admin_portal/core/models/menu_item.dart';",
      "import 'package:franchise_admin_portal/core/models/customization_group.dart';",
      "import 'package:franchise_admin_portal/core/models/ingredient_reference.dart';",
      "import 'package:franchise_admin_portal/core/models/nutrition_info.dart';",
      "import 'package:franchise_admin_portal/core/models/menu_item_schema_issue.dart';",
      "import 'package:franchise_admin_portal/core/models/size_template.dart';",
      "import 'package:franchise_admin_portal/core/models/customization.dart';",
      "import 'package:franchise_admin_portal/core/models/category.dart';",
      "import 'package:franchise_admin_portal/core/models/ingredient_metadata.dart';",
      "import 'package:franchise_admin_portal/core/models/ingredient_type_model.dart';",
      "import 'package:collection/collection.dart';",
      "import 'package:uuid/uuid.dart';",
      "",
      "/// --- SCHEMA & VALIDATION LOGIC ---",
      "",
      "MenuItem buildMenuItemForSchemaCheck({",
      "  required MenuItem? existing,",
      "  required String? name,",
      "  required String? description,",
      "  required double price,",
      "  required String? categoryId,",
      "  required bool outOfStock,",
      "  required String? imageUrl,",
      "  required List<CustomizationGroup> customizationGroups,",
      "  required List<IngredientReference> includedIngredients,",
      "  required List<IngredientReference> optionalAddOns,",
      "  required List<Customization> customizations,",
      "  required NutritionInfo? nutrition,",
      "  required List<String> selectedTemplateRefs,",
      "  required List<SizeData> sizeData,",
      "  required List<Category> categories,",
      "  // All advanced fields:",
      "  String? notes,",
      "  String? sku,",
      "  List<String> dietaryTags = const [],",
      "  List<String> allergens = const [],",
      "  int? prepTime,",
      "  int? sortOrder,",
      "  String taxCategory = 'standard',",
      "  String? exportId,",
      "  List<String>? crustTypes,",
      "  List<String>? cookTypes,",
      "  List<String>? cutStyles,",
      "  List<String>? sauceOptions,",
      "  List<String>? dressingOptions,",
      "  int? maxFreeToppings,",
      "  int? maxFreeSauces,",
      "  int? maxFreeDressings,",
      "  int? maxToppings,",
      "  DateTime? customizationsUpdatedAt,",
      "  DateTime? createdAt,",
      "  String? comboId,",
      "  List<String>? bundleItems,",
      "  double? bundleDiscount,",
      "  List<String>? highlightTags,",
      "  bool? allowSpecialInstructions,",
      "  bool? hideInMenu,",
      "  dynamic freeSauceCount,",
      "  double? extraSauceUpcharge,",
      "  dynamic freeDressingCount,",
      "  double? extraDressingUpcharge,",
      "  List<String>? dippingSauceOptions,",
      "  Map<String, int>? dippingSplits,",
      "  List<String>? sideDipSauceOptions,",
      "  Map<String, int>? freeDipCupCount,",
      "  Map<String, double>? sideDipUpcharge,",
      "  Map<String, dynamic>? extraCharges,",
      "  List<Map<String, dynamic>>? rawCustomizations,",
      "}) {",
      "  final categoryName =",
      "      categories.firstWhereOrNull((cat) => cat.id == categoryId)?.name ?? '';",
      "  return MenuItem(",
      "    id: existing?.id ?? '',",
      "    available: !outOfStock,",
      "    availability: !outOfStock,",
      "    category: categoryName,",
      "    categoryId: categoryId ?? '',",
      "    name: name ?? '',",
      "    price: price,",
      "    description: description ?? '',",
      "    notes: notes,",
      "    sku: sku,",
      "    dietaryTags: dietaryTags,",
      "    allergens: allergens,",
      "    prepTime: prepTime,",
      "    sortOrder: sortOrder,",
      "    taxCategory: taxCategory,",
      "    exportId: exportId,",
      "    customizationGroups: customizationGroups.map((g) => g.toMap()).toList(),",
      "    includedIngredients: includedIngredients.map((i) => i.toMap()).toList(),",
      "    optionalAddOns: optionalAddOns.map((i) => i.toMap()).toList(),",
      "    customizations: customizations,",
      "    image: imageUrl,",
      "    nutrition: nutrition,",
      "    templateRefs: selectedTemplateRefs,",
      "    sizes: sizeData,",
      "    crustTypes: crustTypes,",
      "    cookTypes: cookTypes,",
      "    cutStyles: cutStyles,",
      "    sauceOptions: sauceOptions,",
      "    dressingOptions: dressingOptions,",
      "    maxFreeToppings: maxFreeToppings,",
      "    maxFreeSauces: maxFreeSauces,",
      "    maxFreeDressings: maxFreeDressings,",
      "    maxToppings: maxToppings,",
      "    customizationsUpdatedAt: customizationsUpdatedAt,",
      "    createdAt: createdAt,",
      "    comboId: comboId,",
      "    bundleItems: bundleItems,",
      "    bundleDiscount: bundleDiscount,",
      "    highlightTags: highlightTags,",
      "    allowSpecialInstructions: allowSpecialInstructions,",
      "    hideInMenu: hideInMenu,",
      "    freeSauceCount: freeSauceCount,",
      "    extraSauceUpcharge: extraSauceUpcharge,",
      "    freeDressingCount: freeDressingCount,",
      "    extraDressingUpcharge: extraDressingUpcharge,",
      "    dippingSauceOptions: dippingSauceOptions,",
      "    dippingSplits: dippingSplits,",
      "    sideDipSauceOptions: sideDipSauceOptions,",
      "    freeDipCupCount: freeDipCupCount,",
      "    sideDipUpcharge: sideDipUpcharge,",
      "    extraCharges: extraCharges,",
      "    rawCustomizations: rawCustomizations,",
      "  );",
      "}",
      "",
      "List<MenuItemSchemaIssue> getMenuItemSchemaIssues({",
      "  required MenuItem tempItem,",
      "  required List<Category> categories,",
      "  required List<IngredientMetadata> ingredients,",
      "  required List<IngredientType> ingredientTypes,",
      "}) {",
      "  return MenuItemSchemaIssue.detectAllIssues(",
      "    menuItem: tempItem,",
      "    categories: categories,",
      "    ingredients: ingredients,",
      "    ingredientTypes: ingredientTypes,",
      "  );",
      "}",
      "",
      "/// --- TEMPLATE APPLICATION LOGIC ---",
      "",
      "Map<String, dynamic> extractTemplateFieldsForEditor(",
      "  MenuItem item,",
      "  List<IngredientMetadata> allIngredients,",
      ") {",
      "  // Deep copy and correct all required fields as in _applyTemplate.",
      "  // For each field, apply the exact transformation/mapping logic as in the widget.",
      "  final Map<String, IngredientMetadata> ingredientMap = {",
      "    for (var ing in allIngredients) ing.id: ing",
      "  };",
      "",
      "  // --- Customization groups normalization ---",
      "  List<CustomizationGroup> customizationGroups =",
      "      (item.customizationGroups ?? []).map((g) {",
      "    final groupMap = Map<String, dynamic>.from(g);",
      "",
      "    // 1. If group has 'ingredientIds' (legacy), generate 'ingredients'",
      "    if (groupMap['ingredientIds'] is List &&",
      "        groupMap['ingredientIds'].isNotEmpty) {",
      "      groupMap['ingredients'] = (groupMap['ingredientIds'] as List).map((id) {",
      "        final meta = ingredientMap[id];",
      "        if (meta != null) return meta.toMap();",
      "        return {'id': id, 'name': id, 'typeId': '', 'isRemovable': true};",
      "      }).toList();",
      "    }",
      "",
      "    // 2. If 'ingredients' exists, ensure every entry is a Map",
      "    if (groupMap['ingredients'] is List) {",
      "      groupMap['ingredients'] = (groupMap['ingredients'] as List).map((e) {",
      "        if (e is String) {",
      "          return {'id': e, 'name': e, 'typeId': '', 'isRemovable': true};",
      "        }",
      "        if (e is Map) return e;",
      "        if (e is IngredientReference) return e.toMap();",
      "        // Fallback for legacy/unknown",
      "        return {",
      "          'id': e.toString(),",
      "          'name': e.toString(),",
      "          'typeId': '',",
      "          'isRemovable': true",
      "        };",
      "      }).toList();",
      "    } else {",
      "      // 3. Defensive: If 'ingredients' is missing or not a List, create empty list",
      "      groupMap['ingredients'] = <Map<String, dynamic>>[];",
      "    }",
      "",
      "    // 4. Always remove 'ingredientIds' to prevent model confusion",
      "    groupMap.remove('ingredientIds');",
      "",
      "    // Now safe to call:",
      "    return CustomizationGroup.fromMap(groupMap);",
      "  }).toList();",
      "",
      "  // --- Included Ingredients",
      "  final includedIngredients = (item.includedIngredients ?? [])",
      "      .map((e) => e is IngredientReference",
      "          ? e",
      "          : IngredientReference.fromMap(Map<String, dynamic>.from(e)))",
      "      .toList()",
      "      .cast<IngredientReference>();",
      "",
      "  // --- Optional AddOns",
      "  final optionalAddOns = (item.optionalAddOns ?? [])",
      "      .map((e) => e is IngredientReference",
      "          ? e",
      "          : IngredientReference.fromMap(Map<String, dynamic>.from(e)))",
      "      .toList()",
      "      .cast<IngredientReference>();",
      "",
      "  // --- Sizes / Pricing normalization ---",
      "  List<SizeData> sizeData = [];",
      "  final sizesValue = item.sizes;",
      "  if (sizesValue != null &&",
      "      sizesValue is List<SizeData> &&",
      "      sizesValue.isNotEmpty) {",
      "    sizeData = List<SizeData>.from(sizesValue);",
      "  } else if (sizesValue != null &&",
      "      sizesValue is List &&",
      "      sizesValue.isNotEmpty &&",
      "      (item.sizePrices != null || item.additionalToppingPrices != null)) {",
      "    final basePriceMap = item.sizePrices ?? {};",
      "    final toppingPriceMap = item.additionalToppingPrices ?? {};",
      "    sizeData = sizesValue",
      "        .map((s) => SizeData(",
      "              label: s.toString(),",
      "              basePrice:",
      "                  (basePriceMap[s.toString()] as num?)?.toDouble() ?? 0.0,",
      "              toppingPrice:",
      "                  (toppingPriceMap[s.toString()] as num?)?.toDouble() ?? 0.0,",
      "            ))",
      "        .toList();",
      "  } else {",
      "    sizeData = [];",
      "  }",
      "",
      "  // --- Full field extraction for editor state ---",
      "  return {",
      "    'name': item.name ?? '',",
      "    'description': item.description ?? '',",
      "    'price': item.price ?? 0.0,",
      "    'categoryId': item.categoryId ?? '',",
      "    'imageUrl': item.imageUrl ?? '',",
      "    'nutrition': item.nutrition,",
      "    'includedIngredients': includedIngredients,",
      "    'optionalAddOns': optionalAddOns,",
      "    'customizations': List<Customization>.from(item.customizations ?? []),",
      "    'sizeData': sizeData,",
      "    'customizationGroups': customizationGroups,",
      "    'selectedTemplateRefs': List<String>.from(item.templateRefs ?? []),",
      "    // Advanced:",
      "    'notes': item.notes,",
      "    'sku': item.sku,",
      "    'dietaryTags': List<String>.from(item.dietaryTags ?? []),",
      "    'allergens': List<String>.from(item.allergens ?? []),",
      "    'prepTime': item.prepTime,",
      "    'sortOrder': item.sortOrder,",
      "    'taxCategory': item.taxCategory ?? 'standard',",
      "    'exportId': item.exportId,",
      "    'crustTypes': item.crustTypes,",
      "    'cookTypes': item.cookTypes,",
      "    'cutStyles': item.cutStyles,",
      "    'sauceOptions': item.sauceOptions,",
      "    'dressingOptions': item.dressingOptions,",
      "    'maxFreeToppings': item.maxFreeToppings,",
      "    'maxFreeSauces': item.maxFreeSauces,",
      "    'maxFreeDressings': item.maxFreeDressings,",
      "    'maxToppings': item.maxToppings,",
      "    'customizationsUpdatedAt': item.customizationsUpdatedAt,",
      "    'createdAt': item.createdAt,",
      "    'comboId': item.comboId,",
      "    'bundleItems': item.bundleItems,",
      "    'bundleDiscount': item.bundleDiscount,",
      "    'highlightTags': item.highlightTags,",
      "    'allowSpecialInstructions': item.allowSpecialInstructions,",
      "    'hideInMenu': item.hideInMenu,",
      "    'freeSauceCount': item.freeSauceCount,",
      "    'extraSauceUpcharge': item.extraSauceUpcharge,",
      "    'freeDressingCount': item.freeDressingCount,",
      "    'extraDressingUpcharge': item.extraDressingUpcharge,",
      "    'dippingSauceOptions': item.dippingSauceOptions,",
      "    'dippingSplits': item.dippingSplits,",
      "    'sideDipSauceOptions': item.sideDipSauceOptions,",
      "    'freeDipCupCount': item.freeDipCupCount,",
      "    'sideDipUpcharge': item.sideDipUpcharge,",
      "    'extraCharges': item.extraCharges,",
      "    'rawCustomizations': item.rawCustomizations,",
      "  };",
      "}",
      "",
      "/// --- MENU ITEM CONSTRUCTION LOGIC ---",
      "",
      "MenuItem constructMenuItemFromEditorFields({",
      "  required String? id,",
      "  required bool outOfStock,",
      "  required String categoryName,",
      "  required String categoryId,",
      "  required String name,",
      "  required double price,",
      "  required String description,",
      "  required String? notes,",
      "  required String? sku,",
      "  required List<String> dietaryTags,",
      "  required List<String> allergens,",
      "  required int? prepTime,",
      "  required int? sortOrder,",
      "  required String taxCategory,",
      "  required String? exportId,",
      "  required List<CustomizationGroup> customizationGroups,",
      "  required List<IngredientReference> includedIngredients,",
      "  required List<IngredientReference> optionalAddOns,",
      "  required List<Customization> customizations,",
      "  required String imageUrl,",
      "  required NutritionInfo? nutrition,",
      "  required List<String> selectedTemplateRefs,",
      "  required List<SizeData> sizeData,",
      "  // --- Advanced ---",
      "  List<String>? crustTypes,",
      "  List<String>? cookTypes,",
      "  List<String>? cutStyles,",
      "  List<String>? sauceOptions,",
      "  List<String>? dressingOptions,",
      "  int? maxFreeToppings,",
      "  int? maxFreeSauces,",
      "  int? maxFreeDressings,",
      "  int? maxToppings,",
      "  DateTime? customizationsUpdatedAt,",
      "  DateTime? createdAt,",
      "  String? comboId,",
      "  List<String>? bundleItems,",
      "  double? bundleDiscount,",
      "  List<String>? highlightTags,",
      "  bool? allowSpecialInstructions,",
      "  bool? hideInMenu,",
      "  dynamic freeSauceCount,",
      "  double? extraSauceUpcharge,",
      "  dynamic freeDressingCount,",
      "  double? extraDressingUpcharge,",
      "  List<String>? dippingSauceOptions,",
      "  Map<String, int>? dippingSplits,",
      "  List<String>? sideDipSauceOptions,",
      "  Map<String, int>? freeDipCupCount,",
      "  Map<String, double>? sideDipUpcharge,",
      "  Map<String, dynamic>? extraCharges,",
      "  List<Map<String, dynamic>>? rawCustomizations,",
      "}) {",
      "  return MenuItem(",
      "    id: id ?? '',",
      "    available: !outOfStock,",
      "    availability: !outOfStock,",
      "    category: categoryName,",
      "    categoryId: categoryId,",
      "    name: name,",
      "    price: price,",
      "    description: description,",
      "    notes: notes,",
      "    sku: sku,",
      "    dietaryTags: dietaryTags,",
      "    allergens: allergens,",
      "    prepTime: prepTime,",
      "    sortOrder: sortOrder,",
      "    taxCategory: taxCategory,",
      "    exportId: exportId,",
      "    customizationGroups: customizationGroups.map((g) => g.toMap()).toList(),",
      "    includedIngredients: includedIngredients.map((i) => i.toMap()).toList(),",
      "    optionalAddOns: optionalAddOns.map((i) => i.toMap()).toList(),",
      "    customizations: customizations,",
      "    image: imageUrl,",
      "    nutrition: nutrition,",
      "    templateRefs: selectedTemplateRefs,",
      "    sizes: sizeData,",
      "    // --- Advanced ---",
      "    crustTypes: crustTypes is List<String> ? crustTypes : [],",
      "    cookTypes: cookTypes,",
      "    cutStyles: cutStyles,",
      "    sauceOptions: sauceOptions,",
      "    dressingOptions: dressingOptions,",
      "    maxFreeToppings: maxFreeToppings,",
      "    maxFreeSauces: maxFreeSauces,",
      "    maxFreeDressings: maxFreeDressings,",
      "    maxToppings: maxToppings,",
      "    customizationsUpdatedAt: customizationsUpdatedAt,",
      "    createdAt: createdAt,",
      "    comboId: comboId,",
      "    bundleItems: bundleItems,",
      "    bundleDiscount: bundleDiscount,",
      "    highlightTags: highlightTags,",
      "    allowSpecialInstructions: allowSpecialInstructions,",
      "    hideInMenu: hideInMenu,",
      "    freeSauceCount: freeSauceCount,",
      "    extraSauceUpcharge: extraSauceUpcharge,",
      "    freeDressingCount: freeDressingCount,",
      "    extraDressingUpcharge: extraDressingUpcharge,",
      "    dippingSauceOptions: dippingSauceOptions,",
      "    dippingSplits: dippingSplits,",
      "    sideDipSauceOptions: sideDipSauceOptions,",
      "    freeDipCupCount: freeDipCupCount,",
      "    sideDipUpcharge: sideDipUpcharge,",
      "    extraCharges: extraCharges,",
      "    rawCustomizations: rawCustomizations,",
      "  );",
      "}",
      "",
      "/// --- SCHEMA ISSUE REPAIR LOGIC ---",
      "",
      "void repairSchemaIssueForCategory({",
      "  required String newValue,",
      "  required void Function(String) updateCategoryId,",
      "}) {",
      "  updateCategoryId(newValue);",
      "}",
      "",
      "void repairSchemaIssueForIngredient({",
      "  required String missingReference,",
      "  required String newValue,",
      "  required List<IngredientReference> includedIngredients,",
      "  required List<IngredientReference> optionalAddOns,",
      "  required List<CustomizationGroup> customizationGroups,",
      "}) {",
      "  for (var i = 0; i < includedIngredients.length; i++) {",
      "    if (includedIngredients[i].id == missingReference) {",
      "      includedIngredients[i] = includedIngredients[i].copyWith(id: newValue);",
      "    }",
      "  }",
      "  for (var i = 0; i < optionalAddOns.length; i++) {",
      "    if (optionalAddOns[i].id == missingReference) {",
      "      optionalAddOns[i] = optionalAddOns[i].copyWith(id: newValue);",
      "    }",
      "  }",
      "  for (var groupIdx = 0; groupIdx < customizationGroups.length; groupIdx++) {",
      "    final group = customizationGroups[groupIdx];",
      "    for (var ingIdx = 0; ingIdx < group.ingredients.length; ingIdx++) {",
      "      if (group.ingredients[ingIdx].id == missingReference) {",
      "        group.ingredients[ingIdx] =",
      "            group.ingredients[ingIdx].copyWith(id: newValue);",
      "      }",
      "    }",
      "  }",
      "}",
      "",
      "void repairSchemaIssueForIngredientType({",
      "  required String label,",
      "  required String missingReference,",
      "  required String newValue,",
      "  required List<IngredientReference> includedIngredients,",
      "  required List<IngredientReference> optionalAddOns,",
      "  required List<CustomizationGroup> customizationGroups,",
      "}) {",
      "  for (var i = 0; i < includedIngredients.length; i++) {",
      "    if (includedIngredients[i].name == label ||",
      "        includedIngredients[i].id == missingReference) {",
      "      includedIngredients[i] =",
      "          includedIngredients[i].copyWith(typeId: newValue);",
      "    }",
      "  }",
      "  for (var i = 0; i < optionalAddOns.length; i++) {",
      "    if (optionalAddOns[i].name == label ||",
      "        optionalAddOns[i].id == missingReference) {",
      "      optionalAddOns[i] = optionalAddOns[i].copyWith(typeId: newValue);",
      "    }",
      "  }",
      "  for (var group in customizationGroups) {",
      "    for (var j = 0; j < group.ingredients.length; j++) {",
      "      if (group.ingredients[j].name == label ||",
      "          group.ingredients[j].id == missingReference) {",
      "        group.ingredients[j] = group.ingredients[j].copyWith(typeId: newValue);",
      "      }",
      "    }",
      "  }",
      "}",
      "",
      "/// --- DATA CONVERSION / MAPPING HELPERS ---",
      "",
      "List<IngredientReference> mapToIngredientReferenceList(List<dynamic>? list) {",
      "  if (list == null) return [];",
      "  return list",
      "      .map((e) => e is IngredientReference",
      "          ? e",
      "          : IngredientReference.fromMap(Map<String, dynamic>.from(e)))",
      "      .toList()",
      "      .cast<IngredientReference>();",
      "}",
      "",
      "List<CustomizationGroup> mapToCustomizationGroupList(",
      "    List<dynamic>? list, List<IngredientMetadata> allIngredients) {",
      "  if (list == null) return [];",
      "  final ingredientMap = {for (var ing in allIngredients) ing.id: ing};",
      "  return list.map((g) {",
      "    final groupMap = Map<String, dynamic>.from(g);",
      "",
      "    if (groupMap['ingredientIds'] is List &&",
      "        groupMap['ingredientIds'].isNotEmpty) {",
      "      groupMap['ingredients'] = (groupMap['ingredientIds'] as List).map((id) {",
      "        final meta = ingredientMap[id];",
      "        if (meta != null) return meta.toMap();",
      "        return {'id': id, 'name': id, 'typeId': '', 'isRemovable': true};",
      "      }).toList();",
      "    }",
      "    if (groupMap['ingredients'] is List) {",
      "      groupMap['ingredients'] = (groupMap['ingredients'] as List).map((e) {",
      "        if (e is String) {",
      "          return {'id': e, 'name': e, 'typeId': '', 'isRemovable': true};",
      "        }",
      "        if (e is Map) return e;",
      "        if (e is IngredientReference) return e.toMap();",
      "        return {",
      "          'id': e.toString(),",
      "          'name': e.toString(),",
      "          'typeId': '',",
      "          'isRemovable': true",
      "        };",
      "      }).toList();",
      "    } else {",
      "      groupMap['ingredients'] = <Map<String, dynamic>>[];",
      "    }",
      "    groupMap.remove('ingredientIds');",
      "    return CustomizationGroup.fromMap(groupMap);",
      "  }).toList();",
      "}",
      "",
      "/// Handles all schema issue repairs for the MenuItemEditorSheet.",
      "/// Mutates the passed-in fields directly.",
      "/// Returns true if any changes were made, false if not.",
      "bool repairMenuItemSchemaIssue({",
      "  required MenuItemSchemaIssue issue,",
      "  required String newValue,",
      "  required void Function(String) updateCategoryId,",
      "  required List<IngredientReference> includedIngredients,",
      "  required List<IngredientReference> optionalAddOns,",
      "  required List<CustomizationGroup> customizationGroups,",
      "}) {",
      "  bool changed = false;",
      "  if (issue.type == MenuItemSchemaIssueType.category) {",
      "    updateCategoryId(newValue);",
      "    changed = true;",
      "  } else if (issue.type == MenuItemSchemaIssueType.ingredient) {",
      "    // Update all relevant ingredient IDs",
      "    for (var i = 0; i < includedIngredients.length; i++) {",
      "      if (includedIngredients[i].id == issue.missingReference) {",
      "        includedIngredients[i] = includedIngredients[i].copyWith(id: newValue);",
      "        changed = true;",
      "      }",
      "    }",
      "    for (var i = 0; i < optionalAddOns.length; i++) {",
      "      if (optionalAddOns[i].id == issue.missingReference) {",
      "        optionalAddOns[i] = optionalAddOns[i].copyWith(id: newValue);",
      "        changed = true;",
      "      }",
      "    }",
      "    for (var groupIdx = 0; groupIdx < customizationGroups.length; groupIdx++) {",
      "      final group = customizationGroups[groupIdx];",
      "      for (var ingIdx = 0; ingIdx < group.ingredients.length; ingIdx++) {",
      "        if (group.ingredients[ingIdx].id == issue.missingReference) {",
      "          group.ingredients[ingIdx] =",
      "              group.ingredients[ingIdx].copyWith(id: newValue);",
      "          changed = true;",
      "        }",
      "      }",
      "    }",
      "  } else if (issue.type == MenuItemSchemaIssueType.ingredientType) {",
      "    // Update typeId/type for all relevant ingredient references",
      "    for (var i = 0; i < includedIngredients.length; i++) {",
      "      if (includedIngredients[i].name == issue.label ||",
      "          includedIngredients[i].id == issue.missingReference) {",
      "        includedIngredients[i] =",
      "            includedIngredients[i].copyWith(typeId: newValue);",
      "        changed = true;",
      "      }",
      "    }",
      "    for (var i = 0; i < optionalAddOns.length; i++) {",
      "      if (optionalAddOns[i].name == issue.label ||",
      "          optionalAddOns[i].id == issue.missingReference) {",
      "        optionalAddOns[i] = optionalAddOns[i].copyWith(typeId: newValue);",
      "        changed = true;",
      "      }",
      "    }",
      "    for (var group in customizationGroups) {",
      "      for (var j = 0; j < group.ingredients.length; j++) {",
      "        if (group.ingredients[j].name == issue.label ||",
      "            group.ingredients[j].id == issue.missingReference) {",
      "          group.ingredients[j] =",
      "              group.ingredients[j].copyWith(typeId: newValue);",
      "          changed = true;",
      "        }",
      "      }",
      "    }",
      "  }",
      "  return changed;",
      "}",
      "",
      "MenuItem buildPreviewMenuItem({",
      "  required String? existingId,",
      "  required bool outOfStock,",
      "  required String? categoryId,",
      "  required String name,",
      "  required double price,",
      "  required String description,",
      "  required String imageUrl,",
      "  required NutritionInfo? nutrition,",
      "  required List<IngredientReference> includedIngredients,",
      "  required List<IngredientReference> optionalAddOns,",
      "  required List<Customization> customizations,",
      "  required List<String> selectedTemplateRefs,",
      "}) {",
      "  return MenuItem(",
      "    id: existingId ?? const Uuid().v4(),",
      "    available: !outOfStock,",
      "    category: categoryId ?? '',",
      "    categoryId: categoryId ?? '',",
      "    name: name,",
      "    price: price,",
      "    description: description,",
      "    notes: null,",
      "    customizationGroups: [],",
      "    image: imageUrl,",
      "    taxCategory: 'standard',",
      "    availability: !outOfStock,",
      "    sku: null,",
      "    dietaryTags: [],",
      "    allergens: [],",
      "    prepTime: null,",
      "    nutrition: nutrition,",
      "    sortOrder: null,",
      "    lastModified: null,",
      "    lastModifiedBy: null,",
      "    archived: false,",
      "    exportId: null,",
      "    sizes: null,",
      "    sizePrices: null,",
      "    additionalToppingPrices: null,",
      "    includedIngredients: includedIngredients.map((e) => e.toMap()).toList(),",
      "    optionalAddOns: optionalAddOns.map((e) => e.toMap()).toList(),",
      "    customizations: customizations,",
      "    crustTypes: null,",
      "    cookTypes: null,",
      "    cutStyles: null,",
      "    sauceOptions: null,",
      "    dressingOptions: null,",
      "    maxFreeToppings: null,",
      "    maxFreeSauces: null,",
      "    maxFreeDressings: null,",
      "    maxToppings: null,",
      "    customizationsUpdatedAt: null,",
      "    createdAt: null,",
      "    comboId: null,",
      "    bundleItems: null,",
      "    bundleDiscount: null,",
      "    highlightTags: null,",
      "    allowSpecialInstructions: null,",
      "    hideInMenu: null,",
      "    freeSauceCount: null,",
      "    extraSauceUpcharge: null,",
      "    freeDressingCount: null,",
      "    extraDressingUpcharge: null,",
      "    dippingSauceOptions: null,",
      "    dippingSplits: null,",
      "    sideDipSauceOptions: null,",
      "    freeDipCupCount: null,",
      "    sideDipUpcharge: null,",
      "    extraCharges: null,",
      "    rawCustomizations: null,",
      "    templateRefs: selectedTemplateRefs,",
      "  );",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 668,
      "file_size": 23635,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\widgets\\menu_items\\multi_ingredient_selector.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/models/ingredient_reference.dart';",
      "import 'package:franchise_admin_portal/core/models/ingredient_metadata.dart';",
      "import 'package:franchise_admin_portal/core/providers/ingredient_metadata_provider.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "",
      "/// A reusable multi-selector for choosing ingredients from metadata.",
      "///",
      "/// Usage:",
      "/// ```dart",
      "/// MultiIngredientSelector(",
      "///   title: 'Included Ingredients',",
      "///   selected: includedIngredients,",
      "///   onChanged: (updated) => setState(() => includedIngredients = updated),",
      "/// )",
      "/// ```",
      "class MultiIngredientSelector extends StatelessWidget {",
      "  final String title;",
      "  final List<IngredientReference> selected;",
      "  final ValueChanged<List<IngredientReference>> onChanged;",
      "  final bool allowEmpty;",
      "  final bool isRequired;",
      "  final String? warningMessage;",
      "",
      "  const MultiIngredientSelector({",
      "    Key? key,",
      "    required this.title,",
      "    required this.selected,",
      "    required this.onChanged,",
      "    this.allowEmpty = true,",
      "    this.isRequired = false,",
      "    this.warningMessage,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context)!;",
      "    final ingredientProvider = context.watch<IngredientMetadataProvider>();",
      "    final metadataList = ingredientProvider.allIngredients;",
      "",
      "    if (!ingredientProvider.isInitialized) {",
      "      return const Padding(",
      "        padding: EdgeInsets.all(12.0),",
      "        child: Center(child: CircularProgressIndicator()),",
      "      );",
      "    }",
      "",
      "    if (metadataList.isEmpty) {",
      "      return _EmptyIngredientsWarning(message: warningMessage);",
      "    }",
      "",
      "    final Map<String, List<IngredientMetadata>> groupedByType = {};",
      "    for (final ingredient in metadataList) {",
      "      groupedByType",
      "          .putIfAbsent(",
      "            ingredient.type ?? 'Other',",
      "            () => [],",
      "          )",
      "          .add(ingredient);",
      "    }",
      "",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        Text(title,",
      "            style: Theme.of(context).textTheme.titleMedium?.copyWith(",
      "                  fontWeight: FontWeight.bold,",
      "                )),",
      "        const SizedBox(height: 8),",
      "        ...groupedByType.entries.map((entry) {",
      "          final typeName = entry.key;",
      "          final ingredients = entry.value;",
      "",
      "          return _IngredientTypeGroup(",
      "            typeName: typeName,",
      "            ingredients: ingredients,",
      "            selected: selected,",
      "            onChanged: onChanged,",
      "          );",
      "        }),",
      "        if (isRequired && selected.isEmpty)",
      "          Padding(",
      "            padding: const EdgeInsets.only(top: 4),",
      "            child: Text(",
      "              loc.fieldRequired,",
      "              style: TextStyle(color: Theme.of(context).colorScheme.error),",
      "            ),",
      "          ),",
      "      ],",
      "    );",
      "  }",
      "}",
      "",
      "class _IngredientTypeGroup extends StatelessWidget {",
      "  final String typeName;",
      "  final List<IngredientMetadata> ingredients;",
      "  final List<IngredientReference> selected;",
      "  final ValueChanged<List<IngredientReference>> onChanged;",
      "",
      "  const _IngredientTypeGroup({",
      "    required this.typeName,",
      "    required this.ingredients,",
      "    required this.selected,",
      "    required this.onChanged,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final theme = Theme.of(context);",
      "    return Padding(",
      "      padding: const EdgeInsets.only(bottom: 12),",
      "      child: Column(",
      "        crossAxisAlignment: CrossAxisAlignment.start,",
      "        children: [",
      "          Text(",
      "            typeName,",
      "            style: theme.textTheme.labelLarge?.copyWith(",
      "              fontWeight: FontWeight.w600,",
      "              color: theme.colorScheme.primary,",
      "            ),",
      "          ),",
      "          const SizedBox(height: 6),",
      "          Wrap(",
      "            spacing: 6,",
      "            runSpacing: 4,",
      "            children: ingredients.map((ingredient) {",
      "              final ref = IngredientReference(",
      "                id: ingredient.id,",
      "                name: ingredient.name,",
      "                typeId: ingredient.typeId ?? 'unknown',",
      "              );",
      "",
      "              final isSelected = selected.any((i) => i.id == ref.id);",
      "",
      "              return FilterChip(",
      "                label: Text(ingredient.name),",
      "                selected: isSelected,",
      "                onSelected: (val) {",
      "                  final updated = [...selected];",
      "                  if (val) {",
      "                    updated.add(ref);",
      "                  } else {",
      "                    updated.removeWhere((i) => i.id == ref.id);",
      "                  }",
      "                  onChanged(updated);",
      "                },",
      "              );",
      "            }).toList(),",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "class _EmptyIngredientsWarning extends StatelessWidget {",
      "  final String? message;",
      "",
      "  const _EmptyIngredientsWarning({this.message});",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context)!;",
      "",
      "    return Padding(",
      "      padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 8),",
      "      child: Column(",
      "        crossAxisAlignment: CrossAxisAlignment.start,",
      "        children: [",
      "          Icon(Icons.warning_amber_rounded, color: DesignTokens.errorColor),",
      "          const SizedBox(height: 4),",
      "          Text(",
      "            message ?? loc.noIngredientsConfigured,",
      "            style: Theme.of(context).textTheme.bodyMedium?.copyWith(",
      "                color: Theme.of(context).colorScheme.onSurfaceVariant),",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 184,
      "file_size": 5792,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\widgets\\menu_items\\nutrition_editor_dialog.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/core/models/nutrition_info.dart';",
      "import 'package:franchise_admin_portal/core/utils/features/form_validators.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "",
      "/// A dialog that allows editing or creating `NutritionInfo`.",
      "///",
      "/// Used inside [MenuItemEditorSheet] when nutritional_info feature is enabled.",
      "class NutritionEditorDialog extends StatefulWidget {",
      "  final NutritionInfo? initialValue;",
      "",
      "  const NutritionEditorDialog({Key? key, this.initialValue}) : super(key: key);",
      "",
      "  @override",
      "  State<NutritionEditorDialog> createState() => _NutritionEditorDialogState();",
      "}",
      "",
      "class _NutritionEditorDialogState extends State<NutritionEditorDialog> {",
      "  final _formKey = GlobalKey<FormState>();",
      "",
      "  late TextEditingController _caloriesController;",
      "  late TextEditingController _fatController;",
      "  late TextEditingController _carbsController;",
      "  late TextEditingController _proteinController;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    final init = widget.initialValue;",
      "",
      "    _caloriesController =",
      "        TextEditingController(text: init?.calories.toString() ?? '');",
      "    _fatController = TextEditingController(text: init?.fat.toString() ?? '');",
      "    _carbsController =",
      "        TextEditingController(text: init?.carbs.toString() ?? '');",
      "    _proteinController =",
      "        TextEditingController(text: init?.protein.toString() ?? '');",
      "  }",
      "",
      "  @override",
      "  void dispose() {",
      "    _caloriesController.dispose();",
      "    _fatController.dispose();",
      "    _carbsController.dispose();",
      "    _proteinController.dispose();",
      "    super.dispose();",
      "  }",
      "",
      "  void _submit() {",
      "    if (_formKey.currentState?.validate() != true) return;",
      "",
      "    final result = NutritionInfo(",
      "      calories: double.tryParse(_caloriesController.text.trim())?.round() ?? 0,",
      "      fat: double.tryParse(_fatController.text.trim()) ?? 0.0,",
      "      carbs: double.tryParse(_carbsController.text.trim()) ?? 0.0,",
      "      protein: double.tryParse(_proteinController.text.trim()) ?? 0.0,",
      "    );",
      "",
      "    Navigator.of(context).pop(result);",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context)!;",
      "",
      "    return AlertDialog(",
      "      title: Text(loc.editNutrition),",
      "      content: Form(",
      "        key: _formKey,",
      "        child: Column(",
      "          mainAxisSize: MainAxisSize.min,",
      "          children: [",
      "            _buildField(",
      "              controller: _caloriesController,",
      "              label: loc.calories,",
      "              suffix: 'kcal',",
      "            ),",
      "            _buildField(",
      "              controller: _fatController,",
      "              label: loc.fat,",
      "              suffix: 'g',",
      "            ),",
      "            _buildField(",
      "              controller: _carbsController,",
      "              label: loc.carbohydrates,",
      "              suffix: 'g',",
      "            ),",
      "            _buildField(",
      "              controller: _proteinController,",
      "              label: loc.protein,",
      "              suffix: 'g',",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "      actions: [",
      "        TextButton(",
      "          onPressed: () => Navigator.of(context).pop(null),",
      "          child: Text(loc.cancel),",
      "        ),",
      "        ElevatedButton(",
      "          onPressed: _submit,",
      "          child: Text(loc.save),",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "",
      "  Widget _buildField({",
      "    required TextEditingController controller,",
      "    required String label,",
      "    required String suffix,",
      "  }) {",
      "    return Padding(",
      "      padding: const EdgeInsets.symmetric(vertical: 6.0),",
      "      child: TextFormField(",
      "        controller: controller,",
      "        decoration: InputDecoration(",
      "          labelText: label,",
      "          suffixText: suffix,",
      "        ),",
      "        keyboardType: TextInputType.numberWithOptions(decimal: true),",
      "        validator: FormValidators.nonNegativeNumber,",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 127,
      "file_size": 3895,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\widgets\\menu_items\\preview_menu_item_card.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/core/models/menu_item.dart';",
      "import 'package:franchise_admin_portal/core/models/ingredient_reference.dart';",
      "import 'package:franchise_admin_portal/core/models/customization_group.dart';",
      "import 'package:franchise_admin_portal/core/models/nutrition_info.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "",
      "/// ✅ Production-ready card UI to preview a MenuItem as it would appear",
      "/// in the customer-facing app.",
      "///",
      "/// Used within onboarding flow to validate:",
      "/// - Ingredient relationships",
      "/// - Customization presence",
      "/// - Image and out-of-stock behavior",
      "class PreviewMenuItemCard extends StatelessWidget {",
      "  final MenuItem menuItem;",
      "",
      "  const PreviewMenuItemCard({Key? key, required this.menuItem})",
      "      : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final outOfStock = menuItem.outOfStock;",
      "    final priceString = '\\$${menuItem.price.toStringAsFixed(2)}';",
      "",
      "    return Card(",
      "      color: outOfStock ? Colors.grey.shade200 : Colors.white,",
      "      margin: const EdgeInsets.symmetric(vertical: 8),",
      "      shape: RoundedRectangleBorder(",
      "        borderRadius: BorderRadius.circular(12),",
      "      ),",
      "      child: Opacity(",
      "        opacity: outOfStock ? 0.5 : 1.0,",
      "        child: Padding(",
      "          padding: const EdgeInsets.all(12),",
      "          child: Row(",
      "            crossAxisAlignment: CrossAxisAlignment.start,",
      "            children: [",
      "              _buildImage(context),",
      "              const SizedBox(width: 12),",
      "              Expanded(",
      "                  child: _buildInfoSection(context, priceString, outOfStock)),",
      "            ],",
      "          ),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  Widget _buildImage(BuildContext context) {",
      "    return ClipRRect(",
      "      borderRadius: BorderRadius.circular(8),",
      "      child: menuItem.imageUrl.isNotEmpty",
      "          ? Image.network(",
      "              menuItem.imageUrl,",
      "              width: 100,",
      "              height: 100,",
      "              fit: BoxFit.cover,",
      "              errorBuilder: (_, __, ___) =>",
      "                  const Icon(Icons.broken_image, size: 48),",
      "            )",
      "          : Container(",
      "              width: 100,",
      "              height: 100,",
      "              color: Colors.grey.shade100,",
      "              child: const Icon(Icons.image, size: 40),",
      "            ),",
      "    );",
      "  }",
      "",
      "  Widget _buildInfoSection(",
      "      BuildContext context, String priceString, bool outOfStock) {",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        Text(",
      "          menuItem.name,",
      "          style: Theme.of(context).textTheme.titleMedium?.copyWith(",
      "                fontWeight: FontWeight.bold,",
      "              ),",
      "        ),",
      "        const SizedBox(height: 4),",
      "        Text(",
      "          menuItem.description,",
      "          style: Theme.of(context).textTheme.bodySmall,",
      "        ),",
      "        const SizedBox(height: 6),",
      "        _buildIngredientsPreview(),",
      "        if (menuItem.customizations.isNotEmpty) ...[",
      "          const SizedBox(height: 4),",
      "          _buildCustomizationSummary(),",
      "        ],",
      "        const SizedBox(height: 8),",
      "        Row(",
      "          mainAxisAlignment: MainAxisAlignment.spaceBetween,",
      "          children: [",
      "            Text(",
      "              priceString,",
      "              style: Theme.of(context).textTheme.titleSmall?.copyWith(",
      "                    fontWeight: FontWeight.w600,",
      "                    color: outOfStock ? Colors.grey : Colors.black,",
      "                  ),",
      "            ),",
      "            if (outOfStock)",
      "              const Text(",
      "                'Out of Stock',",
      "                style: TextStyle(",
      "                  color: Colors.red,",
      "                  fontWeight: FontWeight.bold,",
      "                ),",
      "              ),",
      "          ],",
      "        )",
      "      ],",
      "    );",
      "  }",
      "",
      "  Widget _buildIngredientsPreview() {",
      "    final tags = [",
      "      ...?menuItem.includedIngredients?.map((i) => i['name'] as String? ?? ''),",
      "      ...?menuItem.optionalAddOns?.map((i) => i['name'] as String? ?? ''),",
      "    ].where((tag) => tag.isNotEmpty).toList();",
      "",
      "    if (tags.isEmpty) return const SizedBox.shrink();",
      "",
      "    return Wrap(",
      "      spacing: 6,",
      "      runSpacing: 4,",
      "      children: tags",
      "          .map((tag) => Chip(",
      "                label: Text(tag),",
      "                backgroundColor: Colors.grey.shade100,",
      "              ))",
      "          .toList(),",
      "    );",
      "  }",
      "",
      "  Widget _buildCustomizationSummary() {",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: menuItem.customizations.map((group) {",
      "        final groupLabel = group.name.isNotEmpty ? group.name : 'Custom';",
      "        final entries =",
      "            group.options?.map((e) => e.name).join(', ') ?? 'None selected';",
      "        return Padding(",
      "          padding: const EdgeInsets.only(top: 2),",
      "          child: Text(",
      "            '$groupLabel: $entries',",
      "            style: const TextStyle(fontSize: 12, color: Colors.black87),",
      "          ),",
      "        );",
      "      }).toList(),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 155,
      "file_size": 5045,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\widgets\\menu_items\\preview_menu_item_card_error.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "",
      "/// Displayed when a menu item preview cannot be rendered.",
      "/// Can be used in onboarding editors or debug contexts.",
      "class PreviewMenuItemCardError extends StatelessWidget {",
      "  final String title;",
      "  final String message;",
      "  final VoidCallback? onRetry;",
      "",
      "  const PreviewMenuItemCardError({",
      "    Key? key,",
      "    this.title = 'Preview Failed',",
      "    required this.message,",
      "    this.onRetry,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context)!;",
      "",
      "    return Card(",
      "      margin: const EdgeInsets.symmetric(vertical: 8),",
      "      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),",
      "      color: Colors.red.shade50,",
      "      child: Padding(",
      "        padding: const EdgeInsets.all(16),",
      "        child: Row(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            const Icon(Icons.error_outline, color: Colors.red, size: 32),",
      "            const SizedBox(width: 12),",
      "            Expanded(",
      "              child: _buildErrorContent(context, loc),",
      "            ),",
      "            if (onRetry != null)",
      "              IconButton(",
      "                icon: const Icon(Icons.refresh),",
      "                tooltip: loc.retry,",
      "                onPressed: onRetry,",
      "              ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  Widget _buildErrorContent(BuildContext context, AppLocalizations loc) {",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        Text(",
      "          title,",
      "          style: Theme.of(context).textTheme.titleMedium?.copyWith(",
      "                color: Colors.red.shade800,",
      "                fontWeight: FontWeight.bold,",
      "              ),",
      "        ),",
      "        const SizedBox(height: 4),",
      "        Text(",
      "          message,",
      "          style: Theme.of(context).textTheme.bodySmall?.copyWith(",
      "                color: Colors.red.shade800,",
      "              ),",
      "        ),",
      "        if (onRetry != null)",
      "          Padding(",
      "            padding: const EdgeInsets.only(top: 8),",
      "            child: TextButton.icon(",
      "              icon: const Icon(Icons.refresh),",
      "              label: Text(loc.retry),",
      "              onPressed: onRetry,",
      "            ),",
      "          ),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 79,
      "file_size": 2436,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\widgets\\menu_items\\preview_menu_item_card_skeleton.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "",
      "/// Shimmer-free lightweight skeleton for use in onboarding preview sections.",
      "/// Can optionally accept size constraints or adapt fluidly.",
      "class PreviewMenuItemCardSkeleton extends StatelessWidget {",
      "  const PreviewMenuItemCardSkeleton({Key? key}) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Card(",
      "      margin: const EdgeInsets.symmetric(vertical: 8),",
      "      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),",
      "      child: Padding(",
      "        padding: const EdgeInsets.all(12),",
      "        child: Row(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            _buildImagePlaceholder(),",
      "            const SizedBox(width: 12),",
      "            Expanded(child: _buildInfoSkeleton(context)),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  Widget _buildImagePlaceholder() {",
      "    return Container(",
      "      width: 100,",
      "      height: 100,",
      "      decoration: BoxDecoration(",
      "        color: Colors.grey.shade200,",
      "        borderRadius: BorderRadius.circular(8),",
      "      ),",
      "    );",
      "  }",
      "",
      "  Widget _buildInfoSkeleton(BuildContext context) {",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        _skeletonLine(width: 120, height: 18),",
      "        const SizedBox(height: 6),",
      "        _skeletonLine(width: 180, height: 14),",
      "        const SizedBox(height: 10),",
      "        _buildIngredientTagsSkeleton(),",
      "        const SizedBox(height: 10),",
      "        _buildCustomizationSkeleton(),",
      "        const SizedBox(height: 12),",
      "        Row(",
      "          mainAxisAlignment: MainAxisAlignment.spaceBetween,",
      "          children: [",
      "            _skeletonLine(width: 60, height: 16),",
      "            _skeletonLine(width: 80, height: 16),",
      "          ],",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "",
      "  Widget _buildIngredientTagsSkeleton() {",
      "    return Wrap(",
      "      spacing: 6,",
      "      runSpacing: 6,",
      "      children: List.generate(4, (index) {",
      "        return Container(",
      "          width: 60 + (index * 10),",
      "          height: 20,",
      "          decoration: BoxDecoration(",
      "            color: Colors.grey.shade200,",
      "            borderRadius: BorderRadius.circular(16),",
      "          ),",
      "        );",
      "      }),",
      "    );",
      "  }",
      "",
      "  Widget _buildCustomizationSkeleton() {",
      "    return Column(",
      "      children: List.generate(2, (index) {",
      "        return Padding(",
      "          padding: const EdgeInsets.only(top: 4),",
      "          child: _skeletonLine(width: 160, height: 12),",
      "        );",
      "      }),",
      "    );",
      "  }",
      "",
      "  Widget _skeletonLine({double width = 100, double height = 12}) {",
      "    return Container(",
      "      width: width,",
      "      height: height,",
      "      decoration: BoxDecoration(",
      "        color: Colors.grey.shade200,",
      "        borderRadius: BorderRadius.circular(4),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 100,
      "file_size": 2890,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\widgets\\menu_items\\schema_issue_sidebar.dart",
    "content": [
      "// lib/admin/dashboard/onboarding/widgets/menu_items/schema_issue_sidebar.dart",
      "",
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/models/menu_item_schema_issue.dart';",
      "import 'package:franchise_admin_portal/core/providers/category_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/ingredient_metadata_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/ingredient_type_provider.dart';",
      "import 'package:franchise_admin_portal/core/models/category.dart';",
      "import 'package:franchise_admin_portal/core/models/ingredient_metadata.dart';",
      "import 'package:franchise_admin_portal/core/models/ingredient_type_model.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/widgets/menu_items/ingredient_creation_dialog.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/widgets/menu_items/ingredient_type_creation_dialog.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/widgets/menu_items/category_creation_dialog.dart';",
      "",
      "/// Sidebar for displaying and resolving schema issues for a MenuItem during onboarding.",
      "/// All repairs are applied via the passed-in callback.",
      "class SchemaIssueSidebar extends StatelessWidget {",
      "  final List<MenuItemSchemaIssue> issues;",
      "  final void Function(MenuItemSchemaIssue issue, String newValue) onRepair;",
      "  final VoidCallback? onClose;",
      "",
      "  const SchemaIssueSidebar({",
      "    Key? key,",
      "    required this.issues,",
      "    required this.onRepair,",
      "    this.onClose,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final hasIssues = issues.isNotEmpty;",
      "    final categoryProvider = context.watch<CategoryProvider>();",
      "    final ingredientProvider = context.watch<IngredientMetadataProvider>();",
      "    final ingredientTypeProvider = context.watch<IngredientTypeProvider>();",
      "    final resolvedCount = issues.where((issue) => issue.resolved).length;",
      "    final hasUnresolved = issues.any((issue) => !issue.resolved);",
      "    print(",
      "        '[SchemaIssueSidebar] Rendering... hasUnresolved=$hasUnresolved, resolvedCount=$resolvedCount/${issues.length}');",
      "",
      "    return AnimatedContainer(",
      "      duration: const Duration(milliseconds: 300),",
      "      width: hasUnresolved ? 420 : 64,",
      "      constraints: BoxConstraints(",
      "        maxWidth: hasUnresolved ? 480 : 96,",
      "        minWidth: 56,",
      "      ),",
      "      decoration: BoxDecoration(",
      "        color: Colors.white,",
      "        boxShadow: [",
      "          BoxShadow(",
      "              color: Colors.black12, blurRadius: 12, offset: Offset(-3, 0)),",
      "        ],",
      "        border: Border(",
      "          left: BorderSide(",
      "            color: Colors.grey.shade200,",
      "            width: 1,",
      "          ),",
      "        ),",
      "      ),",
      "      child: hasUnresolved",
      "          // ========== FULL SIDEBAR ========== //",
      "          ? Column(",
      "              crossAxisAlignment: CrossAxisAlignment.start,",
      "              children: [",
      "                // Header",
      "                Container(",
      "                  padding:",
      "                      const EdgeInsets.symmetric(vertical: 20, horizontal: 24),",
      "                  color: Colors.red.shade700.withOpacity(0.95),",
      "                  child: Row(",
      "                    children: [",
      "                      const Icon(Icons.warning_amber_rounded,",
      "                          color: Colors.white),",
      "                      const SizedBox(width: 12),",
      "                      Expanded(",
      "                        child: Text(",
      "                          hasUnresolved",
      "                              ? 'Schema Issues Detected'",
      "                              : 'All Issues Resolved',",
      "                          style: const TextStyle(",
      "                              fontWeight: FontWeight.bold,",
      "                              color: Colors.white,",
      "                              fontSize: 18),",
      "                        ),",
      "                      ),",
      "                      if (onClose != null)",
      "                        IconButton(",
      "                          icon: const Icon(Icons.close, color: Colors.white),",
      "                          onPressed: onClose,",
      "                          tooltip: 'Close',",
      "                        ),",
      "                    ],",
      "                  ),",
      "                ),",
      "                // List of issues (scrollable)",
      "                Expanded(",
      "                  child: ListView.separated(",
      "                    itemCount: issues.length,",
      "                    separatorBuilder: (_, __) => const Divider(height: 1),",
      "                    itemBuilder: (context, index) {",
      "                      final issue = issues[index];",
      "                      if (issue.resolved) {",
      "                        return _ResolvedIssueTile(issue: issue);",
      "                      }",
      "                      switch (issue.type) {",
      "                        case MenuItemSchemaIssueType.category:",
      "                          final loc = AppLocalizations.of(context)!;",
      "                          return _CategoryRepairTile(",
      "                            issue: issue,",
      "                            provider: categoryProvider,",
      "                            onRepair: (newValue) =>",
      "                                _handleRepair(context, issue, newValue),",
      "                            loc: loc,",
      "                          );",
      "                        case MenuItemSchemaIssueType.ingredient:",
      "                          final loc = AppLocalizations.of(context)!;",
      "                          return _IngredientRepairTile(",
      "                            issue: issue,",
      "                            provider: ingredientProvider,",
      "                            onRepair: (newValue) =>",
      "                                _handleRepair(context, issue, newValue),",
      "                            loc: loc,",
      "                          );",
      "                        case MenuItemSchemaIssueType.ingredientType:",
      "                          final loc = AppLocalizations.of(context)!;",
      "                          return _IngredientTypeRepairTile(",
      "                            issue: issue,",
      "                            provider: ingredientTypeProvider,",
      "                            onRepair: (newValue) =>",
      "                                _handleRepair(context, issue, newValue),",
      "                            loc: loc,",
      "                          );",
      "                        case MenuItemSchemaIssueType.missingField:",
      "                          return _MissingFieldRepairTile(",
      "                            issue: issue,",
      "                            onRepair: (newValue) =>",
      "                                _handleRepair(context, issue, newValue),",
      "                          );",
      "                        default:",
      "                          return ListTile(",
      "                            contentPadding:",
      "                                const EdgeInsets.symmetric(horizontal: 12),",
      "                            leading: Container(",
      "                              width: 24,",
      "                              alignment: Alignment.center,",
      "                              child: const Icon(Icons.error_outline,",
      "                                  color: Colors.red),",
      "                            ),",
      "                            title: Text(",
      "                              issue.displayMessage.isNotEmpty",
      "                                  ? issue.displayMessage",
      "                                  : 'Unrecognized schema issue',",
      "                              style: const TextStyle(fontSize: 14),",
      "                            ),",
      "                          );",
      "                      }",
      "                    },",
      "                  ),",
      "                ),",
      "                // Status and actions",
      "                Padding(",
      "                  padding: const EdgeInsets.all(20.0),",
      "                  child: Column(",
      "                    crossAxisAlignment: CrossAxisAlignment.stretch,",
      "                    children: [",
      "                      if (hasUnresolved)",
      "                        Row(",
      "                          children: [",
      "                            Icon(Icons.error,",
      "                                color: Colors.red.shade700, size: 20),",
      "                            const SizedBox(width: 6),",
      "                            Expanded(",
      "                              child: Text(",
      "                                '$resolvedCount / ${issues.length} issues resolved',",
      "                                style: TextStyle(",
      "                                    color: Colors.red.shade700,",
      "                                    fontWeight: FontWeight.w600),",
      "                              ),",
      "                            ),",
      "                          ],",
      "                        )",
      "                      else",
      "                        Row(",
      "                          children: [",
      "                            Icon(Icons.check_circle,",
      "                                color: Colors.green.shade700, size: 20),",
      "                            const SizedBox(width: 6),",
      "                            const Expanded(",
      "                              child: Text(",
      "                                'All issues resolved!',",
      "                                style: TextStyle(",
      "                                    color: Colors.green,",
      "                                    fontWeight: FontWeight.w600),",
      "                              ),",
      "                            ),",
      "                          ],",
      "                        ),",
      "                      if (hasUnresolved) const SizedBox(height: 12),",
      "                      if (hasUnresolved)",
      "                        Text(",
      "                          'Please resolve all schema issues before saving this menu item.',",
      "                          style: TextStyle(",
      "                              color: Colors.red.shade600, fontSize: 13),",
      "                        ),",
      "                    ],",
      "                  ),",
      "                ),",
      "              ],",
      "            )",
      "          // ========== COLLAPSED SIDEBAR (NO ISSUES) ========== //",
      "          : Center(",
      "              child: Tooltip(",
      "                message: \"No schema issues detected\",",
      "                preferBelow: false,",
      "                child: Column(",
      "                  mainAxisAlignment: MainAxisAlignment.center,",
      "                  children: const [",
      "                    Icon(Icons.check_circle, color: Colors.green, size: 36),",
      "                    SizedBox(height: 8),",
      "                    RotatedBox(",
      "                      quarterTurns: 3,",
      "                      child: Text(",
      "                        \"No Issues\",",
      "                        style: TextStyle(",
      "                          color: Colors.green,",
      "                          fontWeight: FontWeight.bold,",
      "                          fontSize: 14,",
      "                          letterSpacing: 1.2,",
      "                        ),",
      "                      ),",
      "                    ),",
      "                  ],",
      "                ),",
      "              ),",
      "            ),",
      "    );",
      "  }",
      "",
      "  void _handleRepair(",
      "      BuildContext context, MenuItemSchemaIssue issue, String newValue) async {",
      "    try {",
      "      print(",
      "          '[SchemaIssueSidebar] _handleRepair triggered for issue: ${issue.displayMessage}, value: $newValue');",
      "",
      "      WidgetsBinding.instance.addPostFrameCallback((_) {",
      "        onRepair(issue, newValue);",
      "      });",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'schema_issue_sidebar_repair_failed',",
      "        stack: stack.toString(),",
      "        source: 'schema_issue_sidebar.dart',",
      "        screen: 'schema_issue_sidebar',",
      "        severity: 'error',",
      "        contextData: {",
      "          'issueType': issue.typeKey,",
      "          'missingReference': issue.missingReference,",
      "          'menuItemId': issue.menuItemId,",
      "          'field': issue.field,",
      "          'selectedValue': newValue,",
      "        },",
      "      );",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        const SnackBar(",
      "          content: Text('Failed to update reference. See error logs.'),",
      "          backgroundColor: Colors.red,",
      "        ),",
      "      );",
      "    }",
      "  }",
      "}",
      "",
      "// ---------- Per-Issue-Type Repair Tiles ----------",
      "",
      "class _CategoryRepairTile extends StatelessWidget {",
      "  final MenuItemSchemaIssue issue;",
      "  final CategoryProvider provider;",
      "  final ValueChanged<String> onRepair;",
      "  final AppLocalizations loc;",
      "",
      "  const _CategoryRepairTile({",
      "    Key? key,",
      "    required this.issue,",
      "    required this.provider,",
      "    required this.onRepair,",
      "    required this.loc,",
      "  }) : super(key: key);",
      "",
      "  Future<void> _handleCreateCategory(BuildContext context) async {",
      "    final newCategory = await showDialog<Category>(",
      "      context: context,",
      "      builder: (ctx) => CategoryCreationDialog(",
      "        loc: loc,",
      "        suggestedName: issue.context ?? issue.label ?? issue.missingReference,",
      "      ),",
      "    );",
      "",
      "    if (newCategory != null) {",
      "      try {",
      "        provider.stageCategory(newCategory);",
      "        onRepair(newCategory.id);",
      "",
      "        ScaffoldMessenger.of(context).showSnackBar(",
      "          SnackBar(",
      "            content: Text(",
      "              loc.categoryStagedSuccessfully(newCategory.name),",
      "            ),",
      "            duration: const Duration(seconds: 2),",
      "          ),",
      "        );",
      "      } catch (e, stack) {",
      "        await ErrorLogger.log(",
      "          message: 'category_stage_failed',",
      "          stack: stack.toString(),",
      "          source: '_CategoryRepairTile',",
      "          screen: 'schema_issue_sidebar.dart',",
      "          severity: 'error',",
      "          contextData: {",
      "            'categoryName': newCategory.name,",
      "            'issueContext':",
      "                issue.context ?? issue.label ?? issue.missingReference,",
      "          },",
      "        );",
      "        ScaffoldMessenger.of(context).showSnackBar(",
      "          SnackBar(",
      "            content: Text(loc.genericErrorMessage),",
      "            backgroundColor: Theme.of(context).colorScheme.error,",
      "          ),",
      "        );",
      "      }",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Padding(",
      "      padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 6),",
      "      child: Column(",
      "        crossAxisAlignment: CrossAxisAlignment.start,",
      "        children: [",
      "          Row(",
      "            children: [",
      "              const Icon(Icons.category, color: Colors.orange),",
      "              const SizedBox(width: 8),",
      "              Expanded(",
      "                child: Text(",
      "                  issue.displayMessage,",
      "                  style: const TextStyle(fontWeight: FontWeight.w600),",
      "                ),",
      "              ),",
      "              IconButton(",
      "                icon: const Icon(Icons.add, color: Colors.blueGrey),",
      "                tooltip: loc.createNewCategory,",
      "                onPressed: () => _handleCreateCategory(context),",
      "              ),",
      "            ],",
      "          ),",
      "          const SizedBox(height: 8),",
      "          DropdownButtonFormField<String>(",
      "            value: null,",
      "            isExpanded: true,",
      "            hint: Text(loc.selectCategory),",
      "            items: [",
      "              for (final id in provider.allCategoryIds)",
      "                DropdownMenuItem(",
      "                  value: id,",
      "                  child: Text(provider.categoryIdToName[id] ?? id),",
      "                ),",
      "            ],",
      "            onChanged: (value) {",
      "              if (value != null) onRepair(value);",
      "            },",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "class _IngredientRepairTile extends StatelessWidget {",
      "  final MenuItemSchemaIssue issue;",
      "  final IngredientMetadataProvider provider;",
      "  final ValueChanged<String> onRepair;",
      "  final AppLocalizations loc;",
      "",
      "  const _IngredientRepairTile({",
      "    Key? key,",
      "    required this.issue,",
      "    required this.provider,",
      "    required this.onRepair,",
      "    required this.loc,",
      "  }) : super(key: key);",
      "",
      "  Future<void> _handleCreateIngredient(BuildContext context) async {",
      "    final newIngredient = await showDialog<IngredientMetadata>(",
      "      context: context,",
      "      builder: (ctx) => MultiProvider(",
      "        providers: [",
      "          ChangeNotifierProvider.value(",
      "            value: context.read<IngredientTypeProvider>(),",
      "          ),",
      "          ChangeNotifierProvider.value(",
      "            value: context.read<IngredientMetadataProvider>(),",
      "          ),",
      "        ],",
      "        child: IngredientCreationDialog(",
      "          loc: loc,",
      "          suggestedName: issue.context ?? issue.label ?? issue.missingReference,",
      "        ),",
      "      ),",
      "    );",
      "",
      "    if (newIngredient != null) {",
      "      try {",
      "        provider.stageIngredient(newIngredient); // 🔄 stage it, don’t save",
      "        onRepair(newIngredient.id);",
      "",
      "        ScaffoldMessenger.of(context).showSnackBar(",
      "          SnackBar(",
      "            content: Text(",
      "              loc.ingredientStagedSuccessfully(newIngredient.name),",
      "            ),",
      "            duration: const Duration(seconds: 2),",
      "          ),",
      "        );",
      "      } catch (e, stack) {",
      "        await ErrorLogger.log(",
      "          message: 'ingredient_stage_failed',",
      "          stack: stack.toString(),",
      "          source: '_IngredientRepairTile',",
      "          screen: 'schema_issue_sidebar.dart',",
      "          severity: 'error',",
      "          contextData: {",
      "            'ingredientName': newIngredient.name,",
      "            'issueContext':",
      "                issue.context ?? issue.label ?? issue.missingReference,",
      "          },",
      "        );",
      "        ScaffoldMessenger.of(context).showSnackBar(",
      "          SnackBar(",
      "            content: Text(loc.genericErrorMessage),",
      "            backgroundColor: Theme.of(context).colorScheme.error,",
      "          ),",
      "        );",
      "      }",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final allIds = provider.allIngredientIds;",
      "",
      "    return Padding(",
      "      padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 6),",
      "      child: Column(",
      "        crossAxisAlignment: CrossAxisAlignment.start,",
      "        children: [",
      "          Row(",
      "            children: [",
      "              Container(",
      "                width: 32,",
      "                alignment: Alignment.center,",
      "                child: const Icon(Icons.egg_alt_rounded, color: Colors.brown),",
      "              ),",
      "              const SizedBox(width: 8),",
      "              Expanded(",
      "                child: Text(",
      "                  issue.displayMessage,",
      "                  style: const TextStyle(fontWeight: FontWeight.w600),",
      "                ),",
      "              ),",
      "              IconButton(",
      "                icon: const Icon(Icons.add, color: Colors.blueGrey),",
      "                tooltip: loc.createNewIngredient,",
      "                onPressed: () => _handleCreateIngredient(context),",
      "              ),",
      "            ],",
      "          ),",
      "          const SizedBox(height: 8),",
      "          DropdownButtonFormField<String>(",
      "            value: null,",
      "            isExpanded: true,",
      "            hint: Text(loc.selectIngredient),",
      "            items: [",
      "              for (final id in allIds)",
      "                DropdownMenuItem(",
      "                  value: id,",
      "                  child: Text('${provider.ingredientIdToName[id] ?? id}'),",
      "                ),",
      "            ],",
      "            onChanged: (value) {",
      "              if (value != null) onRepair(value);",
      "            },",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "class _IngredientTypeRepairTile extends StatelessWidget {",
      "  final MenuItemSchemaIssue issue;",
      "  final IngredientTypeProvider provider;",
      "  final ValueChanged<String> onRepair;",
      "  final AppLocalizations loc;",
      "",
      "  const _IngredientTypeRepairTile({",
      "    Key? key,",
      "    required this.issue,",
      "    required this.provider,",
      "    required this.onRepair,",
      "    required this.loc,",
      "  }) : super(key: key);",
      "",
      "  Future<void> _handleCreateIngredientType(BuildContext context) async {",
      "    final newType = await showDialog<IngredientType>(",
      "      context: context,",
      "      builder: (ctx) => ChangeNotifierProvider.value(",
      "        value: provider,",
      "        child: IngredientTypeCreationDialog(",
      "          loc: loc,",
      "          suggestedName: issue.context ?? issue.label ?? issue.missingReference,",
      "        ),",
      "      ),",
      "    );",
      "",
      "    if (newType != null) {",
      "      try {",
      "        provider.stageIngredientType(newType); // ✅ stage for persistence",
      "        onRepair(newType.id!);",
      "",
      "        ScaffoldMessenger.of(context).showSnackBar(",
      "          SnackBar(",
      "            content: Text(",
      "              loc.ingredientTypeStagedSuccessfully(newType.name),",
      "            ),",
      "            duration: const Duration(seconds: 2),",
      "          ),",
      "        );",
      "      } catch (e, stack) {",
      "        await ErrorLogger.log(",
      "          message: 'ingredient_type_stage_failed',",
      "          stack: stack.toString(),",
      "          source: '_IngredientTypeRepairTile',",
      "          screen: 'schema_issue_sidebar.dart',",
      "          severity: 'error',",
      "          contextData: {",
      "            'typeName': newType.name,",
      "            'issueContext':",
      "                issue.context ?? issue.label ?? issue.missingReference,",
      "          },",
      "        );",
      "        ScaffoldMessenger.of(context).showSnackBar(",
      "          SnackBar(",
      "            content: Text(loc.genericErrorMessage),",
      "            backgroundColor: Theme.of(context).colorScheme.error,",
      "          ),",
      "        );",
      "      }",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final allIds = provider.allTypeIds;",
      "    final typeIdToName = provider.typeIdToName;",
      "",
      "    return Padding(",
      "      padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 6),",
      "      child: Column(",
      "        crossAxisAlignment: CrossAxisAlignment.start,",
      "        children: [",
      "          Row(",
      "            children: [",
      "              Container(",
      "                width: 32,",
      "                alignment: Alignment.center,",
      "                child: const Icon(Icons.label_important, color: Colors.purple),",
      "              ),",
      "              const SizedBox(width: 8),",
      "              Expanded(",
      "                child: Text(",
      "                  issue.displayMessage,",
      "                  style: const TextStyle(fontWeight: FontWeight.w600),",
      "                ),",
      "              ),",
      "              IconButton(",
      "                icon: const Icon(Icons.add, color: Colors.blueGrey),",
      "                tooltip: loc.createNewIngredientType,",
      "                onPressed: () => _handleCreateIngredientType(context),",
      "              ),",
      "            ],",
      "          ),",
      "          const SizedBox(height: 8),",
      "          DropdownButtonFormField<String>(",
      "            isExpanded: true,",
      "            value: null,",
      "            hint: Text(loc.selectIngredientType),",
      "            items: [",
      "              for (final id in allIds)",
      "                DropdownMenuItem(",
      "                  value: id,",
      "                  child: Text('${typeIdToName[id] ?? id}'),",
      "                ),",
      "            ],",
      "            onChanged: (value) {",
      "              if (value != null) onRepair(value);",
      "            },",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "class _MissingFieldRepairTile extends StatelessWidget {",
      "  final MenuItemSchemaIssue issue;",
      "  final ValueChanged<String> onRepair;",
      "",
      "  const _MissingFieldRepairTile({",
      "    Key? key,",
      "    required this.issue,",
      "    required this.onRepair,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Padding(",
      "      padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 6),",
      "      child: Column(",
      "        crossAxisAlignment: CrossAxisAlignment.start,",
      "        children: [",
      "          Row(",
      "            children: [",
      "              Container(",
      "                width: 32,",
      "                alignment: Alignment.center,",
      "                child: const Icon(Icons.edit_note_rounded,",
      "                    color: Colors.blueAccent),",
      "              ),",
      "              const SizedBox(width: 8),",
      "              Expanded(",
      "                child: Text(",
      "                  issue.displayMessage,",
      "                  style: const TextStyle(fontWeight: FontWeight.w600),",
      "                ),",
      "              ),",
      "            ],",
      "          ),",
      "          const SizedBox(height: 8),",
      "          TextFormField(",
      "            decoration: InputDecoration(",
      "              labelText: 'Enter ${issue.label ?? issue.field}',",
      "            ),",
      "            onFieldSubmitted: (value) {",
      "              if (value.isNotEmpty) onRepair(value);",
      "            },",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "// ------------- Resolved Issue Tile (read-only) -------------",
      "",
      "class _ResolvedIssueTile extends StatelessWidget {",
      "  final MenuItemSchemaIssue issue;",
      "  const _ResolvedIssueTile({Key? key, required this.issue}) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Padding(",
      "      padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 6),",
      "      child: Column(",
      "        crossAxisAlignment: CrossAxisAlignment.start,",
      "        children: [",
      "          Row(",
      "            children: [",
      "              Container(",
      "                width: 32,",
      "                alignment: Alignment.center,",
      "                child: const Icon(Icons.check_circle, color: Colors.green),",
      "              ),",
      "              const SizedBox(width: 8),",
      "              Expanded(",
      "                child: Text(",
      "                  issue.displayMessage,",
      "                  style: const TextStyle(",
      "                    decoration: TextDecoration.lineThrough,",
      "                    color: Colors.green,",
      "                    fontStyle: FontStyle.italic,",
      "                  ),",
      "                ),",
      "              ),",
      "            ],",
      "          ),",
      "          const SizedBox(height: 4),",
      "          const Padding(",
      "            padding: EdgeInsets.only(left: 40),",
      "            child: Text(",
      "              'Resolved',",
      "              style: TextStyle(color: Colors.grey),",
      "            ),",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 713,
      "file_size": 25564,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\widgets\\menu_items\\size_pricing_editor.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter/services.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/models/size_template.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class SizePricingEditor extends StatefulWidget {",
      "  final List<SizeData> sizes;",
      "  final void Function(List<SizeData>) onChanged;",
      "  final Widget? trailingTemplateDropdown;",
      "",
      "  const SizePricingEditor({",
      "    Key? key,",
      "    required this.sizes,",
      "    required this.onChanged,",
      "    this.trailingTemplateDropdown,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  State<SizePricingEditor> createState() => _SizePricingEditorState();",
      "}",
      "",
      "class _SizePricingEditorState extends State<SizePricingEditor> {",
      "  late List<SizeData> _localSizes;",
      "  int? _hoveredIndex;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _localSizes = List<SizeData>.from(widget.sizes.map((s) => s.copy()));",
      "  }",
      "",
      "  @override",
      "  void didUpdateWidget(covariant SizePricingEditor oldWidget) {",
      "    super.didUpdateWidget(oldWidget);",
      "    if (widget.sizes != oldWidget.sizes) {",
      "      _localSizes = List<SizeData>.from(widget.sizes.map((s) => s.copy()));",
      "    }",
      "  }",
      "",
      "  void _updateSizes() {",
      "    try {",
      "      widget.onChanged(_localSizes);",
      "    } catch (e, stack) {",
      "      ErrorLogger.log(",
      "        message: 'Failed to update size pricing',",
      "        source: 'SizePricingEditor',",
      "        screen: 'menu_item_editor_sheet',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "        contextData: {'sizes': _localSizes.map((s) => s.toMap()).toList()},",
      "      );",
      "    }",
      "  }",
      "",
      "  void _addSize() {",
      "    setState(() {",
      "      _localSizes.add(SizeData(label: '', basePrice: 0.0, toppingPrice: 0.0));",
      "    });",
      "    _updateSizes();",
      "  }",
      "",
      "  void _removeSize(int index) {",
      "    setState(() {",
      "      _localSizes.removeAt(index);",
      "    });",
      "    _updateSizes();",
      "  }",
      "",
      "  void _updateField(int index,",
      "      {String? label, double? basePrice, double? toppingPrice}) {",
      "    setState(() {",
      "      final current = _localSizes[index];",
      "      _localSizes[index] = current.copyWith(",
      "        label: label ?? current.label,",
      "        basePrice: basePrice ?? current.basePrice,",
      "        toppingPrice: toppingPrice ?? current.toppingPrice,",
      "      );",
      "    });",
      "    _updateSizes();",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final theme = Theme.of(context);",
      "",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        const SizedBox(height: 16),",
      "        Row(",
      "          crossAxisAlignment: CrossAxisAlignment.center,",
      "          children: [",
      "            Expanded(",
      "              flex: 2,",
      "              child: Text(",
      "                'Size Pricing',",
      "                style: theme.textTheme.titleLarge,",
      "              ),",
      "            ),",
      "            if (widget.trailingTemplateDropdown != null) ...[",
      "              const SizedBox(width: 12),",
      "              Expanded(",
      "                flex: 3,",
      "                child: widget.trailingTemplateDropdown!,",
      "              ),",
      "            ]",
      "          ],",
      "        ),",
      "        const SizedBox(height: 8),",
      "        ListView.builder(",
      "          itemCount: _localSizes.length,",
      "          shrinkWrap: true,",
      "          physics: const NeverScrollableScrollPhysics(),",
      "          itemBuilder: (context, index) {",
      "            final size = _localSizes[index];",
      "            final isHovered = _hoveredIndex == index;",
      "",
      "            return MouseRegion(",
      "              onEnter: (_) => setState(() => _hoveredIndex = index),",
      "              onExit: (_) => setState(() => _hoveredIndex = null),",
      "              child: AnimatedContainer(",
      "                duration: const Duration(milliseconds: 150),",
      "                decoration: BoxDecoration(",
      "                  // color: isHovered ? DesignTokens.highlightColor : null,",
      "                  borderRadius: BorderRadius.circular(6),",
      "                ),",
      "                padding: const EdgeInsets.symmetric(vertical: 6, horizontal: 4),",
      "                child: Row(",
      "                  children: [",
      "                    // Label",
      "                    Expanded(",
      "                      flex: 3,",
      "                      child: TextFormField(",
      "                        initialValue: size.label,",
      "                        decoration: const InputDecoration(",
      "                          labelText: 'Label',",
      "                          hintText: 'e.g. Small, Medium, Large',",
      "                        ),",
      "                        onChanged: (val) => _updateField(index, label: val),",
      "                      ),",
      "                    ),",
      "                    const SizedBox(width: 12),",
      "                    // Base Price",
      "                    Expanded(",
      "                      flex: 2,",
      "                      child: TextFormField(",
      "                        initialValue: size.basePrice.toStringAsFixed(2),",
      "                        decoration:",
      "                            const InputDecoration(labelText: 'Base Price'),",
      "                        keyboardType: const TextInputType.numberWithOptions(",
      "                            decimal: true),",
      "                        inputFormatters: [",
      "                          FilteringTextInputFormatter.allow(",
      "                              RegExp(r'^\\d*\\.?\\d{0,2}'))",
      "                        ],",
      "                        onChanged: (val) {",
      "                          final parsed = double.tryParse(val) ?? 0.0;",
      "                          _updateField(index, basePrice: parsed);",
      "                        },",
      "                      ),",
      "                    ),",
      "                    const SizedBox(width: 12),",
      "                    // Topping Price",
      "                    Expanded(",
      "                      flex: 2,",
      "                      child: TextFormField(",
      "                        initialValue: size.toppingPrice.toStringAsFixed(2),",
      "                        decoration:",
      "                            const InputDecoration(labelText: 'Topping Price'),",
      "                        keyboardType: const TextInputType.numberWithOptions(",
      "                            decimal: true),",
      "                        inputFormatters: [",
      "                          FilteringTextInputFormatter.allow(",
      "                              RegExp(r'^\\d*\\.?\\d{0,2}'))",
      "                        ],",
      "                        onChanged: (val) {",
      "                          final parsed = double.tryParse(val) ?? 0.0;",
      "                          _updateField(index, toppingPrice: parsed);",
      "                        },",
      "                      ),",
      "                    ),",
      "                    const SizedBox(width: 12),",
      "                    // Remove button",
      "                    IconButton(",
      "                      icon: const Icon(Icons.delete_outline),",
      "                      onPressed: () => _removeSize(index),",
      "                      tooltip: 'Remove Size',",
      "                    ),",
      "                  ],",
      "                ),",
      "              ),",
      "            );",
      "          },",
      "        ),",
      "        const SizedBox(height: 8),",
      "        Align(",
      "          alignment: Alignment.centerLeft,",
      "          child: TextButton.icon(",
      "            onPressed: _addSize,",
      "            icon: const Icon(Icons.add),",
      "            label: const Text('Add Size'),",
      "          ),",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 208,
      "file_size": 7247,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\widgets\\review\\issue_details_expansion.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/models/onboarding_validation_issue.dart';",
      "import 'package:franchise_admin_portal/core/providers/onboarding_review_provider.dart';",
      "import 'package:franchise_admin_portal/core/utils/onboarding_navigation_utils.dart';",
      "",
      "/// Displays an expandable issue detail panel for each onboarding section.",
      "/// - Groups by severity (critical, warning, info)",
      "/// - Supports direct navigation to item needing repair",
      "/// - Fully theme and project integrated",
      "class IssueDetailsExpansion extends StatefulWidget {",
      "  /// The order and sections to show (should match summary table)",
      "  final List<String> sectionOrder;",
      "",
      "  const IssueDetailsExpansion({",
      "    Key? key,",
      "    this.sectionOrder = const [",
      "      'Features',",
      "      'Ingredient Types',",
      "      'Ingredients',",
      "      'Categories',",
      "      'Menu Items',",
      "    ],",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  State<IssueDetailsExpansion> createState() => _IssueDetailsExpansionState();",
      "}",
      "",
      "class _IssueDetailsExpansionState extends State<IssueDetailsExpansion> {",
      "  late List<bool> _expanded;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _expanded = List.generate(widget.sectionOrder.length, (_) => false);",
      "    WidgetsBinding.instance.addPostFrameCallback((_) {",
      "      if (mounted) _logReviewState(context, at: 'initState');",
      "    });",
      "  }",
      "",
      "  @override",
      "  void didUpdateWidget(covariant IssueDetailsExpansion oldWidget) {",
      "    super.didUpdateWidget(oldWidget);",
      "    debugPrint(",
      "        '[IssueDetailsExpansion][didUpdateWidget] oldSections=${oldWidget.sectionOrder} newSections=${widget.sectionOrder}');",
      "    if (widget.sectionOrder.length != oldWidget.sectionOrder.length) {",
      "      _expanded = List.generate(widget.sectionOrder.length, (_) => false);",
      "      debugPrint(",
      "          '[IssueDetailsExpansion][didUpdateWidget] Reset expanded to $_expanded');",
      "      _logReviewState(context, at: 'didUpdateWidget:lengthChanged');",
      "    } else {",
      "      _logReviewState(context, at: 'didUpdateWidget');",
      "    }",
      "  }",
      "",
      "  void _logReviewState(BuildContext context, {String at = ''}) {",
      "    final reviewProvider =",
      "        Provider.of<OnboardingReviewProvider>(context, listen: false);",
      "    final issuesBySection = reviewProvider.allIssuesBySection;",
      "",
      "    debugPrint('[IssueDetailsExpansion] $at '",
      "        'sections=${widget.sectionOrder.length} '",
      "        'expanded=${_expanded.length}:${_expanded} '",
      "        'isPublishable=${reviewProvider.isPublishable} '",
      "        'allIssuesKeys=${issuesBySection.keys.toList()}');",
      "",
      "    for (final sec in widget.sectionOrder) {",
      "      final list = issuesBySection[sec] ?? const <OnboardingValidationIssue>[];",
      "      final crit = list",
      "          .where((e) => e.severity == OnboardingIssueSeverity.critical)",
      "          .length;",
      "      final warn = list",
      "          .where((e) => e.severity == OnboardingIssueSeverity.warning)",
      "          .length;",
      "      final info =",
      "          list.where((e) => e.severity == OnboardingIssueSeverity.info).length;",
      "      debugPrint('[IssueDetailsExpansion] $at section=\"$sec\" '",
      "          'total=${list.length} critical=$crit warning=$warn info=$info');",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final reviewProvider = Provider.of<OnboardingReviewProvider>(context);",
      "    final issuesBySection = reviewProvider.allIssuesBySection;",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "",
      "    _logReviewState(context, at: 'build:before');",
      "",
      "    return Padding(",
      "      padding: const EdgeInsets.symmetric(vertical: 18.0, horizontal: 0),",
      "      child: ExpansionPanelList(",
      "        key: const ValueKey('IssueDetailsExpansionPanelList'),",
      "        elevation: 1,",
      "        expandedHeaderPadding: EdgeInsets.zero,",
      "        expansionCallback: (idx, isOpen) {",
      "          if (idx >= 0 && idx < _expanded.length) {",
      "            setState(() => _expanded[idx] = !_expanded[idx]);",
      "          } else {",
      "            debugPrint(",
      "                '[IssueDetailsExpansion][WARN] expansionCallback index out of range');",
      "          }",
      "        },",
      "        animationDuration: const Duration(milliseconds: 200),",
      "        children: [",
      "          for (int i = 0; i < widget.sectionOrder.length; i++)",
      "            _buildSectionPanel(",
      "              context,",
      "              widget.sectionOrder[i],",
      "              issuesBySection[widget.sectionOrder[i]] ??",
      "                  const <OnboardingValidationIssue>[],",
      "              i,",
      "              colorScheme,",
      "            ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "",
      "  ExpansionPanel _buildSectionPanel(",
      "    BuildContext context,",
      "    String section,",
      "    List<OnboardingValidationIssue> issues,",
      "    int idx,",
      "    ColorScheme colorScheme,",
      "  ) {",
      "    final criticals = issues",
      "        .where((e) =>",
      "            e.isBlocking && e.severity == OnboardingIssueSeverity.critical)",
      "        .toList();",
      "    final warnings = issues",
      "        .where((e) =>",
      "            !e.isBlocking && e.severity == OnboardingIssueSeverity.warning)",
      "        .toList();",
      "    final infos = issues",
      "        .where((e) => e.severity == OnboardingIssueSeverity.info)",
      "        .toList();",
      "",
      "    return ExpansionPanel(",
      "      canTapOnHeader: true,",
      "      isExpanded: idx >= 0 && idx < _expanded.length && _expanded[idx],",
      "      backgroundColor: colorScheme.surfaceVariant.withOpacity(0.92),",
      "      headerBuilder: (context, isOpen) => ListTile(",
      "        key: ValueKey('IssueDetailsHeader::$section'),",
      "        dense: true,",
      "        title: Text(",
      "          section,",
      "          style: TextStyle(",
      "            fontWeight: FontWeight.w700,",
      "            fontSize: 17,",
      "            color: colorScheme.primary,",
      "            fontFamily: DesignTokens.fontFamily,",
      "            letterSpacing: 0.1,",
      "          ),",
      "        ),",
      "        subtitle: Row(",
      "          children: [",
      "            if (criticals.isNotEmpty)",
      "              _buildSeverityCount(",
      "                  Icons.cancel_rounded, colorScheme.error, criticals.length),",
      "            if (warnings.isNotEmpty)",
      "              _buildSeverityCount(Icons.warning_amber_rounded,",
      "                  colorScheme.tertiary, warnings.length),",
      "            if (infos.isNotEmpty)",
      "              _buildSeverityCount(",
      "                  Icons.info_outline, colorScheme.secondary, infos.length),",
      "            if (criticals.isEmpty && warnings.isEmpty && infos.isEmpty)",
      "              Text('No issues',",
      "                  style: TextStyle(",
      "                      color: Colors.green[700], fontWeight: FontWeight.w500)),",
      "          ],",
      "        ),",
      "        onTap: () {",
      "          if (idx >= 0 && idx < _expanded.length) {",
      "            setState(() => _expanded[idx] = !_expanded[idx]);",
      "          }",
      "        },",
      "      ),",
      "      body: issues.isEmpty",
      "          ? _buildNoIssuesBody(section)",
      "          : Padding(",
      "              padding: const EdgeInsets.fromLTRB(20, 10, 8, 20),",
      "              child: Column(",
      "                children: issues",
      "                    .map((issue) =>",
      "                        _buildIssueRow(context, section, issue, colorScheme))",
      "                    .toList(),",
      "              ),",
      "            ),",
      "    );",
      "  }",
      "",
      "  Widget _buildSeverityCount(IconData icon, Color color, int count) {",
      "    return Padding(",
      "      padding: const EdgeInsets.only(right: 8),",
      "      child: Row(",
      "        children: [",
      "          Icon(icon, color: color, size: 17),",
      "          const SizedBox(width: 3),",
      "          Text(",
      "            '$count ${_severityLabel(icon)}${count > 1 ? 's' : ''}',",
      "            style: TextStyle(",
      "                color: color, fontWeight: FontWeight.w500, fontSize: 14),",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "",
      "  String _severityLabel(IconData icon) {",
      "    if (icon == Icons.cancel_rounded) return 'critical';",
      "    if (icon == Icons.warning_amber_rounded) return 'warning';",
      "    return 'info';",
      "  }",
      "",
      "  Widget _buildNoIssuesBody(String section) {",
      "    return Padding(",
      "      padding: const EdgeInsets.symmetric(vertical: 13, horizontal: 28),",
      "      child: Row(",
      "        children: [",
      "          Icon(Icons.check_circle_rounded, color: Colors.green[700], size: 22),",
      "          const SizedBox(width: 9),",
      "          Text(",
      "            'No issues in $section.',",
      "            style: TextStyle(",
      "                color: Colors.green[700],",
      "                fontWeight: FontWeight.w500,",
      "                fontSize: 16),",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "",
      "  Widget _buildIssueRow(",
      "    BuildContext context,",
      "    String section,",
      "    OnboardingValidationIssue issue,",
      "    ColorScheme colorScheme,",
      "  ) {",
      "    Color severityColor;",
      "    IconData icon;",
      "    switch (issue.severity) {",
      "      case OnboardingIssueSeverity.critical:",
      "        severityColor = colorScheme.error;",
      "        icon = Icons.cancel_rounded;",
      "        break;",
      "      case OnboardingIssueSeverity.warning:",
      "        severityColor = colorScheme.tertiary;",
      "        icon = Icons.warning_amber_rounded;",
      "        break;",
      "      case OnboardingIssueSeverity.info:",
      "      default:",
      "        severityColor = colorScheme.secondary;",
      "        icon = Icons.info_outline;",
      "        break;",
      "    }",
      "",
      "    return Card(",
      "      margin: const EdgeInsets.only(bottom: 12),",
      "      elevation: 0.5,",
      "      shape: RoundedRectangleBorder(",
      "        borderRadius: BorderRadius.circular(13),",
      "        side: BorderSide(",
      "          color: severityColor.withOpacity(",
      "              issue.severity == OnboardingIssueSeverity.critical ? 0.22 : 0.10),",
      "          width: 1.2,",
      "        ),",
      "      ),",
      "      color: colorScheme.background,",
      "      child: Padding(",
      "        padding: const EdgeInsets.symmetric(vertical: 10.5, horizontal: 12),",
      "        child: Row(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            Icon(icon, color: severityColor, size: 23),",
      "            const SizedBox(width: 13),",
      "            Expanded(",
      "              child: Column(",
      "                crossAxisAlignment: CrossAxisAlignment.start,",
      "                children: [",
      "                  Text(",
      "                    issue.message,",
      "                    style: TextStyle(",
      "                      color: severityColor,",
      "                      fontWeight: FontWeight.w600,",
      "                      fontSize: 15.7,",
      "                      fontFamily: DesignTokens.fontFamily,",
      "                    ),",
      "                  ),",
      "                  if (issue.itemDisplayName.isNotEmpty ||",
      "                      (issue.itemId.isNotEmpty &&",
      "                          issue.itemDisplayName.isEmpty))",
      "                    Padding(",
      "                      padding: const EdgeInsets.only(top: 3),",
      "                      child: Text(",
      "                        issue.itemDisplayName.isNotEmpty",
      "                            ? \"Item: ${issue.itemDisplayName}\"",
      "                            : \"ID: ${issue.itemId}\",",
      "                        style: TextStyle(",
      "                          color: colorScheme.onSurface.withOpacity(0.65),",
      "                          fontSize: 14,",
      "                        ),",
      "                      ),",
      "                    ),",
      "                  if (issue.resolutionHint?.isNotEmpty ?? false)",
      "                    Padding(",
      "                      padding: const EdgeInsets.only(top: 2),",
      "                      child: Text(",
      "                        issue.resolutionHint!,",
      "                        style: TextStyle(",
      "                          color: colorScheme.onBackground.withOpacity(0.64),",
      "                          fontSize: 13.2,",
      "                        ),",
      "                      ),",
      "                    ),",
      "                  if (issue.affectedFields.isNotEmpty)",
      "                    Padding(",
      "                      padding: const EdgeInsets.only(top: 2),",
      "                      child: Wrap(",
      "                        spacing: 8,",
      "                        runSpacing: 2,",
      "                        children: issue.affectedFields",
      "                            .map((f) => Chip(",
      "                                  label: Text(f,",
      "                                      style: TextStyle(",
      "                                          fontSize: 12.5,",
      "                                          color: colorScheme",
      "                                              .onSecondaryContainer)),",
      "                                  backgroundColor: colorScheme",
      "                                      .secondaryContainer",
      "                                      .withOpacity(0.37),",
      "                                  shape: RoundedRectangleBorder(",
      "                                    borderRadius: BorderRadius.circular(7),",
      "                                  ),",
      "                                  visualDensity: VisualDensity.compact,",
      "                                  materialTapTargetSize:",
      "                                      MaterialTapTargetSize.shrinkWrap,",
      "                                ))",
      "                            .toList(),",
      "                      ),",
      "                    ),",
      "                ],",
      "              ),",
      "            ),",
      "            if (issue.actionLabel?.isNotEmpty ?? false)",
      "              Padding(",
      "                padding: const EdgeInsets.only(left: 9.0, top: 2.0),",
      "                child: TextButton.icon(",
      "                  icon: Icon(Icons.open_in_new_rounded,",
      "                      size: 18, color: severityColor),",
      "                  label: Text(",
      "                    issue.actionLabel!,",
      "                    style: TextStyle(",
      "                      color: severityColor,",
      "                      fontWeight: FontWeight.w600,",
      "                      fontSize: 14.2,",
      "                    ),",
      "                  ),",
      "                  style: TextButton.styleFrom(",
      "                    padding:",
      "                        const EdgeInsets.symmetric(horizontal: 7, vertical: 2),",
      "                  ),",
      "                  onPressed: () {",
      "                    debugPrint(",
      "                        '[IssueDetailsExpansion] Attempting navigation...');",
      "                    debugPrint('  Section (raw): \"$section\"');",
      "                    debugPrint('  Issue.itemId: \"${issue.itemId}\"');",
      "                    debugPrint('  Issue.itemLocator: \"${issue.itemLocator}\"');",
      "                    debugPrint('  Issue.actionLabel: \"${issue.actionLabel}\"');",
      "                    debugPrint(",
      "                        '  Issue.affectedFields: ${issue.affectedFields}');",
      "",
      "                    // ✅ Normalize section before navigation (fix)",
      "                    final normalizedSection =",
      "                        OnboardingNavigationUtils.normalizeForRouting(section);",
      "                    debugPrint('  Normalized section: \"$normalizedSection\"');",
      "",
      "                    final route = OnboardingNavigationUtils.resolveRoute(",
      "                        normalizedSection, issue);",
      "                    debugPrint('  Resolved route: \"$route\"');",
      "",
      "                    if (route.isEmpty) {",
      "                      debugPrint(",
      "                          '[IssueDetailsExpansion][WARN] Route is empty — navigation aborted.');",
      "                      return;",
      "                    }",
      "",
      "                    final args =",
      "                        OnboardingNavigationUtils.buildOnboardingNavArgs(",
      "                      section: normalizedSection,",
      "                      issue: issue,",
      "                    );",
      "                    debugPrint('  Nav args: $args');",
      "",
      "                    WidgetsBinding.instance.addPostFrameCallback((_) {",
      "                      Navigator.of(context).pushNamed(route, arguments: args);",
      "                    });",
      "                  },",
      "                ),",
      "              ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 410,
      "file_size": 15565,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\widgets\\review\\onboarding_audit_trail.dart",
    "content": [
      "// File: lib/admin/dashboard/onboarding/widgets/review/onboarding_audit_trail.dart",
      "import 'package:flutter/services.dart';",
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/models/audit_log.dart';",
      "import 'package:franchise_admin_portal/core/services/audit_log_service.dart';",
      "import 'package:franchise_admin_portal/widgets/empty_state_widget.dart';",
      "",
      "/// Displays recent onboarding audit trail events for the current franchise.",
      "/// - Fetches logs from AuditLogService",
      "/// - Shows event type, timestamp, user info, and allows data export/download",
      "class OnboardingAuditTrail extends StatefulWidget {",
      "  final String franchiseId;",
      "",
      "  const OnboardingAuditTrail({Key? key, required this.franchiseId})",
      "      : super(key: key);",
      "",
      "  @override",
      "  State<OnboardingAuditTrail> createState() => _OnboardingAuditTrailState();",
      "}",
      "",
      "class _OnboardingAuditTrailState extends State<OnboardingAuditTrail> {",
      "  List<AuditLog> _logs = [];",
      "  bool _loading = true;",
      "  String? _error;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _fetchLogs();",
      "  }",
      "",
      "  Future<void> _fetchLogs() async {",
      "    setState(() {",
      "      _loading = true;",
      "      _error = null;",
      "    });",
      "    try {",
      "      final auditLogService =",
      "          Provider.of<AuditLogService>(context, listen: false);",
      "      final logs =",
      "          await auditLogService.getOnboardingAuditLogs(widget.franchiseId);",
      "",
      "      setState(() {",
      "        _logs = logs;",
      "        _loading = false;",
      "      });",
      "    } catch (e) {",
      "      debugPrint('[OnboardingAuditTrail][ERROR] $e');",
      "      setState(() {",
      "        _error = e.toString();",
      "        _loading = false;",
      "      });",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "",
      "    return Material(",
      "      type: MaterialType.transparency,",
      "      child: Padding(",
      "        padding: const EdgeInsets.symmetric(vertical: 3, horizontal: 0),",
      "        child: Column(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            Text(",
      "              \"Onboarding Audit Trail\",",
      "              style: TextStyle(",
      "                fontWeight: FontWeight.bold,",
      "                fontSize: 17.2,",
      "                color: colorScheme.primary,",
      "                fontFamily: DesignTokens.fontFamily,",
      "                letterSpacing: 0.11,",
      "              ),",
      "            ),",
      "            const SizedBox(height: 8),",
      "            if (_loading)",
      "              const Padding(",
      "                padding: EdgeInsets.symmetric(vertical: 25),",
      "                child: Center(child: CircularProgressIndicator()),",
      "              )",
      "            else if (_error != null)",
      "              Padding(",
      "                padding: const EdgeInsets.symmetric(vertical: 14),",
      "                child: EmptyStateWidget(",
      "                  iconData: Icons.error_outline,",
      "                  title: \"Audit Trail Failed\",",
      "                  message: _error!,",
      "                ),",
      "              )",
      "            else if (_logs.isEmpty)",
      "              Padding(",
      "                padding: const EdgeInsets.symmetric(vertical: 14),",
      "                child: EmptyStateWidget(",
      "                  iconData: Icons.history_toggle_off_rounded,",
      "                  title: \"No Onboarding Events\",",
      "                  message:",
      "                      \"No onboarding publish or audit events found for this franchise.\",",
      "                ),",
      "              )",
      "            else",
      "              _buildAuditList(context, colorScheme),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  Widget _buildAuditList(BuildContext context, ColorScheme colorScheme) {",
      "    return ListView.separated(",
      "      shrinkWrap: true,",
      "      physics: const NeverScrollableScrollPhysics(),",
      "      itemCount: _logs.length,",
      "      separatorBuilder: (_, __) => Divider(",
      "          height: 18, color: colorScheme.outlineVariant.withOpacity(0.11)),",
      "      itemBuilder: (context, idx) {",
      "        final log = _logs[idx];",
      "        IconData icon;",
      "        Color iconColor;",
      "        String label;",
      "        switch (log.eventType) {",
      "          case AuditLogEventType.publishOnboarding:",
      "            icon = Icons.rocket_launch_rounded;",
      "            iconColor = colorScheme.primary;",
      "            label = \"Published\";",
      "            break;",
      "          case AuditLogEventType.cancelOnboarding:",
      "            icon = Icons.cancel_rounded;",
      "            iconColor = colorScheme.error;",
      "            label = \"Cancelled\";",
      "            break;",
      "          case AuditLogEventType.editOnboarding:",
      "            icon = Icons.edit_rounded;",
      "            iconColor = colorScheme.tertiary;",
      "            label = \"Edited\";",
      "            break;",
      "          default:",
      "            icon = Icons.info_outline_rounded;",
      "            iconColor = colorScheme.secondary;",
      "            label = log.eventType?.toString() ?? \"Other\";",
      "        }",
      "        final dt = log.createdAt;",
      "        final user = log.userName ?? log.userEmail ?? \"Unknown user\";",
      "",
      "        return ListTile(",
      "          dense: true,",
      "          contentPadding:",
      "              const EdgeInsets.symmetric(vertical: 3, horizontal: 4),",
      "          leading: Icon(icon, color: iconColor, size: 28),",
      "          title: Text(",
      "            \"$label Onboarding\",",
      "            style: TextStyle(",
      "              fontWeight: FontWeight.bold,",
      "              color: iconColor,",
      "              fontSize: 15.7,",
      "            ),",
      "          ),",
      "          subtitle: Column(",
      "            crossAxisAlignment: CrossAxisAlignment.start,",
      "            children: [",
      "              Text(",
      "                user,",
      "                style: TextStyle(",
      "                  color: colorScheme.onSurface.withOpacity(0.73),",
      "                  fontSize: 14.2,",
      "                ),",
      "              ),",
      "              if (dt != null)",
      "                Text(",
      "                  _formatDateTime(dt),",
      "                  style: TextStyle(",
      "                    color: colorScheme.onSurface.withOpacity(0.61),",
      "                    fontSize: 13.2,",
      "                  ),",
      "                ),",
      "              if (log.exportSnapshot != null)",
      "                Padding(",
      "                  padding: const EdgeInsets.only(top: 2),",
      "                  child: TextButton.icon(",
      "                    icon: const Icon(Icons.download_rounded, size: 16),",
      "                    label: const Text('Export snapshot'),",
      "                    style: TextButton.styleFrom(",
      "                      foregroundColor: colorScheme.primary,",
      "                      padding: const EdgeInsets.symmetric(",
      "                          horizontal: 8, vertical: 2),",
      "                      textStyle: const TextStyle(",
      "                          fontWeight: FontWeight.w500, fontSize: 14),",
      "                    ),",
      "                    onPressed: () {",
      "                      _copyExportSnapshot(context, log.exportSnapshot!);",
      "                    },",
      "                  ),",
      "                ),",
      "            ],",
      "          ),",
      "        );",
      "      },",
      "    );",
      "  }",
      "",
      "  String _formatDateTime(DateTime dt) {",
      "    // Use local formatting or package:intl for more advanced options if desired",
      "    return \"${dt.year}-${_two(dt.month)}-${_two(dt.day)}  ${_two(dt.hour)}:${_two(dt.minute)}\";",
      "  }",
      "",
      "  String _two(int n) => n < 10 ? \"0$n\" : \"$n\";",
      "",
      "  Future<void> _copyExportSnapshot(",
      "      BuildContext context, Map<String, dynamic> snapshot) async {",
      "    try {",
      "      // Exports JSON to clipboard; could use a download utility if running on web",
      "      final jsonStr = snapshot.toString();",
      "      await Clipboard.setData(ClipboardData(text: jsonStr));",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        const SnackBar(",
      "          content: Text('Audit snapshot copied to clipboard.'),",
      "          duration: Duration(seconds: 2),",
      "        ),",
      "      );",
      "    } catch (e) {",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(",
      "          content: Text('Failed to copy export: $e'),",
      "          backgroundColor: Theme.of(context).colorScheme.error,",
      "        ),",
      "      );",
      "    }",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 232,
      "file_size": 8051,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\widgets\\review\\onboarding_data_export_button.dart",
    "content": [
      "// File: lib/admin/dashboard/onboarding/widgets/review/onboarding_data_export_button.dart",
      "",
      "import 'package:flutter/material.dart';",
      "import 'package:flutter/services.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/providers/onboarding_review_provider.dart';",
      "",
      "/// Button for exporting onboarding data (including issues) as JSON.",
      "/// - Pulls from OnboardingReviewProvider.exportDataAsJson()",
      "/// - Notifies user on copy/export.",
      "/// - Ready for CSV export or true download integration (see notes).",
      "class OnboardingDataExportButton extends StatefulWidget {",
      "  const OnboardingDataExportButton({Key? key}) : super(key: key);",
      "",
      "  @override",
      "  State<OnboardingDataExportButton> createState() =>",
      "      _OnboardingDataExportButtonState();",
      "}",
      "",
      "class _OnboardingDataExportButtonState",
      "    extends State<OnboardingDataExportButton> {",
      "  bool _copying = false;",
      "  String? _lastStatusMsg;",
      "",
      "  Future<void> _exportJson(",
      "      BuildContext context, OnboardingReviewProvider provider) async {",
      "    setState(() {",
      "      _copying = true;",
      "      _lastStatusMsg = null;",
      "    });",
      "    try {",
      "      final json = provider.exportDataAsJson();",
      "      await Clipboard.setData(ClipboardData(text: json));",
      "      setState(() {",
      "        _lastStatusMsg = \"Exported to clipboard as JSON.\";",
      "      });",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(",
      "          content: const Text('Onboarding export copied to clipboard (JSON).'),",
      "          duration: const Duration(seconds: 2),",
      "        ),",
      "      );",
      "    } catch (e) {",
      "      setState(() {",
      "        _lastStatusMsg = \"Failed to copy export: $e\";",
      "      });",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(",
      "          content: Text('Failed to export: $e'),",
      "          backgroundColor: Theme.of(context).colorScheme.error,",
      "        ),",
      "      );",
      "    } finally {",
      "      setState(() {",
      "        _copying = false;",
      "      });",
      "    }",
      "  }",
      "",
      "  // Placeholder for future CSV export logic (not implemented yet)",
      "  Future<void> _exportCsv(",
      "      BuildContext context, OnboardingReviewProvider provider) async {",
      "    setState(() => _copying = true);",
      "    try {",
      "      // You may implement your CSV export logic here.",
      "      setState(() {",
      "        _lastStatusMsg = \"CSV export not yet implemented.\";",
      "      });",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        const SnackBar(",
      "          content: Text('CSV export coming soon.'),",
      "          duration: Duration(seconds: 2),",
      "        ),",
      "      );",
      "    } finally {",
      "      setState(() => _copying = false);",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final reviewProvider = Provider.of<OnboardingReviewProvider>(context);",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        Text(",
      "          \"Export Onboarding Data\",",
      "          style: TextStyle(",
      "            fontWeight: FontWeight.bold,",
      "            fontSize: 17.2,",
      "            color: colorScheme.primary,",
      "            fontFamily: DesignTokens.fontFamily,",
      "            letterSpacing: 0.11,",
      "          ),",
      "        ),",
      "        const SizedBox(height: 7),",
      "        Row(",
      "          children: [",
      "            // JSON export",
      "            ElevatedButton.icon(",
      "              icon: _copying",
      "                  ? SizedBox(",
      "                      height: 18,",
      "                      width: 18,",
      "                      child: CircularProgressIndicator(",
      "                        strokeWidth: 2.1,",
      "                        color: colorScheme.onPrimary,",
      "                      ),",
      "                    )",
      "                  : const Icon(Icons.download_rounded),",
      "              label: const Text('Export JSON'),",
      "              style: ElevatedButton.styleFrom(",
      "                backgroundColor: colorScheme.primary,",
      "                foregroundColor: colorScheme.onPrimary,",
      "                padding:",
      "                    const EdgeInsets.symmetric(horizontal: 19, vertical: 11),",
      "                shape: RoundedRectangleBorder(",
      "                  borderRadius:",
      "                      BorderRadius.circular(DesignTokens.buttonRadius),",
      "                ),",
      "                textStyle: const TextStyle(",
      "                    fontWeight: FontWeight.w600, fontSize: 15.2),",
      "              ),",
      "              onPressed:",
      "                  _copying ? null : () => _exportJson(context, reviewProvider),",
      "            ),",
      "            const SizedBox(width: 14),",
      "            // CSV export (future)",
      "            OutlinedButton.icon(",
      "              icon: const Icon(Icons.table_chart_outlined, size: 18),",
      "              label: const Text('Export CSV'),",
      "              style: OutlinedButton.styleFrom(",
      "                foregroundColor: colorScheme.primary,",
      "                padding:",
      "                    const EdgeInsets.symmetric(horizontal: 18, vertical: 11),",
      "                side: BorderSide(color: colorScheme.primary, width: 1.1),",
      "                shape: RoundedRectangleBorder(",
      "                  borderRadius:",
      "                      BorderRadius.circular(DesignTokens.buttonRadius),",
      "                ),",
      "                textStyle: const TextStyle(",
      "                    fontWeight: FontWeight.w500, fontSize: 15.2),",
      "              ),",
      "              onPressed:",
      "                  _copying ? null : () => _exportCsv(context, reviewProvider),",
      "            ),",
      "          ],",
      "        ),",
      "        if (_lastStatusMsg != null)",
      "          Padding(",
      "            padding: const EdgeInsets.only(top: 8),",
      "            child: Text(",
      "              _lastStatusMsg!,",
      "              style: TextStyle(",
      "                color: _lastStatusMsg!.startsWith(\"Failed\")",
      "                    ? colorScheme.error",
      "                    : colorScheme.secondary,",
      "                fontSize: 14.5,",
      "                fontWeight: FontWeight.w400,",
      "                fontFamily: DesignTokens.fontFamily,",
      "              ),",
      "            ),",
      "          ),",
      "        Padding(",
      "          padding: const EdgeInsets.only(top: 4),",
      "          child: Text(",
      "            \"Download your full onboarding state (with all issues) for backup, audit, or troubleshooting.\",",
      "            style: TextStyle(",
      "              color: colorScheme.onSurface.withOpacity(0.68),",
      "              fontSize: 13.5,",
      "              fontWeight: FontWeight.w400,",
      "              fontFamily: DesignTokens.fontFamily,",
      "            ),",
      "          ),",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 182,
      "file_size": 6487,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\widgets\\review\\publish_confirmation_dialog.dart",
    "content": [
      "// File: lib/admin/dashboard/onboarding/widgets/review/publish_confirmation_dialog.dart",
      "",
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/models/onboarding_validation_issue.dart';",
      "",
      "/// Confirmation modal shown before onboarding publish.",
      "/// - Lists any remaining blocking issues (should be empty if UI is correct)",
      "/// - Requires user to type \"CONFIRM\" to proceed",
      "/// - Strongly worded, a11y-friendly, and visually consistent",
      "class PublishConfirmationDialog extends StatefulWidget {",
      "  /// Pass any remaining blocking issues. If nonempty, disables publish.",
      "  final List<OnboardingValidationIssue> blockingIssues;",
      "",
      "  const PublishConfirmationDialog({",
      "    Key? key,",
      "    required this.blockingIssues,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  State<PublishConfirmationDialog> createState() =>",
      "      _PublishConfirmationDialogState();",
      "}",
      "",
      "class _PublishConfirmationDialogState extends State<PublishConfirmationDialog> {",
      "  final TextEditingController _confirmController = TextEditingController();",
      "  bool _showValidationError = false;",
      "",
      "  @override",
      "  void dispose() {",
      "    _confirmController.dispose();",
      "    super.dispose();",
      "  }",
      "",
      "  bool get _inputValid =>",
      "      _confirmController.text.trim().toUpperCase() == \"CONFIRM\";",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    final canPublish = widget.blockingIssues.isEmpty && _inputValid;",
      "",
      "    return AlertDialog(",
      "      shape: RoundedRectangleBorder(",
      "        borderRadius: BorderRadius.circular(DesignTokens.adminDialogRadius),",
      "      ),",
      "      backgroundColor: colorScheme.surface,",
      "      title: Row(",
      "        children: [",
      "          Icon(Icons.rocket_launch_rounded,",
      "              color: colorScheme.primary, size: 26),",
      "          const SizedBox(width: 10),",
      "          const Text(",
      "            \"Ready to Publish?\",",
      "            style: TextStyle(fontWeight: FontWeight.bold, fontSize: 21),",
      "          ),",
      "        ],",
      "      ),",
      "      content: SizedBox(",
      "        width: 400,",
      "        child: Column(",
      "          mainAxisSize: MainAxisSize.min,",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            Text(",
      "              \"Publishing will move your franchise from onboarding to LIVE status. This will:\",",
      "              style: TextStyle(",
      "                color: colorScheme.onSurface.withOpacity(0.93),",
      "                fontSize: 15.2,",
      "                fontWeight: FontWeight.w500,",
      "              ),",
      "            ),",
      "            const SizedBox(height: 8),",
      "            Row(",
      "              children: [",
      "                Icon(Icons.check_circle, color: Colors.green[700], size: 17),",
      "                const SizedBox(width: 6),",
      "                const Expanded(",
      "                  child: Text(",
      "                      \"Make your menu and info visible to staff and customers.\"),",
      "                ),",
      "              ],",
      "            ),",
      "            Row(",
      "              children: [",
      "                Icon(Icons.check_circle, color: Colors.green[700], size: 17),",
      "                const SizedBox(width: 6),",
      "                const Expanded(",
      "                  child: Text(",
      "                      \"Prevent further onboarding edits unless unlocked by an admin.\"),",
      "                ),",
      "              ],",
      "            ),",
      "            const SizedBox(height: 15),",
      "            // Show issues if any (should be empty unless a critical bug in UI)",
      "            if (widget.blockingIssues.isNotEmpty)",
      "              Column(",
      "                crossAxisAlignment: CrossAxisAlignment.start,",
      "                children: [",
      "                  Text(",
      "                    \"The following issues must be fixed before publishing:\",",
      "                    style: TextStyle(",
      "                      color: colorScheme.error,",
      "                      fontWeight: FontWeight.bold,",
      "                      fontSize: 15,",
      "                    ),",
      "                  ),",
      "                  const SizedBox(height: 7),",
      "                  ...widget.blockingIssues.map((issue) => Padding(",
      "                        padding: const EdgeInsets.only(bottom: 4),",
      "                        child: Row(",
      "                          crossAxisAlignment: CrossAxisAlignment.start,",
      "                          children: [",
      "                            Icon(Icons.error_outline,",
      "                                color: colorScheme.error, size: 18),",
      "                            const SizedBox(width: 6),",
      "                            Expanded(",
      "                              child: Text(",
      "                                issue.message,",
      "                                style: TextStyle(",
      "                                  color: colorScheme.error,",
      "                                  fontWeight: FontWeight.w500,",
      "                                  fontSize: 14.3,",
      "                                ),",
      "                              ),",
      "                            ),",
      "                          ],",
      "                        ),",
      "                      )),",
      "                  const SizedBox(height: 10),",
      "                ],",
      "              ),",
      "            // Confirmation prompt",
      "            if (widget.blockingIssues.isEmpty) ...[",
      "              Text(",
      "                \"Type CONFIRM to enable publishing:\",",
      "                style: TextStyle(",
      "                  color: colorScheme.primary,",
      "                  fontWeight: FontWeight.w600,",
      "                  fontSize: 15,",
      "                ),",
      "              ),",
      "              const SizedBox(height: 8),",
      "              TextField(",
      "                controller: _confirmController,",
      "                autofocus: true,",
      "                onChanged: (_) {",
      "                  if (_showValidationError) {",
      "                    setState(() {",
      "                      _showValidationError = false;",
      "                    });",
      "                  } else {",
      "                    setState(() {});",
      "                  }",
      "                },",
      "                decoration: InputDecoration(",
      "                  hintText: \"CONFIRM\",",
      "                  border: OutlineInputBorder(",
      "                    borderRadius: BorderRadius.circular(9),",
      "                  ),",
      "                  contentPadding:",
      "                      const EdgeInsets.symmetric(horizontal: 14, vertical: 11),",
      "                  errorText: _showValidationError && !_inputValid",
      "                      ? \"Please type CONFIRM to enable publishing.\"",
      "                      : null,",
      "                ),",
      "                style: TextStyle(",
      "                  letterSpacing: 1.2,",
      "                  fontWeight: FontWeight.bold,",
      "                  fontSize: 15.3,",
      "                  color: colorScheme.primary,",
      "                ),",
      "                textCapitalization: TextCapitalization.characters,",
      "              ),",
      "              const SizedBox(height: 10),",
      "            ],",
      "            if (_showValidationError &&",
      "                !_inputValid &&",
      "                widget.blockingIssues.isEmpty)",
      "              Padding(",
      "                padding: const EdgeInsets.only(top: 3.5),",
      "                child: Text(",
      "                  \"You must type CONFIRM (all caps) to proceed.\",",
      "                  style: TextStyle(",
      "                    color: colorScheme.error,",
      "                    fontWeight: FontWeight.w500,",
      "                  ),",
      "                ),",
      "              ),",
      "          ],",
      "        ),",
      "      ),",
      "      actions: [",
      "        TextButton(",
      "          child: const Text(\"Cancel\"),",
      "          style: TextButton.styleFrom(",
      "            foregroundColor: colorScheme.onSurface,",
      "            textStyle: const TextStyle(fontWeight: FontWeight.w600),",
      "          ),",
      "          onPressed: () => Navigator.of(context).pop(false),",
      "        ),",
      "        ElevatedButton.icon(",
      "          icon: const Icon(Icons.rocket_launch_rounded),",
      "          label: const Text(\"Publish & Go Live\"),",
      "          style: ElevatedButton.styleFrom(",
      "            backgroundColor:",
      "                canPublish ? colorScheme.primary : colorScheme.outlineVariant,",
      "            foregroundColor: canPublish",
      "                ? colorScheme.onPrimary",
      "                : colorScheme.onSurface.withOpacity(0.68),",
      "            textStyle:",
      "                const TextStyle(fontWeight: FontWeight.bold, fontSize: 15.8),",
      "            padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 11),",
      "            shape: RoundedRectangleBorder(",
      "              borderRadius: BorderRadius.circular(DesignTokens.buttonRadius),",
      "            ),",
      "            elevation: canPublish ? 2.5 : 0,",
      "          ),",
      "          onPressed: !canPublish",
      "              ? null",
      "              : () {",
      "                  if (!_inputValid) {",
      "                    setState(() => _showValidationError = true);",
      "                    return;",
      "                  }",
      "                  Navigator.of(context).pop(true);",
      "                },",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 232,
      "file_size": 8855,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\widgets\\review\\publish_onboarding_button.dart",
    "content": [
      "// File: lib/admin/dashboard/onboarding/widgets/review/publish_onboarding_button.dart",
      "",
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/providers/onboarding_review_provider.dart';",
      "import 'package:franchise_admin_portal/widgets/confirmation_dialog.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/widgets/review/publish_confirmation_dialog.dart';",
      "import 'package:franchise_admin_portal/core/models/onboarding_validation_issue.dart';",
      "",
      "// You will implement PublishConfirmationDialog as a separate file/component",
      "",
      "class PublishOnboardingButton extends StatefulWidget {",
      "  final String franchiseId;",
      "  final String userId;",
      "",
      "  const PublishOnboardingButton({",
      "    Key? key,",
      "    required this.franchiseId,",
      "    required this.userId,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  State<PublishOnboardingButton> createState() =>",
      "      _PublishOnboardingButtonState();",
      "}",
      "",
      "class _PublishOnboardingButtonState extends State<PublishOnboardingButton> {",
      "  bool _publishing = false;",
      "  String? _publishStatusMsg;",
      "",
      "  Future<void> _handlePublish(",
      "      BuildContext context, OnboardingReviewProvider provider) async {",
      "    // Trigger confirmation dialog first",
      "    final confirmed = await showDialog<bool>(",
      "      context: context,",
      "      builder: (ctx) => PublishConfirmationDialog(",
      "        blockingIssues: provider.allIssuesFlat",
      "            .where((e) =>",
      "                e.isBlocking && e.severity == OnboardingIssueSeverity.critical)",
      "            .toList(),",
      "      ),",
      "    );",
      "",
      "    if (confirmed != true) return;",
      "",
      "    setState(() {",
      "      _publishing = true;",
      "      _publishStatusMsg = null;",
      "    });",
      "",
      "    try {",
      "      await provider.publishOnboarding(",
      "        franchiseId: widget.franchiseId,",
      "        userId: widget.userId,",
      "      );",
      "      setState(() => _publishStatusMsg = \"Franchise onboarding published!\");",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        const SnackBar(",
      "          content: Text('Franchise onboarding published successfully!'),",
      "          duration: Duration(seconds: 2),",
      "        ),",
      "      );",
      "      // Optional: navigate to main dashboard or onboarding complete screen.",
      "    } catch (e) {",
      "      setState(() => _publishStatusMsg = \"Publish failed: $e\");",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(",
      "          content: Text('Failed to publish onboarding: $e'),",
      "          backgroundColor: Theme.of(context).colorScheme.error,",
      "        ),",
      "      );",
      "    } finally {",
      "      setState(() => _publishing = false);",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final reviewProvider = Provider.of<OnboardingReviewProvider>(context);",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    final canPublish = reviewProvider.isPublishable && !_publishing;",
      "",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.end,",
      "      children: [",
      "        ElevatedButton.icon(",
      "          icon: _publishing",
      "              ? SizedBox(",
      "                  width: 18,",
      "                  height: 18,",
      "                  child: CircularProgressIndicator(",
      "                    color: colorScheme.onPrimary,",
      "                    strokeWidth: 2.2,",
      "                  ),",
      "                )",
      "              : const Icon(Icons.rocket_launch_rounded),",
      "          label: Text(",
      "            _publishing ? \"Publishing...\" : \"Publish / Go Live\",",
      "            style: TextStyle(",
      "              fontWeight: FontWeight.w700,",
      "              fontSize: 17,",
      "              fontFamily: DesignTokens.fontFamily,",
      "            ),",
      "          ),",
      "          style: ElevatedButton.styleFrom(",
      "            backgroundColor:",
      "                canPublish ? colorScheme.primary : colorScheme.outlineVariant,",
      "            foregroundColor: canPublish",
      "                ? colorScheme.onPrimary",
      "                : colorScheme.onSurface.withOpacity(0.61),",
      "            padding: const EdgeInsets.symmetric(horizontal: 30, vertical: 16),",
      "            shape: RoundedRectangleBorder(",
      "              borderRadius: BorderRadius.circular(DesignTokens.buttonRadius),",
      "            ),",
      "            elevation: canPublish ? 2.5 : 0,",
      "            textStyle: const TextStyle(fontWeight: FontWeight.bold),",
      "          ),",
      "          onPressed:",
      "              canPublish ? () => _handlePublish(context, reviewProvider) : null,",
      "        ),",
      "        if (_publishStatusMsg != null)",
      "          Padding(",
      "            padding: const EdgeInsets.only(top: 7.0),",
      "            child: Text(",
      "              _publishStatusMsg!,",
      "              style: TextStyle(",
      "                color: _publishStatusMsg!.toLowerCase().contains('fail')",
      "                    ? colorScheme.error",
      "                    : colorScheme.primary,",
      "                fontWeight: FontWeight.w500,",
      "                fontSize: 14,",
      "                fontFamily: DesignTokens.fontFamily,",
      "              ),",
      "            ),",
      "          ),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 140,
      "file_size": 5014,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\dashboard\\onboarding\\widgets\\review\\review_summary_table.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/ingredient_type_provider.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/models/onboarding_validation_issue.dart';",
      "import 'package:franchise_admin_portal/core/providers/onboarding_review_provider.dart';",
      "import 'package:franchise_admin_portal/core/utils/onboarding_navigation_utils.dart';",
      "import 'package:franchise_admin_portal/core/providers/ingredient_metadata_provider.dart';",
      "",
      "class ReviewSummaryTable extends StatelessWidget {",
      "  static const List<String> _sectionOrder = [",
      "    OnboardingSections.features,",
      "    OnboardingSections.ingredientTypes,",
      "    OnboardingSections.ingredients,",
      "    OnboardingSections.categories,",
      "    OnboardingSections.menuItems,",
      "  ];",
      "",
      "  const ReviewSummaryTable({Key? key}) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    final reviewProvider = Provider.of<OnboardingReviewProvider>(context);",
      "    final issuesBySection = reviewProvider.allIssuesBySection;",
      "",
      "    return Material(",
      "      type: MaterialType.transparency,",
      "      child: Column(",
      "        crossAxisAlignment: CrossAxisAlignment.start,",
      "        children: [",
      "          Text(",
      "            'Onboarding Progress',",
      "            style: TextStyle(",
      "              fontWeight: FontWeight.bold,",
      "              fontSize: 21,",
      "              color: colorScheme.primary,",
      "              fontFamily: DesignTokens.fontFamily,",
      "              letterSpacing: 0.2,",
      "            ),",
      "          ),",
      "          const SizedBox(height: 18),",
      "          Card(",
      "            elevation: DesignTokens.adminCardElevation,",
      "            shape: RoundedRectangleBorder(",
      "              borderRadius: BorderRadius.circular(DesignTokens.adminCardRadius),",
      "            ),",
      "            color: colorScheme.surface,",
      "            child: Table(",
      "              columnWidths: const {",
      "                0: FlexColumnWidth(2.2),",
      "                1: FlexColumnWidth(1.1),",
      "                2: FlexColumnWidth(1.0),",
      "                3: FlexColumnWidth(1.3),",
      "              },",
      "              border: TableBorder(",
      "                horizontalInside: BorderSide(",
      "                  color: colorScheme.outlineVariant.withOpacity(0.16),",
      "                  width: 1.1,",
      "                ),",
      "              ),",
      "              children: [",
      "                _buildHeaderRow(context),",
      "                ..._sectionOrder.map(",
      "                  (section) => _buildSectionRow(",
      "                    context,",
      "                    section,",
      "                    issuesBySection[section] ?? const [],",
      "                  ),",
      "                ),",
      "              ],",
      "            ),",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "",
      "  TableRow _buildHeaderRow(BuildContext context) {",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    final thStyle = TextStyle(",
      "      fontWeight: FontWeight.w600,",
      "      fontSize: 16,",
      "      color: colorScheme.primary.withOpacity(0.87),",
      "      letterSpacing: 0.12,",
      "      fontFamily: DesignTokens.fontFamily,",
      "    );",
      "    return TableRow(",
      "      children: [",
      "        _buildHeaderCell('Section', thStyle,",
      "            align: TextAlign.left, padLeft: 10),",
      "        _buildHeaderCell('Status', thStyle),",
      "        _buildHeaderCell('Issues', thStyle),",
      "        _buildHeaderCell('Action', thStyle),",
      "      ],",
      "    );",
      "  }",
      "",
      "  Widget _buildHeaderCell(String text, TextStyle style,",
      "      {TextAlign align = TextAlign.center, double padLeft = 0}) {",
      "    return Padding(",
      "      padding: EdgeInsets.symmetric(vertical: 11.0, horizontal: padLeft),",
      "      child: Text(text, style: style, textAlign: align),",
      "    );",
      "  }",
      "",
      "  TableRow _buildSectionRow(",
      "    BuildContext context,",
      "    String section,",
      "    List<OnboardingValidationIssue> issues,",
      "  ) {",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "",
      "    final criticalCount = issues",
      "        .where((e) =>",
      "            e.isBlocking && e.severity == OnboardingIssueSeverity.critical)",
      "        .length;",
      "    final warningCount = issues",
      "        .where((e) =>",
      "            !e.isBlocking && e.severity == OnboardingIssueSeverity.warning)",
      "        .length;",
      "",
      "    final statusWidget =",
      "        _buildStatusWidget(colorScheme, criticalCount, warningCount);",
      "    final issuesWidget =",
      "        _buildIssuesWidget(colorScheme, criticalCount, warningCount);",
      "",
      "    final actionWidget = _buildActionWidget(",
      "        context, section, issues, criticalCount, warningCount, colorScheme);",
      "",
      "    final sectionWidget = Padding(",
      "      padding: const EdgeInsets.symmetric(vertical: 11.0, horizontal: 10),",
      "      child: Text(",
      "        section,",
      "        style: TextStyle(",
      "          fontWeight: FontWeight.w500,",
      "          fontSize: 16,",
      "          color: colorScheme.onSurface.withOpacity(0.89),",
      "          fontFamily: DesignTokens.fontFamily,",
      "        ),",
      "      ),",
      "    );",
      "",
      "    return TableRow(",
      "      children: [",
      "        sectionWidget,",
      "        statusWidget,",
      "        issuesWidget,",
      "        Padding(",
      "          padding: const EdgeInsets.symmetric(vertical: 4.0, horizontal: 8.0),",
      "          child: Center(child: actionWidget),",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "",
      "  Widget _buildStatusWidget(",
      "      ColorScheme colorScheme, int criticalCount, int warningCount) {",
      "    if (criticalCount > 0) {",
      "      return _statusRow(Icons.cancel_rounded, 'Blocked', colorScheme.error);",
      "    } else if (warningCount > 0) {",
      "      return _statusRow(",
      "          Icons.warning_amber_rounded, 'Warning', colorScheme.tertiary);",
      "    } else {",
      "      return _statusRow(",
      "          Icons.check_circle_rounded, 'Complete', Colors.green[700]!,",
      "          iconColor: Colors.green[600]!);",
      "    }",
      "  }",
      "",
      "  Widget _statusRow(IconData icon, String label, Color textColor,",
      "      {Color? iconColor}) {",
      "    return Row(",
      "      mainAxisAlignment: MainAxisAlignment.center,",
      "      children: [",
      "        Icon(icon, color: iconColor ?? textColor, size: 22),",
      "        const SizedBox(width: 5),",
      "        Text(label,",
      "            style: TextStyle(",
      "                color: textColor, fontWeight: FontWeight.w600, fontSize: 15)),",
      "      ],",
      "    );",
      "  }",
      "",
      "  Widget _buildIssuesWidget(",
      "      ColorScheme colorScheme, int criticalCount, int warningCount) {",
      "    if (criticalCount + warningCount == 0) {",
      "      return Text('0',",
      "          style: TextStyle(",
      "              color: Colors.green[800],",
      "              fontWeight: FontWeight.bold,",
      "              fontSize: 15),",
      "          textAlign: TextAlign.center);",
      "    }",
      "",
      "    return Row(",
      "      mainAxisAlignment: MainAxisAlignment.center,",
      "      children: [",
      "        if (criticalCount > 0)",
      "          _issueBadge('$criticalCount', colorScheme.error.withOpacity(0.15),",
      "              colorScheme.error,",
      "              tooltip: '$criticalCount critical'),",
      "        if (warningCount > 0)",
      "          _issueBadge('$warningCount', colorScheme.tertiary.withOpacity(0.16),",
      "              colorScheme.tertiary,",
      "              tooltip: '$warningCount warning'),",
      "      ],",
      "    );",
      "  }",
      "",
      "  Widget _issueBadge(String text, Color bgColor, Color fgColor,",
      "      {required String tooltip}) {",
      "    return Padding(",
      "      padding: const EdgeInsets.symmetric(horizontal: 2.5),",
      "      child: Tooltip(",
      "        message: tooltip,",
      "        child: Container(",
      "          padding: const EdgeInsets.symmetric(horizontal: 7, vertical: 3),",
      "          decoration: BoxDecoration(",
      "              color: bgColor, borderRadius: BorderRadius.circular(8)),",
      "          child: Text(text,",
      "              style: TextStyle(",
      "                  color: fgColor, fontWeight: FontWeight.bold, fontSize: 15)),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  Widget _buildActionWidget(",
      "    BuildContext context,",
      "    String section,",
      "    List<OnboardingValidationIssue> issues,",
      "    int criticalCount,",
      "    int warningCount,",
      "    ColorScheme colorScheme,",
      "  ) {",
      "    void _navigateToFix(OnboardingValidationIssue issue) async {",
      "      debugPrint('──────────────────────────────────────────────');",
      "      debugPrint('[ReviewSummaryTable] 🛠 Attempting navigation');",
      "      debugPrint('  • Section (raw): \"$section\"');",
      "      debugPrint('  • Issue.itemId: \"${issue.itemId}\"');",
      "      debugPrint('  • Issue.itemLocator: \"${issue.itemLocator}\"');",
      "      debugPrint('  • Issue.actionLabel: \"${issue.actionLabel}\"');",
      "      debugPrint('  • Issue.affectedFields: ${issue.affectedFields}');",
      "      debugPrint('──────────────────────────────────────────────');",
      "",
      "      // 1) Normalize & resolve route",
      "      final normalizedSection =",
      "          OnboardingNavigationUtils.normalizeForRouting(section);",
      "      debugPrint(",
      "          '[ReviewSummaryTable] Normalized section → \"$normalizedSection\"');",
      "",
      "      final route =",
      "          OnboardingNavigationUtils.resolveRoute(normalizedSection, issue);",
      "      debugPrint('[ReviewSummaryTable] Resolved route → \"$route\"');",
      "",
      "      if (route.isEmpty) {",
      "        debugPrint(",
      "            '[ReviewSummaryTable][WARN] ❌ Route is empty — navigation aborted.');",
      "        return;",
      "      }",
      "",
      "      // 2) Build args for downstream focus/highlight",
      "      final args = OnboardingNavigationUtils.buildOnboardingNavArgs(",
      "        section: normalizedSection,",
      "        issue: issue,",
      "      );",
      "      debugPrint('[ReviewSummaryTable] Built nav args → $args');",
      "",
      "      // 3) Pre-load prerequisites for sections that need them",
      "      try {",
      "        if (normalizedSection == 'onboardingIngredients') {",
      "          debugPrint(",
      "              '[ReviewSummaryTable] 📦 Checking prerequisites for Ingredients…');",
      "",
      "          final typeProvider = context.read<IngredientTypeProvider>();",
      "          final metaProvider = context.read<IngredientMetadataProvider>();",
      "",
      "          // Prefer an already-bound franchiseId on either provider",
      "          String fid = typeProvider.franchiseId;",
      "          if (fid.isEmpty || fid == 'unknown') {",
      "            fid = metaProvider.franchiseId;",
      "          }",
      "          debugPrint('    franchiseId detected: \"$fid\"');",
      "",
      "          // Ingredient Types (must exist for Ingredients screen)",
      "          final typesCount = typeProvider.ingredientTypes.length;",
      "          debugPrint('    IngredientTypes count: $typesCount');",
      "          if (typesCount == 0) {",
      "            debugPrint('    ➤ Loading Ingredient Types…');",
      "            await typeProvider.loadIngredientTypes(fid);",
      "            debugPrint(",
      "                '    ✔ Ingredient Types loaded. New count: ${typeProvider.ingredientTypes.length}');",
      "          }",
      "",
      "          // Ingredient Metadata (screen uses provider.isInitialized + list)",
      "          debugPrint(",
      "              '    IngredientMetadata isInitialized: ${metaProvider.isInitialized}');",
      "          debugPrint(",
      "              '    IngredientMetadata count: ${metaProvider.ingredients.length}');",
      "          if (!metaProvider.isInitialized || metaProvider.ingredients.isEmpty) {",
      "            debugPrint('    ➤ Loading Ingredient Metadata…');",
      "            await metaProvider.load();",
      "            debugPrint(",
      "                '    ✔ Ingredient Metadata loaded. New count: ${metaProvider.ingredients.length}');",
      "          }",
      "        } else if (normalizedSection == 'onboardingIngredientTypes') {",
      "          debugPrint(",
      "              '[ReviewSummaryTable] 📦 Checking prerequisites for Ingredient Types…');",
      "",
      "          final typeProvider = context.read<IngredientTypeProvider>();",
      "          String fid = typeProvider.franchiseId;",
      "          if (fid.isEmpty || fid == 'unknown') {",
      "            // Fallback: try from IngredientMetadataProvider (has final franchiseId)",
      "            final metaProvider = context.read<IngredientMetadataProvider>();",
      "            fid = metaProvider.franchiseId;",
      "          }",
      "          debugPrint('    franchiseId detected: \"$fid\"');",
      "",
      "          final typesCount = typeProvider.ingredientTypes.length;",
      "          debugPrint('    IngredientTypes count: $typesCount');",
      "          if (typesCount == 0) {",
      "            debugPrint('    ➤ Loading Ingredient Types…');",
      "            await typeProvider.loadIngredientTypes(fid);",
      "            debugPrint(",
      "                '    ✔ Ingredient Types loaded. New count: ${typeProvider.ingredientTypes.length}');",
      "          }",
      "        }",
      "      } catch (e, st) {",
      "        debugPrint(",
      "            '[ReviewSummaryTable][ERROR] ⚠ Failed while preloading prerequisites.');",
      "        debugPrint('    Exception: $e');",
      "        debugPrint('    Stacktrace: $st');",
      "        // Continue to navigate; downstream screen may still guard itself.",
      "      }",
      "",
      "      // 4) Navigate after this frame to avoid setState during build",
      "      WidgetsBinding.instance.addPostFrameCallback((_) {",
      "        debugPrint('[ReviewSummaryTable] 🚀 Navigating to → \"$route\"');",
      "        Navigator.of(context).pushNamed(route, arguments: args);",
      "      });",
      "    }",
      "",
      "    if (criticalCount > 0) {",
      "      final issue = issues.firstWhere(",
      "        (e) => e.isBlocking && e.severity == OnboardingIssueSeverity.critical,",
      "        orElse: () => issues.first,",
      "      );",
      "      return _actionButton(",
      "        label: issue.actionLabel?.isNotEmpty == true",
      "            ? issue.actionLabel!",
      "            : 'Fix Now',",
      "        icon: Icons.build_circle_outlined,",
      "        color: colorScheme.primary,",
      "        onPressed: () => _navigateToFix(issue),",
      "      );",
      "    } else if (warningCount > 0) {",
      "      final issue = issues.firstWhere(",
      "        (e) => !e.isBlocking && e.severity == OnboardingIssueSeverity.warning,",
      "        orElse: () => issues.first,",
      "      );",
      "      return _actionButton(",
      "        label: issue.actionLabel?.isNotEmpty == true",
      "            ? issue.actionLabel!",
      "            : 'Review',",
      "        icon: Icons.visibility_outlined,",
      "        color: colorScheme.tertiary,",
      "        onPressed: () => _navigateToFix(issue),",
      "      );",
      "    }",
      "",
      "    return Text('—',",
      "        style: TextStyle(color: colorScheme.outlineVariant, fontSize: 15),",
      "        textAlign: TextAlign.center);",
      "  }",
      "",
      "  Widget _actionButton(",
      "      {required String label,",
      "      required IconData icon,",
      "      required Color color,",
      "      required VoidCallback onPressed}) {",
      "    return TextButton.icon(",
      "      style: TextButton.styleFrom(",
      "        foregroundColor: color,",
      "        textStyle: const TextStyle(fontWeight: FontWeight.w600),",
      "      ),",
      "      onPressed: onPressed,",
      "      icon: Icon(icon, size: 20),",
      "      label: Text(label),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 392,
      "file_size": 14596,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\developer\\admin_error_logs_screen.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class AdminErrorLogsScreen extends StatefulWidget {",
      "  const AdminErrorLogsScreen({Key? key}) : super(key: key);",
      "",
      "  @override",
      "  State<AdminErrorLogsScreen> createState() => _AdminErrorLogsScreenState();",
      "}",
      "",
      "class _AdminErrorLogsScreenState extends State<AdminErrorLogsScreen> {",
      "  bool _loading = true;",
      "  String? _errorMsg;",
      "  List<AdminErrorLog> _logs = [];",
      "  String? _severity;",
      "  DateTimeRange? _dateRange;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _fetchLogs();",
      "  }",
      "",
      "  Future<void> _fetchLogs() async {",
      "    setState(() {",
      "      _loading = true;",
      "      _errorMsg = null;",
      "    });",
      "    try {",
      "      // TODO: Replace with real FirestoreService error log query scoped to this franchise.",
      "      await Future.delayed(const Duration(milliseconds: 500));",
      "      final franchiseId =",
      "          Provider.of<FranchiseProvider>(context, listen: false).franchiseId;",
      "      _logs = [",
      "        AdminErrorLog(",
      "          id: '1',",
      "          timestamp: DateTime.now().subtract(const Duration(minutes: 14)),",
      "          message: 'Customer order failed during checkout.',",
      "          severity: 'error',",
      "          screen: 'CheckoutScreen',",
      "          franchiseId: franchiseId,",
      "        ),",
      "        AdminErrorLog(",
      "          id: '2',",
      "          timestamp: DateTime.now().subtract(const Duration(hours: 2)),",
      "          message: 'Receipt printer not responding.',",
      "          severity: 'warning',",
      "          screen: 'OrderScreen',",
      "          franchiseId: franchiseId,",
      "        ),",
      "        AdminErrorLog(",
      "          id: '3',",
      "          timestamp: DateTime.now().subtract(const Duration(days: 1)),",
      "          message: 'Loyalty points failed to sync for customer.',",
      "          severity: 'error',",
      "          screen: 'CustomerLoyaltyScreen',",
      "          franchiseId: franchiseId,",
      "        ),",
      "      ];",
      "      setState(() => _loading = false);",
      "    } catch (e, stack) {",
      "      setState(() {",
      "        _errorMsg = e.toString();",
      "        _loading = false;",
      "      });",
      "      final franchiseId = context.watch<FranchiseProvider>().franchiseId;",
      "      await ErrorLogger.log(",
      "        message: 'Failed to fetch admin error logs: $e',",
      "        stack: stack.toString(),",
      "        source: 'AdminErrorLogsScreen',",
      "        screen: 'AdminErrorLogsScreen',",
      "        severity: 'warning',",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "        },",
      "      );",
      "    }",
      "  }",
      "",
      "  List<AdminErrorLog> get _filteredLogs {",
      "    return _logs.where((log) {",
      "      final severityOk = _severity == null || log.severity == _severity;",
      "      final dateOk = _dateRange == null ||",
      "          (log.timestamp.isAfter(",
      "                  _dateRange!.start.subtract(const Duration(seconds: 1))) &&",
      "              log.timestamp",
      "                  .isBefore(_dateRange!.end.add(const Duration(days: 1))));",
      "      return severityOk && dateOk;",
      "    }).toList();",
      "  }",
      "",
      "  void _pickDateRange() async {",
      "    final initial = _dateRange ??",
      "        DateTimeRange(",
      "          start: DateTime.now().subtract(const Duration(days: 7)),",
      "          end: DateTime.now(),",
      "        );",
      "    final picked = await showDateRangePicker(",
      "      context: context,",
      "      firstDate: DateTime.now().subtract(const Duration(days: 365)),",
      "      lastDate: DateTime.now().add(const Duration(days: 1)),",
      "      initialDateRange: initial,",
      "    );",
      "    if (picked != null) setState(() => _dateRange = picked);",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    debugPrint('[admin_error_logs_screen] Loaded');",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "    final adminUser = Provider.of<AdminUserProvider>(context).user;",
      "    final roles = adminUser?.roles ?? [];",
      "    final isAdmin = roles.contains('owner') ||",
      "        roles.contains('manager') ||",
      "        roles.contains('staff') ||",
      "        roles.contains('developer');",
      "",
      "    if (!isAdmin) {",
      "      return Scaffold(",
      "        appBar: AppBar(",
      "          title: Text(loc.adminErrorLogsScreenTitle),",
      "        ),",
      "        body: Center(",
      "          child: Text(",
      "            loc.unauthorizedAccess,",
      "            style: theme.textTheme.titleLarge?.copyWith(",
      "              color: colorScheme.error,",
      "              fontWeight: FontWeight.bold,",
      "            ),",
      "          ),",
      "        ),",
      "      );",
      "    }",
      "",
      "    final severities = _logs.map((e) => e.severity).toSet().toList();",
      "",
      "    return Scaffold(",
      "      appBar: AppBar(",
      "        title: Text(loc.adminErrorLogsScreenTitle),",
      "        actions: [",
      "          IconButton(",
      "            icon: const Icon(Icons.refresh),",
      "            tooltip: loc.reload,",
      "            onPressed: _fetchLogs,",
      "          ),",
      "        ],",
      "      ),",
      "      body: Padding(",
      "        padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 14),",
      "        child: Column(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            _buildFilterRow(loc, severities, theme, colorScheme),",
      "            const SizedBox(height: 10),",
      "            if (_loading)",
      "              Center(",
      "                  child: CircularProgressIndicator(color: colorScheme.primary))",
      "            else if (_errorMsg != null)",
      "              Card(",
      "                color: colorScheme.errorContainer,",
      "                child: Padding(",
      "                  padding: const EdgeInsets.all(16.0),",
      "                  child: Row(",
      "                    children: [",
      "                      Icon(Icons.error, color: colorScheme.error),",
      "                      const SizedBox(width: 12),",
      "                      Expanded(",
      "                        child: Text(",
      "                          '${loc.adminErrorLogsScreenError}\\n$_errorMsg',",
      "                          style: theme.textTheme.bodyMedium",
      "                              ?.copyWith(color: colorScheme.error),",
      "                        ),",
      "                      ),",
      "                      IconButton(",
      "                        icon: Icon(Icons.refresh, color: colorScheme.primary),",
      "                        tooltip: loc.reload,",
      "                        onPressed: _fetchLogs,",
      "                      ),",
      "                    ],",
      "                  ),",
      "                ),",
      "              )",
      "            else if (_filteredLogs.isEmpty)",
      "              Center(child: Text(loc.adminErrorLogsScreenEmpty))",
      "            else",
      "              Expanded(",
      "                  child: _AdminErrorLogList(",
      "                      logs: _filteredLogs,",
      "                      colorScheme: colorScheme,",
      "                      loc: loc,",
      "                      theme: theme)),",
      "            const SizedBox(height: 18),",
      "            _ComingSoonCard(",
      "              icon: Icons.support_agent,",
      "              title: loc.adminErrorLogsScreenSupportComingSoon,",
      "              subtitle: loc.adminErrorLogsScreenSupportDesc,",
      "              colorScheme: colorScheme,",
      "              theme: theme,",
      "            ),",
      "            _ComingSoonCard(",
      "              icon: Icons.analytics,",
      "              title: loc.adminErrorLogsScreenTrendsComingSoon,",
      "              subtitle: loc.adminErrorLogsScreenTrendsDesc,",
      "              colorScheme: colorScheme,",
      "              theme: theme,",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  Widget _buildFilterRow(",
      "    AppLocalizations loc,",
      "    List<String> severities,",
      "    ThemeData theme,",
      "    ColorScheme colorScheme,",
      "  ) {",
      "    return Card(",
      "      margin: EdgeInsets.zero,",
      "      color: colorScheme.surfaceVariant,",
      "      child: Padding(",
      "        padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 10),",
      "        child: Wrap(",
      "          spacing: 16,",
      "          runSpacing: 10,",
      "          crossAxisAlignment: WrapCrossAlignment.center,",
      "          children: [",
      "            // Severity filter",
      "            Row(",
      "              mainAxisSize: MainAxisSize.min,",
      "              children: [",
      "                Text('${loc.adminErrorLogsScreenSeverity}: ',",
      "                    style: theme.textTheme.titleMedium),",
      "                DropdownButton<String>(",
      "                  value: _severity,",
      "                  hint: Text(loc.adminErrorLogsScreenFilterAny),",
      "                  items: [",
      "                    DropdownMenuItem(",
      "                        value: null,",
      "                        child: Text(loc.adminErrorLogsScreenFilterAny)),",
      "                    ...severities",
      "                        .map((s) => DropdownMenuItem(value: s, child: Text(s))),",
      "                  ],",
      "                  onChanged: (s) => setState(() => _severity = s),",
      "                ),",
      "              ],",
      "            ),",
      "            // Date range",
      "            Row(",
      "              mainAxisSize: MainAxisSize.min,",
      "              children: [",
      "                Text('${loc.adminErrorLogsScreenDateRange}: ',",
      "                    style: theme.textTheme.titleMedium),",
      "                OutlinedButton.icon(",
      "                  icon: const Icon(Icons.date_range),",
      "                  label: Text(_dateRange == null",
      "                      ? loc.adminErrorLogsScreenAllDates",
      "                      : '${_dateRange!.start.year}-${_dateRange!.start.month.toString().padLeft(2, '0')}-${_dateRange!.start.day.toString().padLeft(2, '0')} — ${_dateRange!.end.year}-${_dateRange!.end.month.toString().padLeft(2, '0')}-${_dateRange!.end.day.toString().padLeft(2, '0')}'),",
      "                  onPressed: _pickDateRange,",
      "                ),",
      "              ],",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "class _AdminErrorLogList extends StatelessWidget {",
      "  final List<AdminErrorLog> logs;",
      "  final ColorScheme colorScheme;",
      "  final AppLocalizations loc;",
      "  final ThemeData theme;",
      "",
      "  const _AdminErrorLogList({",
      "    required this.logs,",
      "    required this.colorScheme,",
      "    required this.loc,",
      "    required this.theme,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return ListView.separated(",
      "      itemCount: logs.length,",
      "      separatorBuilder: (_, __) => const Divider(height: 1),",
      "      itemBuilder: (context, idx) {",
      "        final log = logs[idx];",
      "        return ListTile(",
      "          leading: Icon(",
      "            log.severity == 'error'",
      "                ? Icons.error",
      "                : log.severity == 'warning'",
      "                    ? Icons.warning",
      "                    : Icons.info,",
      "            color: log.severity == 'error'",
      "                ? Colors.red",
      "                : log.severity == 'warning'",
      "                    ? Colors.orange",
      "                    : colorScheme.outline,",
      "          ),",
      "          title: Text(log.message),",
      "          subtitle: Text(",
      "            '${loc.adminErrorLogsScreenAt}: ${log.screen}\\n${_formatDateTime(log.timestamp)}',",
      "            style: const TextStyle(fontSize: 13),",
      "          ),",
      "          shape: RoundedRectangleBorder(",
      "            borderRadius: BorderRadius.circular(DesignTokens.adminCardRadius),",
      "          ),",
      "          onTap: () {",
      "            // Placeholder for future detail dialog/modal",
      "            ScaffoldMessenger.of(context).showSnackBar(",
      "              SnackBar(content: Text(loc.comingSoon)),",
      "            );",
      "          },",
      "        );",
      "      },",
      "    );",
      "  }",
      "",
      "  String _formatDateTime(DateTime dt) {",
      "    return '${dt.year}-${dt.month.toString().padLeft(2, '0')}-${dt.day.toString().padLeft(2, '0')} '",
      "        '${dt.hour.toString().padLeft(2, '0')}:${dt.minute.toString().padLeft(2, '0')}';",
      "  }",
      "}",
      "",
      "class _ComingSoonCard extends StatelessWidget {",
      "  final IconData icon;",
      "  final String title;",
      "  final String subtitle;",
      "  final ColorScheme colorScheme;",
      "  final ThemeData theme;",
      "",
      "  const _ComingSoonCard({",
      "    required this.icon,",
      "    required this.title,",
      "    required this.subtitle,",
      "    required this.colorScheme,",
      "    required this.theme,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Card(",
      "      color: colorScheme.surfaceVariant.withOpacity(0.87),",
      "      elevation: DesignTokens.adminCardElevation,",
      "      shape: RoundedRectangleBorder(",
      "        borderRadius: BorderRadius.circular(DesignTokens.adminCardRadius),",
      "      ),",
      "      child: Padding(",
      "        padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 20),",
      "        child: Row(",
      "          children: [",
      "            Icon(icon, color: colorScheme.outline, size: 30),",
      "            const SizedBox(width: 18),",
      "            Expanded(",
      "              child: Column(",
      "                crossAxisAlignment: CrossAxisAlignment.start,",
      "                children: [",
      "                  Text(",
      "                    title,",
      "                    style: theme.textTheme.titleMedium?.copyWith(",
      "                      color: colorScheme.outline,",
      "                      fontWeight: FontWeight.bold,",
      "                    ),",
      "                  ),",
      "                  const SizedBox(height: 4),",
      "                  Text(",
      "                    subtitle,",
      "                    style: theme.textTheme.bodyMedium,",
      "                  ),",
      "                ],",
      "              ),",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "class AdminErrorLog {",
      "  final String id;",
      "  final DateTime timestamp;",
      "  final String message;",
      "  final String severity;",
      "  final String screen;",
      "  final String franchiseId;",
      "",
      "  AdminErrorLog({",
      "    required this.id,",
      "    required this.timestamp,",
      "    required this.message,",
      "    required this.severity,",
      "    required this.screen,",
      "    required this.franchiseId,",
      "  });",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 415,
      "file_size": 14016,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\developer\\developer_dashboard_screen.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/widgets/admin/admin_sidebar.dart';",
      "import 'package:franchise_admin_portal/widgets/admin/admin_bottom_nav_bar.dart';",
      "import 'package:franchise_admin_portal/core/models/dashboard_section.dart';",
      "import 'package:franchise_admin_portal/widgets/dialogs/franchise_selector_dialog_content.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_selector.dart';",
      "import 'package:franchise_admin_portal/widgets/developer/overview_section.dart';",
      "import 'package:franchise_admin_portal/widgets/developer/impersonation_tools_section.dart';",
      "import 'package:franchise_admin_portal/widgets/developer/error_logs_section.dart';",
      "import 'package:franchise_admin_portal/widgets/developer/feature_toggles_section.dart';",
      "import 'package:franchise_admin_portal/widgets/developer/plugin_registry_section.dart';",
      "import 'package:franchise_admin_portal/widgets/developer/schema_browser_section.dart';",
      "import 'package:franchise_admin_portal/widgets/developer/audit_trail_section.dart';",
      "import 'package:franchise_admin_portal/admin/hq_owner/owner_hq_dashboard_screen.dart';",
      "import 'package:franchise_admin_portal/widgets/dashboard/dashboard_switcher_dropdown.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/admin/devtools/billing/billing_subscription_tools_screen.dart';",
      "import 'package:franchise_admin_portal/admin/devtools/widgets/dev_tools_sidebar_group.dart';",
      "import 'package:franchise_admin_portal/admin/devtools/subscriptions/subscription_dev_tools_screen.dart';",
      "import 'package:franchise_admin_portal/admin/devtools/platform/platform_feature_plan_tools_screen.dart';",
      "import 'package:franchise_admin_portal/widgets/header/settings_icon_button.dart';",
      "import 'package:franchise_admin_portal/widgets/header/help_icon_button.dart';",
      "import 'package:franchise_admin_portal/widgets/header/notifications_icon_button.dart';",
      "import 'package:franchise_admin_portal/widgets/profile/user_avatar_menu.dart';",
      "import 'package:franchise_admin_portal/widgets/dashboard/franchise_picker_dropdown.dart';",
      "",
      "class DeveloperDashboardScreen extends StatefulWidget {",
      "  final String currentScreen;",
      "",
      "  const DeveloperDashboardScreen({",
      "    Key? key,",
      "    required this.currentScreen,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  State<DeveloperDashboardScreen> createState() =>",
      "      _DeveloperDashboardScreenState();",
      "}",
      "",
      "class _DeveloperDashboardScreenState extends State<DeveloperDashboardScreen> {",
      "  late final List<DashboardSection> _sections;",
      "  int _selectedIndex = 0;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _sections = _getDeveloperSections();",
      "  }",
      "",
      "  Future<void> _selectFranchiseDialog(BuildContext context) async {",
      "    final selectedId = await showDialog<String>(",
      "      context: context,",
      "      builder: (context) => Dialog(",
      "        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),",
      "        child: SizedBox(",
      "          width: 420,",
      "          child: FranchiseSelector(",
      "            onSelected: (franchiseId) {",
      "              Navigator.of(context).pop(franchiseId);",
      "            },",
      "          ),",
      "        ),",
      "      ),",
      "    );",
      "    if (selectedId != null && selectedId.isNotEmpty) {",
      "      await context.read<FranchiseProvider>().setFranchiseId(selectedId);",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final appUser = Provider.of<AdminUserProvider>(context).user;",
      "    if (appUser == null) {",
      "      print(",
      "          '[DEBUG] DeveloperDashboardScreen: appUser is null, showing spinner');",
      "      return Scaffold(",
      "        body: Center(child: CircularProgressIndicator()),",
      "      );",
      "    }",
      "    final firestoreService =",
      "        Provider.of<FirestoreService>(context, listen: false);",
      "    final franchiseId = context.watch<FranchiseProvider>().franchiseId;",
      "    final isMobile = MediaQuery.of(context).size.width < 800;",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "",
      "    final roles = appUser.roles;",
      "    if (!roles.contains('developer')) {",
      "      print('[DEBUG] Blocked. appUser=${appUser?.email}, roles=${roles}');",
      "      return Scaffold(",
      "        body: Center(",
      "          child: Text(",
      "            loc.unauthorizedAccess,",
      "            style: Theme.of(context).textTheme.titleLarge?.copyWith(",
      "                  color: colorScheme.error,",
      "                  fontWeight: FontWeight.bold,",
      "                ),",
      "          ),",
      "        ),",
      "      );",
      "    }",
      "",
      "    // --- Robust app bar franchise label ---",
      "    final showFranchise = franchiseId != 'all' &&",
      "        franchiseId != 'unknown' &&",
      "        franchiseId.isNotEmpty;",
      "    final appBarTitle = showFranchise",
      "        ? '${loc.developerDashboardTitle} — $franchiseId'",
      "        : loc.developerDashboardTitle;",
      "",
      "    return Scaffold(",
      "      backgroundColor: colorScheme.background,",
      "      appBar: AppBar(",
      "        title: Text(appBarTitle),",
      "        actions: [",
      "          FranchisePickerDropdown(),",
      "          const SizedBox(width: 8),",
      "          DashboardSwitcherDropdown(",
      "            currentScreen: '/developer/dashboard',",
      "            user: appUser,",
      "          ),",
      "          // IconButton(",
      "          //   icon: const Icon(Icons.sync_alt),",
      "          //   tooltip: loc.switchFranchise,",
      "          //   onPressed: () => _selectFranchiseDialog(context),",
      "          // ),",
      "          const SizedBox(width: 8),",
      "          NotificationsIconButton(),",
      "          const SizedBox(width: 8),",
      "          HelpIconButton(),",
      "          const SizedBox(width: 8),",
      "          SettingsIconButton(),",
      "          const SizedBox(width: 8),",
      "          UserAvatarMenu(),",
      "          const SizedBox(width: 8),",
      "        ],",
      "      ),",
      "      body: Row(",
      "        children: [",
      "          if (!isMobile)",
      "            Container(",
      "              width: 230,",
      "              color: colorScheme.surface.withOpacity(0.97),",
      "              child: SafeArea(",
      "                child: AdminSidebar(",
      "                  sections: _sections.where((s) => s.sidebarOrder < 7).toList(),",
      "                  selectedIndex: _selectedIndex,",
      "                  onSelect: (i) => setState(() => _selectedIndex = i),",
      "                  extraWidgets: [",
      "                    DevToolsSidebarGroup(",
      "                      label: 'Dev Tools',",
      "                      icon: Icons.build_outlined,",
      "                      tools:",
      "                          _sections.where((s) => s.sidebarOrder >= 7).toList(),",
      "                      selectedIndex: _selectedIndex,",
      "                      startIndexOffset: 0,",
      "                      onSelect: (i) => setState(() => _selectedIndex = i),",
      "                    ),",
      "                  ],",
      "                ),",
      "              ),",
      "            ),",
      "          Expanded(",
      "            child: Semantics(",
      "              label: 'Developer dashboard content area',",
      "              child: IndexedStack(",
      "                index: _selectedIndex,",
      "                children: [",
      "                  for (final section in _sections)",
      "                    Builder(",
      "                      builder: (context) {",
      "                        try {",
      "                          return section.builder(context);",
      "                        } catch (e, stack) {",
      "                          ErrorLogger.log(",
      "                            message: 'Developer dashboard section error: $e',",
      "                            source: 'DeveloperDashboardScreen',",
      "                            screen: section.title,",
      "                            stack: stack.toString(),",
      "                            severity: 'error',",
      "                            contextData: {",
      "                              'franchiseId': franchiseId,",
      "                              'sectionIndex': _selectedIndex,",
      "                              'sectionTitle': section.title,",
      "                              'errorType': e.runtimeType.toString(),",
      "                              if (appUser?.id != null) 'userId': appUser!.id,",
      "                            },",
      "                          );",
      "                          return Center(",
      "                            child: Text(",
      "                              'Section failed: $e',",
      "                              style: const TextStyle(",
      "                                  color: Colors.red, fontSize: 16),",
      "                            ),",
      "                          );",
      "                        }",
      "                      },",
      "                    )",
      "                ],",
      "              ),",
      "            ),",
      "          ),",
      "        ],",
      "      ),",
      "      bottomNavigationBar: isMobile",
      "          ? AdminBottomNavBar(",
      "              sections: _sections,",
      "              selectedIndex: _selectedIndex,",
      "              onTap: (i) => setState(() => _selectedIndex = i),",
      "            )",
      "          : null,",
      "    );",
      "  }",
      "",
      "  List<DashboardSection> _getDeveloperSections() {",
      "    String? getFranchiseOrNull(BuildContext context) {",
      "      final id = context.watch<FranchiseProvider>().franchiseId;",
      "      return (id == 'unknown' || id.isEmpty) ? null : id;",
      "    }",
      "",
      "    return [",
      "      DashboardSection(",
      "        key: 'overview',",
      "        title: 'Overview',",
      "        icon: Icons.dashboard_outlined,",
      "        builder: (context) =>",
      "            OverviewSection(franchiseId: getFranchiseOrNull(context)),",
      "        sidebarOrder: 0,",
      "      ),",
      "      DashboardSection(",
      "        key: 'impersonationTools',",
      "        title: 'Impersonation Tools',",
      "        icon: Icons.switch_account_outlined,",
      "        builder: (context) => ImpersonationToolsSection(",
      "          franchiseId: getFranchiseOrNull(context),",
      "        ),",
      "        sidebarOrder: 1,",
      "      ),",
      "      DashboardSection(",
      "        key: 'errorMonitoring',",
      "        title: 'Error Logs',",
      "        icon: Icons.bug_report_outlined,",
      "        builder: (context) => ErrorLogsSection(",
      "          franchiseId: getFranchiseOrNull(context),",
      "        ),",
      "        sidebarOrder: 2,",
      "      ),",
      "      DashboardSection(",
      "        key: 'featureFlags',",
      "        title: 'Feature Toggles',",
      "        icon: Icons.toggle_on_outlined,",
      "        builder: (context) => FeatureTogglesSection(",
      "          franchiseId: getFranchiseOrNull(context),",
      "        ),",
      "        sidebarOrder: 3,",
      "      ),",
      "      DashboardSection(",
      "        key: 'pluginRegistry',",
      "        title: 'Plugin Registry',",
      "        icon: Icons.extension_outlined,",
      "        builder: (context) => PluginRegistrySection(",
      "          franchiseId: getFranchiseOrNull(context),",
      "        ),",
      "        sidebarOrder: 4,",
      "      ),",
      "      DashboardSection(",
      "        key: 'firestoreSchema',",
      "        title: 'Schema Browser',",
      "        icon: Icons.schema_outlined,",
      "        builder: (context) => SchemaBrowserSection(",
      "          franchiseId: getFranchiseOrNull(context),",
      "        ),",
      "        sidebarOrder: 5,",
      "      ),",
      "      DashboardSection(",
      "        key: 'auditTrail',",
      "        title: 'Audit Trail',",
      "        icon: Icons.timeline_outlined,",
      "        builder: (context) => AuditTrailSection(",
      "          franchiseId: getFranchiseOrNull(context),",
      "        ),",
      "        sidebarOrder: 6,",
      "      ),",
      "      // --- DEV TOOLS GROUP ---",
      "      DashboardSection(",
      "        key: 'billingSubscriptionTools',",
      "        title: 'Billing Tools',",
      "        icon: Icons.receipt_long_outlined,",
      "        builder: (context) => const BillingSubscriptionToolsScreen(),",
      "        sidebarOrder: 7,",
      "      ),",
      "      DashboardSection(",
      "        key: 'subscriptionDevTools',",
      "        title: 'Subscription Tools',",
      "        icon: Icons.subscriptions_outlined,",
      "        builder: (context) => const SubscriptionDevToolsScreen(),",
      "        sidebarOrder: 8,",
      "      ),",
      "      DashboardSection(",
      "        key: 'platformFeaturePlanTools',",
      "        title: 'Platform Feature & Plan Tools',",
      "        icon: Icons.tune_outlined,",
      "        builder: (context) => const PlatformFeaturePlanToolsScreen(),",
      "        sidebarOrder: 9,",
      "      ),",
      "    ];",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 321,
      "file_size": 12463,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\developer\\developer_error_logs_screen.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/models/error_log.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "",
      "class DeveloperErrorLogsScreen extends StatefulWidget {",
      "  const DeveloperErrorLogsScreen({Key? key}) : super(key: key);",
      "",
      "  @override",
      "  State<DeveloperErrorLogsScreen> createState() =>",
      "      _DeveloperErrorLogsScreenState();",
      "}",
      "",
      "class _DeveloperErrorLogsScreenState extends State<DeveloperErrorLogsScreen> {",
      "  String? _franchiseId;",
      "  String? _severity;",
      "  String? _userEmail;",
      "  DateTimeRange? _dateRange;",
      "",
      "  void _pickDateRange() async {",
      "    final initial = _dateRange ??",
      "        DateTimeRange(",
      "          start: DateTime.now().subtract(const Duration(days: 7)),",
      "          end: DateTime.now(),",
      "        );",
      "    final picked = await showDateRangePicker(",
      "      context: context,",
      "      initialDateRange: initial,",
      "      firstDate: DateTime(2024),",
      "      lastDate: DateTime(2026),",
      "      builder: (context, child) {",
      "        return Center(",
      "          child: ConstrainedBox(",
      "            constraints: const BoxConstraints(",
      "              maxWidth: 400, // You can adjust this value as needed",
      "              maxHeight: 600, // This limits vertical expansion",
      "            ),",
      "            child: Material(",
      "              type: MaterialType.card,",
      "              elevation: 4,",
      "              borderRadius: BorderRadius.circular(12),",
      "              child: child!,",
      "            ),",
      "          ),",
      "        );",
      "      },",
      "    );",
      "    if (picked != null) setState(() => _dateRange = picked);",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context)!;",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "    final adminUser = Provider.of<AdminUserProvider>(context).user;",
      "",
      "    if (!(adminUser?.isDeveloper ?? false)) {",
      "      return Scaffold(",
      "        appBar: AppBar(title: Text(loc.developerErrorLogsScreenTitle)),",
      "        body: Center(",
      "          child: Text(",
      "            loc.unauthorizedAccess,",
      "            style: theme.textTheme.titleLarge?.copyWith(",
      "              color: colorScheme.error,",
      "              fontWeight: FontWeight.bold,",
      "            ),",
      "          ),",
      "        ),",
      "      );",
      "    }",
      "",
      "    return Scaffold(",
      "      appBar: AppBar(title: Text(loc.developerErrorLogsScreenTitle)),",
      "      body: Padding(",
      "        padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 14),",
      "        child: Consumer<FranchiseProvider>(",
      "          builder: (context, franchiseProvider, _) {",
      "            final options = franchiseProvider.viewableFranchises;",
      "            final selectedFranchiseId =",
      "                (_franchiseId == null || _franchiseId == 'all')",
      "                    ? null",
      "                    : _franchiseId;",
      "",
      "            return StreamBuilder<List<ErrorLog>>(",
      "              stream: FirestoreService().streamErrorLogsGlobal(",
      "                franchiseId: selectedFranchiseId,",
      "                severity: _severity,",
      "                userId: null,",
      "                start: _dateRange?.start,",
      "                end: _dateRange?.end,",
      "                limit: 250,",
      "              ),",
      "              builder: (context, snapshot) {",
      "                if (snapshot.hasError) {",
      "                  debugPrint(",
      "                      '❌ Firestore error in streamErrorLogsGlobal: ${snapshot.error}');",
      "                  return Center(child: Text('Failed to load logs.'));",
      "                }",
      "                if (!snapshot.hasData) {",
      "                  return Center(child: CircularProgressIndicator());",
      "                }",
      "",
      "                final logs = snapshot.data ?? [];",
      "",
      "                final filtered = logs.where((log) {",
      "                  final userEmail = log.contextData?['userEmail'] ??",
      "                      log.contextData?['email'];",
      "                  return _userEmail == null || _userEmail == userEmail;",
      "                }).toList();",
      "",
      "                final allFranchiseIds = {",
      "                  for (final e in logs)",
      "                    if ((e.contextData?['franchiseId'] ?? '')",
      "                        .toString()",
      "                        .isNotEmpty)",
      "                      e.contextData!['franchiseId']",
      "                }.cast<String>();",
      "",
      "                final allFranchises = ['all', ...allFranchiseIds.toSet()]",
      "                  ..sort();",
      "                final severities = logs.map((e) => e.severity).toSet().toList()",
      "                  ..sort();",
      "                final userEmails = logs",
      "                    .map((e) => e.contextData?['userEmail'])",
      "                    .whereType<String>()",
      "                    .toSet()",
      "                    .toList()",
      "                  ..sort();",
      "",
      "                return Column(",
      "                  crossAxisAlignment: CrossAxisAlignment.start,",
      "                  children: [",
      "                    _buildFilterRow(loc, options, severities, userEmails, theme,",
      "                        colorScheme),",
      "                    const SizedBox(height: 10),",
      "                    if (snapshot.connectionState == ConnectionState.waiting)",
      "                      Center(",
      "                          child: CircularProgressIndicator(",
      "                              color: colorScheme.primary))",
      "                    else if (filtered.isEmpty)",
      "                      Center(child: Text(loc.developerErrorLogsScreenEmpty))",
      "                    else",
      "                      Expanded(",
      "                        child: _DevErrorLogList(",
      "                          logs: filtered,",
      "                          colorScheme: colorScheme,",
      "                          loc: loc,",
      "                          theme: theme,",
      "                          franchises: {",
      "                            for (var f in options) f.id: f.name ?? f.id",
      "                          },",
      "                        ),",
      "                      ),",
      "                    const SizedBox(height: 18),",
      "                    _ComingSoonCard(",
      "                      icon: Icons.analytics_outlined,",
      "                      title: loc.developerErrorLogsScreenTrendsComingSoon,",
      "                      subtitle: loc.developerErrorLogsScreenTrendsDesc,",
      "                      colorScheme: colorScheme,",
      "                      theme: theme,",
      "                    ),",
      "                    _ComingSoonCard(",
      "                      icon: Icons.lightbulb_outline,",
      "                      title: loc.developerErrorLogsScreenAIInsightsComingSoon,",
      "                      subtitle: loc.developerErrorLogsScreenAIInsightsDesc,",
      "                      colorScheme: colorScheme,",
      "                      theme: theme,",
      "                    ),",
      "                  ],",
      "                );",
      "              },",
      "            );",
      "          },",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  Widget _buildFilterRow(",
      "    AppLocalizations loc,",
      "    List franchises,",
      "    List<String> severities,",
      "    List<String> users,",
      "    ThemeData theme,",
      "    ColorScheme colorScheme,",
      "  ) {",
      "    return Card(",
      "      margin: EdgeInsets.zero,",
      "      color: colorScheme.surfaceVariant,",
      "      child: Padding(",
      "        padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 10),",
      "        child: Wrap(",
      "          spacing: 16,",
      "          runSpacing: 10,",
      "          crossAxisAlignment: WrapCrossAlignment.center,",
      "          children: [",
      "            Row(",
      "              mainAxisSize: MainAxisSize.min,",
      "              children: [",
      "                Text('${loc.developerErrorLogsScreenFranchise}: ',",
      "                    style: theme.textTheme.titleMedium),",
      "                DropdownButton<String>(",
      "                  value: _franchiseId ?? 'all',",
      "                  hint: Text(loc.allFranchisesLabel),",
      "                  items: [",
      "                    DropdownMenuItem(",
      "                        value: 'all', child: Text(loc.allFranchisesLabel)),",
      "                    ...franchises.map((f) => DropdownMenuItem(",
      "                          value: f.id,",
      "                          child: Text(f.name ?? f.id),",
      "                        )),",
      "                  ],",
      "                  onChanged: (val) => setState(() => _franchiseId = val),",
      "                ),",
      "              ],",
      "            ),",
      "            _buildDropdown(",
      "              label: loc.developerErrorLogsScreenSeverity,",
      "              value: _severity,",
      "              options: severities,",
      "              onChanged: (val) => setState(() => _severity = val),",
      "              hint: loc.developerErrorLogsScreenFilterAny,",
      "              theme: theme,",
      "            ),",
      "            _buildDropdown(",
      "              label: loc.developerErrorLogsScreenUser,",
      "              value: _userEmail,",
      "              options: users,",
      "              onChanged: (val) => setState(() => _userEmail = val),",
      "              hint: loc.developerErrorLogsScreenFilterAny,",
      "              theme: theme,",
      "            ),",
      "            Row(",
      "              mainAxisSize: MainAxisSize.min,",
      "              children: [",
      "                Text('${loc.developerErrorLogsScreenDateRange}: ',",
      "                    style: theme.textTheme.titleMedium),",
      "                OutlinedButton.icon(",
      "                  icon: const Icon(Icons.date_range),",
      "                  label: Text(_dateRange == null",
      "                      ? loc.developerErrorLogsScreenAllDates",
      "                      : '${_dateRange!.start.year}-${_dateRange!.start.month.toString().padLeft(2, '0')}-${_dateRange!.start.day.toString().padLeft(2, '0')} — ${_dateRange!.end.year}-${_dateRange!.end.month.toString().padLeft(2, '0')}-${_dateRange!.end.day.toString().padLeft(2, '0')}'),",
      "                  onPressed: _pickDateRange,",
      "                ),",
      "              ],",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  Widget _buildDropdown({",
      "    required String label,",
      "    required String? value,",
      "    required List<String> options,",
      "    required void Function(String?) onChanged,",
      "    required String hint,",
      "    required ThemeData theme,",
      "  }) {",
      "    final safeValue = value != null && options.contains(value) ? value : null;",
      "",
      "    return Row(",
      "      mainAxisSize: MainAxisSize.min,",
      "      children: [",
      "        Text('$label: ', style: theme.textTheme.titleMedium),",
      "        DropdownButton<String>(",
      "          value: safeValue,",
      "          hint: Text(hint),",
      "          items: [",
      "            DropdownMenuItem(value: null, child: Text(hint)),",
      "            ...options.map((e) => DropdownMenuItem(value: e, child: Text(e))),",
      "          ],",
      "          onChanged: onChanged,",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}",
      "",
      "class _DevErrorLogList extends StatelessWidget {",
      "  final List<ErrorLog> logs;",
      "  final ColorScheme colorScheme;",
      "  final AppLocalizations loc;",
      "  final ThemeData theme;",
      "  final Map<String, String> franchises;",
      "",
      "  const _DevErrorLogList({",
      "    required this.logs,",
      "    required this.colorScheme,",
      "    required this.loc,",
      "    required this.theme,",
      "    required this.franchises,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return ListView.separated(",
      "      itemCount: logs.length,",
      "      separatorBuilder: (_, __) => const Divider(height: 1),",
      "      itemBuilder: (context, idx) {",
      "        final log = logs[idx];",
      "        final email = log.contextData?['userEmail'] ?? '—';",
      "        final device = log.deviceInfo?['deviceModel'] ??",
      "            log.contextData?['device'] ??",
      "            'unknown';",
      "        final franchiseId = log.contextData?['franchiseId'];",
      "        final franchiseLabel = franchises[franchiseId] ?? franchiseId ?? '—';",
      "        final ts = log.timestamp;",
      "",
      "        return ExpansionTile(",
      "          tilePadding: const EdgeInsets.symmetric(horizontal: 10),",
      "          leading: Icon(",
      "            log.severity == 'fatal'",
      "                ? Icons.dangerous",
      "                : log.severity == 'warning'",
      "                    ? Icons.warning",
      "                    : Icons.error,",
      "            color: log.severity == 'fatal'",
      "                ? Colors.deepPurple",
      "                : log.severity == 'warning'",
      "                    ? Colors.orange",
      "                    : Colors.red,",
      "          ),",
      "          title: Text(log.message),",
      "          subtitle: Text(",
      "            '${loc.developerErrorLogsScreenAt}: ${log.screen}\\n${ts != null ? _formatDateTime(ts) : '—'}',",
      "            style: const TextStyle(fontSize: 13),",
      "          ),",
      "          trailing: Icon(Icons.expand_more, color: colorScheme.outline),",
      "          children: [",
      "            ListTile(",
      "              dense: true,",
      "              leading: Icon(Icons.store, color: colorScheme.outline),",
      "              title: Text(",
      "                  '${loc.developerErrorLogsScreenFranchise}: $franchiseLabel'),",
      "              subtitle: Text('${loc.developerErrorLogsScreenUser}: $email'),",
      "            ),",
      "            ListTile(",
      "              dense: true,",
      "              leading: Icon(Icons.devices, color: colorScheme.outline),",
      "              title: Text('${loc.developerErrorLogsScreenDevice}: $device'),",
      "            ),",
      "            if (log.stackTrace != null && log.stackTrace!.isNotEmpty)",
      "              ListTile(",
      "                dense: true,",
      "                leading: Icon(Icons.bug_report, color: colorScheme.outline),",
      "                title: Text(loc.developerErrorLogsScreenStackTrace),",
      "                subtitle: SingleChildScrollView(",
      "                  scrollDirection: Axis.horizontal,",
      "                  child: Text(",
      "                    log.stackTrace!,",
      "                    style:",
      "                        const TextStyle(fontFamily: 'monospace', fontSize: 12),",
      "                  ),",
      "                ),",
      "              ),",
      "          ],",
      "        );",
      "      },",
      "    );",
      "  }",
      "",
      "  String _formatDateTime(DateTime dt) {",
      "    return '${dt.year}-${dt.month.toString().padLeft(2, '0')}-${dt.day.toString().padLeft(2, '0')} '",
      "        '${dt.hour.toString().padLeft(2, '0')}:${dt.minute.toString().padLeft(2, '0')}';",
      "  }",
      "}",
      "",
      "class _ComingSoonCard extends StatelessWidget {",
      "  final IconData icon;",
      "  final String title;",
      "  final String subtitle;",
      "  final ColorScheme colorScheme;",
      "  final ThemeData theme;",
      "",
      "  const _ComingSoonCard({",
      "    required this.icon,",
      "    required this.title,",
      "    required this.subtitle,",
      "    required this.colorScheme,",
      "    required this.theme,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Card(",
      "      color: colorScheme.surfaceVariant.withOpacity(0.87),",
      "      elevation: DesignTokens.adminCardElevation,",
      "      shape: RoundedRectangleBorder(",
      "        borderRadius: BorderRadius.circular(DesignTokens.adminCardRadius),",
      "      ),",
      "      child: Padding(",
      "        padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 20),",
      "        child: Row(",
      "          children: [",
      "            Icon(icon, color: colorScheme.outline, size: 30),",
      "            const SizedBox(width: 18),",
      "            Expanded(",
      "              child: Column(",
      "                crossAxisAlignment: CrossAxisAlignment.start,",
      "                children: [",
      "                  Text(",
      "                    title,",
      "                    style: theme.textTheme.titleMedium?.copyWith(",
      "                      color: colorScheme.outline,",
      "                      fontWeight: FontWeight.bold,",
      "                    ),",
      "                  ),",
      "                  const SizedBox(height: 4),",
      "                  Text(",
      "                    subtitle,",
      "                    style: theme.textTheme.bodyMedium,",
      "                  ),",
      "                ],",
      "              ),",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 428,
      "file_size": 15683,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\developer\\platform\\franchise_subscriptions_section.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "import 'package:franchise_admin_portal/core/models/dashboard_section.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/config/app_config.dart';",
      "import 'package:franchise_admin_portal/core/models/franchise_subscription_model.dart';",
      "import 'package:franchise_admin_portal/admin/developer/platform/franchise_subscription_editor_dialog.dart';",
      "import 'package:franchise_admin_portal/admin/categories/bulk_action_bar.dart';",
      "import 'package:franchise_admin_portal/core/services/franchise_subscription_service.dart';",
      "",
      "final DashboardSection franchiseSubscriptionsSection = DashboardSection(",
      "  key: 'franchiseSubscriptions',",
      "  title: 'Franchise Subscriptions',",
      "  icon: Icons.subscriptions,",
      "  builder: (_) => const FranchiseSubscriptionsSection(),",
      "  sidebarOrder: 100,",
      ");",
      "",
      "class FranchiseSubscriptionsSection extends StatefulWidget {",
      "  const FranchiseSubscriptionsSection({super.key});",
      "",
      "  @override",
      "  State<FranchiseSubscriptionsSection> createState() =>",
      "      _FranchiseSubscriptionsSectionState();",
      "}",
      "",
      "class _FranchiseSubscriptionsSectionState",
      "    extends State<FranchiseSubscriptionsSection> {",
      "  late Future<List<FranchiseSubscription>> _subsFuture;",
      "  final Set<String> _selectedIds = {};",
      "  bool _isBulkMode = false;",
      "  List<FranchiseSubscription> _subs = [];",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _subsFuture = _loadSubscriptions();",
      "  }",
      "",
      "  Future<List<FranchiseSubscription>> _loadSubscriptions() async {",
      "    try {",
      "      final result = await FirestoreService.getFranchiseSubscriptions();",
      "      _subs = result;",
      "      return result;",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'load_franchise_subscriptions_failed',",
      "        stack: stack.toString(),",
      "        source: 'FranchiseSubscriptionsSection',",
      "        screen: 'franchise_subscriptions_section',",
      "        severity: 'error',",
      "        contextData: {'exception': e.toString()},",
      "      );",
      "      return [];",
      "    }",
      "  }",
      "",
      "  void _confirmDelete(String subId, AppLocalizations loc) async {",
      "    final confirmed = await showDialog<bool>(",
      "      context: context,",
      "      builder: (context) => AlertDialog(",
      "        title: Text(loc.confirmDeleteTitle),",
      "        content: Text(loc.confirmDeleteDescription),",
      "        actions: [",
      "          TextButton(",
      "              onPressed: () => Navigator.pop(context, false),",
      "              child: Text(loc.cancel)),",
      "          ElevatedButton(",
      "            onPressed: () => Navigator.pop(context, true),",
      "            style: ElevatedButton.styleFrom(backgroundColor: Colors.red),",
      "            child: Text(loc.delete),",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "",
      "    if (confirmed == true) {",
      "      try {",
      "        await FranchiseSubscriptionService().deleteFranchiseSubscription(subId);",
      "        setState(() => _subsFuture = _loadSubscriptions());",
      "      } catch (e, st) {",
      "        await ErrorLogger.log(",
      "          message: 'Failed to delete subscription: $e',",
      "          stack: st.toString(),",
      "          source: 'FranchiseSubscriptionsSection',",
      "          screen: 'franchise_subscriptions_section',",
      "          severity: 'error',",
      "        );",
      "        ScaffoldMessenger.of(context)",
      "            .showSnackBar(SnackBar(content: Text(loc.deleteFailed)));",
      "      }",
      "    }",
      "  }",
      "",
      "  void _handleBulkDelete() async {",
      "    final loc = AppLocalizations.of(context)!;",
      "    final idsToDelete = _selectedIds.toList();",
      "    final subsToRestore = [..._subs.where((s) => idsToDelete.contains(s.id))];",
      "",
      "    try {",
      "      await FranchiseSubscriptionService()",
      "          .deleteManyFranchiseSubscriptions(idsToDelete);",
      "",
      "      setState(() {",
      "        _subsFuture = _loadSubscriptions();",
      "        _selectedIds.clear();",
      "        _isBulkMode = false;",
      "      });",
      "",
      "      ScaffoldMessenger.of(context).showSnackBar(SnackBar(",
      "        content: Text(loc.bulkDeleteSuccess(idsToDelete.length.toString())),",
      "        action: SnackBarAction(",
      "          label: loc.undo,",
      "          onPressed: () async {",
      "            for (final sub in subsToRestore) {",
      "              await FranchiseSubscriptionService()",
      "                  .saveFranchiseSubscription(sub);",
      "            }",
      "            setState(() => _subsFuture = _loadSubscriptions());",
      "          },",
      "        ),",
      "      ));",
      "    } catch (_) {",
      "      ScaffoldMessenger.of(context)",
      "          .showSnackBar(SnackBar(content: Text(loc.deleteFailed)));",
      "    }",
      "  }",
      "",
      "  void _openEditorDialog(FranchiseSubscription sub) async {",
      "    final result = await showDialog<bool>(",
      "      context: context,",
      "      builder: (context) => FranchiseSubscriptionEditorDialog(",
      "        franchiseId: sub.franchiseId,",
      "        subscription: sub,",
      "      ),",
      "    );",
      "    if (result == true) {",
      "      setState(() => _subsFuture = _loadSubscriptions());",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final user = context.watch<AdminUserProvider>().user;",
      "    final loc = AppLocalizations.of(context)!;",
      "    final theme = Theme.of(context);",
      "",
      "    if (!(user?.isDeveloper == true ||",
      "        user?.isAdmin == false ||",
      "        user?.isPlatformOwner == true)) {",
      "      return const SizedBox.shrink();",
      "    }",
      "",
      "    return FutureBuilder<List<FranchiseSubscription>>(",
      "      future: _subsFuture,",
      "      builder: (context, snapshot) {",
      "        if (snapshot.connectionState != ConnectionState.done) {",
      "          return const Center(child: CircularProgressIndicator());",
      "        }",
      "",
      "        final subs = snapshot.data ?? [];",
      "",
      "        if (subs.isEmpty) {",
      "          return Padding(",
      "            padding: const EdgeInsets.all(16.0),",
      "            child: Text(loc.noSubscriptionsFound),",
      "          );",
      "        }",
      "",
      "        _subs = subs;",
      "",
      "        return Column(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            _isBulkMode",
      "                ? BulkActionBar(",
      "                    selectedCount: _selectedIds.length,",
      "                    onBulkDelete: _handleBulkDelete,",
      "                    onClearSelection: () {",
      "                      setState(() {",
      "                        _selectedIds.clear();",
      "                        _isBulkMode = false;",
      "                      });",
      "                    },",
      "                  )",
      "                : Align(",
      "                    alignment: Alignment.centerRight,",
      "                    child: (user?.isDeveloper == true ||",
      "                            user?.isAdmin == false ||",
      "                            user?.isPlatformOwner == true)",
      "                        ? ElevatedButton.icon(",
      "                            icon: const Icon(Icons.select_all),",
      "                            label: Text(loc.enableBulkSelect),",
      "                            onPressed: () => setState(() => _isBulkMode = true),",
      "                          )",
      "                        : const SizedBox.shrink(),",
      "                  ),",
      "            const SizedBox(height: 12),",
      "            ...subs.map((sub) => _buildSubscriptionCard(sub, loc, theme)),",
      "          ],",
      "        );",
      "      },",
      "    );",
      "  }",
      "",
      "  Widget _buildSubscriptionCard(",
      "    FranchiseSubscription sub,",
      "    AppLocalizations loc,",
      "    ThemeData theme,",
      "  ) {",
      "    final selected = _selectedIds.contains(sub.id);",
      "",
      "    return CheckboxListTile(",
      "      value: selected,",
      "      onChanged: _isBulkMode",
      "          ? (checked) {",
      "              setState(() {",
      "                if (checked == true) {",
      "                  _selectedIds.add(sub.id);",
      "                } else {",
      "                  _selectedIds.remove(sub.id);",
      "                }",
      "              });",
      "            }",
      "          : null,",
      "      title: Card(",
      "        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),",
      "        color: theme.colorScheme.surface,",
      "        child: Padding(",
      "          padding: const EdgeInsets.all(16),",
      "          child:",
      "              Column(crossAxisAlignment: CrossAxisAlignment.start, children: [",
      "            Row(",
      "              children: [",
      "                Text('${loc.franchiseIdLabel}: ${sub.franchiseId}',",
      "                    style: theme.textTheme.titleSmall),",
      "                const Spacer(),",
      "                if (!_isBulkMode &&",
      "                    (context",
      "                                .read<AdminUserProvider>()",
      "                                .user",
      "                                ?.isDeveloper ==",
      "                            true ||",
      "                        context.read<AdminUserProvider>().user?.isAdmin ==",
      "                            false ||",
      "                        context",
      "                                .read<AdminUserProvider>()",
      "                                .user",
      "                                ?.isPlatformOwner ==",
      "                            true)) ...[",
      "                  IconButton(",
      "                    icon: const Icon(Icons.edit, size: 20),",
      "                    tooltip: loc.editSubscription,",
      "                    onPressed: () => _openEditorDialog(sub),",
      "                  ),",
      "                  IconButton(",
      "                    icon: const Icon(Icons.delete_outline, size: 20),",
      "                    tooltip: loc.deleteSubscription,",
      "                    onPressed: () => _confirmDelete(sub.id, loc),",
      "                  ),",
      "                ],",
      "                Chip(",
      "                  label: Text(loc.translateStatus(sub.status)),",
      "                  backgroundColor: AppConfig.statusColor(sub.status, theme),",
      "                ),",
      "              ],",
      "            ),",
      "            const SizedBox(height: 8),",
      "            Text('${loc.planIdLabel}: ${sub.platformPlanId}'),",
      "            const SizedBox(height: 4),",
      "            if (sub.isTrial)",
      "              Text(",
      "                  '${loc.trialEndsLabel}: ${AppConfig.formatDate(sub.trialEndsAt)}',",
      "                  style: theme.textTheme.labelMedium?.copyWith(",
      "                    color: theme.colorScheme.secondary,",
      "                  )),",
      "            const SizedBox(height: 8),",
      "            Text(",
      "                '${loc.nextBillingLabel}: ${AppConfig.formatDate(sub.nextBillingDate)}'),",
      "            const SizedBox(height: 4),",
      "            if (sub.discountPercent > 0)",
      "              Text('${loc.discountLabel}: ${sub.discountPercent}%',",
      "                  style: theme.textTheme.labelSmall),",
      "            const SizedBox(height: 12),",
      "            Text(",
      "              loc.featureComingSoon('Subscription settings'),",
      "              style: theme.textTheme.labelSmall?.copyWith(",
      "                color: theme.colorScheme.outline,",
      "              ),",
      "            )",
      "          ]),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 301,
      "file_size": 10897,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\developer\\platform\\franchise_subscription_editor_dialog.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/config/app_config.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/core/models/dashboard_section.dart';",
      "import 'package:franchise_admin_portal/core/models/platform_plan_model.dart';",
      "import 'package:franchise_admin_portal/core/models/franchise_subscription_model.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/role_guard.dart';",
      "import 'package:franchise_admin_portal/core/services/franchise_subscription_service.dart';",
      "",
      "class FranchiseSubscriptionEditorDialog extends StatefulWidget {",
      "  final FranchiseSubscription? subscription; // null if creating new",
      "  final String franchiseId;",
      "",
      "  const FranchiseSubscriptionEditorDialog({",
      "    super.key,",
      "    required this.franchiseId,",
      "    this.subscription,",
      "  });",
      "",
      "  @override",
      "  State<FranchiseSubscriptionEditorDialog> createState() =>",
      "      _FranchiseSubscriptionEditorDialogState();",
      "}",
      "",
      "class _FranchiseSubscriptionEditorDialogState",
      "    extends State<FranchiseSubscriptionEditorDialog> {",
      "  late DateTime _startDate;",
      "  late DateTime _nextBillingDate;",
      "  bool _isTrial = false;",
      "  DateTime? _trialEndsAt;",
      "  int _discountPercent = 0;",
      "  String? _customQuoteDetails;",
      "  bool _isLoading = false;",
      "  final _formKey = GlobalKey<FormState>();",
      "  String? _selectedPlanId;",
      "  String _status = 'active';",
      "  bool _cancelAtPeriodEnd = false;",
      "  List<PlatformPlan> _plans = [];",
      "  String? _paymentTokenId;",
      "  String? _cardLast4;",
      "  String? _cardBrand;",
      "  String? _billingEmail;",
      "  String? _paymentStatus;",
      "  String? _receiptUrl;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    final sub = widget.subscription;",
      "",
      "    _startDate = sub?.startDate ?? DateTime.now();",
      "    _nextBillingDate =",
      "        sub?.nextBillingDate ?? _startDate.add(const Duration(days: 30));",
      "    _isTrial = sub?.isTrial ?? false;",
      "    _trialEndsAt = sub?.trialEndsAt;",
      "    _discountPercent = sub?.discountPercent ?? 0;",
      "    _customQuoteDetails = sub?.customQuoteDetails;",
      "",
      "    _selectedPlanId = sub?.platformPlanId;",
      "    final validStatuses = ['active', 'paused', 'trialing', 'canceled'];",
      "    _status = validStatuses.contains(sub?.status) ? sub!.status! : 'active';",
      "    _cancelAtPeriodEnd = sub?.cancelAtPeriodEnd ?? false;",
      "    _paymentTokenId = sub?.paymentTokenId;",
      "    _cardLast4 = sub?.cardLast4;",
      "    _cardBrand = sub?.cardBrand;",
      "    _billingEmail = sub?.billingEmail;",
      "    _paymentStatus = sub?.paymentStatus;",
      "    _receiptUrl = sub?.receiptUrl;",
      "    _loadPlans();",
      "  }",
      "",
      "  Future<void> _loadPlans() async {",
      "    try {",
      "      final plans = await FranchiseSubscriptionService().getPlatformPlans();",
      "      String? validSelectedId = _selectedPlanId;",
      "",
      "      final planIds = plans.map((p) => p.id).toSet();",
      "      if (validSelectedId != null && !planIds.contains(validSelectedId)) {",
      "        validSelectedId = null; // Avoid assigning a non-existent plan",
      "      }",
      "",
      "      debugPrint('[DEBUG] Loaded ${plans.length} plans from Firestore');",
      "      for (final p in plans) {",
      "        debugPrint('[DEBUG] Plan ID: ${p.id}, name: ${p.name}');",
      "      }",
      "      debugPrint('[DEBUG] Current selected planId = $_selectedPlanId');",
      "",
      "      setState(() {",
      "        _plans = plans;",
      "",
      "        // Ensure _selectedPlanId is only set if it's a valid option",
      "        final matchingPlan = plans.where((p) => p.id == _selectedPlanId);",
      "        if (_selectedPlanId == null || matchingPlan.isEmpty) {",
      "          _selectedPlanId = null;",
      "        }",
      "      });",
      "    } catch (e, st) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to load platform plans: $e',",
      "        stack: st.toString(),",
      "        source: 'FranchiseSubscriptionEditorDialog',",
      "        screen: 'franchise_subscription_editor',",
      "        severity: 'error',",
      "      );",
      "    }",
      "  }",
      "",
      "  Future<void> _submit() async {",
      "    if (!_formKey.currentState!.validate()) return;",
      "    setState(() => _isLoading = true);",
      "    final loc = AppLocalizations.of(context)!;",
      "    final fs = FranchiseSubscriptionService();",
      "",
      "    try {",
      "      final selectedPlan = _plans.firstWhere((p) => p.id == _selectedPlanId);",
      "      final billingCycleInDays =",
      "          selectedPlan.billingInterval == 'yearly' ? 365 : 30;",
      "      final newSub = FranchiseSubscription(",
      "        id: widget.subscription?.id ?? '',",
      "        franchiseId: widget.franchiseId,",
      "        platformPlanId: _selectedPlanId!,",
      "        status: _status,",
      "        startDate: _startDate,",
      "        nextBillingDate: _startDate.add(Duration(days: billingCycleInDays)),",
      "        billingCycleInDays: billingCycleInDays,",
      "        isTrial: _isTrial,",
      "        trialEndsAt: _isTrial ? _trialEndsAt : null,",
      "        discountPercent: _discountPercent,",
      "        customQuoteDetails: _customQuoteDetails,",
      "        lastInvoiceId: widget.subscription?.lastInvoiceId,",
      "        createdAt: widget.subscription?.createdAt,",
      "        updatedAt: DateTime.now(),",
      "        priceAtSubscription: widget.subscription?.priceAtSubscription ?? 0.0,",
      "        subscribedAt: widget.subscription?.subscribedAt ?? DateTime.now(),",
      "        cancelAtPeriodEnd: _cancelAtPeriodEnd,",
      "        paymentTokenId: _paymentTokenId,",
      "        cardLast4: _cardLast4,",
      "        cardBrand: _cardBrand,",
      "        billingEmail: _billingEmail,",
      "        paymentStatus: _paymentStatus,",
      "        receiptUrl: _receiptUrl,",
      "      );",
      "",
      "      await fs.saveFranchiseSubscription(newSub);",
      "      Navigator.of(context).pop(true); // Signal success",
      "    } catch (e, st) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to save franchise subscription: $e',",
      "        stack: st.toString(),",
      "        source: 'FranchiseSubscriptionEditorDialog',",
      "        screen: 'franchise_subscription_editor',",
      "        severity: 'error',",
      "      );",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(content: Text(loc.saveFailed)),",
      "      );",
      "    } finally {",
      "      setState(() => _isLoading = false);",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context)!;",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "",
      "    final validStatuses = ['active', 'paused', 'trialing', 'canceled'];",
      "    final statusItems = validStatuses",
      "        .map((s) => DropdownMenuItem(",
      "              value: s,",
      "              child: Text(loc.translateStatus(s)),",
      "            ))",
      "        .toList();",
      "",
      "    if (!validStatuses.contains(_status)) {",
      "      statusItems.insert(",
      "        0,",
      "        DropdownMenuItem(",
      "          value: _status,",
      "          enabled: false,",
      "          child: Text('[Invalid status] $_status'),",
      "        ),",
      "      );",
      "    }",
      "",
      "    return AlertDialog(",
      "      title: Text(widget.subscription == null",
      "          ? loc.addSubscription",
      "          : loc.editSubscription),",
      "      content: _isLoading",
      "          ? const SizedBox(",
      "              height: 120,",
      "              child: Center(child: CircularProgressIndicator()),",
      "            )",
      "          : Form(",
      "              key: _formKey,",
      "              child: Column(",
      "                mainAxisSize: MainAxisSize.min,",
      "                children: [",
      "                  DropdownButtonFormField<String>(",
      "                    decoration: InputDecoration(",
      "                      labelText: loc.plan,",
      "                      border: const OutlineInputBorder(),",
      "                    ),",
      "                    value: _selectedPlanId,",
      "                    isExpanded: true,",
      "                    items: _plans",
      "                        .map((p) => DropdownMenuItem<String>(",
      "                              value: p.id,",
      "                              child: Text(p.name),",
      "                            ))",
      "                        .toList(),",
      "                    onChanged: (value) {",
      "                      setState(() => _selectedPlanId = value);",
      "                    },",
      "                    validator: (value) =>",
      "                        (value == null || !_plans.any((p) => p.id == value))",
      "                            ? loc.pleaseSelectAPlan",
      "                            : null,",
      "                  ),",
      "                  const SizedBox(height: 16),",
      "                  DropdownButtonFormField<String>(",
      "                    decoration: InputDecoration(",
      "                      labelText: loc.status,",
      "                      border: const OutlineInputBorder(),",
      "                    ),",
      "                    value: _status,",
      "                    isExpanded: true,",
      "                    items: statusItems,",
      "                    onChanged: (value) {",
      "                      if (value != null && validStatuses.contains(value)) {",
      "                        setState(() => _status = value);",
      "                      }",
      "                    },",
      "                    validator: (value) =>",
      "                        value == null || !validStatuses.contains(value)",
      "                            ? loc.pleaseSelectAPlan",
      "                            : null,",
      "                  ),",
      "                  Tooltip(",
      "                    message: (_status == 'paused' || _status == 'canceled')",
      "                        ? loc.toggleLockedDueToStatus",
      "                        : '',",
      "                    child: SwitchListTile(",
      "                      title: Text(loc.cancelAtPeriodEndToggle),",
      "                      subtitle: Text(loc.cancelAtPeriodEndDescription),",
      "                      value: _cancelAtPeriodEnd,",
      "                      onChanged: (_status == 'paused' || _status == 'canceled')",
      "                          ? null",
      "                          : (val) {",
      "                              setState(() {",
      "                                _cancelAtPeriodEnd = val;",
      "                              });",
      "                            },",
      "                      contentPadding: const EdgeInsets.only(top: 8, bottom: 8),",
      "                      secondary: (_status == 'paused' || _status == 'canceled')",
      "                          ? const Icon(Icons.lock_outline)",
      "                          : null,",
      "                    ),",
      "                  ),",
      "                  const SizedBox(height: 16),",
      "                  RoleGuard(",
      "                    allowedRoles: ['platform_owner', 'developer'],",
      "                    child: Column(",
      "                      children: [",
      "                        const SizedBox(height: 16),",
      "                        TextFormField(",
      "                          initialValue: _billingEmail,",
      "                          decoration: InputDecoration(",
      "                            labelText: loc.billingEmail,",
      "                            border: const OutlineInputBorder(),",
      "                          ),",
      "                          onChanged: (val) => _billingEmail = val.trim(),",
      "                        ),",
      "                        const SizedBox(height: 16),",
      "                        TextFormField(",
      "                          initialValue: _paymentTokenId,",
      "                          decoration: const InputDecoration(",
      "                            labelText: 'Payment Token (for debug)',",
      "                            border: OutlineInputBorder(),",
      "                          ),",
      "                          onChanged: (val) => _paymentTokenId = val.trim(),",
      "                        ),",
      "                        const SizedBox(height: 16),",
      "                        TextFormField(",
      "                          initialValue: _cardLast4,",
      "                          decoration: const InputDecoration(",
      "                            labelText: 'Card Last 4',",
      "                            border: OutlineInputBorder(),",
      "                          ),",
      "                          readOnly: true,",
      "                        ),",
      "                        const SizedBox(height: 16),",
      "                        TextFormField(",
      "                          initialValue: _cardBrand,",
      "                          decoration: const InputDecoration(",
      "                            labelText: 'Card Brand',",
      "                            border: OutlineInputBorder(),",
      "                          ),",
      "                          readOnly: true,",
      "                        ),",
      "                      ],",
      "                    ),",
      "                  ),",
      "                ],",
      "              ),",
      "            ),",
      "      actions: [",
      "        TextButton(",
      "          onPressed: () => Navigator.of(context).pop(false),",
      "          child: Text(loc.cancel),",
      "        ),",
      "        ElevatedButton(",
      "          onPressed: _isLoading ? null : _submit,",
      "          child: Text(loc.save),",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 324,
      "file_size": 12602,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\developer\\platform\\platform_plans_section.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/config/app_config.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/core/models/dashboard_section.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/models/platform_plan_model.dart';",
      "import 'package:franchise_admin_portal/core/services/franchise_subscription_service.dart';",
      "",
      "class PlatformPlansSection extends StatefulWidget {",
      "  const PlatformPlansSection({super.key});",
      "",
      "  @override",
      "  State<PlatformPlansSection> createState() => _PlatformPlansSectionState();",
      "}",
      "",
      "class _PlatformPlansSectionState extends State<PlatformPlansSection> {",
      "  late Future<List<PlatformPlan>> _plansFuture;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _plansFuture = _loadPlans();",
      "  }",
      "",
      "  Future<List<PlatformPlan>> _loadPlans() async {",
      "    try {",
      "      final service = FranchiseSubscriptionService();",
      "      return await service.getPlatformPlans();",
      "    } catch (e, stack) {",
      "      ErrorLogger.log(",
      "        message: \"platform_plans_load_error\",",
      "        stack: stack.toString(),",
      "        source: 'PlatformPlansSection',",
      "        screen: 'platform_plans_section',",
      "        severity: 'error',",
      "        contextData: {'exception': e.toString()},",
      "      );",
      "      return [];",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final user = context.watch<AdminUserProvider>().user;",
      "    final loc = AppLocalizations.of(context)!;",
      "    final theme = Theme.of(context);",
      "",
      "    if (!(user?.isDeveloper ?? false) &&",
      "        !(user?.isAdmin ?? false) &&",
      "        !(user?.isHqOwner ?? false)) {",
      "      return const SizedBox.shrink();",
      "    }",
      "",
      "    return FutureBuilder<List<PlatformPlan>>(",
      "      future: _plansFuture,",
      "      builder: (context, snapshot) {",
      "        if (snapshot.connectionState != ConnectionState.done) {",
      "          return const Center(child: CircularProgressIndicator());",
      "        }",
      "",
      "        final plans = snapshot.data ?? [];",
      "",
      "        if (plans.isEmpty) {",
      "          return Padding(",
      "            padding: const EdgeInsets.all(16.0),",
      "            child: Text(loc.noPlansAvailable),",
      "          );",
      "        }",
      "",
      "        return Column(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            Text(loc.platformPlansTitle, style: theme.textTheme.headlineSmall),",
      "            const SizedBox(height: 16),",
      "            ...plans",
      "                .map((plan) => _buildPlanCard(plan, loc, theme, user))",
      "                .toList(),",
      "          ],",
      "        );",
      "      },",
      "    );",
      "  }",
      "",
      "  Widget _buildPlanCard(",
      "      PlatformPlan plan, AppLocalizations loc, ThemeData theme, user) {",
      "    return Card(",
      "      margin: const EdgeInsets.symmetric(vertical: 8),",
      "      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),",
      "      color: plan.active",
      "          ? theme.colorScheme.surface",
      "          : theme.colorScheme.surfaceVariant.withOpacity(0.5),",
      "      child: Padding(",
      "        padding: const EdgeInsets.all(16.0),",
      "        child: Column(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            Row(",
      "              children: [",
      "                Text(plan.name,",
      "                    style: theme.textTheme.titleMedium?.copyWith(",
      "                      color: plan.active",
      "                          ? theme.colorScheme.onSurface",
      "                          : theme.colorScheme.onSurface.withOpacity(0.6),",
      "                    )),",
      "                const Spacer(),",
      "                if (user?.isDeveloper == true || user?.isAdmin == true) ...[",
      "                  IconButton(",
      "                    icon: const Icon(Icons.edit),",
      "                    tooltip: loc.editPlan,",
      "                    onPressed: () {",
      "                      // TODO: implement plan edit dialog",
      "                    },",
      "                  ),",
      "                  IconButton(",
      "                    icon: const Icon(Icons.delete_outline),",
      "                    tooltip: loc.deletePlan,",
      "                    onPressed: () {",
      "                      // TODO: implement delete confirmation",
      "                    },",
      "                  ),",
      "                ],",
      "                if (plan.isCustom)",
      "                  Chip(",
      "                    label: Text(loc.customPlan),",
      "                    backgroundColor: theme.colorScheme.secondaryContainer,",
      "                  ),",
      "                if (!plan.active)",
      "                  Padding(",
      "                    padding: const EdgeInsets.only(left: 8.0),",
      "                    child: Chip(",
      "                      label: Text(loc.inactive),",
      "                      backgroundColor: theme.colorScheme.errorContainer,",
      "                    ),",
      "                  )",
      "              ],",
      "            ),",
      "            const SizedBox(height: 8),",
      "            Text('\\$${plan.price.toStringAsFixed(2)} / ${loc.perMonth}',",
      "                style: theme.textTheme.bodyMedium),",
      "            const SizedBox(height: 12),",
      "            Wrap(",
      "              spacing: 6,",
      "              runSpacing: 6,",
      "              children: plan.features",
      "                  .map((feature) => Chip(",
      "                        label: Text(AppConfig.featureDisplayName(feature)),",
      "                        backgroundColor: theme.colorScheme.primaryContainer,",
      "                      ))",
      "                  .toList(),",
      "            ),",
      "            const SizedBox(height: 12),",
      "            // 🔮 Future: Button to view subscribers / switch UI / plan analytics",
      "            Text(loc.featurePlanComingSoon,",
      "                style: theme.textTheme.labelSmall",
      "                    ?.copyWith(color: theme.colorScheme.outline)),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 165,
      "file_size": 6023,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\devtools\\feature_debug_inspector.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/utils/features/enum_platform_features.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_feature_provider.dart';",
      "",
      "class FeatureDebugInspector extends StatefulWidget {",
      "  const FeatureDebugInspector({super.key});",
      "",
      "  @override",
      "  State<FeatureDebugInspector> createState() => _FeatureDebugInspectorState();",
      "}",
      "",
      "class _FeatureDebugInspectorState extends State<FeatureDebugInspector> {",
      "  bool _showOnlyInactive = false;",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final franchiseId = context.watch<FranchiseProvider>().franchiseId;",
      "    final featureProvider = context.watch<FranchiseFeatureProvider>();",
      "",
      "    if (franchiseId.isEmpty || franchiseId == 'unknown') {",
      "      return const Center(child: Text('⚠️ No franchise selected.'));",
      "    }",
      "",
      "    if (!featureProvider.isInitialized) {",
      "      return const Center(child: CircularProgressIndicator());",
      "    }",
      "",
      "    final features = PlatformFeature.values.where((f) {",
      "      final key = f.key;",
      "      final isAvailable = featureProvider.hasFeature(key);",
      "      final isEnabled = featureProvider.isModuleEnabled(key);",
      "      final isActive = isAvailable && isEnabled;",
      "      return !_showOnlyInactive || !isActive;",
      "    }).toList();",
      "",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        const Text(",
      "          '🧩 Feature Debug Inspector',",
      "          style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),",
      "        ),",
      "        const SizedBox(height: 6),",
      "        Row(",
      "          children: [",
      "            Text('Franchise ID: $franchiseId'),",
      "            const Spacer(),",
      "            FilterChip(",
      "              label: const Text('Show only inactive'),",
      "              selected: _showOnlyInactive,",
      "              onSelected: (val) => setState(() => _showOnlyInactive = val),",
      "            ),",
      "          ],",
      "        ),",
      "        const SizedBox(height: 10),",
      "        Expanded(",
      "          child: ListView.separated(",
      "            itemCount: features.length,",
      "            separatorBuilder: (_, __) => const Divider(height: 1),",
      "            itemBuilder: (context, index) {",
      "              final feature = features[index];",
      "              final key = feature.key;",
      "",
      "              final isAvailable = featureProvider.hasFeature(key);",
      "              final isEnabled = featureProvider.isModuleEnabled(key);",
      "              final isActive = isAvailable && isEnabled;",
      "              final subfeatures = featureProvider.getSubfeatures(key);",
      "",
      "              return ExpansionTile(",
      "                tilePadding: const EdgeInsets.symmetric(horizontal: 16),",
      "                title: Text(key),",
      "                subtitle: Text(",
      "                  'Available: ${_yesNo(isAvailable)}  •  Enabled: ${_yesNo(isEnabled)}  •  Active: ${_yesNo(isActive)}',",
      "                ),",
      "                trailing: Icon(",
      "                  isActive ? Icons.check_circle : Icons.cancel,",
      "                  color: isActive ? Colors.green : Colors.redAccent,",
      "                ),",
      "                children: [",
      "                  if (subfeatures.isEmpty)",
      "                    const Padding(",
      "                      padding: EdgeInsets.only(bottom: 12),",
      "                      child: Text('  ⟶ No subfeatures',",
      "                          style: TextStyle(fontSize: 13)),",
      "                    )",
      "                  else",
      "                    ...subfeatures.entries.map(",
      "                      (entry) => ListTile(",
      "                        dense: true,",
      "                        contentPadding:",
      "                            const EdgeInsets.only(left: 32, right: 16),",
      "                        title: Text(entry.key),",
      "                        trailing: Icon(",
      "                          entry.value",
      "                              ? Icons.toggle_on",
      "                              : Icons.toggle_off_outlined,",
      "                          color: entry.value ? Colors.green : Colors.grey,",
      "                          size: 28,",
      "                        ),",
      "                      ),",
      "                    ),",
      "                ],",
      "              );",
      "            },",
      "          ),",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "",
      "  String _yesNo(bool val) => val ? '✅' : '❌';",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 114,
      "file_size": 4363,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\devtools\\billing\\admin_webhook_simulator.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/models/platform_invoice.dart';",
      "import 'package:franchise_admin_portal/core/models/franchise_info.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class AdminWebhookSimulator extends StatefulWidget {",
      "  const AdminWebhookSimulator({super.key});",
      "",
      "  @override",
      "  State<AdminWebhookSimulator> createState() => _AdminWebhookSimulatorState();",
      "}",
      "",
      "class _AdminWebhookSimulatorState extends State<AdminWebhookSimulator> {",
      "  bool _loading = false;",
      "  String? _selectedEvent;",
      "  String? _selectedFranchiseId;",
      "  PlatformInvoice? _selectedInvoice;",
      "  List<FranchiseInfo> _franchises = [];",
      "  List<PlatformInvoice> _invoices = [];",
      "  double _delaySeconds = 0.0;",
      "",
      "  final List<String> _webhookEvents = [",
      "    'invoice.paid',",
      "    'invoice.payment_failed',",
      "    'invoice.upcoming',",
      "  ];",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _loadFranchises();",
      "  }",
      "",
      "  Future<void> _loadFranchises() async {",
      "    final fs = context.read<FirestoreService>();",
      "    try {",
      "      final list = await fs.getAllFranchises();",
      "      setState(() {",
      "        _franchises = list;",
      "      });",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        source: 'AdminWebhookSimulator',",
      "        screen: 'dev_tools_screen',",
      "        message: 'Failed to load franchises: $e',",
      "        stack: stack.toString(),",
      "        severity: 'error',",
      "      );",
      "    }",
      "  }",
      "",
      "  Future<void> _loadInvoicesForFranchise(String franchiseId) async {",
      "    if (franchiseId.isEmpty || franchiseId == 'unknown') {",
      "      debugPrint(",
      "          '[AdminWebhookSimulator] Skipping load — invalid franchiseId.');",
      "      setState(() {",
      "        _invoices = [];",
      "        _loading = false;",
      "      });",
      "      return;",
      "    }",
      "",
      "    final fs = context.read<FirestoreService>();",
      "    try {",
      "      setState(() {",
      "        _loading = true;",
      "        _invoices = [];",
      "        _selectedInvoice = null;",
      "      });",
      "",
      "      final invoices =",
      "          await fs.getTestPlatformInvoices(franchiseeId: franchiseId);",
      "      final testInvoices = invoices.where((i) => i.isTest).toList();",
      "",
      "      debugPrint(",
      "          '[AdminWebhookSimulator] Found ${testInvoices.length} test invoices for franchiseId=$franchiseId');",
      "",
      "      setState(() {",
      "        _invoices = testInvoices;",
      "        _loading = false;",
      "      });",
      "    } catch (e, stack) {",
      "      setState(() => _loading = false);",
      "      await ErrorLogger.log(",
      "        source: 'AdminWebhookSimulator',",
      "        screen: 'dev_tools_screen',",
      "        message: 'Failed to load test invoices: $e',",
      "        stack: stack.toString(),",
      "        severity: 'warning',",
      "      );",
      "    }",
      "  }",
      "",
      "  Future<void> _simulateEvent() async {",
      "    if (_selectedEvent == null || _selectedInvoice == null) return;",
      "",
      "    final invoice = _selectedInvoice!;",
      "    final payload = invoice.toWebhookPayload();",
      "    final delay = Duration(milliseconds: (_delaySeconds * 1000).round());",
      "",
      "    try {",
      "      await context.read<FirestoreService>().logSimulatedWebhookEvent({",
      "        'eventType': _selectedEvent,",
      "        'invoiceId': invoice.id,",
      "        'franchiseeId': invoice.franchiseeId,",
      "        'timestamp': DateTime.now().toIso8601String(),",
      "        'payload': payload,",
      "        'delaySeconds': _delaySeconds,",
      "        'simulated': true,",
      "      });",
      "",
      "      await ErrorLogger.log(",
      "        source: 'AdminWebhookSimulator',",
      "        screen: 'dev_tools_screen',",
      "        message:",
      "            'Simulated webhook $_selectedEvent for invoice ${invoice.id} with $_delaySeconds sec delay.',",
      "        severity: 'info',",
      "        contextData: {",
      "          'invoiceId': invoice.id,",
      "          'franchiseeId': invoice.franchiseeId,",
      "          'amount': invoice.amount,",
      "          'eventType': _selectedEvent,",
      "          'delaySeconds': _delaySeconds,",
      "        },",
      "      );",
      "",
      "      if (!mounted) return;",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(",
      "          content: Text(",
      "              'Webhook $_selectedEvent simulated for invoice ${invoice.invoiceNumber}'),",
      "        ),",
      "      );",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        source: 'AdminWebhookSimulator',",
      "        screen: 'dev_tools_screen',",
      "        message: 'Webhook simulation failed: $e',",
      "        stack: stack.toString(),",
      "        severity: 'error',",
      "      );",
      "      if (mounted) {",
      "        ScaffoldMessenger.of(context).showSnackBar(",
      "          const SnackBar(",
      "              content: Text('Error occurred during webhook simulation.')),",
      "        );",
      "      }",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "    debugPrint(",
      "        '[AdminWebhookSimulator] Loaded ${_invoices.length} test invoices');",
      "    for (final inv in _invoices) {",
      "      debugPrint(' - Invoice ${inv.invoiceNumber} (${inv.id})');",
      "    }",
      "",
      "    return Card(",
      "      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 24),",
      "      elevation: 3,",
      "      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),",
      "      child: Padding(",
      "        padding: const EdgeInsets.all(24),",
      "        child: Column(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            Text('Webhook Simulator',",
      "                style: theme.textTheme.headlineSmall?.copyWith(",
      "                  fontWeight: FontWeight.bold,",
      "                )),",
      "            const SizedBox(height: 12),",
      "            Text(",
      "              'Use this to simulate webhook events like `invoice.paid` for a test invoice.',",
      "              style: theme.textTheme.bodyMedium,",
      "            ),",
      "            const SizedBox(height: 24),",
      "",
      "            /// Franchise selector",
      "            DropdownButtonFormField<String>(",
      "              value: _selectedFranchiseId,",
      "              items: _franchises",
      "                  .map((f) => DropdownMenuItem(",
      "                        value: f.id,",
      "                        child: Text(f.name),",
      "                      ))",
      "                  .toList(),",
      "              onChanged: (val) {",
      "                setState(() {",
      "                  _selectedFranchiseId = val;",
      "                  _selectedInvoice = null;",
      "                });",
      "                if (val != null) {",
      "                  _loadInvoicesForFranchise(val);",
      "                }",
      "              },",
      "              decoration: const InputDecoration(",
      "                labelText: 'Select Franchise',",
      "                border: OutlineInputBorder(),",
      "              ),",
      "            ),",
      "",
      "            const SizedBox(height: 20),",
      "            DropdownButtonFormField<String>(",
      "              value: _selectedEvent,",
      "              items: _webhookEvents",
      "                  .map((e) => DropdownMenuItem(value: e, child: Text(e)))",
      "                  .toList(),",
      "              onChanged: (val) => setState(() => _selectedEvent = val),",
      "              decoration: const InputDecoration(",
      "                labelText: 'Webhook Event Type',",
      "                border: OutlineInputBorder(),",
      "              ),",
      "            ),",
      "",
      "            const SizedBox(height: 20),",
      "            if (_loading)",
      "              const Center(child: CircularProgressIndicator())",
      "            else",
      "              DropdownButtonFormField<PlatformInvoice>(",
      "                value: _selectedInvoice,",
      "                items: _invoices",
      "                    .map((invoice) => DropdownMenuItem(",
      "                          value: invoice,",
      "                          child: Text(invoice.invoiceNumber),",
      "                        ))",
      "                    .toList(),",
      "                onChanged: (val) => setState(() => _selectedInvoice = val),",
      "                decoration: const InputDecoration(",
      "                  labelText: 'Select Invoice',",
      "                  border: OutlineInputBorder(),",
      "                ),",
      "              ),",
      "",
      "            if (_selectedInvoice != null) ...[",
      "              const SizedBox(height: 8),",
      "              Text(",
      "                'Invoice ID: ${_selectedInvoice!.id}',",
      "                style: theme.textTheme.bodySmall",
      "                    ?.copyWith(color: colorScheme.primary),",
      "              ),",
      "              Text(",
      "                'Amount: ${_selectedInvoice!.amount} ${_selectedInvoice!.currency}',",
      "                style: theme.textTheme.bodySmall,",
      "              ),",
      "            ],",
      "",
      "            const SizedBox(height: 20),",
      "            Text('Simulated Delay (seconds)',",
      "                style: theme.textTheme.bodyMedium),",
      "            Slider(",
      "              value: _delaySeconds,",
      "              min: 0,",
      "              max: 10,",
      "              divisions: 20,",
      "              label: _delaySeconds.toStringAsFixed(1),",
      "              onChanged: (val) => setState(() => _delaySeconds = val),",
      "            ),",
      "            const SizedBox(height: 12),",
      "            ElevatedButton.icon(",
      "              onPressed: (_selectedEvent == null || _selectedInvoice == null)",
      "                  ? null",
      "                  : _simulateEvent,",
      "              icon: const Icon(Icons.send),",
      "              label: const Text('Simulate Webhook'),",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 276,
      "file_size": 9252,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\devtools\\billing\\billing_subscription_tools_screen.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/admin/devtools/billing/admin_webhook_simulator.dart';",
      "import 'package:franchise_admin_portal/admin/devtools/billing/mock_payment_editor.dart';",
      "import 'package:franchise_admin_portal/admin/devtools/billing/test_invoice_generator.dart';",
      "import 'package:franchise_admin_portal/admin/devtools/billing/test_invoice_cleaner.dart';",
      "import 'package:franchise_admin_portal/admin/devtools/billing/clear_all_test_invoices_button.dart';",
      "import 'package:franchise_admin_portal/admin/devtools/billing/mock_payment_tester.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "",
      "class BillingSubscriptionToolsScreen extends StatelessWidget {",
      "  const BillingSubscriptionToolsScreen({super.key});",
      "",
      "  void _showDevGuide(BuildContext context) {",
      "    showDialog(",
      "      context: context,",
      "      builder: (context) => AlertDialog(",
      "        title: const Text('🧾 Billing & Subscription Dev Guide'),",
      "        content: SizedBox(",
      "          width: double.maxFinite,",
      "          child: SingleChildScrollView(",
      "            child: Column(",
      "              crossAxisAlignment: CrossAxisAlignment.start,",
      "              children: const [",
      "                Text('🔹 Test Invoice Generator',",
      "                    style: TextStyle(fontWeight: FontWeight.bold)),",
      "                Text(",
      "                  'Use this to create mock invoices for a specific franchise. '",
      "                  'These invoices are flagged as test data and can be used in webhook simulations or payment flows.',",
      "                ),",
      "                SizedBox(height: 12),",
      "                Text('🔹 Webhook Simulator',",
      "                    style: TextStyle(fontWeight: FontWeight.bold)),",
      "                Text(",
      "                  'Simulate Stripe-style webhook events for test invoices. '",
      "                  'Select a franchise and test invoice, then choose a webhook type like `invoice.paid`. '",
      "                  'Results are logged and can be audited via Firestore or the ErrorLogger.',",
      "                ),",
      "                SizedBox(height: 12),",
      "                Text('🔹 Mock Payment Editor',",
      "                    style: TextStyle(fontWeight: FontWeight.bold)),",
      "                Text(",
      "                  'Generate mock payment records tied to a franchise or invoice. '",
      "                  'Supports input for method, status, source, and attempts. '",
      "                  'Use this for testing how the platform handles payment edge cases.',",
      "                ),",
      "                SizedBox(height: 12),",
      "                Text('🔹 Test Invoice Cleaner',",
      "                    style: TextStyle(fontWeight: FontWeight.bold)),",
      "                Text(",
      "                  'View, reset, or delete test invoices. Useful for keeping the test environment clean or reproducing failed flows.',",
      "                ),",
      "                SizedBox(height: 12),",
      "                Text('🔹 Logs & Audit Trails',",
      "                    style: TextStyle(fontWeight: FontWeight.bold)),",
      "                Text(",
      "                  'All test tool actions are logged via `ErrorLogger`. '",
      "                  'Visit Firestore > platform_logs to view full context, errors, or confirmation of test flows.',",
      "                ),",
      "              ],",
      "            ),",
      "          ),",
      "        ),",
      "        actions: [",
      "          TextButton(",
      "            child: const Text('Close'),",
      "            onPressed: () => Navigator.of(context).pop(),",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context)!;",
      "    return Scaffold(",
      "      appBar: AppBar(",
      "        title: Text(",
      "          loc.billingTools,",
      "          style: Theme.of(context).textTheme.titleLarge?.copyWith(",
      "                fontWeight: FontWeight.bold,",
      "                color: Colors.black,",
      "              ),",
      "        ),",
      "        automaticallyImplyLeading: false,",
      "        backgroundColor: Theme.of(context).scaffoldBackgroundColor,",
      "        elevation: 0,",
      "        iconTheme: const IconThemeData(color: Colors.black),",
      "        actions: [",
      "          IconButton(",
      "            icon: const Icon(Icons.help_outline),",
      "            tooltip: 'Tool Guide',",
      "            onPressed: () => _showDevGuide(context),",
      "          ),",
      "        ],",
      "      ),",
      "      body: SafeArea(",
      "        child: SingleChildScrollView(",
      "          padding: const EdgeInsets.all(16),",
      "          child: Column(",
      "            crossAxisAlignment: CrossAxisAlignment.start,",
      "            children: const [",
      "              Text(",
      "                '🧪 Test Data Utilities',",
      "                style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),",
      "              ),",
      "              SizedBox(height: 16),",
      "              ClearAllTestInvoicesButton(),",
      "              SizedBox(height: 24),",
      "              TestInvoiceGenerator(),",
      "              SizedBox(height: 32),",
      "",
      "              Text(",
      "                '📦 Webhook Testing',",
      "                style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),",
      "              ),",
      "              SizedBox(height: 16),",
      "              AdminWebhookSimulator(),",
      "              SizedBox(height: 32),",
      "",
      "              Text(",
      "                '💳 Mock Payment Simulator',",
      "                style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),",
      "              ),",
      "              SizedBox(height: 16),",
      "              MockPaymentEditor(),",
      "              SizedBox(height: 32),",
      "",
      "              Text(",
      "                '🧹 Test Invoice Cleaner',",
      "                style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),",
      "              ),",
      "              SizedBox(height: 16),",
      "              TestInvoiceCleaner(),",
      "",
      "              SizedBox(height: 32),",
      "              // Future tool slots...",
      "            ],",
      "          ),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 144,
      "file_size": 5800,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\devtools\\billing\\clear_all_test_invoices_button.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class ClearAllTestInvoicesButton extends StatefulWidget {",
      "  final VoidCallback? onCleared; // Optional callback to refresh parent UI",
      "",
      "  const ClearAllTestInvoicesButton({super.key, this.onCleared});",
      "",
      "  @override",
      "  State<ClearAllTestInvoicesButton> createState() =>",
      "      _ClearAllTestInvoicesButtonState();",
      "}",
      "",
      "class _ClearAllTestInvoicesButtonState",
      "    extends State<ClearAllTestInvoicesButton> {",
      "  bool _isClearing = false;",
      "",
      "  Future<void> _clearAllTestInvoices() async {",
      "    final confirm = await showDialog<bool>(",
      "      context: context,",
      "      builder: (ctx) => AlertDialog(",
      "        title: const Text('Confirm Delete'),",
      "        content: const Text(",
      "          'Are you sure you want to permanently delete all test invoices? '",
      "          'This cannot be undone.',",
      "        ),",
      "        actions: [",
      "          TextButton(",
      "              onPressed: () => Navigator.pop(ctx, false),",
      "              child: const Text('Cancel')),",
      "          TextButton(",
      "              onPressed: () => Navigator.pop(ctx, true),",
      "              child: const Text('Delete')),",
      "        ],",
      "      ),",
      "    );",
      "",
      "    if (confirm != true) return;",
      "",
      "    setState(() => _isClearing = true);",
      "",
      "    try {",
      "      final snapshot = await FirebaseFirestore.instance",
      "          .collection('platform_invoices')",
      "          .where('isTest', isEqualTo: true)",
      "          .get();",
      "",
      "      final batch = FirebaseFirestore.instance.batch();",
      "      for (var doc in snapshot.docs) {",
      "        batch.delete(doc.reference);",
      "      }",
      "      await batch.commit();",
      "",
      "      if (!mounted) return;",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(",
      "            content: Text('Deleted ${snapshot.docs.length} test invoices.')),",
      "      );",
      "",
      "      widget.onCleared?.call();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to clear test invoices: $e',",
      "        stack: stack.toString(),",
      "        source: 'ClearAllTestInvoicesButton',",
      "        screen: 'dev_tools',",
      "        severity: 'fatal',",
      "      );",
      "      if (mounted) {",
      "        ScaffoldMessenger.of(context).showSnackBar(",
      "          const SnackBar(content: Text('Error occurred while deleting.')),",
      "        );",
      "      }",
      "    } finally {",
      "      if (mounted) setState(() => _isClearing = false);",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return ElevatedButton.icon(",
      "      icon: const Icon(Icons.delete_sweep_outlined),",
      "      label: Text(_isClearing ? 'Clearing...' : 'Clear All Test Invoices'),",
      "      style: ElevatedButton.styleFrom(backgroundColor: Colors.redAccent),",
      "      onPressed: _isClearing ? null : _clearAllTestInvoices,",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 89,
      "file_size": 2818,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\devtools\\billing\\mock_payment_editor.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter/services.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class MockPaymentEditor extends StatefulWidget {",
      "  const MockPaymentEditor({super.key});",
      "",
      "  @override",
      "  State<MockPaymentEditor> createState() => _MockPaymentEditorState();",
      "}",
      "",
      "class _MockPaymentEditorState extends State<MockPaymentEditor> {",
      "  final _formKey = GlobalKey<FormState>();",
      "",
      "  final _brandController = TextEditingController(text: 'Visa');",
      "  final _last4Controller = TextEditingController(text: '4242');",
      "  final _tokenIdController = TextEditingController(text: 'tok_mock_abc123');",
      "",
      "  bool _isSaving = false;",
      "  String? _statusMessage;",
      "",
      "  @override",
      "  void dispose() {",
      "    _brandController.dispose();",
      "    _last4Controller.dispose();",
      "    _tokenIdController.dispose();",
      "    super.dispose();",
      "  }",
      "",
      "  Future<void> _submit() async {",
      "    if (!_formKey.currentState!.validate()) return;",
      "",
      "    setState(() {",
      "      _isSaving = true;",
      "      _statusMessage = null;",
      "    });",
      "",
      "    try {",
      "      final brand = _brandController.text.trim();",
      "      final last4 = _last4Controller.text.trim();",
      "      final tokenId = _tokenIdController.text.trim();",
      "",
      "      await Clipboard.setData(ClipboardData(text: '''",
      "{",
      "  \"cardBrand\": \"$brand\",",
      "  \"cardLast4\": \"$last4\",",
      "  \"paymentTokenId\": \"$tokenId\"",
      "}",
      "'''));",
      "",
      "      if (!mounted) return;",
      "      setState(() {",
      "        _statusMessage = 'Mock payment data copied to clipboard!';",
      "      });",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'MockPaymentEditor error: $e',",
      "        stack: stack.toString(),",
      "        source: 'MockPaymentEditor',",
      "        screen: 'mock_payment_editor',",
      "        severity: 'error',",
      "      );",
      "      if (!mounted) return;",
      "      setState(() {",
      "        _statusMessage = 'Failed to generate mock data.';",
      "      });",
      "    } finally {",
      "      if (mounted) setState(() => _isSaving = false);",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context)!;",
      "",
      "    return Card(",
      "      margin: const EdgeInsets.symmetric(vertical: 16),",
      "      elevation: 3,",
      "      child: Padding(",
      "        padding: const EdgeInsets.all(16),",
      "        child: Column(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            Text('Mock Payment Editor',",
      "                style: Theme.of(context).textTheme.titleLarge),",
      "            const SizedBox(height: 16),",
      "            Form(",
      "              key: _formKey,",
      "              child: Column(",
      "                children: [",
      "                  TextFormField(",
      "                    controller: _brandController,",
      "                    decoration: const InputDecoration(labelText: 'Card Brand'),",
      "                    validator: (val) =>",
      "                        val == null || val.isEmpty ? 'Required' : null,",
      "                  ),",
      "                  const SizedBox(height: 12),",
      "                  TextFormField(",
      "                    controller: _last4Controller,",
      "                    decoration: const InputDecoration(labelText: 'Card Last 4'),",
      "                    maxLength: 4,",
      "                    keyboardType: TextInputType.number,",
      "                    validator: (val) {",
      "                      if (val == null || val.length != 4) {",
      "                        return 'Must be 4 digits';",
      "                      }",
      "                      return null;",
      "                    },",
      "                  ),",
      "                  const SizedBox(height: 12),",
      "                  TextFormField(",
      "                    controller: _tokenIdController,",
      "                    decoration: const InputDecoration(labelText: 'Token ID'),",
      "                    validator: (val) =>",
      "                        val == null || val.isEmpty ? 'Required' : null,",
      "                  ),",
      "                  const SizedBox(height: 16),",
      "                  ElevatedButton.icon(",
      "                    onPressed: _isSaving ? null : _submit,",
      "                    icon: const Icon(Icons.copy),",
      "                    label: Text(_isSaving ? 'Copying...' : 'Copy to Clipboard'),",
      "                  ),",
      "                  if (_statusMessage != null) ...[",
      "                    const SizedBox(height: 12),",
      "                    Text(",
      "                      _statusMessage!,",
      "                      style: TextStyle(",
      "                        color: _statusMessage!.contains('Failed')",
      "                            ? Colors.red",
      "                            : Colors.green,",
      "                      ),",
      "                    ),",
      "                  ]",
      "                ],",
      "              ),",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 143,
      "file_size": 4715,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\devtools\\billing\\mock_payment_tester.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:uuid/uuid.dart';",
      "import 'package:franchise_admin_portal/core/models/platform_invoice.dart';",
      "import 'package:franchise_admin_portal/core/models/platform_payment.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/admin/hq_owner/widgets/mock_payment_data.dart';",
      "import 'package:franchise_admin_portal/admin/hq_owner/widgets/mock_payment_form.dart';",
      "",
      "class MockPaymentTester extends StatefulWidget {",
      "  final PlatformInvoice invoice;",
      "",
      "  const MockPaymentTester({super.key, required this.invoice});",
      "",
      "  @override",
      "  State<MockPaymentTester> createState() => _MockPaymentTesterState();",
      "}",
      "",
      "class _MockPaymentTesterState extends State<MockPaymentTester> {",
      "  MockPaymentData? _mockData;",
      "  bool _submitting = false;",
      "  String? _result;",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context)!;",
      "    final theme = Theme.of(context);",
      "",
      "    return Card(",
      "      margin: const EdgeInsets.symmetric(vertical: 24),",
      "      elevation: 3,",
      "      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),",
      "      child: Padding(",
      "        padding: const EdgeInsets.all(24),",
      "        child: Column(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            Text(",
      "              loc.mockPaymentHeader,",
      "              style: theme.textTheme.headlineSmall?.copyWith(",
      "                fontWeight: FontWeight.bold,",
      "              ),",
      "            ),",
      "            const SizedBox(height: 12),",
      "            Text(",
      "              loc.mockPaymentDisclaimer,",
      "              style: theme.textTheme.bodyMedium,",
      "            ),",
      "            const SizedBox(height: 24),",
      "            MockPaymentForm(",
      "              onValidated: (mock) => setState(() => _mockData = mock),",
      "            ),",
      "            const SizedBox(height: 24),",
      "            ElevatedButton.icon(",
      "              onPressed: (_mockData == null || _submitting)",
      "                  ? null",
      "                  : () => _submitMockPayment(context),",
      "              icon: const Icon(Icons.payment),",
      "              label:",
      "                  Text(_submitting ? 'Submitting...' : 'Submit Mock Payment'),",
      "            ),",
      "            if (_result != null) ...[",
      "              const SizedBox(height: 16),",
      "              Text(",
      "                _result!,",
      "                style: TextStyle(",
      "                  color:",
      "                      _result!.startsWith('Error') ? Colors.red : Colors.green,",
      "                  fontWeight: FontWeight.w500,",
      "                ),",
      "              ),",
      "            ],",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  Future<void> _submitMockPayment(BuildContext context) async {",
      "    final fs = context.read<FirestoreService>();",
      "    final invoice = widget.invoice;",
      "    final mock = _mockData!;",
      "    final loc = AppLocalizations.of(context)!;",
      "",
      "    final now = DateTime.now();",
      "    final paymentId = const Uuid().v4();",
      "",
      "    final payment = PlatformPayment(",
      "      id: paymentId,",
      "      franchiseeId: invoice.franchiseeId,",
      "      invoiceId: invoice.id,",
      "      amount: invoice.amount,",
      "      currency: invoice.currency,",
      "      paymentMethod: 'mock_card',",
      "      type: 'one_time',",
      "      status: 'completed',",
      "      attempts: 1,",
      "      sourceSystem: 'admin_portal',",
      "      createdAt: now,",
      "      executedAt: now,",
      "      note: 'Mock payment submitted via dev tool',",
      "      isTest: true,",
      "      methodDetails: {",
      "        'cardType': mock.maskedCardString.split(' ').first,",
      "        'maskedCard': mock.maskedCardString,",
      "      },",
      "    );",
      "",
      "    try {",
      "      setState(() {",
      "        _submitting = true;",
      "        _result = null;",
      "      });",
      "",
      "      await fs.createPlatformPayment(payment);",
      "      await fs.markPlatformInvoicePaid(invoice.id, 'mock_card');",
      "",
      "      setState(() {",
      "        _result = '✅ Payment submitted and invoice marked as paid.';",
      "        _submitting = false;",
      "      });",
      "",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(content: Text(loc.mockPaymentValidated)),",
      "      );",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to simulate payment: $e',",
      "        stack: stack.toString(),",
      "        source: 'MockPaymentTester',",
      "        screen: 'dev_tools_screen',",
      "        severity: 'error',",
      "      );",
      "",
      "      if (!mounted) return;",
      "      setState(() {",
      "        _result = '❌ Error: $e';",
      "        _submitting = false;",
      "      });",
      "    }",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 144,
      "file_size": 4668,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\devtools\\billing\\test_invoice_cleaner.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class TestInvoiceCleaner extends StatefulWidget {",
      "  const TestInvoiceCleaner({super.key});",
      "",
      "  @override",
      "  State<TestInvoiceCleaner> createState() => _TestInvoiceCleanerState();",
      "}",
      "",
      "class _TestInvoiceCleanerState extends State<TestInvoiceCleaner> {",
      "  late Future<List<QueryDocumentSnapshot<Map<String, dynamic>>>>",
      "      _testInvoicesFuture;",
      "  List<QueryDocumentSnapshot<Map<String, dynamic>>> _invoices = [];",
      "  QueryDocumentSnapshot<Map<String, dynamic>>? _selectedInvoice;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _testInvoicesFuture = _fetchTestInvoices();",
      "  }",
      "",
      "  Future<List<QueryDocumentSnapshot<Map<String, dynamic>>>>",
      "      _fetchTestInvoices() async {",
      "    try {",
      "      final snapshot = await FirebaseFirestore.instance",
      "          .collection('platform_invoices')",
      "          .where('isTest', isEqualTo: true)",
      "          .orderBy('createdAt', descending: true)",
      "          .get();",
      "",
      "      _invoices = snapshot.docs;",
      "      if (_invoices.isNotEmpty) {",
      "        _selectedInvoice = _invoices.first;",
      "      }",
      "      return _invoices;",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to load test invoices: $e',",
      "        stack: stack.toString(),",
      "        source: 'TestInvoiceCleaner',",
      "        screen: 'dev_tools',",
      "        severity: 'error',",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  Future<void> _deleteInvoice(String id) async {",
      "    try {",
      "      await FirebaseFirestore.instance",
      "          .collection('platform_invoices')",
      "          .doc(id)",
      "          .delete();",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        const SnackBar(content: Text('Invoice deleted.')),",
      "      );",
      "      _refresh();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to delete invoice: $e',",
      "        stack: stack.toString(),",
      "        source: 'TestInvoiceCleaner',",
      "        screen: 'dev_tools',",
      "        severity: 'error',",
      "        contextData: {'invoiceId': id},",
      "      );",
      "    }",
      "  }",
      "",
      "  Future<void> _resetInvoice(String id) async {",
      "    try {",
      "      await FirebaseFirestore.instance",
      "          .collection('platform_invoices')",
      "          .doc(id)",
      "          .update({",
      "        'status': 'unpaid',",
      "        'paidAt': FieldValue.delete(),",
      "        'paymentIds': [],",
      "        'lastPaymentMethod': FieldValue.delete(),",
      "      });",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        const SnackBar(content: Text('Invoice reset.')),",
      "      );",
      "      _refresh();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to reset invoice: $e',",
      "        stack: stack.toString(),",
      "        source: 'TestInvoiceCleaner',",
      "        screen: 'dev_tools',",
      "        severity: 'error',",
      "        contextData: {'invoiceId': id},",
      "      );",
      "    }",
      "  }",
      "",
      "  Future<void> _bulkReset() async {",
      "    for (final doc in _invoices) {",
      "      await _resetInvoice(doc.id);",
      "    }",
      "  }",
      "",
      "  Future<void> _bulkDelete() async {",
      "    for (final doc in _invoices) {",
      "      await _deleteInvoice(doc.id);",
      "    }",
      "  }",
      "",
      "  void _refresh() {",
      "    setState(() {",
      "      _testInvoicesFuture = _fetchTestInvoices();",
      "    });",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return FutureBuilder<List<QueryDocumentSnapshot<Map<String, dynamic>>>>(",
      "      future: _testInvoicesFuture,",
      "      builder: (context, snapshot) {",
      "        if (snapshot.connectionState != ConnectionState.done) {",
      "          return const Padding(",
      "            padding: EdgeInsets.all(16),",
      "            child: Center(child: CircularProgressIndicator()),",
      "          );",
      "        }",
      "        if (snapshot.hasError) {",
      "          return Padding(",
      "            padding: const EdgeInsets.all(16),",
      "            child: Center(",
      "              child: Text('Failed to load invoices: ${snapshot.error}'),",
      "            ),",
      "          );",
      "        }",
      "",
      "        final invoices = snapshot.data ?? [];",
      "        if (invoices.isEmpty) {",
      "          return const Padding(",
      "            padding: EdgeInsets.all(16),",
      "            child: Center(child: Text('No test invoices found.')),",
      "          );",
      "        }",
      "",
      "        return Padding(",
      "          padding: const EdgeInsets.all(8.0),",
      "          child: Column(",
      "            crossAxisAlignment: CrossAxisAlignment.start,",
      "            children: [",
      "              Row(",
      "                children: [",
      "                  ElevatedButton.icon(",
      "                    icon: const Icon(Icons.refresh),",
      "                    label: const Text('Reset All'),",
      "                    style: ElevatedButton.styleFrom(",
      "                      backgroundColor: Colors.orange,",
      "                    ),",
      "                    onPressed: _bulkReset,",
      "                  ),",
      "                  const SizedBox(width: 12),",
      "                  ElevatedButton.icon(",
      "                    icon: const Icon(Icons.delete),",
      "                    label: const Text('Delete All'),",
      "                    style: ElevatedButton.styleFrom(",
      "                      backgroundColor: Colors.red,",
      "                    ),",
      "                    onPressed: _bulkDelete,",
      "                  ),",
      "                ],",
      "              ),",
      "              const SizedBox(height: 16),",
      "              DropdownButtonFormField<",
      "                  QueryDocumentSnapshot<Map<String, dynamic>>>(",
      "                value: _selectedInvoice,",
      "                items: invoices.map((doc) {",
      "                  final data = doc.data();",
      "                  return DropdownMenuItem(",
      "                    value: doc,",
      "                    child: Text(data['invoiceNumber'] ?? doc.id),",
      "                  );",
      "                }).toList(),",
      "                onChanged: (val) => setState(() => _selectedInvoice = val),",
      "                decoration: const InputDecoration(",
      "                  labelText: 'Select Invoice',",
      "                  border: OutlineInputBorder(),",
      "                ),",
      "              ),",
      "              const SizedBox(height: 16),",
      "              if (_selectedInvoice != null)",
      "                Card(",
      "                  child: ListTile(",
      "                    title: Text(",
      "                        'Invoice: ${_selectedInvoice!.data()['invoiceNumber'] ?? _selectedInvoice!.id}'),",
      "                    subtitle: Column(",
      "                      crossAxisAlignment: CrossAxisAlignment.start,",
      "                      children: [",
      "                        Text(",
      "                            'Franchisee: ${_selectedInvoice!.data()['franchiseeId'] ?? 'unknown'}'),",
      "                        Text(",
      "                            'Amount: \\$${_selectedInvoice!.data()['amount'] ?? '--'}'),",
      "                        if (_selectedInvoice!.data()['createdAt'] != null)",
      "                          Text(",
      "                              'Created: ${_selectedInvoice!.data()['createdAt'].toDate().toLocal()}'),",
      "                        if (_selectedInvoice!.data()['paidAt'] != null)",
      "                          Text(",
      "                              'Paid At: ${_selectedInvoice!.data()['paidAt'].toDate().toLocal()}'),",
      "                      ],",
      "                    ),",
      "                    trailing: Wrap(",
      "                      spacing: 8,",
      "                      children: [",
      "                        IconButton(",
      "                          icon: const Icon(Icons.refresh, color: Colors.orange),",
      "                          tooltip: 'Reset',",
      "                          onPressed: () => _resetInvoice(_selectedInvoice!.id),",
      "                        ),",
      "                        IconButton(",
      "                          icon: const Icon(Icons.delete, color: Colors.red),",
      "                          tooltip: 'Delete',",
      "                          onPressed: () => _deleteInvoice(_selectedInvoice!.id),",
      "                        ),",
      "                      ],",
      "                    ),",
      "                  ),",
      "                ),",
      "            ],",
      "          ),",
      "        );",
      "      },",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 232,
      "file_size": 7939,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\devtools\\billing\\test_invoice_generator.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:intl/intl.dart';",
      "import 'package:uuid/uuid.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/models/platform_invoice.dart';",
      "import 'package:franchise_admin_portal/core/models/franchise_info.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class TestInvoiceGenerator extends StatefulWidget {",
      "  const TestInvoiceGenerator({super.key});",
      "",
      "  @override",
      "  State<TestInvoiceGenerator> createState() => _TestInvoiceGeneratorState();",
      "}",
      "",
      "class _TestInvoiceGeneratorState extends State<TestInvoiceGenerator> {",
      "  final _formKey = GlobalKey<FormState>();",
      "  final _amountController = TextEditingController(text: '99.00');",
      "  final _currencyController = TextEditingController(text: 'USD');",
      "  final _noteController = TextEditingController(text: 'Test invoice for QA');",
      "",
      "  DateTime _dueDate = DateTime.now().add(const Duration(days: 7));",
      "  bool _isSaving = false;",
      "  String? _statusMessage;",
      "",
      "  List<FranchiseInfo> _franchises = [];",
      "  FranchiseInfo? _selectedFranchise;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _loadFranchises();",
      "  }",
      "",
      "  Future<void> _loadFranchises() async {",
      "    try {",
      "      final firestoreService =",
      "          Provider.of<FirestoreService>(context, listen: false);",
      "      final franchises = await firestoreService.fetchFranchiseList();",
      "      if (mounted) {",
      "        setState(() {",
      "          _franchises = franchises;",
      "        });",
      "      }",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to load franchises: $e',",
      "        stack: stack.toString(),",
      "        source: 'TestInvoiceGenerator',",
      "        screen: 'test_invoice_generator',",
      "        severity: 'error',",
      "      );",
      "    }",
      "  }",
      "",
      "  Future<void> _submit() async {",
      "    if (!_formKey.currentState!.validate()) return;",
      "",
      "    final franchise = _selectedFranchise;",
      "    if (franchise == null) {",
      "      setState(() => _statusMessage = 'Franchise must be selected.');",
      "      return;",
      "    }",
      "",
      "    setState(() {",
      "      _isSaving = true;",
      "      _statusMessage = null;",
      "    });",
      "",
      "    try {",
      "      final uuid = const Uuid().v4();",
      "      final now = DateTime.now();",
      "      final invoiceNumber =",
      "          'TEST-${DateFormat('yyMMdd-HHmm').format(now)}-${uuid.substring(0, 6).toUpperCase()}';",
      "",
      "      final invoice = PlatformInvoice(",
      "        id: uuid,",
      "        franchiseeId: franchise.id,",
      "        invoiceNumber: invoiceNumber,",
      "        amount: double.tryParse(_amountController.text.trim()) ?? 0.0,",
      "        currency: _currencyController.text.trim().toUpperCase(),",
      "        createdAt: now,",
      "        dueDate: _dueDate,",
      "        status: 'unpaid',",
      "        issuedBy: 'platform',",
      "        isTest: true,",
      "        paymentIds: [],",
      "        lineItems: {",
      "          'mockItem': {'label': 'Dev Item', 'amount': 9999}",
      "        },",
      "        note: _noteController.text.trim(),",
      "      );",
      "",
      "      final firestoreService =",
      "          Provider.of<FirestoreService>(context, listen: false);",
      "      await firestoreService.createPlatformInvoice(invoice);",
      "",
      "      if (!mounted) return;",
      "      setState(() => _statusMessage = 'Test invoice created: $invoiceNumber');",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to generate test invoice: $e',",
      "        stack: stack.toString(),",
      "        source: 'TestInvoiceGenerator',",
      "        screen: 'test_invoice_generator',",
      "        severity: 'error',",
      "      );",
      "      if (!mounted) return;",
      "      setState(() => _statusMessage = 'Error generating invoice.');",
      "    } finally {",
      "      if (mounted) setState(() => _isSaving = false);",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context)!;",
      "",
      "    return Card(",
      "      margin: const EdgeInsets.symmetric(vertical: 16),",
      "      elevation: 3,",
      "      child: Padding(",
      "        padding: const EdgeInsets.all(16),",
      "        child: Form(",
      "          key: _formKey,",
      "          child: Column(",
      "            crossAxisAlignment: CrossAxisAlignment.start,",
      "            children: [",
      "              Text('Test Invoice Generator',",
      "                  style: Theme.of(context).textTheme.titleLarge),",
      "              const SizedBox(height: 16),",
      "              DropdownButtonFormField<FranchiseInfo>(",
      "                decoration:",
      "                    const InputDecoration(labelText: 'Select Franchise'),",
      "                items: _franchises",
      "                    .map((f) => DropdownMenuItem(value: f, child: Text(f.name)))",
      "                    .toList(),",
      "                value: _selectedFranchise,",
      "                onChanged: (val) => setState(() => _selectedFranchise = val),",
      "                validator: (val) =>",
      "                    val == null ? 'Franchise is required' : null,",
      "              ),",
      "              const SizedBox(height: 12),",
      "              TextFormField(",
      "                controller: _amountController,",
      "                decoration:",
      "                    const InputDecoration(labelText: 'Amount (e.g. 99.00)'),",
      "                keyboardType: TextInputType.number,",
      "                validator: (val) =>",
      "                    (val == null || double.tryParse(val) == null)",
      "                        ? 'Invalid amount'",
      "                        : null,",
      "              ),",
      "              const SizedBox(height: 12),",
      "              TextFormField(",
      "                controller: _currencyController,",
      "                decoration:",
      "                    const InputDecoration(labelText: 'Currency (e.g. USD)'),",
      "                validator: (val) =>",
      "                    (val == null || val.isEmpty) ? 'Required' : null,",
      "              ),",
      "              const SizedBox(height: 12),",
      "              TextFormField(",
      "                controller: _noteController,",
      "                decoration: const InputDecoration(labelText: 'Invoice Note'),",
      "              ),",
      "              const SizedBox(height: 12),",
      "              InputDatePickerFormField(",
      "                firstDate: DateTime.now().subtract(const Duration(days: 1)),",
      "                lastDate: DateTime.now().add(const Duration(days: 365)),",
      "                initialDate: _dueDate,",
      "                onDateSubmitted: (val) => _dueDate = val,",
      "                fieldLabelText: 'Due Date',",
      "              ),",
      "              const SizedBox(height: 16),",
      "              ElevatedButton.icon(",
      "                onPressed: _isSaving ? null : _submit,",
      "                icon: const Icon(Icons.play_circle_fill),",
      "                label:",
      "                    Text(_isSaving ? 'Creating...' : 'Generate Test Invoice'),",
      "              ),",
      "              if (_statusMessage != null) ...[",
      "                const SizedBox(height: 12),",
      "                Text(",
      "                  _statusMessage!,",
      "                  style: TextStyle(",
      "                    color: _statusMessage!.startsWith('Error')",
      "                        ? Colors.red",
      "                        : Colors.green,",
      "                  ),",
      "                ),",
      "              ],",
      "            ],",
      "          ),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 201,
      "file_size": 7163,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\devtools\\platform\\platform_feature_plan_tools_screen.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/admin/devtools/platform/seed_platform_features_form.dart';",
      "import 'package:franchise_admin_portal/admin/devtools/platform/seed_platform_plans_form.dart';",
      "import 'package:franchise_admin_portal/admin/devtools/platform/remove_platform_plans_form.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/admin/devtools/platform/remove_platform_features_form.dart';",
      "",
      "class PlatformFeaturePlanToolsScreen extends StatelessWidget {",
      "  const PlatformFeaturePlanToolsScreen({super.key});",
      "",
      "  void _showDevGuide(BuildContext context) {",
      "    showDialog(",
      "      context: context,",
      "      builder: (context) => AlertDialog(",
      "        title: const Text('🛠️ Platform Feature + Plan Dev Guide'),",
      "        content: SizedBox(",
      "          width: double.maxFinite,",
      "          child: SingleChildScrollView(",
      "            child: Column(",
      "              crossAxisAlignment: CrossAxisAlignment.start,",
      "              children: const [",
      "                Text('Platform Feature Seeder',",
      "                    style: TextStyle(fontWeight: FontWeight.bold)),",
      "                Text(",
      "                  'Create or replace individual feature documents in `/platform_features`. '",
      "                  'These documents define which modules are available to include in plan configurations.',",
      "                ),",
      "                SizedBox(height: 12),",
      "                Text('Platform Plan Creator',",
      "                    style: TextStyle(fontWeight: FontWeight.bold)),",
      "                Text(",
      "                  'Create subscription plans in `/platform_plans`. '",
      "                  'Each plan includes price, billing interval, and a list of feature keys from `/platform_features`.',",
      "                ),",
      "                SizedBox(height: 12),",
      "                Text('Plan Snapshot Behavior',",
      "                    style: TextStyle(fontWeight: FontWeight.bold)),",
      "                Text(",
      "                  'Upon subscription, the selected plan’s features are snapshotted into the franchise\\'s `franchise_subscriptions` '",
      "                  'and seeded into `feature_metadata` under that franchise. Changes to `/platform_plans` do not retroactively affect existing subscriptions.',",
      "                ),",
      "                SizedBox(height: 12),",
      "                Text('Delete Plan Behavior',",
      "                    style: TextStyle(fontWeight: FontWeight.bold)),",
      "                Text(",
      "                    'A simple widget to delete a selected plan completely from the database.'),",
      "                SizedBox(height: 12),",
      "                Text('Delete Feature Behavior',",
      "                    style: TextStyle(fontWeight: FontWeight.bold)),",
      "                Text(",
      "                    'A simple widget to delete a selected feature completely from the database.'),",
      "                SizedBox(height: 12),",
      "                Text('🔒 Locked Features',",
      "                    style: TextStyle(fontWeight: FontWeight.bold)),",
      "                Text(",
      "                  'Features not included in a plan will appear locked and uneditable in onboarding or admin screens.',",
      "                ),",
      "              ],",
      "            ),",
      "          ),",
      "        ),",
      "        actions: [",
      "          TextButton(",
      "            child: const Text('Close'),",
      "            onPressed: () => Navigator.of(context).pop(),",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context)!;",
      "    return Scaffold(",
      "      appBar: AppBar(",
      "        title: Text(",
      "          loc.platformFeaturePlanTools,",
      "          style: Theme.of(context).textTheme.titleLarge?.copyWith(",
      "                fontWeight: FontWeight.bold,",
      "                color: Colors.black,",
      "              ),",
      "        ),",
      "        automaticallyImplyLeading: false,",
      "        backgroundColor: Theme.of(context).scaffoldBackgroundColor,",
      "        elevation: 0,",
      "        iconTheme: const IconThemeData(color: Colors.black),",
      "        actions: [",
      "          IconButton(",
      "            icon: const Icon(Icons.help_outline),",
      "            tooltip: 'Dev Guide',",
      "            onPressed: () => _showDevGuide(context),",
      "          ),",
      "        ],",
      "      ),",
      "      body: SafeArea(",
      "        child: SingleChildScrollView(",
      "          padding: const EdgeInsets.all(16),",
      "          child: Column(",
      "            crossAxisAlignment: CrossAxisAlignment.start,",
      "            children: const [",
      "              SeedPlatformFeaturesForm(),",
      "              SizedBox(height: 64),",
      "",
      "              const RemovePlatformFeaturesForm(),",
      "              SizedBox(height: 64),",
      "",
      "              SeedPlatformPlansForm(),",
      "              SizedBox(height: 64),",
      "",
      "              const RemovePlatformPlansForm(),",
      "              SizedBox(height: 64),",
      "              // Future expansion...",
      "            ],",
      "          ),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 120,
      "file_size": 4894,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\devtools\\platform\\remove_platform_features_form.dart",
    "content": [
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class RemovePlatformFeaturesForm extends StatefulWidget {",
      "  const RemovePlatformFeaturesForm({super.key});",
      "",
      "  @override",
      "  State<RemovePlatformFeaturesForm> createState() =>",
      "      _RemovePlatformFeaturesFormState();",
      "}",
      "",
      "class _RemovePlatformFeaturesFormState",
      "    extends State<RemovePlatformFeaturesForm> {",
      "  late final FirebaseFirestore _db;",
      "  List<String> _featureKeys = [];",
      "  String? _selectedFeatureKey;",
      "  String? _statusMessage;",
      "  bool _isLoading = false;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _db = FirebaseFirestore.instance;",
      "    _loadFeatureKeys();",
      "  }",
      "",
      "  Future<void> _loadFeatureKeys() async {",
      "    try {",
      "      final snapshot = await _db.collection('platform_features').get();",
      "      final keys = snapshot.docs.map((doc) => doc.id).toList();",
      "",
      "      setState(() => _featureKeys = keys);",
      "    } catch (e, st) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to fetch platform_features for deletion',",
      "        stack: st.toString(),",
      "        screen: 'RemovePlatformFeaturesForm',",
      "        source: 'remove_platform_features_form.dart',",
      "        severity: 'warning',",
      "      );",
      "    }",
      "  }",
      "",
      "  Future<void> _deleteFeature() async {",
      "    final loc = AppLocalizations.of(context)!;",
      "",
      "    if (_selectedFeatureKey == null) return;",
      "",
      "    setState(() {",
      "      _isLoading = true;",
      "      _statusMessage = null;",
      "    });",
      "",
      "    try {",
      "      await _db",
      "          .collection('platform_features')",
      "          .doc(_selectedFeatureKey)",
      "          .delete();",
      "",
      "      setState(() {",
      "        _featureKeys.remove(_selectedFeatureKey);",
      "        _selectedFeatureKey = null;",
      "        _statusMessage = loc.devtoolsDeleteSuccess;",
      "      });",
      "    } catch (e, st) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to delete platform_feature',",
      "        stack: st.toString(),",
      "        screen: 'RemovePlatformFeaturesForm',",
      "        source: 'remove_platform_features_form.dart',",
      "        contextData: {'featureKey': _selectedFeatureKey},",
      "        severity: 'error',",
      "      );",
      "",
      "      setState(() => _statusMessage = loc.devtoolsDeleteError);",
      "    } finally {",
      "      setState(() => _isLoading = false);",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context)!;",
      "    final theme = Theme.of(context);",
      "",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        Text(",
      "          loc.devtoolsDeletePlatformFeaturesTitle,",
      "          style: theme.textTheme.titleLarge?.copyWith(",
      "            fontWeight: FontWeight.bold,",
      "          ),",
      "        ),",
      "        const SizedBox(height: 12),",
      "        Row(",
      "          children: [",
      "            Expanded(",
      "              child: DropdownButtonFormField<String>(",
      "                value: _selectedFeatureKey,",
      "                items: _featureKeys",
      "                    .map((id) => DropdownMenuItem(",
      "                          value: id,",
      "                          child: Text(id),",
      "                        ))",
      "                    .toList(),",
      "                onChanged: (value) =>",
      "                    setState(() => _selectedFeatureKey = value),",
      "                decoration: InputDecoration(",
      "                  labelText: loc.devtoolsSelectFeature,",
      "                  border: const OutlineInputBorder(),",
      "                ),",
      "              ),",
      "            ),",
      "            const SizedBox(width: 12),",
      "            ElevatedButton.icon(",
      "              icon: _isLoading",
      "                  ? const SizedBox(",
      "                      width: 18,",
      "                      height: 18,",
      "                      child: CircularProgressIndicator(",
      "                        strokeWidth: 2,",
      "                        valueColor: AlwaysStoppedAnimation<Color>(Colors.white),",
      "                      ),",
      "                    )",
      "                  : const Icon(Icons.delete_outline),",
      "              onPressed: _selectedFeatureKey == null || _isLoading",
      "                  ? null",
      "                  : _deleteFeature,",
      "              label: Text(",
      "                _isLoading ? loc.deleting : loc.delete,",
      "                style: const TextStyle(color: Colors.white),",
      "              ),",
      "              style: ElevatedButton.styleFrom(",
      "                backgroundColor: theme.colorScheme.error,",
      "              ),",
      "            ),",
      "          ],",
      "        ),",
      "        if (_statusMessage != null) ...[",
      "          const SizedBox(height: 12),",
      "          Text(",
      "            _statusMessage!,",
      "            style: TextStyle(",
      "              color: _statusMessage == loc.devtoolsDeleteSuccess",
      "                  ? Colors.green",
      "                  : theme.colorScheme.error,",
      "              fontWeight: FontWeight.w600,",
      "            ),",
      "          ),",
      "        ],",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 157,
      "file_size": 4940,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\devtools\\platform\\remove_platform_plans_form.dart",
    "content": [
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class RemovePlatformPlansForm extends StatefulWidget {",
      "  const RemovePlatformPlansForm({super.key});",
      "",
      "  @override",
      "  State<RemovePlatformPlansForm> createState() =>",
      "      _RemovePlatformPlansFormState();",
      "}",
      "",
      "class _RemovePlatformPlansFormState extends State<RemovePlatformPlansForm> {",
      "  late final FirebaseFirestore _db;",
      "  List<String> _planIds = [];",
      "  String? _selectedPlanId;",
      "  String? _statusMessage;",
      "  bool _isLoading = false;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _db = FirebaseFirestore.instance;",
      "    _loadPlanIds();",
      "  }",
      "",
      "  Future<void> _loadPlanIds() async {",
      "    try {",
      "      final snapshot = await _db.collection('platform_plans').get();",
      "      final ids = snapshot.docs.map((doc) => doc.id).toList();",
      "",
      "      setState(() => _planIds = ids);",
      "    } catch (e, st) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to fetch platform_plans for deletion',",
      "        stack: st.toString(),",
      "        screen: 'RemovePlatformPlansForm',",
      "        source: 'remove_platform_plans_form.dart',",
      "        severity: 'warning',",
      "      );",
      "    }",
      "  }",
      "",
      "  Future<void> _deletePlan() async {",
      "    final loc = AppLocalizations.of(context)!;",
      "",
      "    if (_selectedPlanId == null) return;",
      "",
      "    setState(() {",
      "      _isLoading = true;",
      "      _statusMessage = null;",
      "    });",
      "",
      "    try {",
      "      await _db.collection('platform_plans').doc(_selectedPlanId).delete();",
      "",
      "      setState(() {",
      "        _planIds.remove(_selectedPlanId);",
      "        _selectedPlanId = null;",
      "        _statusMessage = loc.devtoolsDeleteSuccess;",
      "      });",
      "    } catch (e, st) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to delete platform_plan',",
      "        stack: st.toString(),",
      "        screen: 'RemovePlatformPlansForm',",
      "        source: 'remove_platform_plans_form.dart',",
      "        contextData: {'planId': _selectedPlanId},",
      "        severity: 'error',",
      "      );",
      "",
      "      setState(() => _statusMessage = loc.devtoolsDeleteError);",
      "    } finally {",
      "      setState(() => _isLoading = false);",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context)!;",
      "    final theme = Theme.of(context);",
      "",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        Text(",
      "          loc.devtoolsDeletePlatformPlansTitle,",
      "          style: theme.textTheme.titleLarge?.copyWith(",
      "            fontWeight: FontWeight.bold,",
      "          ),",
      "        ),",
      "        const SizedBox(height: 12),",
      "        Row(",
      "          children: [",
      "            Expanded(",
      "              child: DropdownButtonFormField<String>(",
      "                value: _selectedPlanId,",
      "                items: _planIds",
      "                    .map((id) => DropdownMenuItem(",
      "                          value: id,",
      "                          child: Text(id),",
      "                        ))",
      "                    .toList(),",
      "                onChanged: (value) => setState(() => _selectedPlanId = value),",
      "                decoration: InputDecoration(",
      "                  labelText: loc.devtoolsSelectPlan,",
      "                  border: const OutlineInputBorder(),",
      "                ),",
      "              ),",
      "            ),",
      "            const SizedBox(width: 12),",
      "            ElevatedButton.icon(",
      "              icon: _isLoading",
      "                  ? const SizedBox(",
      "                      width: 18,",
      "                      height: 18,",
      "                      child: CircularProgressIndicator(",
      "                        strokeWidth: 2,",
      "                        valueColor: AlwaysStoppedAnimation<Color>(Colors.white),",
      "                      ),",
      "                    )",
      "                  : const Icon(Icons.delete_outline),",
      "              onPressed:",
      "                  _selectedPlanId == null || _isLoading ? null : _deletePlan,",
      "              label: Text(",
      "                _isLoading ? loc.deleting : loc.delete,",
      "                style: const TextStyle(color: Colors.white),",
      "              ),",
      "              style: ElevatedButton.styleFrom(",
      "                backgroundColor: theme.colorScheme.error,",
      "              ),",
      "            ),",
      "          ],",
      "        ),",
      "        if (_statusMessage != null) ...[",
      "          const SizedBox(height: 12),",
      "          Text(",
      "            _statusMessage!,",
      "            style: TextStyle(",
      "              color: _statusMessage == loc.devtoolsDeleteSuccess",
      "                  ? Colors.green",
      "                  : theme.colorScheme.error,",
      "              fontWeight: FontWeight.w600,",
      "            ),",
      "          ),",
      "        ],",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 151,
      "file_size": 4739,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\devtools\\platform\\seed_platform_features_form.dart",
    "content": [
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class SeedPlatformFeaturesForm extends StatefulWidget {",
      "  const SeedPlatformFeaturesForm({super.key});",
      "",
      "  @override",
      "  State<SeedPlatformFeaturesForm> createState() =>",
      "      _SeedPlatformFeaturesFormState();",
      "}",
      "",
      "class _SeedPlatformFeaturesFormState extends State<SeedPlatformFeaturesForm> {",
      "  final _keyController = TextEditingController();",
      "  final _nameController = TextEditingController();",
      "  final _descController = TextEditingController();",
      "  final _moduleController = TextEditingController();",
      "",
      "  bool _deprecated = false;",
      "  bool _developerOnly = false;",
      "  bool _isSaving = false;",
      "  String? _statusMessage;",
      "",
      "  final List<Map<String, dynamic>> _featuresToSeed = [];",
      "",
      "  void _addFeature() {",
      "    final key = _keyController.text.trim();",
      "    final name = _nameController.text.trim();",
      "    final description = _descController.text.trim();",
      "    final module = _moduleController.text.trim();",
      "",
      "    if (key.isEmpty || name.isEmpty) {",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(",
      "            content: Text(",
      "                AppLocalizations.of(context)!.devtoolsValidationMissingFields)),",
      "      );",
      "      return;",
      "    }",
      "",
      "    setState(() {",
      "      _featuresToSeed.add({",
      "        'key': key,",
      "        'name': name,",
      "        'description': description,",
      "        'module': module,",
      "        'deprecated': _deprecated,",
      "        'developerOnly': _developerOnly,",
      "      });",
      "      _keyController.clear();",
      "      _nameController.clear();",
      "      _descController.clear();",
      "      _moduleController.clear();",
      "      _deprecated = false;",
      "      _developerOnly = false;",
      "    });",
      "  }",
      "",
      "  Future<void> _submitFeatures() async {",
      "    final loc = AppLocalizations.of(context)!;",
      "",
      "    if (_featuresToSeed.isEmpty) {",
      "      setState(() => _statusMessage = loc.devtoolsValidationEmptyFeatureList);",
      "      return;",
      "    }",
      "",
      "    setState(() {",
      "      _isSaving = true;",
      "      _statusMessage = null;",
      "    });",
      "",
      "    try {",
      "      final batch = FirebaseFirestore.instance.batch();",
      "      final ref = FirebaseFirestore.instance.collection('platform_features');",
      "",
      "      for (final f in _featuresToSeed) {",
      "        final key = f['key'];",
      "        if (key == null || key.toString().isEmpty) continue;",
      "        batch.set(ref.doc(key), f);",
      "      }",
      "",
      "      await batch.commit();",
      "      setState(() {",
      "        _featuresToSeed.clear();",
      "        _statusMessage = loc.devtoolsSeedSuccess;",
      "      });",
      "    } catch (e, st) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to seed platform_features',",
      "        stack: st.toString(),",
      "        source: 'SeedPlatformFeaturesForm',",
      "        screen: 'seed_platform_features_form',",
      "        severity: 'error',",
      "      );",
      "      setState(() => _statusMessage = loc.devtoolsSeedError);",
      "    } finally {",
      "      setState(() => _isSaving = false);",
      "    }",
      "  }",
      "",
      "  @override",
      "  void dispose() {",
      "    _keyController.dispose();",
      "    _nameController.dispose();",
      "    _descController.dispose();",
      "    _moduleController.dispose();",
      "    super.dispose();",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context)!;",
      "    final theme = Theme.of(context);",
      "",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        Text(",
      "          loc.seedPlatformFeaturesTitle,",
      "          style:",
      "              theme.textTheme.titleLarge?.copyWith(fontWeight: FontWeight.bold),",
      "        ),",
      "        const SizedBox(height: 12),",
      "        Text(loc.seedPlatformFeaturesDescription,",
      "            style: theme.textTheme.bodyMedium),",
      "        const SizedBox(height: 16),",
      "",
      "        // ─── Horizontal Row 1 ────────────────────────────────────────",
      "        Row(children: [",
      "          Expanded(",
      "            child: TextField(",
      "              controller: _keyController,",
      "              decoration: InputDecoration(labelText: loc.devtoolsFieldKey),",
      "            ),",
      "          ),",
      "          const SizedBox(width: 12),",
      "          Expanded(",
      "            child: TextField(",
      "              controller: _nameController,",
      "              decoration: InputDecoration(labelText: loc.devtoolsFieldName),",
      "            ),",
      "          ),",
      "        ]),",
      "        const SizedBox(height: 12),",
      "",
      "        // ─── Horizontal Row 2 ────────────────────────────────────────",
      "        Row(",
      "          mainAxisAlignment: MainAxisAlignment.start,",
      "          children: [",
      "            Row(",
      "              mainAxisSize: MainAxisSize.min,",
      "              children: [",
      "                Checkbox(",
      "                  value: _deprecated,",
      "                  onChanged: (val) =>",
      "                      setState(() => _deprecated = val ?? false),",
      "                ),",
      "                Text(loc.devtoolsFieldDeprecated),",
      "              ],",
      "            ),",
      "            const SizedBox(width: 24),",
      "            Row(",
      "              mainAxisSize: MainAxisSize.min,",
      "              children: [",
      "                Checkbox(",
      "                  value: _developerOnly,",
      "                  onChanged: (val) =>",
      "                      setState(() => _developerOnly = val ?? false),",
      "                ),",
      "                Text(loc.devtoolsFieldDeveloperOnly),",
      "              ],",
      "            ),",
      "          ],",
      "        ),",
      "        const SizedBox(height: 12),",
      "",
      "        // ─── Multiline Description ──────────────────────────────────",
      "        TextField(",
      "          controller: _descController,",
      "          maxLines: 2,",
      "          decoration: InputDecoration(",
      "            labelText: loc.devtoolsFieldDescription,",
      "            border: const OutlineInputBorder(),",
      "          ),",
      "        ),",
      "        const SizedBox(height: 16),",
      "",
      "        Row(",
      "          children: [",
      "            ElevatedButton.icon(",
      "              icon: const Icon(Icons.add),",
      "              label: Text(loc.devtoolsAddFeature),",
      "              onPressed: _addFeature,",
      "            ),",
      "            const SizedBox(width: 12),",
      "            OutlinedButton.icon(",
      "              icon: const Icon(Icons.upload_file),",
      "              label: Text(loc.uploadViaJson),",
      "              onPressed: () {",
      "                // TODO: Open JSON upload dialog",
      "              },",
      "            ),",
      "          ],",
      "        ),",
      "        const SizedBox(height: 24),",
      "",
      "        // ─── List of Features ───────────────────────────────────────",
      "        if (_featuresToSeed.isNotEmpty) ...[",
      "          Text(",
      "            loc.devtoolsFeaturesToSeed,",
      "            style: theme.textTheme.titleMedium",
      "                ?.copyWith(fontWeight: FontWeight.w600),",
      "          ),",
      "          const SizedBox(height: 8),",
      "          ..._featuresToSeed.map((f) => Text('- ${f['key']} → ${f['name']}')),",
      "          const SizedBox(height: 12),",
      "        ],",
      "",
      "        Row(",
      "          children: [",
      "            ElevatedButton.icon(",
      "              onPressed: _isSaving ? null : _submitFeatures,",
      "              icon: const Icon(Icons.save),",
      "              label: Text(_isSaving ? loc.saving : loc.seed),",
      "            ),",
      "            const SizedBox(width: 16),",
      "            if (_statusMessage != null)",
      "              Text(",
      "                _statusMessage!,",
      "                style: TextStyle(",
      "                  color: _statusMessage == loc.devtoolsSeedSuccess",
      "                      ? Colors.green",
      "                      : theme.colorScheme.error,",
      "                  fontWeight: FontWeight.w600,",
      "                ),",
      "              ),",
      "          ],",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 243,
      "file_size": 7891,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\devtools\\platform\\seed_platform_plans_form.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class SeedPlatformPlansForm extends StatefulWidget {",
      "  const SeedPlatformPlansForm({super.key});",
      "",
      "  @override",
      "  State<SeedPlatformPlansForm> createState() => _SeedPlatformPlansFormState();",
      "}",
      "",
      "class _SeedPlatformPlansFormState extends State<SeedPlatformPlansForm> {",
      "  final _formKey = GlobalKey<FormState>();",
      "  final _idController = TextEditingController();",
      "  final _nameController = TextEditingController();",
      "  final _descController = TextEditingController();",
      "  final _priceController = TextEditingController();",
      "  final _currencyController = TextEditingController(text: 'USD');",
      "  final _intervalController = TextEditingController(text: 'monthly');",
      "  final _versionController = TextEditingController(text: 'v1');",
      "  bool _active = true;",
      "  bool _isCustom = false;",
      "  String? _statusMessage;",
      "  bool _isSaving = false;",
      "",
      "  final List<String> _selectedFeatures = [];",
      "  List<String> _availableFeatures = [];",
      "  String? _selectedFeatureToAdd;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _loadPlatformFeatures();",
      "  }",
      "",
      "  Future<void> _loadPlatformFeatures() async {",
      "    try {",
      "      final snap = await FirebaseFirestore.instance",
      "          .collection('platform_features')",
      "          .get();",
      "      final featureKeys = snap.docs.map((doc) => doc.id).toList();",
      "      setState(() => _availableFeatures = featureKeys);",
      "    } catch (e, st) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to load platform_features',",
      "        stack: st.toString(),",
      "        source: 'SeedPlatformPlansForm',",
      "        screen: 'seed_platform_plans_form',",
      "        severity: 'error',",
      "      );",
      "    }",
      "  }",
      "",
      "  Future<void> _handleSubmit() async {",
      "    final loc = AppLocalizations.of(context)!;",
      "    if (!_formKey.currentState!.validate()) return;",
      "",
      "    setState(() {",
      "      _isSaving = true;",
      "      _statusMessage = null;",
      "    });",
      "",
      "    final planData = {",
      "      'id': _idController.text.trim(),",
      "      'name': _nameController.text.trim(),",
      "      'description': _descController.text.trim(),",
      "      'price': double.tryParse(_priceController.text.trim()) ?? 0,",
      "      'currency': _currencyController.text.trim(),",
      "      'active': _active,",
      "      'isCustom': _isCustom,",
      "      'billingInterval': _intervalController.text.trim(),",
      "      'planVersion': _versionController.text.trim(),",
      "      'features': _selectedFeatures,",
      "    };",
      "",
      "    try {",
      "      final docRef = FirebaseFirestore.instance",
      "          .collection('platform_plans')",
      "          .doc(planData['id'] as String?);",
      "",
      "      await docRef.set(planData);",
      "",
      "      setState(() => _statusMessage = loc.devtoolsSeedSuccess);",
      "    } catch (e, st) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to seed platform_plan',",
      "        stack: st.toString(),",
      "        source: 'SeedPlatformPlansForm',",
      "        screen: 'seed_platform_plans_form',",
      "        severity: 'error',",
      "        contextData: {",
      "          'formData': planData,",
      "          'errorType': e.runtimeType.toString(),",
      "          'errorMessage': e.toString(),",
      "        },",
      "      );",
      "",
      "      setState(() => _statusMessage = loc.devtoolsSeedError);",
      "    } finally {",
      "      setState(() => _isSaving = false);",
      "    }",
      "  }",
      "",
      "  void _addFeature(String feature) {",
      "    if (!_selectedFeatures.contains(feature)) {",
      "      setState(() {",
      "        _selectedFeatures.add(feature);",
      "        _availableFeatures.remove(feature);",
      "        _selectedFeatureToAdd = null;",
      "      });",
      "    }",
      "  }",
      "",
      "  void _removeFeature(String feature) {",
      "    setState(() => _selectedFeatures.remove(feature));",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context)!;",
      "    final theme = Theme.of(context);",
      "",
      "    return Form(",
      "      key: _formKey,",
      "      child: Column(",
      "        crossAxisAlignment: CrossAxisAlignment.start,",
      "        children: [",
      "          Text(loc.devtoolsSeedPlatformPlansTitle,",
      "              style: theme.textTheme.titleLarge",
      "                  ?.copyWith(fontWeight: FontWeight.bold)),",
      "          const SizedBox(height: 12),",
      "          Wrap(",
      "            spacing: 16,",
      "            runSpacing: 16,",
      "            children: [",
      "              SizedBox(",
      "                width: 200,",
      "                child: TextFormField(",
      "                  controller: _idController,",
      "                  decoration: InputDecoration(labelText: 'Plan ID'),",
      "                  validator: (val) =>",
      "                      val == null || val.trim().isEmpty ? 'Required' : null,",
      "                ),",
      "              ),",
      "              SizedBox(",
      "                width: 300,",
      "                child: TextFormField(",
      "                  controller: _nameController,",
      "                  decoration: InputDecoration(labelText: 'Name'),",
      "                  validator: (val) =>",
      "                      val == null || val.trim().isEmpty ? 'Required' : null,",
      "                ),",
      "              ),",
      "              SizedBox(",
      "                width: 200,",
      "                child: TextFormField(",
      "                  controller: _priceController,",
      "                  decoration: InputDecoration(labelText: 'Price'),",
      "                ),",
      "              ),",
      "              SizedBox(",
      "                width: 150,",
      "                child: TextFormField(",
      "                  controller: _currencyController,",
      "                  decoration: InputDecoration(labelText: 'Currency'),",
      "                ),",
      "              ),",
      "              Row(",
      "                mainAxisSize: MainAxisSize.min,",
      "                children: [",
      "                  Switch(",
      "                      value: _active,",
      "                      onChanged: (v) => setState(() => _active = v)),",
      "                  const SizedBox(width: 8),",
      "                  const Text('Active')",
      "                ],",
      "              ),",
      "              Row(",
      "                mainAxisSize: MainAxisSize.min,",
      "                children: [",
      "                  Switch(",
      "                      value: _isCustom,",
      "                      onChanged: (v) => setState(() => _isCustom = v)),",
      "                  const SizedBox(width: 8),",
      "                  const Text('Custom Plan')",
      "                ],",
      "              ),",
      "              SizedBox(",
      "                width: 180,",
      "                child: TextFormField(",
      "                  controller: _intervalController,",
      "                  decoration: InputDecoration(labelText: 'Billing Interval'),",
      "                ),",
      "              ),",
      "              SizedBox(",
      "                width: 100,",
      "                child: TextFormField(",
      "                  controller: _versionController,",
      "                  decoration: InputDecoration(labelText: 'Version'),",
      "                ),",
      "              ),",
      "            ],",
      "          ),",
      "          const SizedBox(height: 16),",
      "          TextFormField(",
      "            controller: _descController,",
      "            maxLines: 3,",
      "            decoration: InputDecoration(labelText: 'Description'),",
      "          ),",
      "          const SizedBox(height: 24),",
      "          Row(",
      "            children: [",
      "              DropdownButton<String>(",
      "                value: _selectedFeatureToAdd,",
      "                hint: const Text('Add Feature'),",
      "                items: _availableFeatures",
      "                    .where((f) => !_selectedFeatures.contains(f))",
      "                    .map((feature) => DropdownMenuItem(",
      "                          value: feature,",
      "                          child: Text(feature),",
      "                        ))",
      "                    .toList(),",
      "                onChanged: (value) =>",
      "                    setState(() => _selectedFeatureToAdd = value),",
      "              ),",
      "              const SizedBox(width: 8),",
      "              ElevatedButton(",
      "                onPressed: _selectedFeatureToAdd == null ||",
      "                        _selectedFeatures.contains(_selectedFeatureToAdd)",
      "                    ? null",
      "                    : () => _addFeature(_selectedFeatureToAdd!),",
      "                child: const Text('+ Add'),",
      "              ),",
      "            ],",
      "          ),",
      "          const SizedBox(height: 8),",
      "          Wrap(",
      "            spacing: 8,",
      "            runSpacing: 8,",
      "            children: _selectedFeatures",
      "                .map((f) =>",
      "                    Chip(label: Text(f), onDeleted: () => _removeFeature(f)))",
      "                .toList(),",
      "          ),",
      "          const SizedBox(height: 24),",
      "          Row(",
      "            children: [",
      "              ElevatedButton.icon(",
      "                onPressed: _isSaving ? null : _handleSubmit,",
      "                icon: const Icon(Icons.save),",
      "                label: Text(_isSaving ? loc.saving : loc.seed),",
      "              ),",
      "              const SizedBox(width: 12),",
      "              OutlinedButton.icon(",
      "                onPressed: () {",
      "                  // TODO: Replace with JSON import/export dialog",
      "                  ScaffoldMessenger.of(context).showSnackBar(",
      "                    const SnackBar(content: Text('JSON Upload Placeholder')),",
      "                  );",
      "                },",
      "                icon: const Icon(Icons.upload_file),",
      "                label: const Text('Upload via JSON'),",
      "              ),",
      "              const SizedBox(width: 12),",
      "              if (_statusMessage != null)",
      "                Text(_statusMessage!,",
      "                    style: theme.textTheme.bodyMedium?.copyWith(",
      "                      color: theme.colorScheme.primary,",
      "                      fontWeight: FontWeight.w600,",
      "                    )),",
      "            ],",
      "          )",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "",
      "  @override",
      "  void dispose() {",
      "    _idController.dispose();",
      "    _nameController.dispose();",
      "    _descController.dispose();",
      "    _priceController.dispose();",
      "    _currencyController.dispose();",
      "    _intervalController.dispose();",
      "    _versionController.dispose();",
      "    super.dispose();",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 291,
      "file_size": 9951,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\devtools\\subscriptions\\manual_subscription_injector.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/models/platform_plan_model.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/services/franchise_subscription_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class ManualSubscriptionInjector extends StatefulWidget {",
      "  const ManualSubscriptionInjector({super.key});",
      "",
      "  @override",
      "  State<ManualSubscriptionInjector> createState() =>",
      "      _ManualSubscriptionInjectorState();",
      "}",
      "",
      "class _ManualSubscriptionInjectorState",
      "    extends State<ManualSubscriptionInjector> {",
      "  String? selectedFranchiseId;",
      "  PlatformPlan? selectedPlan;",
      "  String status = 'active'; // active | trial | paused",
      "  bool isSubmitting = false;",
      "",
      "  late Future<List<PlatformPlan>> platformPlansFuture;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    platformPlansFuture = FranchiseSubscriptionService().getPlatformPlans();",
      "  }",
      "",
      "  Future<void> _submit(BuildContext context) async {",
      "    final loc = AppLocalizations.of(context)!;",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "",
      "    if (selectedFranchiseId == null || selectedPlan == null) {",
      "      ScaffoldMessenger.of(context).showSnackBar(SnackBar(",
      "        content: Text(loc.pleaseSelectFranchiseAndPlan),",
      "        backgroundColor: colorScheme.error,",
      "      ));",
      "      return;",
      "    }",
      "",
      "    setState(() => isSubmitting = true);",
      "    final service = FranchiseSubscriptionService();",
      "",
      "    try {",
      "      await service.subscribeFranchiseToPlan(",
      "        franchiseId: selectedFranchiseId!,",
      "        plan: selectedPlan!,",
      "      );",
      "      ScaffoldMessenger.of(context).showSnackBar(SnackBar(",
      "        content: Text(loc.subscriptionInjectionSuccess),",
      "        backgroundColor: colorScheme.primary,",
      "      ));",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Manual Subscription Injection Failed',",
      "        stack: stack.toString(),",
      "        source: 'ManualSubscriptionInjector',",
      "        screen: 'manual_subscription_injector.dart',",
      "        severity: 'error',",
      "        contextData: {",
      "          'franchiseId': selectedFranchiseId,",
      "          'planId': selectedPlan?.id,",
      "          'error': e.toString(),",
      "        },",
      "      );",
      "      ScaffoldMessenger.of(context).showSnackBar(SnackBar(",
      "        content: Text('${loc.subscriptionInjectionFailed}: $e'),",
      "        backgroundColor: colorScheme.error,",
      "      ));",
      "    } finally {",
      "      setState(() => isSubmitting = false);",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context)!;",
      "    final franchiseProvider = context.watch<FranchiseProvider>();",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "",
      "    final franchises = franchiseProvider.viewableFranchises ?? [];",
      "",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        Text(loc.manualSubscriptionInjectorTitle,",
      "            style: theme.textTheme.titleMedium),",
      "        const SizedBox(height: 12),",
      "        DropdownButtonFormField<String>(",
      "          value: selectedFranchiseId,",
      "          decoration: InputDecoration(labelText: loc.selectFranchise),",
      "          items: franchises.map((f) {",
      "            return DropdownMenuItem<String>(",
      "              value: f.id,",
      "              child: Text('${f.name} (${f.id})'),",
      "            );",
      "          }).toList(),",
      "          onChanged: (val) => setState(() => selectedFranchiseId = val),",
      "        ),",
      "        const SizedBox(height: 12),",
      "        FutureBuilder<List<PlatformPlan>>(",
      "          future: platformPlansFuture,",
      "          builder: (context, snapshot) {",
      "            if (snapshot.connectionState == ConnectionState.waiting) {",
      "              return const LinearProgressIndicator();",
      "            }",
      "            final plans = snapshot.data ?? [];",
      "            return DropdownButtonFormField<PlatformPlan>(",
      "              value: selectedPlan,",
      "              decoration: InputDecoration(labelText: loc.selectPlan),",
      "              items: plans.map((plan) {",
      "                return DropdownMenuItem<PlatformPlan>(",
      "                  value: plan,",
      "                  child: Text(",
      "                      '${plan.name} (${plan.billingInterval}, \\$${plan.price})'),",
      "                );",
      "              }).toList(),",
      "              onChanged: (val) => setState(() => selectedPlan = val),",
      "            );",
      "          },",
      "        ),",
      "        const SizedBox(height: 12),",
      "        DropdownButtonFormField<String>(",
      "          value: status,",
      "          decoration: InputDecoration(labelText: loc.selectStatus),",
      "          items: ['active', 'trial', 'paused']",
      "              .map((s) => DropdownMenuItem(value: s, child: Text(s)))",
      "              .toList(),",
      "          onChanged: (val) => setState(() => status = val ?? 'active'),",
      "        ),",
      "        const SizedBox(height: 24),",
      "        ElevatedButton.icon(",
      "          icon: isSubmitting",
      "              ? const SizedBox(",
      "                  width: 20,",
      "                  height: 20,",
      "                  child: CircularProgressIndicator(strokeWidth: 2),",
      "                )",
      "              : const Icon(Icons.send),",
      "          label: Text(loc.injectSubscription),",
      "          onPressed: isSubmitting ? null : () => _submit(context),",
      "        ),",
      "        const SizedBox(height: 20),",
      "        // 💡 Future: support custom startDate or backdating UI here",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 153,
      "file_size": 5662,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\devtools\\subscriptions\\plan_swapper_tool.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/models/franchise_subscription_model.dart';",
      "import 'package:franchise_admin_portal/core/models/platform_plan_model.dart';",
      "import 'package:franchise_admin_portal/core/services/franchise_subscription_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class PlanSwapperTool extends StatefulWidget {",
      "  const PlanSwapperTool({super.key});",
      "",
      "  @override",
      "  State<PlanSwapperTool> createState() => _PlanSwapperToolState();",
      "}",
      "",
      "class _PlanSwapperToolState extends State<PlanSwapperTool> {",
      "  final _subscriptionService = FranchiseSubscriptionService();",
      "  FranchiseSubscription? _selectedSub;",
      "  PlatformPlan? _selectedPlan;",
      "  bool _saving = false;",
      "",
      "  Future<void> _handleSwap() async {",
      "    if (_selectedSub == null || _selectedPlan == null) return;",
      "",
      "    setState(() => _saving = true);",
      "    final loc = AppLocalizations.of(context)!;",
      "",
      "    try {",
      "      await _subscriptionService.subscribeFranchiseToPlan(",
      "        franchiseId: _selectedSub!.franchiseId,",
      "        plan: _selectedPlan!,",
      "      );",
      "",
      "      await ErrorLogger.log(",
      "        message: 'Plan manually swapped by developer',",
      "        source: 'PlanSwapperTool',",
      "        screen: 'subscription_dev_tools_screen',",
      "        contextData: {",
      "          'franchiseId': _selectedSub!.franchiseId,",
      "          'newPlanId': _selectedPlan!.id,",
      "        },",
      "      );",
      "",
      "      if (mounted) {",
      "        ScaffoldMessenger.of(context).showSnackBar(",
      "          SnackBar(content: Text(loc.genericSavedSuccess)),",
      "        );",
      "      }",
      "",
      "      setState(() {",
      "        _selectedSub = null;",
      "        _selectedPlan = null;",
      "      });",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to swap plan: $e',",
      "        source: 'PlanSwapperTool',",
      "        screen: 'subscription_dev_tools_screen',",
      "        stack: stack.toString(),",
      "        severity: 'error',",
      "      );",
      "    }",
      "",
      "    if (mounted) setState(() => _saving = false);",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context)!;",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        Text(loc.planSwapperTitle, style: theme.textTheme.titleMedium),",
      "        const SizedBox(height: 12),",
      "        StreamBuilder<List<FranchiseSubscription>>(",
      "          stream: _subscriptionService.watchAllFranchiseSubscriptions(),",
      "          builder: (context, snapshot) {",
      "            if (!snapshot.hasData) {",
      "              return const LinearProgressIndicator();",
      "            }",
      "",
      "            final subs = snapshot.data!;",
      "            return DropdownButtonFormField<FranchiseSubscription>(",
      "              value: subs.any((sub) => sub.id == _selectedSub?.id)",
      "                  ? _selectedSub",
      "                  : null,",
      "              decoration: InputDecoration(",
      "                labelText: loc.selectFranchise,",
      "                border: const OutlineInputBorder(),",
      "              ),",
      "              items: subs",
      "                  .map((sub) => DropdownMenuItem<FranchiseSubscription>(",
      "                        value: sub,",
      "                        child: Text('${sub.franchiseId} (${sub.status})'),",
      "                      ))",
      "                  .toList(),",
      "              onChanged: (val) => setState(() => _selectedSub = val),",
      "            );",
      "          },",
      "        ),",
      "        const SizedBox(height: 12),",
      "        FutureBuilder<List<PlatformPlan>>(",
      "          future: _subscriptionService.getAllPlatformPlans(),",
      "          builder: (context, snapshot) {",
      "            if (!snapshot.hasData) {",
      "              return const LinearProgressIndicator();",
      "            }",
      "",
      "            final plans = snapshot.data!;",
      "            return DropdownButtonFormField<PlatformPlan>(",
      "              value: plans.any((p) => p.id == _selectedPlan?.id)",
      "                  ? _selectedPlan",
      "                  : null,",
      "              decoration: InputDecoration(",
      "                labelText: loc.selectPlan,",
      "                border: const OutlineInputBorder(),",
      "              ),",
      "              items: plans",
      "                  .map((plan) => DropdownMenuItem(",
      "                        value: plan,",
      "                        child: Text('${plan.name} (${plan.billingInterval})'),",
      "                      ))",
      "                  .toList(),",
      "              onChanged: (val) => setState(() => _selectedPlan = val),",
      "            );",
      "          },",
      "        ),",
      "        const SizedBox(height: 16),",
      "        ElevatedButton.icon(",
      "          icon: _saving",
      "              ? const SizedBox(",
      "                  height: 18,",
      "                  width: 18,",
      "                  child: CircularProgressIndicator(strokeWidth: 2),",
      "                )",
      "              : const Icon(Icons.swap_horiz),",
      "          label: Text(loc.swap),",
      "          onPressed: _saving ? null : _handleSwap,",
      "        ),",
      "        const SizedBox(height: 20),",
      "        if (_selectedSub != null)",
      "          Text('${loc.franchiseIdLabel}: ${_selectedSub!.franchiseId}'),",
      "        // 💡 Future: Show before/after plan snapshot diff or audit trail",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 150,
      "file_size": 5325,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\devtools\\subscriptions\\subscription_dev_tools_screen.dart",
    "content": [
      "// File: lib/admin/developer/subscriptions/subscription_dev_tools_screen.dart",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/admin/devtools/subscriptions/manual_subscription_injector.dart';",
      "import 'package:franchise_admin_portal/admin/devtools/subscriptions/subscription_state_toggler.dart';",
      "import 'package:franchise_admin_portal/admin/devtools/subscriptions/plan_swapper_tool.dart';",
      "",
      "class SubscriptionDevToolsScreen extends StatelessWidget {",
      "  const SubscriptionDevToolsScreen({super.key});",
      "",
      "  void _showDevGuide(BuildContext context) {",
      "    showDialog(",
      "      context: context,",
      "      builder: (context) => AlertDialog(",
      "        title: const Text('🧾 Subscription Dev Tools Guide'),",
      "        content: SizedBox(",
      "          width: double.maxFinite,",
      "          child: SingleChildScrollView(",
      "            child: Column(",
      "              crossAxisAlignment: CrossAxisAlignment.start,",
      "              children: const [",
      "                Text('🔹 Manual Subscription Injector',",
      "                    style: TextStyle(fontWeight: FontWeight.bold)),",
      "                Text(",
      "                  'Create a new subscription manually for a selected franchise. '",
      "                  'Used for testing plans, onboarding flows, or plan migrations.',",
      "                ),",
      "                SizedBox(height: 12),",
      "                Text('🔹 Plan Swapper',",
      "                    style: TextStyle(fontWeight: FontWeight.bold)),",
      "                Text(",
      "                  'Replaces a franchise’s active subscription with a different plan. '",
      "                  'Keeps an audit trail of the change.',",
      "                ),",
      "                SizedBox(height: 12),",
      "                Text('🔹 State Toggler',",
      "                    style: TextStyle(fontWeight: FontWeight.bold)),",
      "                Text(",
      "                  'Quickly toggle the subscription between `active`, `paused`, and `canceled` states.',",
      "                ),",
      "                SizedBox(height: 12),",
      "                Text('🔹 Trial Expiry Simulator',",
      "                    style: TextStyle(fontWeight: FontWeight.bold)),",
      "                Text(",
      "                  'Forcefully end or extend a trial period to test onboarding or expiration logic.',",
      "                ),",
      "                SizedBox(height: 12),",
      "                Text('🔹 Raw Snapshot Viewer',",
      "                    style: TextStyle(fontWeight: FontWeight.bold)),",
      "                Text(",
      "                  'View the raw Firestore data for a franchise’s subscription. Useful for debugging.',",
      "                ),",
      "                SizedBox(height: 12),",
      "                Text('🔹 Billing Schedule Debugger',",
      "                    style: TextStyle(fontWeight: FontWeight.bold)),",
      "                Text(",
      "                  'Visualize and verify upcoming billing anchors, renewal dates, and status transitions.',",
      "                ),",
      "              ],",
      "            ),",
      "          ),",
      "        ),",
      "        actions: [",
      "          TextButton(",
      "            child: const Text('Close'),",
      "            onPressed: () => Navigator.of(context).pop(),",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context)!;",
      "    return Scaffold(",
      "      appBar: AppBar(",
      "        title: Text(",
      "          loc.subscriptionTools,",
      "          style: Theme.of(context).textTheme.titleLarge?.copyWith(",
      "                fontWeight: FontWeight.bold,",
      "                color: Colors.black,",
      "              ),",
      "        ),",
      "        automaticallyImplyLeading: false,",
      "        backgroundColor: Theme.of(context).scaffoldBackgroundColor,",
      "        elevation: 0,",
      "        iconTheme: const IconThemeData(color: Colors.black),",
      "        actions: [",
      "          IconButton(",
      "            icon: const Icon(Icons.help_outline),",
      "            tooltip: 'Tool Guide',",
      "            onPressed: () => _showDevGuide(context),",
      "          ),",
      "        ],",
      "      ),",
      "      body: SafeArea(",
      "        child: SingleChildScrollView(",
      "          padding: const EdgeInsets.all(16),",
      "          child: Column(",
      "            crossAxisAlignment: CrossAxisAlignment.start,",
      "            children: const [",
      "              Text(",
      "                '🧩 Manual Controls',",
      "                style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),",
      "              ),",
      "              SizedBox(height: 16),",
      "              ManualSubscriptionInjector(),",
      "",
      "              SizedBox(height: 24),",
      "              const PlanSwapperTool(),",
      "",
      "              SizedBox(height: 24),",
      "              const SubscriptionStateToggler(),",
      "",
      "              SizedBox(height: 32),",
      "              Text(",
      "                '⏳ Trial Tools',",
      "                style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),",
      "              ),",
      "              SizedBox(height: 16),",
      "              Placeholder(",
      "                fallbackHeight: 50,",
      "                color: Colors.redAccent,",
      "              ), // TODO: TrialExpirySimulator()",
      "",
      "              SizedBox(height: 32),",
      "              Text(",
      "                '🛠 Debugging & Snapshots',",
      "                style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),",
      "              ),",
      "              SizedBox(height: 16),",
      "              Placeholder(",
      "                fallbackHeight: 60,",
      "                color: Colors.grey,",
      "              ), // TODO: RawSubscriptionSnapshotViewer()",
      "",
      "              SizedBox(height: 24),",
      "              Placeholder(",
      "                fallbackHeight: 50,",
      "                color: Colors.indigo,",
      "              ), // TODO: BillingScheduleDebugger()",
      "            ],",
      "          ),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 149,
      "file_size": 5666,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\devtools\\subscriptions\\subscription_state_toggler.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/models/franchise_subscription_model.dart';",
      "import 'package:franchise_admin_portal/core/services/franchise_subscription_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "",
      "class SubscriptionStateToggler extends StatefulWidget {",
      "  const SubscriptionStateToggler({super.key});",
      "",
      "  @override",
      "  State<SubscriptionStateToggler> createState() =>",
      "      _SubscriptionStateTogglerState();",
      "}",
      "",
      "class _SubscriptionStateTogglerState extends State<SubscriptionStateToggler> {",
      "  FranchiseSubscription? _selectedSubscription;",
      "  String? _selectedState;",
      "  bool _saving = false;",
      "",
      "  final _states = ['active', 'paused', 'cancelled'];",
      "",
      "  Future<void> _updateStatus() async {",
      "    if (_selectedSubscription == null || _selectedState == null) return;",
      "    setState(() => _saving = true);",
      "",
      "    try {",
      "      await FranchiseSubscriptionService().updateFranchiseSubscription(",
      "        documentId: _selectedSubscription!.id,",
      "        data: {",
      "          'status': _selectedState,",
      "          'active': _selectedState == 'active',",
      "        },",
      "      );",
      "",
      "      await ErrorLogger.log(",
      "        message: 'Manually updated subscription status',",
      "        source: 'SubscriptionStateToggler',",
      "        screen: 'subscription_dev_tools_screen',",
      "        contextData: {",
      "          'franchiseId': _selectedSubscription!.franchiseId,",
      "          'newStatus': _selectedState,",
      "        },",
      "      );",
      "",
      "      if (mounted) {",
      "        ScaffoldMessenger.of(context).showSnackBar(",
      "          SnackBar(",
      "            content: Text(AppLocalizations.of(context)!.genericSavedSuccess),",
      "          ),",
      "        );",
      "      }",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to update subscription status: $e',",
      "        source: 'SubscriptionStateToggler',",
      "        screen: 'subscription_dev_tools_screen',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "      );",
      "    }",
      "",
      "    setState(() => _saving = false);",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context)!;",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "",
      "    return StreamBuilder<List<FranchiseSubscription>>(",
      "      stream: FranchiseSubscriptionService().watchAllFranchiseSubscriptions(),",
      "      builder: (context, snapshot) {",
      "        if (snapshot.connectionState == ConnectionState.waiting) {",
      "          return const Center(child: CircularProgressIndicator());",
      "        }",
      "",
      "        final subscriptions = snapshot.data ?? [];",
      "",
      "        return Column(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            Text(loc.toggleSubscriptionTitle,",
      "                style: theme.textTheme.titleMedium),",
      "            const SizedBox(height: 12),",
      "            DropdownButtonFormField<FranchiseSubscription>(",
      "              value: _selectedSubscription != null",
      "                  ? subscriptions.firstWhere(",
      "                      (s) => s.id == _selectedSubscription!.id,",
      "                      orElse: () => subscriptions.first,",
      "                    )",
      "                  : null,",
      "              items: subscriptions.map((sub) {",
      "                return DropdownMenuItem(",
      "                  value: sub,",
      "                  child: Text('${sub.franchiseId} (${sub.status})'),",
      "                );",
      "              }).toList(),",
      "              onChanged: (val) {",
      "                setState(() {",
      "                  _selectedSubscription = val;",
      "                  _selectedState = val?.status;",
      "                });",
      "              },",
      "              decoration: InputDecoration(",
      "                labelText: loc.selectFranchise,",
      "                border: const OutlineInputBorder(),",
      "              ),",
      "            ),",
      "            const SizedBox(height: 12),",
      "            DropdownButtonFormField<String>(",
      "              value: _selectedState,",
      "              items: _states.map((state) {",
      "                return DropdownMenuItem(",
      "                  value: state,",
      "                  child: Text(state.toUpperCase()),",
      "                );",
      "              }).toList(),",
      "              onChanged: (val) => setState(() => _selectedState = val),",
      "              decoration: InputDecoration(",
      "                labelText: loc.statusLabel,",
      "                border: const OutlineInputBorder(),",
      "              ),",
      "            ),",
      "            const SizedBox(height: 16),",
      "            ElevatedButton.icon(",
      "              icon: _saving",
      "                  ? const SizedBox(",
      "                      height: 18,",
      "                      width: 18,",
      "                      child: CircularProgressIndicator(strokeWidth: 2),",
      "                    )",
      "                  : const Icon(Icons.save),",
      "              label: Text(loc.save),",
      "              onPressed: _saving ? null : _updateStatus,",
      "            ),",
      "            const SizedBox(height: 20),",
      "            if (_selectedSubscription != null) ...[",
      "              Text(",
      "                  '${loc.franchiseIdLabel}: ${_selectedSubscription!.franchiseId}'),",
      "              Text(",
      "                  '${loc.startDateLabel}: ${_selectedSubscription!.startDate.toIso8601String()}'),",
      "              Text(",
      "                  '${loc.nextBillingDateLabel}: ${_selectedSubscription!.nextBillingDate.toIso8601String()}'),",
      "            ],",
      "          ],",
      "        );",
      "      },",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 153,
      "file_size": 5596,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\devtools\\widgets\\dev_tools_sidebar_group.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/core/models/dashboard_section.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "",
      "class DevToolsSidebarGroup extends StatefulWidget {",
      "  final List<DashboardSection> tools;",
      "  final int selectedIndex;",
      "  final ValueChanged<int> onSelect;",
      "  final String label;",
      "  final IconData icon;",
      "  final int startIndexOffset;",
      "",
      "  const DevToolsSidebarGroup({",
      "    super.key,",
      "    required this.tools,",
      "    required this.selectedIndex,",
      "    required this.onSelect,",
      "    this.label = 'Dev Tools',",
      "    this.icon = Icons.build_outlined,",
      "    this.startIndexOffset = 0,",
      "  });",
      "",
      "  @override",
      "  State<DevToolsSidebarGroup> createState() => _DevToolsSidebarGroupState();",
      "}",
      "",
      "class _DevToolsSidebarGroupState extends State<DevToolsSidebarGroup> {",
      "  bool _expanded = true;",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "    final isSelectedGroup = widget.tools.any((section) =>",
      "        widget.selectedIndex == section.sidebarOrder + widget.startIndexOffset);",
      "",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        ListTile(",
      "          contentPadding: const EdgeInsets.symmetric(horizontal: 16),",
      "          leading: Icon(widget.icon,",
      "              color: isSelectedGroup",
      "                  ? colorScheme.primary",
      "                  : colorScheme.onSurfaceVariant),",
      "          title: Text(",
      "            widget.label,",
      "            style: theme.textTheme.titleSmall?.copyWith(",
      "              fontWeight: FontWeight.w600,",
      "              color:",
      "                  isSelectedGroup ? colorScheme.primary : colorScheme.onSurface,",
      "            ),",
      "          ),",
      "          trailing: Icon(",
      "            _expanded ? Icons.expand_less : Icons.expand_more,",
      "            color: colorScheme.onSurfaceVariant,",
      "            size: 20,",
      "          ),",
      "          onTap: () => setState(() => _expanded = !_expanded),",
      "        ),",
      "        if (_expanded)",
      "          ...widget.tools.map((section) {",
      "            final index = section.sidebarOrder + widget.startIndexOffset;",
      "            final selected = index == widget.selectedIndex;",
      "",
      "            return Padding(",
      "              padding: const EdgeInsets.only(left: 12),",
      "              child: Material(",
      "                color: selected",
      "                    ? colorScheme.primaryContainer.withOpacity(0.15)",
      "                    : Colors.transparent,",
      "                borderRadius: BorderRadius.circular(8),",
      "                child: InkWell(",
      "                  borderRadius: BorderRadius.circular(8),",
      "                  onTap: () => widget.onSelect(index),",
      "                  child: Container(",
      "                    padding: const EdgeInsets.symmetric(",
      "                        horizontal: 12, vertical: 10),",
      "                    child: Row(",
      "                      children: [",
      "                        Icon(",
      "                          section.icon,",
      "                          size: 20,",
      "                          color: selected",
      "                              ? colorScheme.primary",
      "                              : colorScheme.onSurfaceVariant,",
      "                        ),",
      "                        const SizedBox(width: 12),",
      "                        Expanded(",
      "                          child: Text(",
      "                            section.title,",
      "                            style: theme.textTheme.bodySmall?.copyWith(",
      "                              fontWeight: selected",
      "                                  ? FontWeight.bold",
      "                                  : FontWeight.normal,",
      "                              color: selected",
      "                                  ? colorScheme.primary",
      "                                  : colorScheme.onSurface,",
      "                            ),",
      "                          ),",
      "                        ),",
      "                      ],",
      "                    ),",
      "                  ),",
      "                ),",
      "              ),",
      "            );",
      "          }),",
      "        const SizedBox(height: 12),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 113,
      "file_size": 4091,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\error_logs\\error_logs_screen.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/models/error_log.dart';",
      "import 'widgets/paginated_error_log_table.dart';",
      "import 'widgets/error_log_filter_bar.dart';",
      "import 'widgets/error_log_stats_bar.dart';",
      "import 'package:franchise_admin_portal/core/providers/user_profile_notifier.dart';",
      "import 'package:franchise_admin_portal/widgets/clear_filters_button.dart';",
      "import 'package:franchise_admin_portal/widgets/admin/admin_empty_state_widget.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "",
      "class ErrorLogsScreen extends StatefulWidget {",
      "  const ErrorLogsScreen({super.key});",
      "",
      "  @override",
      "  State<ErrorLogsScreen> createState() => _ErrorLogsScreenState();",
      "}",
      "",
      "class _ErrorLogsScreenState extends State<ErrorLogsScreen> {",
      "  String? _severity = 'all';",
      "  String? _source;",
      "  String? _screen;",
      "  DateTime? _start;",
      "  DateTime? _end;",
      "  String? _search;",
      "  bool _showArchived = false;",
      "  bool? _showResolved = false;",
      "  static const _allowedRoles = ['owner', 'developer', 'admin', 'manager'];",
      "",
      "  void _updateFilters({",
      "    String? severity,",
      "    String? source,",
      "    String? screen,",
      "    DateTime? start,",
      "    DateTime? end,",
      "    String? search,",
      "  }) {",
      "    setState(() {",
      "      _severity = (severity == null || severity == 'null') ? 'all' : severity;",
      "      _source = source;",
      "      _screen = screen;",
      "      _start = start;",
      "      _end = end;",
      "      _search = search;",
      "    });",
      "  }",
      "",
      "  void _clearFilters() {",
      "    setState(() {",
      "      _severity = 'all';",
      "      _source = null;",
      "      _screen = null;",
      "      _start = null;",
      "      _end = null;",
      "      _search = null;",
      "      // Optionally: _showArchived = false; _showResolved = false;",
      "    });",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final franchiseId = context.watch<FranchiseProvider>().franchiseId;",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    final adminUserProvider = Provider.of<AdminUserProvider>(context);",
      "    final appUser = adminUserProvider.user;",
      "",
      "    if (appUser == null) {",
      "      return const Scaffold(",
      "        body: Center(child: CircularProgressIndicator()),",
      "      );",
      "    }",
      "",
      "    if (!appUser.roles.any((r) => _allowedRoles.contains(r))) {",
      "      return Scaffold(",
      "        body: AdminEmptyStateWidget(",
      "          title: loc.unauthorizedAccessTitle,",
      "          message: loc.unauthorizedAccessMessage,",
      "          icon: Icons.lock_outline,",
      "          actionLabel: loc.returnHome,",
      "          onAction: () =>",
      "              Navigator.of(context).popUntil((route) => route.isFirst),",
      "        ),",
      "      );",
      "    }",
      "",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    final String? querySeverity =",
      "        (_severity == 'all' || _severity == 'null') ? null : _severity;",
      "",
      "    return Scaffold(",
      "      backgroundColor: colorScheme.surface,",
      "      appBar: AppBar(",
      "        title: Text(loc.errorLogManagementTitle),",
      "        elevation: 0,",
      "        backgroundColor: colorScheme.surface,",
      "        centerTitle: false,",
      "      ),",
      "      body: Column(",
      "        crossAxisAlignment: CrossAxisAlignment.stretch,",
      "        children: [",
      "          // Stats bar",
      "          Material(",
      "            elevation: 1,",
      "            color: colorScheme.surface,",
      "            child: Padding(",
      "              padding:",
      "                  const EdgeInsets.symmetric(vertical: 8.0, horizontal: 16),",
      "              child: ErrorLogStatsBar(",
      "                severity: querySeverity,",
      "                start: _start,",
      "                end: _end,",
      "              ),",
      "            ),",
      "          ),",
      "          // Filter bar",
      "          Material(",
      "            elevation: 1,",
      "            color: colorScheme.surface,",
      "            child: Padding(",
      "              padding:",
      "                  const EdgeInsets.symmetric(vertical: 8.0, horizontal: 16),",
      "              child: ErrorLogFilterBar(",
      "                severity: _severity,",
      "                source: _source,",
      "                screen: _screen,",
      "                start: _start,",
      "                end: _end,",
      "                search: _search,",
      "                onFilterChanged: _updateFilters,",
      "                trailing: Row(",
      "                  mainAxisSize: MainAxisSize.min,",
      "                  children: [",
      "                    Tooltip(",
      "                      message: loc.toggleArchivedTooltip,",
      "                      child: Row(",
      "                        children: [",
      "                          Switch(",
      "                            value: _showArchived,",
      "                            onChanged: (val) =>",
      "                                setState(() => _showArchived = val),",
      "                          ),",
      "                          Text(",
      "                            _showArchived",
      "                                ? loc.showingArchived",
      "                                : loc.hideArchived,",
      "                            style: Theme.of(context).textTheme.labelLarge,",
      "                          ),",
      "                        ],",
      "                      ),",
      "                    ),",
      "                    const SizedBox(width: 20),",
      "                    Tooltip(",
      "                      message: loc.resolvedFilterTooltip,",
      "                      child: Row(",
      "                        children: [",
      "                          Text(\"${loc.resolved}:  \"),",
      "                          DropdownButton<bool?>(",
      "                            value: _showResolved,",
      "                            items: [",
      "                              DropdownMenuItem(",
      "                                value: null,",
      "                                child: Text(loc.all),",
      "                              ),",
      "                              DropdownMenuItem(",
      "                                value: false,",
      "                                child: Text(loc.unresolvedOnly),",
      "                              ),",
      "                              DropdownMenuItem(",
      "                                value: true,",
      "                                child: Text(loc.resolvedOnly),",
      "                              ),",
      "                            ],",
      "                            onChanged: (val) =>",
      "                                setState(() => _showResolved = val),",
      "                            underline: const SizedBox(),",
      "                            style: Theme.of(context).textTheme.bodyMedium,",
      "                          ),",
      "                        ],",
      "                      ),",
      "                    ),",
      "                    const SizedBox(width: 16),",
      "                    ClearFiltersButton(",
      "                      onClear: _clearFilters,",
      "                      enabled: _severity != 'all' ||",
      "                          _source != null ||",
      "                          _screen != null ||",
      "                          _start != null ||",
      "                          _end != null ||",
      "                          (_search != null && _search!.isNotEmpty),",
      "                    ),",
      "                  ],",
      "                ),",
      "              ),",
      "            ),",
      "          ),",
      "          const SizedBox(height: 4),",
      "          // Error log paginated table",
      "          Expanded(",
      "            child: Container(",
      "              color: colorScheme.background,",
      "              child: StreamBuilder<List<ErrorLog>>(",
      "                stream: context.read<FirestoreService>().streamErrorLogs(",
      "                      franchiseId,",
      "                      severity: querySeverity,",
      "                      source: _source,",
      "                      screen: _screen,",
      "                      start: _start,",
      "                      end: _end,",
      "                      search: _search,",
      "                      archived: _showArchived,",
      "                      showResolved: _showResolved,",
      "                    ),",
      "                builder: (context, snapshot) {",
      "                  if (snapshot.connectionState == ConnectionState.waiting) {",
      "                    return const Center(child: CircularProgressIndicator());",
      "                  }",
      "                  if (snapshot.hasError) {",
      "                    return AdminEmptyStateWidget(",
      "                      title: loc.errorLoadingTitle,",
      "                      message: loc.errorLoadingMessage,",
      "                      icon: Icons.error_outline,",
      "                      actionLabel: loc.retry,",
      "                      onAction: () => setState(() {}),",
      "                    );",
      "                  }",
      "                  final logs = snapshot.data ?? [];",
      "                  if (logs.isEmpty) {",
      "                    return AdminEmptyStateWidget(",
      "                      title: loc.noErrorLogsTitle,",
      "                      message: loc.noErrorLogsMessage,",
      "                      icon: Icons.inbox_rounded,",
      "                    );",
      "                  }",
      "                  // Always use paginated table, regardless of count",
      "                  return PaginatedErrorLogTable(",
      "                    logs: logs,",
      "                    rowsPerPage:",
      "                        5, // Use a small value for best fit, adjust as needed",
      "                  );",
      "                },",
      "              ),",
      "            ),",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 258,
      "file_size": 9468,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\error_logs\\widgets\\error_log_detail_drawer.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/core/models/error_log.dart';",
      "import 'package:intl/intl.dart';",
      "import 'dart:convert';",
      "import 'package:flutter/services.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/widgets/collapsible_panel.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "",
      "String _truncateTooltip(String text, [int max = 150]) {",
      "  if (text.length <= max) return text;",
      "  return text.substring(0, max) + '...';",
      "}",
      "",
      "class ErrorLogDetailDrawer extends StatefulWidget {",
      "  final ErrorLog log;",
      "  const ErrorLogDetailDrawer({Key? key, required this.log}) : super(key: key);",
      "",
      "  @override",
      "  State<ErrorLogDetailDrawer> createState() => _ErrorLogDetailDrawerState();",
      "}",
      "",
      "class _ErrorLogDetailDrawerState extends State<ErrorLogDetailDrawer> {",
      "  final _commentController = TextEditingController();",
      "  bool _isCommenting = false;",
      "  bool _isResolving = false;",
      "  bool _isArchiving = false;",
      "  late ErrorLog log;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    log = widget.log;",
      "  }",
      "",
      "  Future<void> _addComment() async {",
      "    final franchiseId =",
      "        Provider.of<FranchiseProvider>(context, listen: false).franchiseId;",
      "    final text = _commentController.text.trim();",
      "    if (text.isEmpty) return;",
      "    setState(() => _isCommenting = true);",
      "    try {",
      "      final comment = {",
      "        'text': text,",
      "        'userId': log.userId ?? 'system',",
      "        'timestamp': DateTime.now().toIso8601String(),",
      "      };",
      "      await context",
      "          .read<FirestoreService>()",
      "          .addCommentToErrorLog(franchiseId, log.id, comment);",
      "      setState(() {",
      "        log = log.copyWith(",
      "          comments: List<Map<String, dynamic>>.from(log.comments)..add(comment),",
      "        );",
      "        _commentController.clear();",
      "      });",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "          SnackBar(content: Text(AppLocalizations.of(context)!.commentAdded)));",
      "    } finally {",
      "      setState(() => _isCommenting = false);",
      "    }",
      "  }",
      "",
      "  Future<void> _toggleResolved() async {",
      "    final franchiseId =",
      "        Provider.of<FranchiseProvider>(context, listen: false).franchiseId;",
      "    setState(() => _isResolving = true);",
      "    try {",
      "      await context",
      "          .read<FirestoreService>()",
      "          .setErrorLogStatus(franchiseId, log.id, resolved: !(log.resolved));",
      "      setState(() {",
      "        log = log.copyWith(resolved: !log.resolved);",
      "      });",
      "    } finally {",
      "      setState(() => _isResolving = false);",
      "    }",
      "  }",
      "",
      "  Future<void> _toggleArchived() async {",
      "    final franchiseId =",
      "        Provider.of<FranchiseProvider>(context, listen: false).franchiseId;",
      "    setState(() => _isArchiving = true);",
      "    try {",
      "      await context",
      "          .read<FirestoreService>()",
      "          .setErrorLogStatus(franchiseId, log.id, archived: !(log.archived));",
      "      setState(() {",
      "        log = log.copyWith(archived: !log.archived);",
      "      });",
      "    } finally {",
      "      setState(() => _isArchiving = false);",
      "    }",
      "  }",
      "",
      "  String _timeAgo(DateTime timestamp) {",
      "    final now = DateTime.now();",
      "    final diff = now.difference(timestamp);",
      "    if (diff.inMinutes < 1) return AppLocalizations.of(context)!.justNow;",
      "    if (diff.inMinutes < 60)",
      "      return AppLocalizations.of(context)!.minutesAgo(diff.inMinutes);",
      "    if (diff.inHours < 24)",
      "      return AppLocalizations.of(context)!.hoursAgo(diff.inHours);",
      "    return AppLocalizations.of(context)!.daysAgo(diff.inDays);",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final franchiseId = context.watch<FranchiseProvider>().franchiseId;",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "",
      "    return Dialog(",
      "      insetPadding: const EdgeInsets.all(32),",
      "      backgroundColor: colorScheme.surface,",
      "      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),",
      "      child: Container(",
      "        width: 600,",
      "        padding: const EdgeInsets.all(28),",
      "        child: SingleChildScrollView(",
      "          child: Column(",
      "            crossAxisAlignment: CrossAxisAlignment.start,",
      "            children: [",
      "              Text(loc.errorDetailsTitle,",
      "                  style: Theme.of(context).textTheme.titleLarge),",
      "              const SizedBox(height: 10),",
      "              Row(",
      "                children: [",
      "                  Icon(",
      "                    log.severity.toLowerCase() == 'fatal'",
      "                        ? Icons.error",
      "                        : Icons.warning,",
      "                    color: log.severity.toLowerCase() == 'fatal'",
      "                        ? colorScheme.error",
      "                        : colorScheme.secondary,",
      "                    size: 28,",
      "                  ),",
      "                  const SizedBox(width: 8),",
      "                  Text(",
      "                    log.severity,",
      "                    style: TextStyle(",
      "                      color: log.severity.toLowerCase() == 'fatal'",
      "                          ? colorScheme.error",
      "                          : colorScheme.secondary,",
      "                      fontWeight: FontWeight.bold,",
      "                      fontSize: 20,",
      "                    ),",
      "                  ),",
      "                  const Spacer(),",
      "                  Text(DateFormat('yyyy-MM-dd HH:mm').format(log.timestamp),",
      "                      style: TextStyle(",
      "                          color: colorScheme.onSurface.withOpacity(0.7))),",
      "                ],",
      "              ),",
      "              const SizedBox(height: 18),",
      "              SelectableText(",
      "                log.message,",
      "                style:",
      "                    const TextStyle(fontSize: 16, fontWeight: FontWeight.w500),",
      "              ),",
      "",
      "              if (log.stackTrace != null && log.stackTrace!.isNotEmpty) ...[",
      "                const SizedBox(height: 18),",
      "                CollapsiblePanel(",
      "                  title: loc.stackTraceSection,",
      "                  child: Container(",
      "                    width: double.infinity,",
      "                    color: colorScheme.surfaceVariant,",
      "                    padding: const EdgeInsets.all(10),",
      "                    child: SingleChildScrollView(",
      "                      scrollDirection: Axis.horizontal,",
      "                      child: SelectableText(",
      "                        log.stackTrace!,",
      "                        style: const TextStyle(",
      "                            fontFamily: 'monospace', fontSize: 13),",
      "                      ),",
      "                    ),",
      "                  ),",
      "                ),",
      "              ],",
      "              if (log.contextData != null && log.contextData!.isNotEmpty) ...[",
      "                const SizedBox(height: 8),",
      "                CollapsiblePanel(",
      "                  title: loc.contextDataSection,",
      "                  child: Container(",
      "                    width: double.infinity,",
      "                    color: colorScheme.surfaceVariant,",
      "                    padding: const EdgeInsets.all(10),",
      "                    child: SingleChildScrollView(",
      "                      scrollDirection: Axis.horizontal,",
      "                      child: SelectableText(",
      "                        const JsonEncoder.withIndent('  ')",
      "                            .convert(log.contextData),",
      "                        style: const TextStyle(",
      "                            fontFamily: 'monospace', fontSize: 13),",
      "                      ),",
      "                    ),",
      "                  ),",
      "                ),",
      "              ],",
      "              if (log.deviceInfo != null && log.deviceInfo!.isNotEmpty) ...[",
      "                const SizedBox(height: 8),",
      "                CollapsiblePanel(",
      "                  title: loc.deviceInfoSection,",
      "                  child: Container(",
      "                    width: double.infinity,",
      "                    color: colorScheme.surfaceVariant,",
      "                    padding: const EdgeInsets.all(10),",
      "                    child: SingleChildScrollView(",
      "                      scrollDirection: Axis.horizontal,",
      "                      child: SelectableText(",
      "                        const JsonEncoder.withIndent('  ')",
      "                            .convert(log.deviceInfo),",
      "                        style: const TextStyle(",
      "                            fontFamily: 'monospace', fontSize: 13),",
      "                      ),",
      "                    ),",
      "                  ),",
      "                ),",
      "              ],",
      "              const SizedBox(height: 18),",
      "              Wrap(",
      "                spacing: 12,",
      "                children: [",
      "                  Tooltip(",
      "                    message: log.resolved",
      "                        ? loc.resolvedTooltip",
      "                        : loc.unresolvedTooltip,",
      "                    child: Chip(",
      "                      avatar: Icon(",
      "                        log.resolved",
      "                            ? Icons.check_circle",
      "                            : Icons.radio_button_unchecked,",
      "                        color: log.resolved",
      "                            ? colorScheme.secondary",
      "                            : colorScheme.outline,",
      "                      ),",
      "                      label: Text(",
      "                        log.resolved ? loc.resolved : loc.unresolvedOnly,",
      "                        style: TextStyle(",
      "                          color: log.resolved",
      "                              ? colorScheme.secondary",
      "                              : colorScheme.outline,",
      "                        ),",
      "                      ),",
      "                    ),",
      "                  ),",
      "                  Tooltip(",
      "                    message: log.archived",
      "                        ? loc.archivedTooltip",
      "                        : loc.notArchivedTooltip,",
      "                    child: Chip(",
      "                      avatar: Icon(",
      "                        log.archived ? Icons.archive : Icons.unarchive,",
      "                        color: log.archived",
      "                            ? colorScheme.secondary",
      "                            : colorScheme.outline,",
      "                      ),",
      "                      label: Text(",
      "                        log.archived ? loc.archived : loc.active,",
      "                        style: TextStyle(",
      "                          color: log.archived",
      "                              ? colorScheme.secondary",
      "                              : colorScheme.outline,",
      "                        ),",
      "                      ),",
      "                    ),",
      "                  ),",
      "                  if (log.userId != null)",
      "                    Tooltip(",
      "                      message: loc.userIdTooltip,",
      "                      child: Chip(",
      "                        avatar: const Icon(Icons.person),",
      "                        label: Text(\"${loc.userLabel}: ${log.userId!}\"),",
      "                      ),",
      "                    ),",
      "                ],",
      "              ),",
      "              if (log.comments.isNotEmpty) ...[",
      "                const SizedBox(height: 22),",
      "                Text(loc.commentsSection,",
      "                    style: Theme.of(context).textTheme.titleMedium),",
      "                Column(",
      "                  children: log.comments.map((comment) {",
      "                    DateTime? timestamp;",
      "                    if (comment['timestamp'] != null) {",
      "                      timestamp = DateTime.tryParse(comment['timestamp']);",
      "                    }",
      "                    final timeAgo =",
      "                        timestamp != null ? _timeAgo(timestamp) : '';",
      "                    return Container(",
      "                      alignment: Alignment.centerLeft,",
      "                      margin: const EdgeInsets.symmetric(vertical: 6),",
      "                      padding: const EdgeInsets.all(8),",
      "                      decoration: BoxDecoration(",
      "                        color: colorScheme.surfaceVariant,",
      "                        borderRadius: BorderRadius.circular(8),",
      "                      ),",
      "                      child: Row(",
      "                        crossAxisAlignment: CrossAxisAlignment.start,",
      "                        children: [",
      "                          Icon(Icons.comment,",
      "                              color: colorScheme.secondary, size: 18),",
      "                          const SizedBox(width: 6),",
      "                          Expanded(",
      "                            child: Text(",
      "                              comment['text'] ?? '',",
      "                              style: const TextStyle(fontSize: 13),",
      "                            ),",
      "                          ),",
      "                          if (comment['userId'] != null)",
      "                            Padding(",
      "                              padding: const EdgeInsets.only(left: 12.0),",
      "                              child: CircleAvatar(",
      "                                radius: 10,",
      "                                backgroundColor: colorScheme.primaryContainer,",
      "                                child: Text(",
      "                                  (comment['userId'] as String?)?.isNotEmpty ==",
      "                                          true",
      "                                      ? comment['userId'][0].toUpperCase()",
      "                                      : '',",
      "                                  style: TextStyle(",
      "                                    fontSize: 12,",
      "                                    color: colorScheme.onPrimaryContainer,",
      "                                    fontWeight: FontWeight.bold,",
      "                                  ),",
      "                                ),",
      "                              ),",
      "                            ),",
      "                          if (timeAgo.isNotEmpty)",
      "                            Padding(",
      "                              padding: const EdgeInsets.only(left: 8.0),",
      "                              child: Text(",
      "                                timeAgo,",
      "                                style: TextStyle(",
      "                                    fontSize: 11,",
      "                                    color: colorScheme.onSurfaceVariant),",
      "                              ),",
      "                            ),",
      "                        ],",
      "                      ),",
      "                    );",
      "                  }).toList(),",
      "                ),",
      "              ],",
      "              // Add comment box",
      "              const SizedBox(height: 18),",
      "              TextField(",
      "                controller: _commentController,",
      "                decoration: InputDecoration(",
      "                  hintText: loc.addCommentHint,",
      "                  suffixIcon: _isCommenting",
      "                      ? Padding(",
      "                          padding: const EdgeInsets.all(8.0),",
      "                          child: SizedBox(",
      "                              width: 16,",
      "                              height: 16,",
      "                              child: CircularProgressIndicator(strokeWidth: 2)),",
      "                        )",
      "                      : IconButton(",
      "                          icon: const Icon(Icons.send),",
      "                          tooltip: loc.addCommentTooltip,",
      "                          onPressed: _isCommenting ? null : _addComment,",
      "                        ),",
      "                  border: OutlineInputBorder(",
      "                    borderRadius: BorderRadius.circular(8),",
      "                  ),",
      "                  isDense: true,",
      "                ),",
      "                minLines: 1,",
      "                maxLines: 4,",
      "                enabled: !_isCommenting,",
      "              ),",
      "              const SizedBox(height: 18),",
      "              IntrinsicWidth(",
      "                child: Row(",
      "                  mainAxisAlignment: MainAxisAlignment.spaceBetween,",
      "                  children: [",
      "                    Flexible(",
      "                      child: Tooltip(",
      "                        message: loc.copyErrorTooltip,",
      "                        child: ElevatedButton.icon(",
      "                          icon: const Icon(Icons.copy),",
      "                          label: Text(loc.copy),",
      "                          onPressed: () {",
      "                            final errorJson = log.toJson();",
      "                            Clipboard.setData(ClipboardData(",
      "                                text: const JsonEncoder.withIndent('  ')",
      "                                    .convert(errorJson)));",
      "                            ScaffoldMessenger.of(context).showSnackBar(",
      "                                SnackBar(content: Text(loc.copiedJson)));",
      "                          },",
      "                          style: ElevatedButton.styleFrom(",
      "                            backgroundColor: colorScheme.primary,",
      "                            foregroundColor: colorScheme.onPrimary,",
      "                            minimumSize: const Size(",
      "                                96, 44), // 96 is a good web min width",
      "                          ),",
      "                        ),",
      "                      ),",
      "                    ),",
      "                    const SizedBox(width: 12),",
      "                    Flexible(",
      "                      child: Tooltip(",
      "                        message: log.resolved",
      "                            ? loc.unresolveTooltip",
      "                            : loc.resolveTooltip,",
      "                        child: ElevatedButton.icon(",
      "                          icon: Icon(log.resolved",
      "                              ? Icons.radio_button_unchecked",
      "                              : Icons.check_circle),",
      "                          label:",
      "                              Text(log.resolved ? loc.unresolve : loc.resolve),",
      "                          onPressed: _isResolving ? null : _toggleResolved,",
      "                          style: ElevatedButton.styleFrom(",
      "                            backgroundColor: colorScheme.secondary,",
      "                            foregroundColor: colorScheme.onSecondary,",
      "                            minimumSize: const Size(96, 44),",
      "                          ),",
      "                        ),",
      "                      ),",
      "                    ),",
      "                    const SizedBox(width: 12),",
      "                    Flexible(",
      "                      child: Tooltip(",
      "                        message: log.archived",
      "                            ? loc.unarchiveTooltip",
      "                            : loc.archiveTooltip,",
      "                        child: ElevatedButton.icon(",
      "                          icon: Icon(log.archived",
      "                              ? Icons.unarchive",
      "                              : Icons.archive_outlined),",
      "                          label:",
      "                              Text(log.archived ? loc.unarchive : loc.archive),",
      "                          onPressed: _isArchiving ? null : _toggleArchived,",
      "                          style: ElevatedButton.styleFrom(",
      "                            backgroundColor: colorScheme.tertiary,",
      "                            foregroundColor: colorScheme.onTertiary,",
      "                            minimumSize: const Size(96, 44),",
      "                          ),",
      "                        ),",
      "                      ),",
      "                    ),",
      "                    const SizedBox(width: 12),",
      "                    Flexible(",
      "                      child: Tooltip(",
      "                        message: loc.closeTooltip,",
      "                        child: ElevatedButton.icon(",
      "                          icon: const Icon(Icons.close),",
      "                          label: Text(loc.close),",
      "                          style: ElevatedButton.styleFrom(",
      "                            backgroundColor: colorScheme.primary,",
      "                            foregroundColor: colorScheme.onPrimary,",
      "                            minimumSize: const Size(96, 44),",
      "                          ),",
      "                          onPressed: () => Navigator.of(context).pop(),",
      "                        ),",
      "                      ),",
      "                    ),",
      "                  ],",
      "                ),",
      "              )",
      "            ],",
      "          ),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "extension ErrorLogCopyWith on ErrorLog {",
      "  ErrorLog copyWith({",
      "    String? id,",
      "    String? message,",
      "    String? severity,",
      "    String? source,",
      "    String? screen,",
      "    String? stackTrace,",
      "    Map<String, dynamic>? contextData,",
      "    Map<String, dynamic>? deviceInfo,",
      "    String? userId,",
      "    String? errorType,",
      "    String? assignedTo,",
      "    bool? resolved,",
      "    bool? archived,",
      "    List<Map<String, dynamic>>? comments,",
      "    DateTime? timestamp,",
      "    DateTime? updatedAt,",
      "  }) {",
      "    return ErrorLog(",
      "      id: id ?? this.id,",
      "      message: message ?? this.message,",
      "      severity: severity ?? this.severity,",
      "      source: source ?? this.source,",
      "      screen: screen ?? this.screen,",
      "      stackTrace: stackTrace ?? this.stackTrace,",
      "      contextData: contextData ?? this.contextData,",
      "      deviceInfo: deviceInfo ?? this.deviceInfo,",
      "      userId: userId ?? this.userId,",
      "      errorType: errorType ?? this.errorType,",
      "      assignedTo: assignedTo ?? this.assignedTo,",
      "      resolved: resolved ?? this.resolved,",
      "      archived: archived ?? this.archived,",
      "      comments: comments ?? this.comments,",
      "      timestamp: timestamp ?? this.timestamp,",
      "      updatedAt: updatedAt ?? this.updatedAt,",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 518,
      "file_size": 21173,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\error_logs\\widgets\\error_log_filter_bar.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:intl/intl.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "",
      "class ErrorLogFilterBar extends StatelessWidget {",
      "  final String? severity;",
      "  final String? source;",
      "  final String? screen;",
      "  final DateTime? start;",
      "  final DateTime? end;",
      "  final String? search;",
      "  final void Function({",
      "    String? severity,",
      "    String? source,",
      "    String? screen,",
      "    DateTime? start,",
      "    DateTime? end,",
      "    String? search,",
      "  }) onFilterChanged;",
      "  final Widget? trailing;",
      "",
      "  const ErrorLogFilterBar({",
      "    super.key,",
      "    required this.severity,",
      "    required this.source,",
      "    required this.screen,",
      "    required this.start,",
      "    required this.end,",
      "    required this.search,",
      "    required this.onFilterChanged,",
      "    this.trailing,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "",
      "    final searchController = TextEditingController(text: search ?? '');",
      "    final sourceController = TextEditingController(text: source ?? '');",
      "    final screenController = TextEditingController(text: screen ?? '');",
      "",
      "    return Padding(",
      "      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),",
      "      child: Row(",
      "        crossAxisAlignment: CrossAxisAlignment.center,",
      "        children: [",
      "          Expanded(",
      "            child: Wrap(",
      "              spacing: 16,",
      "              runSpacing: 8,",
      "              crossAxisAlignment: WrapCrossAlignment.center,",
      "              children: [",
      "                Tooltip(",
      "                  message: loc.severityTooltip,",
      "                  child: DropdownButton<String>(",
      "                    value: severity ?? 'all',",
      "                    hint: Text(loc.severity),",
      "                    items: [",
      "                      DropdownMenuItem(value: 'all', child: Text(loc.all)),",
      "                      DropdownMenuItem(value: 'fatal', child: Text(loc.fatal)),",
      "                      DropdownMenuItem(",
      "                          value: 'warning', child: Text(loc.warning)),",
      "                      DropdownMenuItem(value: 'info', child: Text(loc.info)),",
      "                    ],",
      "                    onChanged: (val) => onFilterChanged(",
      "                      severity: (val == null || val == 'all' || val == 'null')",
      "                          ? null",
      "                          : val,",
      "                      source: source,",
      "                      screen: screen,",
      "                      start: start,",
      "                      end: end,",
      "                      search: search,",
      "                    ),",
      "                  ),",
      "                ),",
      "                SizedBox(",
      "                  width: 130,",
      "                  child: Tooltip(",
      "                    message: loc.sourceTooltip,",
      "                    child: TextField(",
      "                      controller: sourceController,",
      "                      decoration: InputDecoration(",
      "                        labelText: loc.source,",
      "                        prefixIcon: const Icon(Icons.scatter_plot, size: 18),",
      "                        isDense: true,",
      "                      ),",
      "                      onChanged: (val) => onFilterChanged(",
      "                        severity: severity,",
      "                        source: val.trim().isEmpty ? null : val.trim(),",
      "                        screen: screen,",
      "                        start: start,",
      "                        end: end,",
      "                        search: search,",
      "                      ),",
      "                    ),",
      "                  ),",
      "                ),",
      "                SizedBox(",
      "                  width: 130,",
      "                  child: Tooltip(",
      "                    message: loc.screenTooltip,",
      "                    child: TextField(",
      "                      controller: screenController,",
      "                      decoration: InputDecoration(",
      "                        labelText: loc.screen,",
      "                        prefixIcon: const Icon(Icons.smartphone, size: 18),",
      "                        isDense: true,",
      "                      ),",
      "                      onChanged: (val) => onFilterChanged(",
      "                        severity: severity,",
      "                        source: source,",
      "                        screen: val.trim().isEmpty ? null : val.trim(),",
      "                        start: start,",
      "                        end: end,",
      "                        search: search,",
      "                      ),",
      "                    ),",
      "                  ),",
      "                ),",
      "                SizedBox(",
      "                  width: 160,",
      "                  child: Tooltip(",
      "                    message: loc.searchTooltip,",
      "                    child: TextField(",
      "                      controller: searchController,",
      "                      decoration: InputDecoration(",
      "                        labelText: loc.search,",
      "                        prefixIcon: const Icon(Icons.search),",
      "                        isDense: true,",
      "                      ),",
      "                      onChanged: (val) => onFilterChanged(",
      "                        severity: severity,",
      "                        source: source,",
      "                        screen: screen,",
      "                        start: start,",
      "                        end: end,",
      "                        search: val.trim().isEmpty ? null : val.trim(),",
      "                      ),",
      "                    ),",
      "                  ),",
      "                ),",
      "                Tooltip(",
      "                  message: loc.dateRangeTooltip,",
      "                  child: OutlinedButton.icon(",
      "                    icon: const Icon(Icons.date_range),",
      "                    label: Text(",
      "                      start != null && end != null",
      "                          ? '${DateFormat('yyyy-MM-dd').format(start!)} - ${DateFormat('yyyy-MM-dd').format(end!)}'",
      "                          : loc.dateRange,",
      "                    ),",
      "                    style: OutlinedButton.styleFrom(",
      "                      foregroundColor: colorScheme.primary,",
      "                      side: BorderSide(",
      "                          color: colorScheme.primary.withOpacity(0.45)),",
      "                    ),",
      "                    onPressed: () async {",
      "                      final now = DateTime.now();",
      "                      final picked = await showDateRangePicker(",
      "                        context: context,",
      "                        firstDate: DateTime(now.year - 2),",
      "                        lastDate: now.add(const Duration(days: 1)),",
      "                        initialDateRange: (start != null && end != null)",
      "                            ? DateTimeRange(start: start!, end: end!)",
      "                            : null,",
      "                        builder: (context, child) => Theme(",
      "                          data: Theme.of(context).copyWith(",
      "                            colorScheme: colorScheme,",
      "                          ),",
      "                          child: child!,",
      "                        ),",
      "                      );",
      "                      if (picked != null) {",
      "                        onFilterChanged(",
      "                          severity: severity,",
      "                          source: source,",
      "                          screen: screen,",
      "                          start: picked.start,",
      "                          end: picked.end,",
      "                          search: search,",
      "                        );",
      "                      }",
      "                    },",
      "                  ),",
      "                ),",
      "                if (start != null || end != null)",
      "                  Tooltip(",
      "                    message: loc.clearDateFilter,",
      "                    child: IconButton(",
      "                      tooltip: loc.clearDateFilter,",
      "                      icon: Icon(Icons.clear, color: colorScheme.outline),",
      "                      onPressed: () {",
      "                        onFilterChanged(",
      "                          severity: severity,",
      "                          source: source,",
      "                          screen: screen,",
      "                          start: null,",
      "                          end: null,",
      "                          search: search,",
      "                        );",
      "                      },",
      "                    ),",
      "                  ),",
      "              ],",
      "            ),",
      "          ),",
      "          if (trailing != null) ...[",
      "            const SizedBox(width: 16),",
      "            trailing!,",
      "          ]",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 223,
      "file_size": 8529,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\error_logs\\widgets\\error_log_stats_bar.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/models/error_log.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "",
      "class ErrorLogStatsBar extends StatelessWidget {",
      "  final String? severity;",
      "  final DateTime? start;",
      "  final DateTime? end;",
      "",
      "  const ErrorLogStatsBar({super.key, this.severity, this.start, this.end});",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final franchiseId = context.watch<FranchiseProvider>().franchiseId;",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "",
      "    Color _chipBg(Color? token, Color fallback) =>",
      "        token ?? fallback.withOpacity(0.12);",
      "",
      "    Color _chipText(Color? token, Color fallback) => token ?? fallback;",
      "",
      "    return StreamBuilder<List<ErrorLog>>(",
      "      stream: context.read<FirestoreService>().streamErrorLogs(",
      "            franchiseId,",
      "            severity: severity,",
      "            start: start,",
      "            end: end,",
      "            limit: 1000,",
      "          ),",
      "      builder: (context, snapshot) {",
      "        if (!snapshot.hasData) return const SizedBox(height: 48);",
      "        final logs = snapshot.data!;",
      "        final total = logs.length;",
      "        final critical = logs",
      "            .where((l) =>",
      "                l.severity.toLowerCase() == 'fatal' ||",
      "                l.severity.toLowerCase() == 'critical')",
      "            .length;",
      "        final warning =",
      "            logs.where((l) => l.severity.toLowerCase() == 'warning').length;",
      "        final info =",
      "            logs.where((l) => l.severity.toLowerCase() == 'info').length;",
      "",
      "        return Padding(",
      "          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),",
      "          child: Row(",
      "            children: [",
      "              Tooltip(",
      "                message: loc.totalErrorsTooltip(total),",
      "                child: Chip(",
      "                  label: Text('${loc.total}: $total'),",
      "                  backgroundColor: _chipBg(DesignTokens.neutralChipColor,",
      "                      colorScheme.surfaceVariant),",
      "                  labelStyle: TextStyle(",
      "                    color: _chipText(DesignTokens.neutralChipTextColor,",
      "                        colorScheme.onSurfaceVariant),",
      "                  ),",
      "                ),",
      "              ),",
      "              const SizedBox(width: 8),",
      "              Tooltip(",
      "                message: loc.criticalErrorsTooltip(critical),",
      "                child: Chip(",
      "                  label: Text('${loc.critical}: $critical'),",
      "                  backgroundColor:",
      "                      _chipBg(DesignTokens.errorChipColor, colorScheme.error),",
      "                  labelStyle: TextStyle(",
      "                    color: _chipText(",
      "                        DesignTokens.errorChipTextColor, colorScheme.onError),",
      "                  ),",
      "                ),",
      "              ),",
      "              const SizedBox(width: 8),",
      "              Tooltip(",
      "                message: loc.warningErrorsTooltip(warning),",
      "                child: Chip(",
      "                  label: Text('${loc.warnings}: $warning'),",
      "                  backgroundColor: _chipBg(",
      "                      DesignTokens.warningChipColor, colorScheme.tertiary),",
      "                  labelStyle: TextStyle(",
      "                    color: _chipText(DesignTokens.warningChipTextColor,",
      "                        colorScheme.onTertiary),",
      "                  ),",
      "                ),",
      "              ),",
      "              const SizedBox(width: 8),",
      "              Tooltip(",
      "                message: loc.infoErrorsTooltip(info),",
      "                child: Chip(",
      "                  label: Text('${loc.info}: $info'),",
      "                  backgroundColor: _chipBg(",
      "                      DesignTokens.infoChipColor, colorScheme.secondary),",
      "                  labelStyle: TextStyle(",
      "                    color: _chipText(DesignTokens.infoChipTextColor,",
      "                        colorScheme.onSecondary),",
      "                  ),",
      "                ),",
      "              ),",
      "            ],",
      "          ),",
      "        );",
      "      },",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 117,
      "file_size": 4540,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\error_logs\\widgets\\error_log_table.dart",
    "content": [
      "import 'package:csv/csv.dart';",
      "import 'package:flutter/material.dart';",
      "import 'package:intl/intl.dart';",
      "import 'package:franchise_admin_portal/core/models/error_log.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'error_log_detail_drawer.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:provider/provider.dart';",
      "import 'dart:convert';",
      "import 'package:file_picker/file_picker.dart';",
      "import 'dart:io';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "",
      "class ErrorLogTable extends StatefulWidget {",
      "  final List<ErrorLog> logs;",
      "  const ErrorLogTable({super.key, required this.logs});",
      "",
      "  @override",
      "  State<ErrorLogTable> createState() => _ErrorLogTableState();",
      "}",
      "",
      "class _ErrorLogTableState extends State<ErrorLogTable> {",
      "  late List<ErrorLog> _sortedLogs;",
      "  final Set<String> _selectedIds = {};",
      "  int? _sortColumnIndex;",
      "  bool _sortAscending = false;",
      "  bool _condensed = false;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _sortedLogs = widget.logs;",
      "  }",
      "",
      "  @override",
      "  void didUpdateWidget(ErrorLogTable oldWidget) {",
      "    super.didUpdateWidget(oldWidget);",
      "    _sortedLogs = _applySort(widget.logs);",
      "  }",
      "",
      "  List<ErrorLog> _applySort(List<ErrorLog> logs) {",
      "    if (_sortColumnIndex == null) return List.of(logs);",
      "    List<ErrorLog> sorted = List.of(logs);",
      "    switch (_sortColumnIndex) {",
      "      case 0:",
      "        sorted.sort((a, b) => a.timestamp.compareTo(b.timestamp));",
      "        break;",
      "      case 1:",
      "        sorted.sort((a, b) => a.severity.compareTo(b.severity));",
      "        break;",
      "      case 2:",
      "        sorted.sort((a, b) => a.source.compareTo(b.source));",
      "        break;",
      "      case 3:",
      "        sorted.sort((a, b) => a.screen.compareTo(b.screen));",
      "        break;",
      "      case 4:",
      "        sorted.sort((a, b) => a.message.compareTo(b.message));",
      "        break;",
      "      default:",
      "        break;",
      "    }",
      "    if (!_sortAscending) sorted = sorted.reversed.toList();",
      "    return sorted;",
      "  }",
      "",
      "  void _onSort(int columnIndex, bool ascending) {",
      "    setState(() {",
      "      _sortColumnIndex = columnIndex;",
      "      _sortAscending = ascending;",
      "      _sortedLogs = _applySort(widget.logs);",
      "    });",
      "  }",
      "",
      "  Future<void> _exportCsv({bool onlySelected = false}) async {",
      "    final logsToExport = onlySelected",
      "        ? _sortedLogs.where((log) => _selectedIds.contains(log.id)).toList()",
      "        : _sortedLogs;",
      "    List<List<String>> rows = [",
      "      [",
      "        'Time',",
      "        'Severity',",
      "        'Source',",
      "        'Screen',",
      "        'Message',",
      "        'UserId',",
      "        'Resolved',",
      "        'Archived'",
      "      ],",
      "      ...logsToExport.map((log) => [",
      "            DateFormat('yyyy-MM-dd HH:mm').format(log.timestamp),",
      "            log.severity,",
      "            log.source,",
      "            log.screen,",
      "            log.message.replaceAll('\\n', ' '),",
      "            log.userId ?? '',",
      "            log.resolved.toString(),",
      "            log.archived.toString(),",
      "          ])",
      "    ];",
      "",
      "    String csv = const ListToCsvConverter().convert(rows);",
      "    String? outputFile = await FilePicker.platform.saveFile(",
      "      dialogTitle: 'Export error logs to CSV',",
      "      fileName: 'error_logs_export_${DateTime.now().toIso8601String()}.csv',",
      "    );",
      "    if (outputFile != null) {",
      "      await File(outputFile).writeAsString(csv);",
      "      if (mounted) {",
      "        ScaffoldMessenger.of(context).showSnackBar(",
      "          const SnackBar(content: Text('CSV exported successfully.')),",
      "        );",
      "      }",
      "    }",
      "  }",
      "",
      "  Future<void> _exportJson({bool onlySelected = false}) async {",
      "    final logsToExport = onlySelected",
      "        ? _sortedLogs.where((log) => _selectedIds.contains(log.id)).toList()",
      "        : _sortedLogs;",
      "    List<Map<String, dynamic>> logsJson =",
      "        logsToExport.map((log) => log.toJson()).toList();",
      "    String jsonString = const JsonEncoder.withIndent('  ').convert(logsJson);",
      "    String? outputFile = await FilePicker.platform.saveFile(",
      "      dialogTitle: 'Export error logs to JSON',",
      "      fileName: 'error_logs_export_${DateTime.now().toIso8601String()}.json',",
      "    );",
      "    if (outputFile != null) {",
      "      await File(outputFile).writeAsString(jsonString);",
      "      if (mounted) {",
      "        ScaffoldMessenger.of(context).showSnackBar(",
      "          const SnackBar(content: Text('JSON exported successfully.')),",
      "        );",
      "      }",
      "    }",
      "  }",
      "",
      "  void _toggleCondensed() {",
      "    setState(() {",
      "      _condensed = !_condensed;",
      "    });",
      "  }",
      "",
      "  void _toggleSelectAll(bool? checked) {",
      "    setState(() {",
      "      if (checked ?? false) {",
      "        _selectedIds.addAll(_sortedLogs.map((log) => log.id));",
      "      } else {",
      "        _selectedIds.clear();",
      "      }",
      "    });",
      "  }",
      "",
      "  void _toggleSelectOne(String id, bool? checked) {",
      "    setState(() {",
      "      if (checked ?? false) {",
      "        _selectedIds.add(id);",
      "      } else {",
      "        _selectedIds.remove(id);",
      "      }",
      "    });",
      "  }",
      "",
      "  Future<void> _bulkResolve(bool resolved) async {",
      "    String franchiseId =",
      "        Provider.of<FranchiseProvider>(context, listen: false).franchiseId;",
      "    final service = context.read<FirestoreService>();",
      "    final ids = _selectedIds.toList();",
      "    for (final id in ids) {",
      "      await service.setErrorLogStatus(franchiseId, id, resolved: resolved);",
      "    }",
      "    _selectedIds.clear();",
      "    if (mounted) {",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(",
      "            content: Text(",
      "                'Marked ${ids.length} logs as ${resolved ? \"resolved\" : \"unresolved\"}')),",
      "      );",
      "    }",
      "  }",
      "",
      "  Future<void> _bulkArchive(bool archived) async {",
      "    String franchiseId =",
      "        Provider.of<FranchiseProvider>(context, listen: false).franchiseId;",
      "    final service = context.read<FirestoreService>();",
      "    final ids = _selectedIds.toList();",
      "    for (final id in ids) {",
      "      await service.setErrorLogStatus(franchiseId, id, archived: archived);",
      "    }",
      "    setState(() {",
      "      _selectedIds.clear();",
      "    });",
      "    if (mounted) {",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(",
      "          content: Text(",
      "              'Marked ${ids.length} logs as ${archived ? \"archived\" : \"active\"}'),",
      "        ),",
      "      );",
      "    }",
      "  }",
      "",
      "  Future<void> _bulkDelete() async {",
      "    String franchiseId =",
      "        Provider.of<FranchiseProvider>(context, listen: false).franchiseId;",
      "    final service = context.read<FirestoreService>();",
      "    final ids = _selectedIds.toList();",
      "    for (final id in ids) {",
      "      await service.deleteErrorLog(franchiseId, id);",
      "    }",
      "    setState(() {",
      "      _sortedLogs.removeWhere((log) => _selectedIds.contains(log.id));",
      "      _selectedIds.clear();",
      "    });",
      "    if (mounted) {",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(content: Text('Deleted ${ids.length} logs.')),",
      "      );",
      "    }",
      "  }",
      "",
      "  Future<void> _addComment(String logId, String text) async {",
      "    String franchiseId =",
      "        Provider.of<FranchiseProvider>(context, listen: false).franchiseId;",
      "    if (text.trim().isEmpty) return;",
      "    final comment = {",
      "      'text': text,",
      "      'userId': 'admin', // You may replace with currentUser",
      "      'timestamp': DateTime.now().toIso8601String(),",
      "    };",
      "    await context",
      "        .read<FirestoreService>()",
      "        .addCommentToErrorLog(franchiseId, logId, comment);",
      "    if (mounted) {",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        const SnackBar(content: Text('Comment added.')),",
      "      );",
      "    }",
      "  }",
      "",
      "  Color _severityColor(BuildContext context, String severity) {",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    switch (severity.toLowerCase()) {",
      "      case 'fatal':",
      "      case 'critical':",
      "        return DesignTokens.errorChipColor ?? colorScheme.error;",
      "      case 'warning':",
      "        return DesignTokens.warningChipColor ?? colorScheme.tertiary;",
      "      case 'info':",
      "        return DesignTokens.infoChipColor ?? colorScheme.secondary;",
      "      default:",
      "        return DesignTokens.neutralChipColor ?? colorScheme.primary;",
      "    }",
      "  }",
      "",
      "  Widget _emptyState() {",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    return Center(",
      "      child: Column(",
      "        mainAxisAlignment: MainAxisAlignment.center,",
      "        children: [",
      "          Icon(Icons.inbox_rounded,",
      "              color: colorScheme.onSurface.withOpacity(0.30), size: 54),",
      "          const SizedBox(height: 12),",
      "          Text(",
      "            'No error logs found',",
      "            style: Theme.of(context).textTheme.titleMedium?.copyWith(",
      "                  color: colorScheme.onSurface.withOpacity(0.65),",
      "                ),",
      "          ),",
      "          const SizedBox(height: 4),",
      "          Text(",
      "            'Everything is running smoothly!',",
      "            style: Theme.of(context).textTheme.bodyMedium?.copyWith(",
      "                  color: colorScheme.onSurface.withOpacity(0.45),",
      "                ),",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "",
      "  // --- Combined Action Bar ---",
      "  Widget _buildActionBar() {",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    final isBulk = _selectedIds.isNotEmpty;",
      "",
      "    return Padding(",
      "      padding: const EdgeInsets.symmetric(vertical: 4, horizontal: 12),",
      "      child: AnimatedSwitcher(",
      "        duration: const Duration(milliseconds: 200),",
      "        child: isBulk",
      "            ? Card(",
      "                elevation: 2,",
      "                margin: EdgeInsets.zero,",
      "                color: colorScheme.surfaceVariant,",
      "                shape: RoundedRectangleBorder(",
      "                  borderRadius: BorderRadius.circular(8),",
      "                ),",
      "                child: Padding(",
      "                  padding:",
      "                      const EdgeInsets.symmetric(vertical: 10, horizontal: 20),",
      "                  child: Row(",
      "                    children: [",
      "                      Checkbox(",
      "                        value: _selectedIds.length == _sortedLogs.length &&",
      "                            _sortedLogs.isNotEmpty,",
      "                        tristate: true,",
      "                        onChanged: (v) => _toggleSelectAll(v),",
      "                      ),",
      "                      Text('${_selectedIds.length} selected',",
      "                          style: TextStyle(",
      "                              fontWeight: FontWeight.w600,",
      "                              color: colorScheme.primary)),",
      "                      const SizedBox(width: 20),",
      "                      OutlinedButton.icon(",
      "                        icon: const Icon(Icons.check_circle),",
      "                        label: const Text(\"Mark Resolved\"),",
      "                        onPressed: () => _bulkResolve(true),",
      "                      ),",
      "                      const SizedBox(width: 8),",
      "                      OutlinedButton.icon(",
      "                        icon: const Icon(Icons.radio_button_unchecked),",
      "                        label: const Text(\"Mark Unresolved\"),",
      "                        onPressed: () => _bulkResolve(false),",
      "                      ),",
      "                      const SizedBox(width: 8),",
      "                      OutlinedButton.icon(",
      "                        icon: const Icon(Icons.archive),",
      "                        label: const Text(\"Archive\"),",
      "                        onPressed: () => _bulkArchive(true),",
      "                      ),",
      "                      const SizedBox(width: 8),",
      "                      OutlinedButton.icon(",
      "                        icon: const Icon(Icons.unarchive),",
      "                        label: const Text(\"Unarchive\"),",
      "                        onPressed: () => _bulkArchive(false),",
      "                      ),",
      "                      const SizedBox(width: 8),",
      "                      OutlinedButton.icon(",
      "                        icon: const Icon(Icons.delete_forever),",
      "                        label: const Text(\"Delete\"),",
      "                        style: OutlinedButton.styleFrom(",
      "                          foregroundColor: colorScheme.error,",
      "                        ),",
      "                        onPressed: _bulkDelete,",
      "                      ),",
      "                      const SizedBox(width: 12),",
      "                      OutlinedButton.icon(",
      "                        icon: const Icon(Icons.file_download),",
      "                        label: const Text(\"Export (CSV)\"),",
      "                        onPressed: () => _exportCsv(onlySelected: true),",
      "                      ),",
      "                      const SizedBox(width: 8),",
      "                      OutlinedButton.icon(",
      "                        icon: const Icon(Icons.code),",
      "                        label: const Text(\"Export (JSON)\"),",
      "                        onPressed: () => _exportJson(onlySelected: true),",
      "                      ),",
      "                    ],",
      "                  ),",
      "                ),",
      "              )",
      "            : Row(",
      "                children: [",
      "                  const Spacer(),",
      "                  ElevatedButton.icon(",
      "                    icon: const Icon(Icons.file_download),",
      "                    label: const Text(\"Export All CSV\"),",
      "                    onPressed: _sortedLogs.isNotEmpty ? _exportCsv : null,",
      "                  ),",
      "                  const SizedBox(width: 8),",
      "                  ElevatedButton.icon(",
      "                    icon: const Icon(Icons.code),",
      "                    label: const Text(\"Export All JSON\"),",
      "                    onPressed: _sortedLogs.isNotEmpty ? _exportJson : null,",
      "                  ),",
      "                  const SizedBox(width: 8),",
      "                  IconButton(",
      "                    tooltip: _condensed ? \"Expanded View\" : \"Condensed View\",",
      "                    icon: Icon(_condensed ? Icons.zoom_out : Icons.zoom_in),",
      "                    onPressed: _toggleCondensed,",
      "                  ),",
      "                ],",
      "              ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final franchiseId = context.watch<FranchiseProvider>().franchiseId;",
      "    print('ErrorLogTable received logs: ${widget.logs.length}');",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    if (widget.logs.isEmpty) return _emptyState();",
      "",
      "    return Card(",
      "      margin: const EdgeInsets.symmetric(horizontal: 20, vertical: 12),",
      "      elevation: 1,",
      "      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),",
      "      child: Padding(",
      "        padding: const EdgeInsets.all(8),",
      "        child: Column(",
      "          crossAxisAlignment: CrossAxisAlignment.stretch,",
      "          children: [",
      "            _buildActionBar(),",
      "            const Divider(height: 1),",
      "            // --- Data Table ---",
      "            Expanded(",
      "              child: Scrollbar(",
      "                child: SingleChildScrollView(",
      "                  scrollDirection: Axis.horizontal,",
      "                  child: ConstrainedBox(",
      "                    constraints: const BoxConstraints(minWidth: 1000),",
      "                    child: SingleChildScrollView(",
      "                      scrollDirection: Axis.vertical,",
      "                      child: DataTable(",
      "                        sortColumnIndex: _sortColumnIndex,",
      "                        sortAscending: _sortAscending,",
      "                        columns: [",
      "                          DataColumn(",
      "                            label: Checkbox(",
      "                              value:",
      "                                  _selectedIds.length == _sortedLogs.length &&",
      "                                      _sortedLogs.isNotEmpty,",
      "                              onChanged: (v) => _toggleSelectAll(v),",
      "                            ),",
      "                          ),",
      "                          DataColumn(",
      "                            label: const Text('Time'),",
      "                            onSort: (i, asc) => _onSort(i, asc),",
      "                          ),",
      "                          DataColumn(",
      "                            label: const Text('Severity'),",
      "                            onSort: (i, asc) => _onSort(i, asc),",
      "                          ),",
      "                          DataColumn(",
      "                            label: const Text('Source'),",
      "                            onSort: (i, asc) => _onSort(i, asc),",
      "                          ),",
      "                          DataColumn(",
      "                            label: const Text('Screen'),",
      "                            onSort: (i, asc) => _onSort(i, asc),",
      "                          ),",
      "                          DataColumn(",
      "                            label: const Text('Message'),",
      "                            onSort: (i, asc) => _onSort(i, asc),",
      "                          ),",
      "                          const DataColumn(label: Text('Resolved')),",
      "                          const DataColumn(label: Text('Archived')),",
      "                          const DataColumn(label: Text('Actions')),",
      "                        ],",
      "                        rows: _sortedLogs.map((log) {",
      "                          // Defensive: Provide default values for any possibly null field",
      "                          final severity = log.severity ?? '';",
      "                          final source = log.source ?? '';",
      "                          final screen = log.screen ?? '';",
      "                          final message = log.message ?? '';",
      "                          final resolved = log.resolved ?? false;",
      "                          final archived = log.archived ?? false;",
      "                          final userId = log.userId ?? '';",
      "",
      "                          final isCritical =",
      "                              (severity.toLowerCase() == 'fatal' ||",
      "                                  severity.toLowerCase() == 'critical');",
      "",
      "                          return DataRow(",
      "                            selected: _selectedIds.contains(log.id),",
      "                            color: isCritical",
      "                                ? WidgetStateProperty.all(",
      "                                    _severityColor(context, severity)",
      "                                        .withOpacity(0.12))",
      "                                : null,",
      "                            cells: [",
      "                              DataCell(",
      "                                Checkbox(",
      "                                  value: _selectedIds.contains(log.id),",
      "                                  onChanged: (checked) =>",
      "                                      _toggleSelectOne(log.id, checked),",
      "                                ),",
      "                              ),",
      "                              DataCell(",
      "                                Text(",
      "                                  DateFormat('yyyy-MM-dd HH:mm')",
      "                                      .format(log.timestamp),",
      "                                  style: _condensed",
      "                                      ? const TextStyle(fontSize: 12)",
      "                                      : null,",
      "                                ),",
      "                              ),",
      "                              DataCell(",
      "                                Container(",
      "                                  constraints:",
      "                                      const BoxConstraints(maxWidth: 140),",
      "                                  child: Row(",
      "                                    children: [",
      "                                      Icon(",
      "                                        severity.toLowerCase() == 'fatal'",
      "                                            ? Icons.error",
      "                                            : Icons.warning,",
      "                                        color:",
      "                                            _severityColor(context, severity),",
      "                                        size: 18,",
      "                                      ),",
      "                                      const SizedBox(width: 4),",
      "                                      Text(",
      "                                        severity.isNotEmpty",
      "                                            ? severity",
      "                                            : 'unknown',",
      "                                        style: TextStyle(",
      "                                          color:",
      "                                              _severityColor(context, severity),",
      "                                          fontWeight: FontWeight.bold,",
      "                                          fontSize: _condensed ? 12 : 14,",
      "                                        ),",
      "                                      ),",
      "                                    ],",
      "                                  ),",
      "                                ),",
      "                              ),",
      "                              DataCell(Text(source,",
      "                                  style: _condensed",
      "                                      ? const TextStyle(fontSize: 12)",
      "                                      : null)),",
      "                              DataCell(Text(screen,",
      "                                  style: _condensed",
      "                                      ? const TextStyle(fontSize: 12)",
      "                                      : null)),",
      "                              DataCell(",
      "                                Container(",
      "                                  constraints: BoxConstraints(",
      "                                      maxWidth: _condensed ? 120 : 280),",
      "                                  child: Text(",
      "                                    message.length > (_condensed ? 24 : 48)",
      "                                        ? '${message.substring(0, _condensed ? 24 : 48)}…'",
      "                                        : message,",
      "                                    overflow: TextOverflow.ellipsis,",
      "                                    softWrap: false,",
      "                                    style: _condensed",
      "                                        ? const TextStyle(fontSize: 12)",
      "                                        : null,",
      "                                  ),",
      "                                ),",
      "                              ),",
      "                              DataCell(",
      "                                IconButton(",
      "                                  icon: Icon(",
      "                                    resolved",
      "                                        ? Icons.check_circle",
      "                                        : Icons.radio_button_unchecked,",
      "                                    color: resolved",
      "                                        ? colorScheme.secondary",
      "                                        : colorScheme.outline,",
      "                                    size: 20,",
      "                                  ),",
      "                                  tooltip: resolved",
      "                                      ? \"Mark Unresolved\"",
      "                                      : \"Mark Resolved\",",
      "                                  onPressed: () => context",
      "                                      .read<FirestoreService>()",
      "                                      .setErrorLogStatus(",
      "                                        franchiseId,",
      "                                        log.id,",
      "                                        resolved: !resolved,",
      "                                      ),",
      "                                ),",
      "                              ),",
      "                              DataCell(",
      "                                IconButton(",
      "                                  icon: Icon(",
      "                                    archived ? Icons.archive : Icons.unarchive,",
      "                                    color: archived",
      "                                        ? colorScheme.secondary",
      "                                        : colorScheme.outline,",
      "                                    size: 20,",
      "                                  ),",
      "                                  tooltip: archived ? \"Unarchive\" : \"Archive\",",
      "                                  onPressed: () => context",
      "                                      .read<FirestoreService>()",
      "                                      .setErrorLogStatus(",
      "                                        franchiseId,",
      "                                        log.id,",
      "                                        archived: !archived,",
      "                                      ),",
      "                                ),",
      "                              ),",
      "                              DataCell(",
      "                                Container(",
      "                                  constraints:",
      "                                      const BoxConstraints(maxWidth: 130),",
      "                                  child: Row(",
      "                                    children: [",
      "                                      IconButton(",
      "                                        icon: const Icon(Icons.open_in_new),",
      "                                        tooltip: \"View Details\",",
      "                                        onPressed: () async {",
      "                                          await showDialog(",
      "                                            context: context,",
      "                                            builder: (_) =>",
      "                                                ErrorLogDetailDrawer(log: log),",
      "                                          );",
      "                                        },",
      "                                      ),",
      "                                      IconButton(",
      "                                        icon: const Icon(Icons.comment),",
      "                                        tooltip: \"Add Comment\",",
      "                                        onPressed: () async {",
      "                                          final controller =",
      "                                              TextEditingController();",
      "                                          final result =",
      "                                              await showDialog<String>(",
      "                                            context: context,",
      "                                            builder: (context) => AlertDialog(",
      "                                              title: const Text('Add Comment'),",
      "                                              content: TextField(",
      "                                                controller: controller,",
      "                                                decoration:",
      "                                                    const InputDecoration(",
      "                                                        hintText:",
      "                                                            'Enter comment...'),",
      "                                              ),",
      "                                              actions: [",
      "                                                TextButton(",
      "                                                  onPressed: () =>",
      "                                                      Navigator.pop(context),",
      "                                                  child: const Text('Cancel'),",
      "                                                ),",
      "                                                ElevatedButton(",
      "                                                  onPressed: () =>",
      "                                                      Navigator.pop(context,",
      "                                                          controller.text),",
      "                                                  child: const Text('Add'),",
      "                                                ),",
      "                                              ],",
      "                                            ),",
      "                                          );",
      "                                          if (result != null &&",
      "                                              result.trim().isNotEmpty) {",
      "                                            await _addComment(log.id, result);",
      "                                          }",
      "                                        },",
      "                                      ),",
      "                                    ],",
      "                                  ),",
      "                                ),",
      "                              ),",
      "                            ],",
      "                          );",
      "                        }).toList(),",
      "                      ),",
      "                    ),",
      "                  ),",
      "                ),",
      "              ),",
      "            )",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 661,
      "file_size": 27749,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\error_logs\\widgets\\error_log_trend_chart.dart",
    "content": [
      "import 'package:intl/intl.dart';",
      "import 'package:flutter/material.dart';",
      "import 'package:fl_chart/fl_chart.dart';",
      "",
      "class ErrorLogTrendChart extends StatelessWidget {",
      "  final List<DateTime> timestamps;",
      "  final int days; // e.g., last 7 or 30 days",
      "  final Color color;",
      "  final String? label;",
      "",
      "  /// [timestamps] - list of error log DateTimes to plot",
      "  /// [days] - number of days in the past to show (e.g., 7 or 30)",
      "  /// [color] - color for the line/bar",
      "  /// [label] - optional label for accessibility",
      "",
      "  const ErrorLogTrendChart({",
      "    Key? key,",
      "    required this.timestamps,",
      "    this.days = 7,",
      "    this.color = Colors.red,",
      "    this.label,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    // Count errors per day for [days] days",
      "    final now = DateTime.now();",
      "    final dayCounts = List.generate(days, (i) => 0);",
      "    for (final t in timestamps) {",
      "      final diff = now.difference(DateTime(t.year, t.month, t.day)).inDays;",
      "      if (diff >= 0 && diff < days) {",
      "        dayCounts[days - 1 - diff] += 1; // reverse order for left-to-right",
      "      }",
      "    }",
      "    final maxCount = (dayCounts.isNotEmpty)",
      "        ? (dayCounts.reduce((a, b) => a > b ? a : b))",
      "        : 1;",
      "",
      "    return SizedBox(",
      "      height: 80,",
      "      width: days * 16.0 + 40,",
      "      child: BarChart(",
      "        BarChartData(",
      "          alignment: BarChartAlignment.spaceAround,",
      "          maxY: (maxCount + 1).toDouble(),",
      "          barTouchData: BarTouchData(enabled: false),",
      "          titlesData: FlTitlesData(",
      "            show: true,",
      "            leftTitles: const AxisTitles(),",
      "            topTitles: const AxisTitles(),",
      "            rightTitles: const AxisTitles(),",
      "            bottomTitles: AxisTitles(",
      "              sideTitles: SideTitles(",
      "                showTitles: true,",
      "                interval: 1,",
      "                getTitlesWidget: (v, m) {",
      "                  int idx = v.toInt();",
      "                  if (idx < 0 || idx >= days) return const SizedBox.shrink();",
      "                  final date = now.subtract(Duration(days: days - 1 - idx));",
      "                  return Text(",
      "                    days <= 7",
      "                        ? DateFormat('E').format(date)",
      "                        : DateFormat('M/d').format(date),",
      "                    style: Theme.of(context).textTheme.labelSmall,",
      "                  );",
      "                },",
      "              ),",
      "            ),",
      "          ),",
      "          gridData: FlGridData(show: false),",
      "          borderData: FlBorderData(show: false),",
      "          barGroups: List.generate(days, (i) {",
      "            return BarChartGroupData(",
      "              x: i,",
      "              barRods: [",
      "                BarChartRodData(",
      "                  toY: dayCounts[i].toDouble(),",
      "                  color: color,",
      "                  width: 12,",
      "                  borderRadius: BorderRadius.circular(4),",
      "                ),",
      "              ],",
      "            );",
      "          }),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 89,
      "file_size": 2963,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\error_logs\\widgets\\paginated_error_log_table.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:intl/intl.dart';",
      "import 'package:franchise_admin_portal/core/models/error_log.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'error_log_detail_drawer.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "",
      "String _truncateTooltip(String text, [int max = 150]) {",
      "  if (text.length <= max) return text;",
      "  return text.substring(0, max) + '...';",
      "}",
      "",
      "class PaginatedErrorLogTable extends StatelessWidget {",
      "  final List<ErrorLog> logs;",
      "  final int rowsPerPage;",
      "  final void Function(ErrorLog)? onRowTap;",
      "",
      "  const PaginatedErrorLogTable({",
      "    super.key,",
      "    required this.logs,",
      "    this.rowsPerPage = 5, // For best fit, adjust as needed",
      "    this.onRowTap,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "",
      "    return PaginatedDataTable(",
      "      showCheckboxColumn: false,",
      "      rowsPerPage: rowsPerPage,",
      "      availableRowsPerPage: const [5, 10, 25, 50, 100],",
      "      columns: [",
      "        DataColumn(",
      "            label: Tooltip(message: loc.timeTooltip, child: Text(loc.time))),",
      "        DataColumn(",
      "            label: Tooltip(",
      "                message: loc.severityTooltip, child: Text(loc.severity))),",
      "        DataColumn(",
      "            label:",
      "                Tooltip(message: loc.sourceTooltip, child: Text(loc.source))),",
      "        DataColumn(",
      "            label:",
      "                Tooltip(message: loc.screenTooltip, child: Text(loc.screen))),",
      "        DataColumn(",
      "            label:",
      "                Tooltip(message: loc.messageTooltip, child: Text(loc.message))),",
      "        DataColumn(",
      "            label:",
      "                Tooltip(message: loc.userIdTooltip, child: Text(loc.userId))),",
      "        DataColumn(",
      "            label: Tooltip(",
      "                message: loc.resolvedTooltip, child: Text(loc.resolved))),",
      "        DataColumn(",
      "            label: Tooltip(",
      "                message: loc.archivedTooltip, child: Text(loc.archived))),",
      "      ],",
      "      source: _ErrorLogDataSource(logs, context, onRowTap, loc),",
      "      headingRowColor: MaterialStateProperty.all(colorScheme.surfaceVariant),",
      "      dividerThickness: 1,",
      "      columnSpacing: 18,",
      "    );",
      "  }",
      "}",
      "",
      "class _ErrorLogDataSource extends DataTableSource {",
      "  final List<ErrorLog> logs;",
      "  final BuildContext context;",
      "  final void Function(ErrorLog)? onRowTap;",
      "  final AppLocalizations loc;",
      "",
      "  _ErrorLogDataSource(this.logs, this.context, this.onRowTap, this.loc);",
      "",
      "  @override",
      "  DataRow getRow(int index) {",
      "    final log = logs[index];",
      "    return DataRow.byIndex(",
      "      index: index,",
      "      cells: [",
      "        DataCell(Text(DateFormat('yyyy-MM-dd HH:mm').format(log.timestamp))),",
      "        DataCell(Tooltip(",
      "          message: log.severity,",
      "          child: Text(log.severity),",
      "        )),",
      "        DataCell(Tooltip(",
      "          message: _truncateTooltip(log.source ?? ''),",
      "          child: Text(log.source, maxLines: 1, overflow: TextOverflow.ellipsis),",
      "        )),",
      "        DataCell(Tooltip(",
      "          message: _truncateTooltip(log.screen ?? ''),",
      "          child: Text(log.screen, maxLines: 1, overflow: TextOverflow.ellipsis),",
      "        )),",
      "        DataCell(Tooltip(",
      "          message: _truncateTooltip(log.message ?? ''),",
      "          child:",
      "              Text(log.message, maxLines: 1, overflow: TextOverflow.ellipsis),",
      "        )),",
      "        DataCell(Tooltip(",
      "          message: _truncateTooltip(log.userId ?? ''),",
      "          child: Text(log.userId ?? '',",
      "              maxLines: 1, overflow: TextOverflow.ellipsis),",
      "        )),",
      "        DataCell(",
      "          Tooltip(",
      "            message: log.resolved ? loc.resolved : loc.unresolvedOnly,",
      "            child: Icon(",
      "              log.resolved ? Icons.check_circle : Icons.radio_button_unchecked,",
      "              color: log.resolved ? Colors.green : Colors.grey,",
      "              semanticLabel: log.resolved ? loc.resolved : loc.unresolvedOnly,",
      "            ),",
      "          ),",
      "        ),",
      "        DataCell(",
      "          Tooltip(",
      "            message: log.archived ? loc.archived : loc.notArchived,",
      "            child: Icon(",
      "              log.archived ? Icons.archive : Icons.unarchive,",
      "              color: log.archived ? Colors.blueGrey : Colors.grey,",
      "              semanticLabel: log.archived ? loc.archived : loc.notArchived,",
      "            ),",
      "          ),",
      "        ),",
      "      ],",
      "      onSelectChanged: (_) {",
      "        if (onRowTap != null) {",
      "          onRowTap!(log);",
      "        } else {",
      "          showDialog(",
      "            context: context,",
      "            builder: (_) => ErrorLogDetailDrawer(log: log),",
      "          );",
      "        }",
      "      },",
      "    );",
      "  }",
      "",
      "  @override",
      "  bool get isRowCountApproximate => false;",
      "  @override",
      "  int get rowCount => logs.length;",
      "  @override",
      "  int get selectedRowCount => 0;",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 151,
      "file_size": 5121,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\features\\feature_settings_screen.dart",
    "content": [
      "import 'package:franchise_admin_portal/widgets/feature_toggle_list.dart';",
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/models/user.dart' as admin_user;",
      "import 'package:franchise_admin_portal/core/services/audit_log_service.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/user_profile_notifier.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "",
      "class FeatureSettingsScreen extends StatefulWidget {",
      "  const FeatureSettingsScreen({super.key});",
      "",
      "  @override",
      "  State<FeatureSettingsScreen> createState() => _FeatureSettingsScreenState();",
      "}",
      "",
      "class _FeatureSettingsScreenState extends State<FeatureSettingsScreen> {",
      "  bool _unauthorizedLogged = false;",
      "",
      "  Future<void> _updateFeature(String key, bool value, admin_user.User user,",
      "      Map<String, dynamic> meta) async {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[YourWidget] loc is null! Localization not available for this context.');",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(content: Text('Localization missing! [debug]')),",
      "      );",
      "      return;",
      "    }",
      "    final franchiseId =",
      "        Provider.of<FranchiseProvider>(context, listen: false).franchiseId;",
      "",
      "    if (!(user.isOwner || user.isAdmin || user.isDeveloper)) {",
      "      await AuditLogService().addLog(",
      "        franchiseId: franchiseId,",
      "        userId: user.id,",
      "        action: 'unauthorized_feature_toggle_attempt',",
      "        targetType: 'feature_toggle',",
      "        targetId: key,",
      "        details: {",
      "          'attemptedValue': value,",
      "          'message': 'User with insufficient role tried to toggle feature.',",
      "        },",
      "      );",
      "      await ErrorLogger.log(",
      "        message: 'Unauthorized feature toggle attempt by ${user.email}',",
      "        source: 'FeatureSettingsScreen',",
      "        screen: 'FeatureSettingsScreen',",
      "        severity: 'warning',",
      "        contextData: {",
      "          'roles': user.roles,",
      "          'attemptedKey': key,",
      "          'attemptedValue': value,",
      "          'userId': user.id,",
      "          'franchiseId': franchiseId,",
      "        },",
      "      );",
      "      _showUnauthorizedDialog(loc);",
      "      return;",
      "    }",
      "",
      "    if (meta['paid_service'] == true && !user.isDeveloper) {",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(content: Text(loc.paidFeatureAdminOnly)),",
      "      );",
      "      return;",
      "    }",
      "",
      "    try {",
      "      await Provider.of<FirestoreService>(context, listen: false)",
      "          .updateFeatureToggle(franchiseId, key, value);",
      "      await AuditLogService().addLog(",
      "        franchiseId: franchiseId,",
      "        userId: user.id,",
      "        action: 'update_feature_toggle',",
      "        targetType: 'feature_toggle',",
      "        targetId: key,",
      "        details: {'newValue': value},",
      "      );",
      "    } catch (e) {",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(content: Text(loc.toggleUpdateFailed)),",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  void _showUnauthorizedDialog(AppLocalizations loc) {",
      "    showDialog(",
      "      context: context,",
      "      builder: (_) => AlertDialog(",
      "        title: Text(loc.unauthorizedTitle),",
      "        content: Text(loc.unauthorizedFeatureChange),",
      "        actions: [",
      "          TextButton(",
      "            onPressed: () => Navigator.of(context).pop(),",
      "            child: Text(loc.ok),",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final franchiseId =",
      "        Provider.of<FranchiseProvider>(context, listen: false).franchiseId!;",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    final user = Provider.of<AdminUserProvider>(context, listen: false).user;",
      "",
      "    // Not logged in",
      "    if (user == null) {",
      "      return Scaffold(",
      "        backgroundColor: DesignTokens.backgroundColor,",
      "        body: Row(",
      "          children: [",
      "            Expanded(",
      "              flex: 11,",
      "              child: Center(child: Text(loc.unauthorizedPleaseLogin)),",
      "            ),",
      "            Expanded(flex: 9, child: Container()),",
      "          ],",
      "        ),",
      "      );",
      "    }",
      "",
      "    // Not allowed",
      "    if (!(user.isOwner || user.isAdmin || user.isDeveloper)) {",
      "      if (!_unauthorizedLogged) {",
      "        _unauthorizedLogged = true;",
      "        Future.microtask(() async {",
      "          await AuditLogService().addLog(",
      "            franchiseId: franchiseId,",
      "            userId: user.id,",
      "            action: 'unauthorized_feature_settings_access',",
      "            targetType: 'feature_settings',",
      "            targetId: '',",
      "            details: {",
      "              'message':",
      "                  'User with insufficient role tried to access feature settings.',",
      "            },",
      "          );",
      "          await ErrorLogger.log(",
      "            message: 'Unauthorized feature settings access by ${user.email}',",
      "            source: 'FeatureSettingsScreen',",
      "            screen: 'FeatureSettingsScreen',",
      "            severity: 'warning',",
      "            contextData: {",
      "              'roles': user.roles,",
      "              'attempt': 'access',",
      "              'userId': user.id,",
      "              'franchiseId': franchiseId,",
      "            },",
      "          );",
      "        });",
      "      }",
      "      return Scaffold(",
      "        backgroundColor: DesignTokens.backgroundColor,",
      "        body: Row(",
      "          children: [",
      "            Expanded(",
      "              flex: 11,",
      "              child: Center(",
      "                child: Column(",
      "                  mainAxisAlignment: MainAxisAlignment.center,",
      "                  children: [",
      "                    const Icon(Icons.lock_outline,",
      "                        size: 54, color: Colors.redAccent),",
      "                    const SizedBox(height: 16),",
      "                    Text(",
      "                      loc.unauthorizedNoPermission,",
      "                      style: const TextStyle(",
      "                          fontWeight: FontWeight.bold, fontSize: 18),",
      "                      textAlign: TextAlign.center,",
      "                    ),",
      "                    const SizedBox(height: 18),",
      "                    ElevatedButton.icon(",
      "                      icon: const Icon(Icons.home),",
      "                      label: Text(loc.returnToHome),",
      "                      onPressed: () {",
      "                        Navigator.of(context)",
      "                            .popUntil((route) => route.isFirst);",
      "                      },",
      "                    ),",
      "                  ],",
      "                ),",
      "              ),",
      "            ),",
      "            Expanded(flex: 9, child: Container()),",
      "          ],",
      "        ),",
      "      );",
      "    }",
      "",
      "    return Scaffold(",
      "      backgroundColor: DesignTokens.backgroundColor,",
      "      body: Row(",
      "        crossAxisAlignment: CrossAxisAlignment.start,",
      "        children: [",
      "          // Main content column",
      "          Expanded(",
      "            flex: 11,",
      "            child: Padding(",
      "              padding:",
      "                  const EdgeInsets.only(top: 24.0, left: 24.0, right: 24.0),",
      "              child: Column(",
      "                crossAxisAlignment: CrossAxisAlignment.start,",
      "                children: [",
      "                  // Header row",
      "                  Padding(",
      "                    padding: const EdgeInsets.only(bottom: 12.0),",
      "                    child: Row(",
      "                      crossAxisAlignment: CrossAxisAlignment.center,",
      "                      children: [",
      "                        Text(",
      "                          loc.featureSettingsTitle,",
      "                          style: const TextStyle(",
      "                            color: Colors.black,",
      "                            fontWeight: FontWeight.bold,",
      "                            fontSize: 22,",
      "                          ),",
      "                        ),",
      "                      ],",
      "                    ),",
      "                  ),",
      "                  // Feature toggles with live updates and sections",
      "                  Expanded(",
      "                    child: FeatureToggleList(",
      "                      franchiseId: franchiseId,",
      "                      user: user,",
      "                      onUpdateFeature: (key, value, user, meta) =>",
      "                          _updateFeature(key, value, user, meta),",
      "                    ),",
      "                  ),",
      "                ],",
      "              ),",
      "            ),",
      "          ),",
      "          Expanded(flex: 9, child: Container()),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 256,
      "file_size": 8901,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\features\\feature_toggle_dialog.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/config/feature_config.dart';",
      "",
      "class FeatureToggleDialog extends StatefulWidget {",
      "  final VoidCallback? onChanged;",
      "  const FeatureToggleDialog({Key? key, this.onChanged}) : super(key: key);",
      "",
      "  @override",
      "  State<FeatureToggleDialog> createState() => _FeatureToggleDialogState();",
      "}",
      "",
      "class _FeatureToggleDialogState extends State<FeatureToggleDialog> {",
      "  late Map<String, bool> featureMap;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    featureMap = Map<String, bool>.from(FeatureConfig.instance.asMap);",
      "  }",
      "",
      "  Future<void> _save() async {",
      "    // You'll want to save updated toggles to Firestore here, e.g.:",
      "    // await FirestoreService().updateFeatureToggles(featureMap);",
      "    if (widget.onChanged != null) widget.onChanged!();",
      "    Navigator.pop(context);",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return AlertDialog(",
      "      title: const Text('Feature Toggles'),",
      "      content: SingleChildScrollView(",
      "        child: Column(",
      "          mainAxisSize: MainAxisSize.min,",
      "          children: featureMap.entries.map((e) {",
      "            return SwitchListTile(",
      "              value: e.value,",
      "              title: Text(e.key),",
      "              onChanged: (v) => setState(() => featureMap[e.key] = v),",
      "            );",
      "          }).toList(),",
      "        ),",
      "      ),",
      "      actions: [",
      "        TextButton(",
      "            onPressed: () => Navigator.pop(context),",
      "            child: const Text('Cancel')),",
      "        ElevatedButton(onPressed: _save, child: const Text('Save')),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 52,
      "file_size": 1625,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\features\\alerts\\alerts_repository.dart",
    "content": [
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/config/app_config.dart';",
      "import 'package:franchise_admin_portal/core/models/alert_model.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/models/dashboard_section.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class AlertsRepository {",
      "  final FirebaseFirestore _firestore;",
      "  final FirestoreService _firestoreService;",
      "  final AppConfig? _appConfig;",
      "",
      "  AlertsRepository({",
      "    FirebaseFirestore? firestore,",
      "    FirestoreService? firestoreService,",
      "    AppConfig? appConfig,",
      "  })  : _firestore = firestore ?? FirebaseFirestore.instance,",
      "        _firestoreService = firestoreService ?? FirestoreService(),",
      "        _appConfig = appConfig;",
      "",
      "  /// Stream all active alerts for the given franchise/location.",
      "  Stream<List<AlertModel>> watchActiveAlerts({",
      "    required String franchiseId,",
      "    String? locationId,",
      "    bool developerMode = false,",
      "  }) {",
      "    Query query = _firestore.collection('alerts');",
      "    query = query",
      "        .where('franchiseId.path', isEqualTo: 'franchises/$franchiseId')",
      "        .where('dismissed_at', isNull: true);",
      "",
      "    if (locationId != null) {",
      "      query = query.where('locationId.path',",
      "          isEqualTo: 'franchise_locations/$locationId');",
      "    }",
      "",
      "    // Hide developer/test alerts if not in dev mode",
      "    if (!developerMode) {",
      "      query = query.where('type', isNotEqualTo: 'developer');",
      "    }",
      "",
      "    return query.orderBy('created_at', descending: true).snapshots().map(",
      "      (snapshot) {",
      "        return snapshot.docs.map(AlertModel.fromFirestore).toList();",
      "      },",
      "    );",
      "  }",
      "",
      "  /// Fetch all alert history for the given franchise/location.",
      "  Future<List<AlertModel>> fetchAllAlerts({",
      "    required String franchiseId,",
      "    String? locationId,",
      "    bool includeDismissed = true,",
      "    bool developerMode = false,",
      "    String? userId,",
      "  }) async {",
      "    try {",
      "      Query query = _firestore.collection('alerts');",
      "      query =",
      "          query.where('franchiseId.path', isEqualTo: 'franchises/$franchiseId');",
      "      if (locationId != null) {",
      "        query = query.where('locationId.path',",
      "            isEqualTo: 'franchise_locations/$locationId');",
      "      }",
      "      if (!includeDismissed) {",
      "        query = query.where('dismissed_at', isNull: true);",
      "      }",
      "      if (!developerMode) {",
      "        query = query.where('type', isNotEqualTo: 'developer');",
      "      }",
      "      final snapshot =",
      "          await query.orderBy('created_at', descending: true).get();",
      "      return snapshot.docs.map(AlertModel.fromFirestore).toList();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to fetch all alerts: $e',",
      "        source: 'alerts_repository_fetchAllAlerts',",
      "        stack: stack.toString(),",
      "        screen: 'AlertsRepository',",
      "        severity: 'error',",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "          'locationId': locationId,",
      "          'userId': userId,",
      "          'errorType': e.runtimeType.toString(),",
      "        },",
      "      );",
      "      return [];",
      "    }",
      "  }",
      "",
      "  /// Dismiss an alert (mark as dismissed for all users).",
      "  Future<void> dismissAlert(",
      "    String franchiseId,",
      "    String alertId,",
      "    String userId, {",
      "    String? screen,",
      "  }) async {",
      "    try {",
      "      await _firestore.collection('alerts').doc(alertId).update({",
      "        'dismissed_at': FieldValue.serverTimestamp(),",
      "        'seen_by': FieldValue.arrayUnion([userId]),",
      "      });",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to dismiss alert: $e',",
      "        source: 'alerts_repository_dismissAlert',",
      "        stack: stack.toString(),",
      "        screen: screen ?? 'AlertsRepository',",
      "        severity: 'error',",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "          'alertId': alertId,",
      "          'userId': userId,",
      "          'errorType': e.runtimeType.toString(),",
      "        },",
      "      );",
      "    }",
      "  }",
      "",
      "  /// Mark alert as seen by this user.",
      "  Future<void> markAlertSeen(",
      "    String franchiseId,",
      "    String alertId,",
      "    String userId, {",
      "    String? screen,",
      "  }) async {",
      "    try {",
      "      await _firestore.collection('alerts').doc(alertId).update({",
      "        'seen_by': FieldValue.arrayUnion([userId]),",
      "      });",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to mark alert as seen: $e',",
      "        source: 'alerts_repository_markAlertSeen',",
      "        stack: stack.toString(),",
      "        screen: screen ?? 'AlertsRepository',",
      "        severity: 'error',",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "          'alertId': alertId,",
      "          'userId': userId,",
      "          'errorType': e.runtimeType.toString(),",
      "        },",
      "      );",
      "    }",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 150,
      "file_size": 4959,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\feedback\\feedback_management_screen.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:intl/intl.dart';",
      "import 'package:franchise_admin_portal/core/models/feedback_entry.dart'",
      "    as feedback_model;",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/config/branding_config.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/widgets/feedback/feedback_detail_dialog.dart';",
      "",
      "class FeedbackManagementScreen extends StatefulWidget {",
      "  const FeedbackManagementScreen({super.key});",
      "",
      "  @override",
      "  State<FeedbackManagementScreen> createState() =>",
      "      _FeedbackManagementScreenState();",
      "}",
      "",
      "class _FeedbackManagementScreenState extends State<FeedbackManagementScreen> {",
      "  String _filterType = 'all';",
      "  String _sortOrder = 'recent';",
      "  String _search = '';",
      "",
      "  void _confirmDelete(",
      "      BuildContext context, FirestoreService service, String feedbackId) {",
      "    final loc = AppLocalizations.of(context);",
      "    final franchiseId = context.read<FranchiseProvider>().franchiseId;",
      "    if (loc == null) return;",
      "",
      "    showDialog(",
      "      context: context,",
      "      builder: (_) => AlertDialog(",
      "        title: Text(loc.deleteFeedback),",
      "        content: Text(loc.deleteFeedbackConfirm),",
      "        actions: [",
      "          TextButton(",
      "            onPressed: () => Navigator.pop(context),",
      "            child: Text(loc.cancel),",
      "          ),",
      "          ElevatedButton(",
      "            onPressed: () async {",
      "              await service.deleteFeedbackEntry(franchiseId, feedbackId);",
      "              if (!mounted) return;",
      "              Navigator.pop(context);",
      "            },",
      "            style: ElevatedButton.styleFrom(backgroundColor: Colors.red),",
      "            child: Text(loc.delete),",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "",
      "  // void _showFeedbackDetailDialog(BuildContext context,",
      "  //     feedback_model.FeedbackEntry feedback, AppLocalizations loc) {",
      "  //   showDialog(",
      "  //     context: context,",
      "  //     builder: (_) => AlertDialog(",
      "  //       title: Row(",
      "  //         children: [",
      "  //           _TypeIcon(feedback: feedback),",
      "  //           const SizedBox(width: 8),",
      "  //           Text(",
      "  //             feedback.feedbackMode == 'orderExperience'",
      "  //                 ? loc.filterOrderFeedback",
      "  //                 : loc.filterAppFeedback,",
      "  //             style: const TextStyle(fontWeight: FontWeight.bold),",
      "  //           ),",
      "  //           ...List.generate(",
      "  //             5,",
      "  //             (idx) => Icon(",
      "  //               idx < feedback.rating ? Icons.star : Icons.star_border,",
      "  //               color:",
      "  //                   idx < feedback.rating ? Colors.amber : Colors.grey.shade400,",
      "  //               size: 18,",
      "  //             ),",
      "  //           ),",
      "  //         ],",
      "  //       ),",
      "  //       content: SingleChildScrollView(",
      "  //         child: Column(",
      "  //           crossAxisAlignment: CrossAxisAlignment.start,",
      "  //           children: [",
      "  //             if (feedback.orderId.isNotEmpty)",
      "  //               Text('${loc.orderIdLabel}: ${feedback.orderId}'),",
      "  //             if (feedback.anonymous)",
      "  //               Padding(",
      "  //                 padding: const EdgeInsets.only(top: 6),",
      "  //                 child: Text(loc.feedbackAnonymous,",
      "  //                     style: const TextStyle(color: Colors.grey)),",
      "  //               ),",
      "  //             if (feedback.categories.isNotEmpty)",
      "  //               Padding(",
      "  //                 padding: const EdgeInsets.only(top: 2.0),",
      "  //                 child: Column(",
      "  //                   crossAxisAlignment: CrossAxisAlignment.start,",
      "  //                   children: feedback.categories.map((catScore) {",
      "  //                     final parts = catScore.split(':');",
      "  //                     return Padding(",
      "  //                       padding: const EdgeInsets.only(bottom: 4),",
      "  //                       child: Chip(",
      "  //                         label: Text(",
      "  //                           parts.length > 1",
      "  //                               ? '${parts[0].trim()}: ${parts[1].trim()}'",
      "  //                               : catScore,",
      "  //                           style: const TextStyle(fontSize: 13),",
      "  //                         ),",
      "  //                         backgroundColor: DesignTokens.surfaceColor,",
      "  //                         side: BorderSide.none,",
      "  //                         visualDensity: VisualDensity.compact,",
      "  //                       ),",
      "  //                     );",
      "  //                   }).toList(),",
      "  //                 ),",
      "  //               ),",
      "  //             Padding(",
      "  //               padding: const EdgeInsets.symmetric(vertical: 8),",
      "  //               child: Text(",
      "  //                 feedback.comment?.isNotEmpty == true",
      "  //                     ? feedback.comment!",
      "  //                     : (feedback.message.isNotEmpty",
      "  //                         ? feedback.message",
      "  //                         : loc.noMessage),",
      "  //                 style: const TextStyle(fontSize: 15),",
      "  //               ),",
      "  //             ),",
      "  //             Text(",
      "  //                 '${loc.submitted}: ${DateFormat('yyyy-MM-dd – HH:mm').format(feedback.timestamp)}',",
      "  //                 style: const TextStyle(fontSize: 12, color: Colors.grey)),",
      "  //             if (feedback.userId.isNotEmpty && !feedback.anonymous)",
      "  //               Padding(",
      "  //                 padding: const EdgeInsets.only(top: 6),",
      "  //                 child: Text('User: ${feedback.userId}',",
      "  //                     style: const TextStyle(fontSize: 12, color: Colors.grey)),",
      "  //               ),",
      "  //           ],",
      "  //         ),",
      "  //       ),",
      "  //       actions: [",
      "  //         TextButton(",
      "  //           onPressed: () => Navigator.of(context).pop(),",
      "  //           child: Text(loc.close),",
      "  //         ),",
      "  //       ],",
      "  //     ),",
      "  //   );",
      "  // }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final franchiseId = context.watch<FranchiseProvider>().franchiseId;",
      "    final firestoreService = context.read<FirestoreService>();",
      "    final loc = AppLocalizations.of(context);",
      "    final theme = Theme.of(context);",
      "",
      "    final isDarkMode = Theme.of(context).brightness == Brightness.dark;",
      "    final dropdownTextStyle = TextStyle(",
      "      color: isDarkMode ? Colors.white : Colors.black87,",
      "    );",
      "",
      "    if (loc == null) {",
      "      return const Scaffold(body: Center(child: Text('Localization missing')));",
      "    }",
      "",
      "    return Scaffold(",
      "      backgroundColor: theme.colorScheme.background,",
      "      body: Row(",
      "        children: [",
      "          Expanded(",
      "            flex: 11,",
      "            child: Padding(",
      "              padding: const EdgeInsets.all(24.0),",
      "              child: Column(",
      "                crossAxisAlignment: CrossAxisAlignment.start,",
      "                children: [",
      "                  Row(",
      "                    children: [",
      "                      Text(loc.feedbackManagement,",
      "                          style: theme.textTheme.titleLarge),",
      "                      const Spacer(),",
      "                      IconButton(",
      "                        icon: const Icon(Icons.refresh),",
      "                        onPressed: () => setState(() {}),",
      "                      ),",
      "                    ],",
      "                  ),",
      "                  const SizedBox(height: 8),",
      "                  Row(",
      "                    children: [",
      "                      DropdownButton<String>(",
      "                        value: _filterType,",
      "                        onChanged: (val) => setState(() => _filterType = val!),",
      "                        items: [",
      "                          DropdownMenuItem(",
      "                              value: 'all',",
      "                              child:",
      "                                  Text(loc.allTypes, style: dropdownTextStyle)),",
      "                          DropdownMenuItem(",
      "                              value: 'ordering',",
      "                              child: Text(loc.filterAppFeedback,",
      "                                  style: dropdownTextStyle)),",
      "                          DropdownMenuItem(",
      "                              value: 'orderExperience',",
      "                              child: Text(loc.filterOrderFeedback,",
      "                                  style: dropdownTextStyle)),",
      "                        ],",
      "                        dropdownColor: Theme.of(context).cardColor,",
      "                        style: dropdownTextStyle,",
      "                        underline: const SizedBox(),",
      "                      ),",
      "                      const SizedBox(width: 12),",
      "                      DropdownButton<String>(",
      "                        value: _sortOrder,",
      "                        onChanged: (val) => setState(() => _sortOrder = val!),",
      "                        items: [",
      "                          DropdownMenuItem(",
      "                              value: 'recent',",
      "                              child: Text(loc.sortRecent,",
      "                                  style: dropdownTextStyle)),",
      "                          DropdownMenuItem(",
      "                              value: 'oldest',",
      "                              child: Text(loc.sortOldest,",
      "                                  style: dropdownTextStyle)),",
      "                          DropdownMenuItem(",
      "                              value: 'lowest',",
      "                              child: Text(loc.sortLowest,",
      "                                  style: dropdownTextStyle)),",
      "                          DropdownMenuItem(",
      "                              value: 'highest',",
      "                              child: Text(loc.sortHighest,",
      "                                  style: dropdownTextStyle)),",
      "                        ],",
      "                        dropdownColor: Theme.of(context).cardColor,",
      "                        style: dropdownTextStyle,",
      "                        underline: const SizedBox(),",
      "                      ),",
      "                      const SizedBox(width: 12),",
      "                      Expanded(",
      "                        child: TextField(",
      "                          decoration: InputDecoration(",
      "                            hintText: loc.searchFeedback,",
      "                            prefixIcon: const Icon(Icons.search, size: 18),",
      "                            border: OutlineInputBorder(",
      "                              borderRadius: BorderRadius.circular(24),",
      "                              borderSide: BorderSide(",
      "                                  width: 0.5, color: Colors.grey.shade400),",
      "                            ),",
      "                            isDense: true,",
      "                          ),",
      "                          style: const TextStyle(fontSize: 14),",
      "                          onChanged: (v) => setState(() => _search = v),",
      "                        ),",
      "                      ),",
      "                    ],",
      "                  ),",
      "                  const SizedBox(height: 12),",
      "                  Expanded(",
      "                    child: StreamBuilder<List<feedback_model.FeedbackEntry>>(",
      "                      stream: firestoreService.getFeedbackEntries(franchiseId),",
      "                      builder: (context, snapshot) {",
      "                        if (!snapshot.hasData || snapshot.data!.isEmpty) {",
      "                          return Center(child: Text(loc.noFeedbackSubmitted));",
      "                        }",
      "                        List<feedback_model.FeedbackEntry> feedbacks =",
      "                            snapshot.data!;",
      "                        if (_filterType != 'all') {",
      "                          feedbacks = feedbacks",
      "                              .where((f) => f.feedbackMode == _filterType)",
      "                              .toList();",
      "                        }",
      "                        if (_search.trim().isNotEmpty) {",
      "                          final s = _search.toLowerCase();",
      "                          feedbacks = feedbacks",
      "                              .where((f) =>",
      "                                  (f.comment?.toLowerCase().contains(s) ??",
      "                                      false) ||",
      "                                  f.categories.any(",
      "                                      (c) => c.toLowerCase().contains(s)) ||",
      "                                  f.orderId.toLowerCase().contains(s) ||",
      "                                  f.userId.toLowerCase().contains(s))",
      "                              .toList();",
      "                        }",
      "                        switch (_sortOrder) {",
      "                          case 'oldest':",
      "                            feedbacks.sort(",
      "                                (a, b) => a.timestamp.compareTo(b.timestamp));",
      "                            break;",
      "                          case 'lowest':",
      "                            feedbacks",
      "                                .sort((a, b) => a.rating.compareTo(b.rating));",
      "                            break;",
      "                          case 'highest':",
      "                            feedbacks",
      "                                .sort((a, b) => b.rating.compareTo(a.rating));",
      "                            break;",
      "                          default:",
      "                            feedbacks.sort(",
      "                                (a, b) => b.timestamp.compareTo(a.timestamp));",
      "                        }",
      "                        return ListView.separated(",
      "                          itemCount: feedbacks.length,",
      "                          separatorBuilder: (_, __) => const Divider(height: 1),",
      "                          itemBuilder: (context, i) {",
      "                            final feedback = feedbacks[i];",
      "                            final isOrderFeedback =",
      "                                feedback.feedbackMode == 'orderExperience';",
      "                            return ListTile(",
      "                              contentPadding: const EdgeInsets.symmetric(",
      "                                  horizontal: 14, vertical: 6),",
      "                              leading: _TypeIcon(feedback: feedback),",
      "                              title: Row(",
      "                                children: [",
      "                                  Text(",
      "                                    isOrderFeedback",
      "                                        ? loc.filterOrderFeedback",
      "                                        : loc.filterAppFeedback,",
      "                                    style: TextStyle(",
      "                                      fontWeight: FontWeight.bold,",
      "                                      fontSize: 16,",
      "                                      color: isOrderFeedback",
      "                                          ? theme.colorScheme.primary",
      "                                          : theme.colorScheme.secondary,",
      "                                    ),",
      "                                  ),",
      "                                  const SizedBox(width: 6),",
      "                                  Row(",
      "                                    children: List.generate(",
      "                                        5,",
      "                                        (idx) => Icon(",
      "                                              idx < feedback.rating",
      "                                                  ? Icons.star",
      "                                                  : Icons.star_border,",
      "                                              color: idx < feedback.rating",
      "                                                  ? Colors.amber",
      "                                                  : Colors.grey.shade400,",
      "                                              size: 18,",
      "                                            )),",
      "                                  ),",
      "                                  if (feedback.anonymous) ...[",
      "                                    const SizedBox(width: 8),",
      "                                    Tooltip(",
      "                                      message: loc.feedbackAnonymous,",
      "                                      child: const Icon(Icons.visibility_off,",
      "                                          color: Colors.grey, size: 16),",
      "                                    ),",
      "                                  ],",
      "                                ],",
      "                              ),",
      "                              subtitle: Column(",
      "                                crossAxisAlignment: CrossAxisAlignment.start,",
      "                                children: [",
      "                                  if (feedback.orderId.isNotEmpty)",
      "                                    Text(",
      "                                        '${loc.orderIdLabel}: ${feedback.orderId}',",
      "                                        style: const TextStyle(fontSize: 12)),",
      "                                  if (feedback.categories.isNotEmpty)",
      "                                    Padding(",
      "                                      padding: const EdgeInsets.only(top: 6.0),",
      "                                      child: SingleChildScrollView(",
      "                                        scrollDirection: Axis.horizontal,",
      "                                        child: Row(",
      "                                          children: feedback.categories",
      "                                              .map((catScore) {",
      "                                            final parts = catScore.split(':');",
      "                                            final labelText = parts.length > 1",
      "                                                ? '${parts[0].trim()}: ${parts[1].trim()}'",
      "                                                : catScore;",
      "",
      "                                            final theme = Theme.of(context);",
      "                                            final chipBackground = theme",
      "                                                .colorScheme.surfaceVariant;",
      "                                            final chipTextColor = theme",
      "                                                .colorScheme.onSurfaceVariant;",
      "",
      "                                            return Padding(",
      "                                              padding: const EdgeInsets.only(",
      "                                                  right: 8),",
      "                                              child: Chip(",
      "                                                label: Text(",
      "                                                  labelText,",
      "                                                  style: TextStyle(",
      "                                                    fontSize: 13,",
      "                                                    color: chipTextColor,",
      "                                                  ),",
      "                                                ),",
      "                                                backgroundColor: chipBackground,",
      "                                                side: BorderSide.none,",
      "                                                visualDensity:",
      "                                                    VisualDensity.compact,",
      "                                              ),",
      "                                            );",
      "                                          }).toList(),",
      "                                        ),",
      "                                      ),",
      "                                    ),",
      "                                  if ((feedback.comment?.isNotEmpty ?? false) ||",
      "                                      feedback.message.isNotEmpty)",
      "                                    Padding(",
      "                                      padding: const EdgeInsets.symmetric(",
      "                                          vertical: 4),",
      "                                      child: Row(",
      "                                        crossAxisAlignment:",
      "                                            CrossAxisAlignment.start,",
      "                                        children: [",
      "                                          Text('${loc.notesLabel ?? 'Notes:'} ',",
      "                                              style: const TextStyle(",
      "                                                  fontWeight: FontWeight.bold,",
      "                                                  fontSize: 13)),",
      "                                          Expanded(",
      "                                            child: Text(",
      "                                              feedback.comment?.isNotEmpty ==",
      "                                                      true",
      "                                                  ? feedback.comment!",
      "                                                  : feedback.message,",
      "                                              style:",
      "                                                  const TextStyle(fontSize: 13),",
      "                                              maxLines: 2,",
      "                                              overflow: TextOverflow.ellipsis,",
      "                                            ),",
      "                                          ),",
      "                                        ],",
      "                                      ),",
      "                                    ),",
      "                                  Padding(",
      "                                    padding: const EdgeInsets.only(top: 2),",
      "                                    child: Text(",
      "                                      DateFormat('yyyy-MM-dd – HH:mm')",
      "                                          .format(feedback.timestamp),",
      "                                      style: const TextStyle(",
      "                                          fontSize: 11, color: Colors.grey),",
      "                                    ),",
      "                                  ),",
      "                                ],",
      "                              ),",
      "                              trailing: PopupMenuButton<String>(",
      "                                onSelected: (val) {",
      "                                  if (val == 'delete') {",
      "                                    _confirmDelete(",
      "                                        context, firestoreService, feedback.id);",
      "                                  }",
      "                                },",
      "                                itemBuilder: (context) => [",
      "                                  PopupMenuItem(",
      "                                    value: 'delete',",
      "                                    child: Row(",
      "                                      children: [",
      "                                        const Icon(Icons.delete,",
      "                                            color: Colors.red, size: 18),",
      "                                        const SizedBox(width: 6),",
      "                                        Text(loc.delete),",
      "                                      ],",
      "                                    ),",
      "                                  ),",
      "                                ],",
      "                              ),",
      "                              onTap: () => showDialog(",
      "                                context: context,",
      "                                builder: (_) =>",
      "                                    FeedbackDetailDialog(feedback: feedback),",
      "                              ),",
      "                            );",
      "                          },",
      "                        );",
      "                      },",
      "                    ),",
      "                  ),",
      "                ],",
      "              ),",
      "            ),",
      "          ),",
      "          const Expanded(flex: 9, child: SizedBox()),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "class _TypeIcon extends StatelessWidget {",
      "  final feedback_model.FeedbackEntry feedback;",
      "  const _TypeIcon({required this.feedback});",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final isOrderFeedback = feedback.feedbackMode == 'orderExperience';",
      "    return Icon(",
      "      isOrderFeedback ? Icons.fastfood : Icons.app_settings_alt,",
      "      color: isOrderFeedback",
      "          ? Theme.of(context).colorScheme.primary",
      "          : Theme.of(context).colorScheme.secondary,",
      "      size: 28,",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 495,
      "file_size": 23673,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\franchise\\franchise_selector_screen.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/widgets/admin/admin_sidebar.dart';",
      "import 'package:franchise_admin_portal/widgets/admin/franchise_selector.dart';",
      "import 'package:franchise_admin_portal/core/models/franchise_info.dart';",
      "import 'package:franchise_admin_portal/core/providers/user_profile_notifier.dart';",
      "import 'package:franchise_admin_portal/core/utils/franchise_utils.dart';",
      "",
      "class FranchiseSelectorScreen extends StatefulWidget {",
      "  const FranchiseSelectorScreen({super.key});",
      "",
      "  @override",
      "  State<FranchiseSelectorScreen> createState() =>",
      "      _FranchiseSelectorScreenState();",
      "}",
      "",
      "class _FranchiseSelectorScreenState extends State<FranchiseSelectorScreen> {",
      "  late Future<List<FranchiseInfo>> _franchisesFuture;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    final firestoreService =",
      "        Provider.of<FirestoreService>(context, listen: false);",
      "    _franchisesFuture = firestoreService.fetchFranchiseList();",
      "    print('[FranchiseSelectorScreen] initState: fetching franchise list...');",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    print(",
      "        '[FranchiseSelectorScreen] build called (if you see this, YOU ARE ON THE SELECTOR SCREEN)');",
      "",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    final franchiseProvider =",
      "        Provider.of<FranchiseProvider>(context, listen: false);",
      "",
      "    return Scaffold(",
      "      appBar: AppBar(",
      "        title: Text(loc.switchFranchise),",
      "      ),",
      "      drawer: AdminSidebar(",
      "        sections: const [],",
      "        selectedIndex: 0,",
      "        onSelect: (_) {},",
      "      ),",
      "      body: SafeArea(",
      "        child: FutureBuilder<List<FranchiseInfo>>(",
      "          future: _franchisesFuture,",
      "          builder: (context, snapshot) {",
      "            if (snapshot.connectionState == ConnectionState.waiting) {",
      "              print('[FranchiseSelectorScreen] Loading franchises...');",
      "              return const Center(child: CircularProgressIndicator());",
      "            } else if (snapshot.hasError) {",
      "              print(",
      "                  '[FranchiseSelectorScreen] Error loading franchises: ${snapshot.error}');",
      "              return Center(child: Text(loc.errorLoadingFranchises));",
      "            } else if (!snapshot.hasData || snapshot.data!.isEmpty) {",
      "              print('[FranchiseSelectorScreen] No franchises found.');",
      "              return Center(child: Text(loc.noFranchisesFound));",
      "            }",
      "",
      "            final franchises = snapshot.data!;",
      "            print(",
      "                '[FranchiseSelectorScreen] Franchises loaded: ${franchises.map((f) => f.id).toList()}');",
      "",
      "            return Padding(",
      "              padding: const EdgeInsets.all(16.0),",
      "              child: FranchiseSelector(",
      "                items: franchises,",
      "                selectedFranchiseId: franchiseProvider.franchiseId,",
      "                onSelected: (franchiseId) {",
      "                  print(",
      "                      '[FranchiseSelectorScreen] onSelected fired with: $franchiseId');",
      "                  franchiseProvider.setFranchiseId(franchiseId).then((_) {",
      "                    print(",
      "                        '[FranchiseSelectorScreen] franchiseProvider updated.');",
      "                    Navigator.of(context)",
      "                        .pushReplacementNamed('/admin/dashboard');",
      "                    print('[Routing] Navigating to /admin/dashboard');",
      "                  });",
      "                },",
      "              ),",
      "            );",
      "          },",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 100,
      "file_size": 4009,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\hq_owner\\invoice_audit_trail_widget.dart",
    "content": [
      "// File: lib/admin/hq_owner/invoice_audit_trail_widget.dart",
      "",
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "",
      "import 'package:franchise_admin_portal/core/models/invoice.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "/// InvoiceAuditTrailWidget",
      "/// Displays a chronological timeline of audit events for a given invoice.",
      "/// Shows event type, timestamp, user info, and optional notes.",
      "/// Designed for franchise HQ/Owner portals with localization, theming,",
      "/// and modular UI architecture.",
      "",
      "class InvoiceAuditTrailWidget extends StatelessWidget {",
      "  final List<InvoiceAuditEvent> auditEvents;",
      "",
      "  const InvoiceAuditTrailWidget({Key? key, required this.auditEvents})",
      "      : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "",
      "    if (auditEvents.isEmpty) {",
      "      return Center(",
      "        child: Text(loc.noAuditTrail),",
      "      );",
      "    }",
      "",
      "    final sortedEvents = List<InvoiceAuditEvent>.from(auditEvents)",
      "      ..sort((a, b) => a.timestamp.compareTo(b.timestamp));",
      "",
      "    return ListView.builder(",
      "      shrinkWrap: true,",
      "      physics: const NeverScrollableScrollPhysics(),",
      "      itemCount: sortedEvents.length,",
      "      itemBuilder: (context, index) {",
      "        final event = sortedEvents[index];",
      "        final isLast = index == sortedEvents.length - 1;",
      "        return _buildTimelineTile(context, event, isLast);",
      "      },",
      "    );",
      "  }",
      "",
      "  Widget _buildTimelineTile(",
      "      BuildContext context, InvoiceAuditEvent event, bool isLast) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    final theme = Theme.of(context);",
      "",
      "    final formattedDate =",
      "        MaterialLocalizations.of(context).formatShortDate(event.timestamp);",
      "    final formattedTime = MaterialLocalizations.of(context).formatTimeOfDay(",
      "      TimeOfDay.fromDateTime(event.timestamp),",
      "      alwaysUse24HourFormat: false,",
      "    );",
      "",
      "    return IntrinsicHeight(",
      "      child: Row(",
      "        crossAxisAlignment: CrossAxisAlignment.start,",
      "        children: [",
      "          // Timeline indicator",
      "          Container(",
      "            width: 24,",
      "            child: Column(",
      "              children: [",
      "                Container(",
      "                  width: 12,",
      "                  height: 12,",
      "                  decoration: BoxDecoration(",
      "                    color: theme.colorScheme.primary,",
      "                    shape: BoxShape.circle,",
      "                  ),",
      "                ),",
      "                if (!isLast)",
      "                  Expanded(",
      "                    child: Container(",
      "                      width: 2,",
      "                      color: theme.colorScheme.primary.withOpacity(0.5),",
      "                    ),",
      "                  ),",
      "              ],",
      "            ),",
      "          ),",
      "",
      "          const SizedBox(width: DesignTokens.paddingMd),",
      "",
      "          // Event details",
      "          Expanded(",
      "            child: Column(",
      "              crossAxisAlignment: CrossAxisAlignment.start,",
      "              children: [",
      "                Text(",
      "                  _localizedEventType(event.eventType, loc),",
      "                  style: theme.textTheme.titleMedium",
      "                      ?.copyWith(fontWeight: FontWeight.bold),",
      "                ),",
      "                const SizedBox(height: 4),",
      "                Text(",
      "                  '$formattedDate $formattedTime',",
      "                  style: theme.textTheme.bodySmall,",
      "                ),",
      "                if (event.userId.isNotEmpty)",
      "                  Padding(",
      "                    padding: const EdgeInsets.only(top: 2),",
      "                    child: Text(",
      "                      '${loc.byUser}: ${event.userId}',",
      "                      style: theme.textTheme.bodySmall,",
      "                    ),",
      "                  ),",
      "                if (event.notes != null && event.notes!.isNotEmpty)",
      "                  Padding(",
      "                    padding: const EdgeInsets.only(top: 6),",
      "                    child: Text(",
      "                      event.notes!,",
      "                      style: theme.textTheme.bodyMedium,",
      "                    ),",
      "                  ),",
      "              ],",
      "            ),",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "",
      "  String _localizedEventType(String eventType, AppLocalizations loc) {",
      "    switch (eventType.toLowerCase()) {",
      "      case 'created':",
      "        return loc.eventCreated;",
      "      case 'sent':",
      "        return loc.eventSent;",
      "      case 'viewed':",
      "        return loc.eventViewed;",
      "      case 'paid':",
      "        return loc.eventPaid;",
      "      case 'overdue':",
      "        return loc.eventOverdue;",
      "      case 'refunded':",
      "        return loc.eventRefunded;",
      "      case 'voided':",
      "        return loc.eventVoided;",
      "      case 'failed':",
      "        return loc.eventFailed;",
      "      default:",
      "        return eventType;",
      "    }",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 164,
      "file_size": 5353,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\hq_owner\\invoice_search_bar.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "",
      "/// InvoiceSearchBar",
      "/// A reusable widget for searching, filtering, and sorting invoice history.",
      "/// Includes:",
      "/// - Text search input with debounce support.",
      "/// - Status dropdown filter.",
      "/// - Sort order selector.",
      "/// - Uses localized labels from AppLocalizations.",
      "/// - Uses consistent spacing and theming from DesignTokens.",
      "/// - Designed modularly to fit dashboard/filter panels.",
      "",
      "typedef InvoiceSearchCallback = void Function(String? searchTerm);",
      "typedef InvoiceStatusFilterCallback = void Function(String? status);",
      "typedef InvoiceSortOrderCallback = void Function(InvoiceSortOrder order);",
      "",
      "enum InvoiceSortOrder {",
      "  dateAsc,",
      "  dateDesc,",
      "  totalAsc,",
      "  totalDesc,",
      "}",
      "",
      "class InvoiceSearchBar extends StatefulWidget {",
      "  final InvoiceSearchCallback? onSearchChanged;",
      "  final InvoiceStatusFilterCallback? onStatusFilterChanged;",
      "  final InvoiceSortOrderCallback? onSortOrderChanged;",
      "",
      "  final String? initialSearchTerm;",
      "  final String? initialStatusFilter;",
      "  final InvoiceSortOrder initialSortOrder;",
      "",
      "  const InvoiceSearchBar({",
      "    Key? key,",
      "    this.onSearchChanged,",
      "    this.onStatusFilterChanged,",
      "    this.onSortOrderChanged,",
      "    this.initialSearchTerm,",
      "    this.initialStatusFilter,",
      "    this.initialSortOrder = InvoiceSortOrder.dateDesc,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  State<InvoiceSearchBar> createState() => _InvoiceSearchBarState();",
      "}",
      "",
      "class _InvoiceSearchBarState extends State<InvoiceSearchBar> {",
      "  late TextEditingController _searchController;",
      "  String? _selectedStatus;",
      "  late InvoiceSortOrder _selectedSortOrder;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _searchController =",
      "        TextEditingController(text: widget.initialSearchTerm ?? '');",
      "    _selectedStatus = widget.initialStatusFilter;",
      "    _selectedSortOrder = widget.initialSortOrder;",
      "  }",
      "",
      "  @override",
      "  void dispose() {",
      "    _searchController.dispose();",
      "    super.dispose();",
      "  }",
      "",
      "  void _onSearchChanged() {",
      "    widget.onSearchChanged?.call(_searchController.text.trim().isEmpty",
      "        ? null",
      "        : _searchController.text.trim());",
      "  }",
      "",
      "  void _onStatusChanged(String? value) {",
      "    setState(() {",
      "      _selectedStatus = value;",
      "    });",
      "    widget.onStatusFilterChanged?.call(value);",
      "  }",
      "",
      "  void _onSortOrderChanged(InvoiceSortOrder? order) {",
      "    if (order == null) return;",
      "    setState(() {",
      "      _selectedSortOrder = order;",
      "    });",
      "    widget.onSortOrderChanged?.call(order);",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "",
      "    return Padding(",
      "      padding: const EdgeInsets.all(DesignTokens.paddingMd),",
      "      child: Column(",
      "        crossAxisAlignment: CrossAxisAlignment.start,",
      "        children: [",
      "          // Search field",
      "          TextField(",
      "            controller: _searchController,",
      "            decoration: InputDecoration(",
      "              labelText: loc.searchInvoices,",
      "              prefixIcon: const Icon(Icons.search),",
      "              border: const OutlineInputBorder(),",
      "              isDense: true,",
      "            ),",
      "            onChanged: (_) => _onSearchChanged(),",
      "          ),",
      "          const SizedBox(height: DesignTokens.paddingMd),",
      "",
      "          // Filters & Sort Row",
      "          Row(",
      "            children: [",
      "              // Status filter dropdown",
      "              Expanded(",
      "                child: DropdownButtonFormField<String?>(",
      "                  value: _selectedStatus,",
      "                  decoration: InputDecoration(",
      "                    labelText: loc.filterByStatus,",
      "                    border: const OutlineInputBorder(),",
      "                    isDense: true,",
      "                  ),",
      "                  items: <String?>[",
      "                    null,",
      "                    'draft',",
      "                    'sent',",
      "                    'paid',",
      "                    'overdue',",
      "                    'refunded',",
      "                    'voided',",
      "                    'failed',",
      "                  ].map((status) {",
      "                    return DropdownMenuItem<String?>(",
      "                      value: status,",
      "                      child: Text(status == null",
      "                          ? loc.allStatuses",
      "                          : _capitalize(status)),",
      "                    );",
      "                  }).toList(),",
      "                  onChanged: _onStatusChanged,",
      "                  isExpanded: true,",
      "                ),",
      "              ),",
      "",
      "              const SizedBox(width: DesignTokens.paddingMd),",
      "",
      "              // Sort order dropdown",
      "              Expanded(",
      "                child: DropdownButtonFormField<InvoiceSortOrder>(",
      "                  value: _selectedSortOrder,",
      "                  decoration: InputDecoration(",
      "                    labelText: loc.sortBy,",
      "                    border: const OutlineInputBorder(),",
      "                    isDense: true,",
      "                  ),",
      "                  items: [",
      "                    DropdownMenuItem(",
      "                      value: InvoiceSortOrder.dateDesc,",
      "                      child: Text(loc.sortDateDesc),",
      "                    ),",
      "                    DropdownMenuItem(",
      "                      value: InvoiceSortOrder.dateAsc,",
      "                      child: Text(loc.sortDateAsc),",
      "                    ),",
      "                    DropdownMenuItem(",
      "                      value: InvoiceSortOrder.totalDesc,",
      "                      child: Text(loc.sortTotalDesc),",
      "                    ),",
      "                    DropdownMenuItem(",
      "                      value: InvoiceSortOrder.totalAsc,",
      "                      child: Text(loc.sortTotalAsc),",
      "                    ),",
      "                  ],",
      "                  onChanged: _onSortOrderChanged,",
      "                  isExpanded: true,",
      "                ),",
      "              ),",
      "            ],",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "",
      "  String _capitalize(String s) =>",
      "      s.isEmpty ? s : s[0].toUpperCase() + s.substring(1);",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 195,
      "file_size": 6293,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\hq_owner\\owner_hq_dashboard_screen.dart",
    "content": [
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/config/branding_config.dart';",
      "import 'package:franchise_admin_portal/core/models/dashboard_section.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/user_profile_notifier.dart';",
      "import 'package:franchise_admin_portal/widgets/dashboard/role_badge.dart';",
      "import 'package:franchise_admin_portal/admin/developer/developer_dashboard_screen.dart';",
      "import 'package:franchise_admin_portal/widgets/dashboard/dashboard_switcher_dropdown.dart';",
      "import 'package:franchise_admin_portal/widgets/financials/franchise_financial_kpi_card.dart';",
      "import 'package:franchise_admin_portal/widgets/dashboard/franchise_picker_dropdown.dart';",
      "import 'package:franchise_admin_portal/core/models/franchise_info.dart';",
      "import 'package:franchise_admin_portal/widgets/financials/cash_flow_forecast_card.dart';",
      "import 'package:franchise_admin_portal/admin/hq_owner/widgets/alerts_card.dart';",
      "import 'package:firebase_auth/firebase_auth.dart';",
      "import 'package:franchise_admin_portal/admin/hq_owner/screens/invoice_list_screen.dart';",
      "import 'package:franchise_admin_portal/admin/hq_owner/screens/invoice_detail_screen.dart';",
      "import 'package:franchise_admin_portal/widgets/financials/invoice_export_dialog.dart';",
      "import 'package:franchise_admin_portal/admin/hq_owner/invoice_audit_trail_widget.dart';",
      "import 'package:franchise_admin_portal/admin/hq_owner/invoice_search_bar.dart';",
      "import 'package:franchise_admin_portal/widgets/financials/invoice_data_table.dart';",
      "import 'package:franchise_admin_portal/widgets/financials/invoices_card.dart';",
      "import 'package:franchise_admin_portal/widgets/dashboard/billing_summary_card.dart';",
      "import 'package:franchise_admin_portal/widgets/financials/payout_status_card.dart';",
      "import 'package:franchise_admin_portal/widgets/profile/user_avatar_menu.dart';",
      "import 'package:franchise_admin_portal/core/services/franchise_subscription_service.dart';",
      "import 'package:franchise_admin_portal/core/models/franchise_subscription_model.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "import 'package:franchise_admin_portal/widgets/header/settings_icon_button.dart';",
      "import 'package:franchise_admin_portal/widgets/header/help_icon_button.dart';",
      "import 'package:franchise_admin_portal/widgets/header/notifications_icon_button.dart';",
      "",
      "/// Developer/HQ-only: Entry-point for HQ/Owner dashboard.",
      "/// Add this to your DashboardSection registry for 'hq_owner'.",
      "class OwnerHQDashboardScreen extends StatelessWidget {",
      "  final String currentScreen;",
      "",
      "  const OwnerHQDashboardScreen({",
      "    super.key,",
      "    required this.currentScreen,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    FirebaseAuth.instance.currentUser?.getIdTokenResult(true).then((token) {",
      "      print('[DEBUG] Firebase ID token claims: ${token.claims}');",
      "    });",
      "    print('[OwnerHQDashboardScreen] build called');",
      "    WidgetsBinding.instance.addPostFrameCallback((_) async {",
      "      final franchiseProvider =",
      "          Provider.of<FranchiseProvider>(context, listen: false);",
      "      final firestoreService =",
      "          Provider.of<FirestoreService>(context, listen: false);",
      "",
      "      if (franchiseProvider.allFranchises.isEmpty) {",
      "        final franchises = await firestoreService.getFranchises();",
      "        franchiseProvider.setAllFranchises(franchises);",
      "      }",
      "",
      "      // Set initial franchiseId if none is selected yet",
      "      if (!franchiseProvider.isFranchiseSelected &&",
      "          franchiseProvider.allFranchises.isNotEmpty) {",
      "        String initialId;",
      "        final user =",
      "            Provider.of<AdminUserProvider>(context, listen: false).user;",
      "        if (user != null &&",
      "            user.defaultFranchise != null &&",
      "            user.defaultFranchise!.isNotEmpty) {",
      "          initialId = user.defaultFranchise!;",
      "        } else {",
      "          initialId = franchiseProvider.allFranchises.first.id;",
      "        }",
      "        await franchiseProvider.setInitialFranchiseId(initialId);",
      "      }",
      "    });",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    final user = Provider.of<AdminUserProvider>(context).user;",
      "    final franchiseId = Provider.of<FranchiseProvider>(context).franchiseId;",
      "    final firestoreService =",
      "        Provider.of<FirestoreService>(context, listen: false);",
      "    final userProfileUrl =",
      "        user?.avatarUrl ?? FirebaseAuth.instance.currentUser?.photoURL ?? '';",
      "    // HQ/Owner-only guard (not visible to regular managers, staff, etc)",
      "    final allowedRoles = ['hq_owner', 'hq_manager', 'developer'];",
      "    if (user == null || !user.roles.any((r) => allowedRoles.contains(r))) {",
      "      // Log and show unauthorized",
      "      Future.microtask(() => ErrorLogger.log(",
      "            message: \"Unauthorized HQ Dashboard access attempt.\",",
      "            source: \"OwnerHQDashboardScreen\",",
      "            screen: \"OwnerHQDashboardScreen\",",
      "            severity: \"warning\",",
      "            contextData: {",
      "              'roles': user?.roles,",
      "              'attempt': 'access',",
      "              'userId': user?.id ?? \"unknown\",",
      "              'franchiseId': franchiseId,",
      "            },",
      "          ));",
      "      return Scaffold(",
      "        body: Center(",
      "          child: Card(",
      "            color: colorScheme.errorContainer,",
      "            margin: const EdgeInsets.all(32),",
      "            child: Padding(",
      "              padding: const EdgeInsets.all(36),",
      "              child: Column(",
      "                mainAxisSize: MainAxisSize.min,",
      "                children: [",
      "                  Icon(Icons.lock, color: colorScheme.error, size: 48),",
      "                  const SizedBox(height: 18),",
      "                  Text(loc.unauthorizedAccessTitle,",
      "                      style: Theme.of(context).textTheme.titleLarge?.copyWith(",
      "                          color: colorScheme.error,",
      "                          fontWeight: FontWeight.bold)),",
      "                  const SizedBox(height: 10),",
      "                  Text(loc.unauthorizedAccessMessage,",
      "                      style: Theme.of(context)",
      "                          .textTheme",
      "                          .bodyMedium",
      "                          ?.copyWith(color: colorScheme.onErrorContainer)),",
      "                  const SizedBox(height: 18),",
      "                  ElevatedButton.icon(",
      "                    icon: const Icon(Icons.home),",
      "                    onPressed: () => Navigator.of(context)",
      "                        .popUntil((route) => route.isFirst),",
      "                    label: Text(loc.returnHome),",
      "                  ),",
      "                ],",
      "              ),",
      "            ),",
      "          ),",
      "        ),",
      "      );",
      "    }",
      "    WidgetsBinding.instance.addPostFrameCallback((_) async {",
      "      final franchiseProvider =",
      "          Provider.of<FranchiseProvider>(context, listen: false);",
      "      if (franchiseProvider.allFranchises.isEmpty) {",
      "        try {",
      "          final firestoreService =",
      "              Provider.of<FirestoreService>(context, listen: false);",
      "          final franchises = await firestoreService.getFranchises();",
      "          franchiseProvider.setAllFranchises(franchises);",
      "        } catch (e) {",
      "          // Optional: Show error/snackbar if needed",
      "        }",
      "      }",
      "    });",
      "    final isMobile = MediaQuery.of(context).size.width < 800;",
      "    final gridColumns = isMobile ? 1 : 3;",
      "    final gap = isMobile ? 12.0 : 22.0;",
      "",
      "    return Scaffold(",
      "      backgroundColor: colorScheme.background,",
      "      appBar: AppBar(",
      "        elevation: 1,",
      "        title: Row(",
      "          children: [",
      "            const SizedBox(width: 8),",
      "            Icon(Icons.business_center_rounded, color: colorScheme.primary),",
      "            const SizedBox(width: 12),",
      "            Text(",
      "              loc.ownerHQDashboardTitle ?? \"Franchise HQ Dashboard\",",
      "              style: Theme.of(context).textTheme.titleLarge?.copyWith(",
      "                  fontWeight: FontWeight.bold, color: colorScheme.onSurface),",
      "            ),",
      "            const Spacer(),",
      "            // --- ADD DEVELOPER DASHBOARD SWITCH IF USER IS DEVELOPER ---",
      "            FranchisePickerDropdown(),",
      "            const SizedBox(width: 14), // Optional: space before other controls",
      "            DashboardSwitcherDropdown(",
      "              currentScreen: '/hq-owner/dashboard',",
      "              user:",
      "                  Provider.of<AdminUserProvider>(context, listen: false).user!,",
      "            ),",
      "            const SizedBox(width: 8),",
      "            NotificationsIconButton(),",
      "            const SizedBox(width: 8),",
      "            HelpIconButton(),",
      "            const SizedBox(width: 8),",
      "            SettingsIconButton(),",
      "            const SizedBox(width: 8),",
      "            UserAvatarMenu(),",
      "            const SizedBox(width: 8),",
      "          ],",
      "        ),",
      "      ),",
      "      body: Padding(",
      "        padding: EdgeInsets.all(gap),",
      "        child: SingleChildScrollView(",
      "          child: Column(",
      "            children: [",
      "              // Fixed childAspectRatio for consistent card heights",
      "              GridView.count(",
      "                crossAxisCount: gridColumns,",
      "                shrinkWrap: true,",
      "                physics: const NeverScrollableScrollPhysics(),",
      "                crossAxisSpacing: gap,",
      "                mainAxisSpacing: gap,",
      "                childAspectRatio: isMobile ? 1.8 : 2.4,",
      "                children: [",
      "                  ConstrainedBox(",
      "                    constraints: BoxConstraints(",
      "                      minHeight: 180,",
      "                      maxHeight: 320,",
      "                    ),",
      "                    child: FranchiseFinancialKpiCard(",
      "                      franchiseId: franchiseId,",
      "                      brandId: user.defaultFranchise,",
      "                    ),",
      "                  ),",
      "                  ConstrainedBox(",
      "                    constraints: BoxConstraints(minHeight: 220),",
      "                    child: CashFlowForecastCard(",
      "                      franchiseId: franchiseId,",
      "                      brandId: user.defaultFranchise,",
      "                    ),",
      "                  ),",
      "                  ConstrainedBox(",
      "                    constraints: BoxConstraints(minHeight: 220),",
      "                    child: FutureBuilder<Map<String, dynamic>>(",
      "                      future: FirestoreService()",
      "                          .getInvoiceStatsForFranchise(franchiseId),",
      "                      builder: (context, snapshot) {",
      "                        if (snapshot.connectionState ==",
      "                            ConnectionState.waiting) {",
      "                          return const Center(",
      "                              child: CircularProgressIndicator());",
      "                        } else if (snapshot.hasError) {",
      "                          return Center(",
      "                              child: Text('Error loading invoice stats'));",
      "                        } else if (!snapshot.hasData ||",
      "                            snapshot.data!.isEmpty) {",
      "                          return InvoicesCard(",
      "                            totalInvoices: 0,",
      "                            openInvoiceCount: 0,",
      "                            overdueInvoiceCount: 0,",
      "                            overdueAmount: 0.0,",
      "                            paidInvoiceCount: 0,",
      "                            outstandingBalance: 0.0,",
      "                            lastInvoiceDate: null,",
      "                            onViewAllPressed: () {",
      "                              Navigator.of(context).pushNamed('/hq/invoices');",
      "                            },",
      "                          );",
      "                        }",
      "                        final stats = snapshot.data!;",
      "                        return InvoicesCard(",
      "                          totalInvoices: stats['totalInvoices'] ?? 0,",
      "                          openInvoiceCount: stats['openInvoiceCount'] ?? 0,",
      "                          overdueInvoiceCount:",
      "                              stats['overdueInvoiceCount'] ?? 0,",
      "                          overdueAmount: stats['overdueAmount'] ?? 0.0,",
      "                          paidInvoiceCount: stats['paidInvoiceCount'] ?? 0,",
      "                          outstandingBalance:",
      "                              stats['outstandingBalance'] ?? 0.0,",
      "                          lastInvoiceDate: stats['lastInvoiceDate'],",
      "                          onViewAllPressed: () {",
      "                            Navigator.of(context).pushNamed('/hq/invoices');",
      "                          },",
      "                        );",
      "                      },",
      "                    ),",
      "                  ),",
      "                  ConstrainedBox(",
      "                    constraints: BoxConstraints(minHeight: 220),",
      "                    child: PayoutStatusCard(),",
      "                  ),",
      "                  ConstrainedBox(",
      "                    constraints: BoxConstraints(minHeight: 220),",
      "                    child: BillingSummaryCard(),",
      "                  ),",
      "                  ConstrainedBox(",
      "                    constraints: const BoxConstraints(minHeight: 180),",
      "                    child: StreamBuilder<FranchiseSubscription?>(",
      "                      stream: FranchiseSubscriptionService()",
      "                          .watchCurrentSubscription(franchiseId),",
      "                      builder: (context, snapshot) {",
      "                        print(",
      "                            '[HQDashboard] StreamBuilder state=${snapshot.connectionState}, hasData=${snapshot.hasData}, hasError=${snapshot.hasError}');",
      "",
      "                        if (snapshot.connectionState ==",
      "                            ConnectionState.waiting) {",
      "                          print(",
      "                              '[HQDashboard] Waiting for subscription data...');",
      "                          return const Center(",
      "                              child: CircularProgressIndicator());",
      "                        } else if (snapshot.hasError) {",
      "                          print(",
      "                              '[HQDashboard] ERROR loading subscription: ${snapshot.error}');",
      "                          return Center(",
      "                              child: Text(AppLocalizations.of(context)",
      "                                      ?.subscriptionLoadError ??",
      "                                  'Error loading subscription'));",
      "                        }",
      "",
      "                        final subscription = snapshot.data;",
      "                        if (subscription == null) {",
      "                          print('[HQDashboard] No active subscription found.');",
      "                          return Card(",
      "                            child: Center(",
      "                              child: Padding(",
      "                                padding: const EdgeInsets.all(16),",
      "                                child: Text(",
      "                                  AppLocalizations.of(context)",
      "                                          ?.noActiveSubscription ??",
      "                                      'No active subscription',",
      "                                  style: Theme.of(context).textTheme.bodyLarge,",
      "                                ),",
      "                              ),",
      "                            ),",
      "                          );",
      "                        }",
      "",
      "                        final snapshotMap = subscription.planSnapshot;",
      "                        final planName = snapshotMap?['name'] ?? 'Unknown Plan';",
      "                        final price = snapshotMap?['price']",
      "                                ?.toStringAsFixed(2) ??",
      "                            subscription.priceAtSubscription.toStringAsFixed(2);",
      "                        final interval = snapshotMap?['billingInterval'] ??",
      "                            subscription.billingInterval ??",
      "                            'unknown';",
      "                        print(",
      "                            '[HQDashboard] Rendering active subscription card: Plan=${planName}, Price=$price, Interval=$interval');",
      "",
      "                        return Card(",
      "                          color: Theme.of(context).colorScheme.surfaceVariant,",
      "                          shape: RoundedRectangleBorder(",
      "                            borderRadius: BorderRadius.circular(",
      "                                DesignTokens.adminCardRadius),",
      "                          ),",
      "                          elevation: DesignTokens.adminCardElevation,",
      "                          child: Padding(",
      "                            padding: const EdgeInsets.all(16),",
      "                            child: Column(",
      "                              crossAxisAlignment: CrossAxisAlignment.start,",
      "                              children: [",
      "                                Text(AppLocalizations.of(context)",
      "                                        ?.activePlanLabel ??",
      "                                    'Active Platform Plan'),",
      "                                const SizedBox(height: 8),",
      "                                Text(",
      "                                  planName,",
      "                                  style: Theme.of(context)",
      "                                      .textTheme",
      "                                      .titleMedium",
      "                                      ?.copyWith(fontWeight: FontWeight.bold),",
      "                                ),",
      "                                const SizedBox(height: 6),",
      "                                Text(",
      "                                  '\\$$price / $interval',",
      "                                  style: Theme.of(context)",
      "                                      .textTheme",
      "                                      .bodyMedium",
      "                                      ?.copyWith(",
      "                                        color: Theme.of(context)",
      "                                            .colorScheme",
      "                                            .primary,",
      "                                      ),",
      "                                ),",
      "                                const SizedBox(height: 6),",
      "                                Text(",
      "                                  'Subscribed on: ${subscription.subscribedAt?.toLocal().toString().split(' ').first ?? 'unknown'}',",
      "                                  style: Theme.of(context).textTheme.bodySmall,",
      "                                ),",
      "                              ],",
      "                            ),",
      "                          ),",
      "                        );",
      "                      },",
      "                    ),",
      "                  ),",
      "                ],",
      "              ),",
      "              SizedBox(height: gap),",
      "              GridView.count(",
      "                crossAxisCount: gridColumns,",
      "                shrinkWrap: true,",
      "                physics: const NeverScrollableScrollPhysics(),",
      "                crossAxisSpacing: gap,",
      "                mainAxisSpacing: gap,",
      "                childAspectRatio: isMobile ? 1.8 : 2.4,",
      "                children: [",
      "                  const MultiBrandOverviewPanel(),",
      "                  AlertsCard(",
      "                    franchiseId: user.franchiseIds.isNotEmpty",
      "                        ? user.franchiseIds.first",
      "                        : '',",
      "                    userId: user.id,",
      "                    developerMode: user.isDeveloper,",
      "                  ),",
      "                  QuickLinksPanel(",
      "                    key: UniqueKey(), // Optional: force rebuild if needed",
      "                    // Pass no args if your QuickLinksPanel uses Provider or context internally",
      "                    // Just make sure the widget uses context for navigation and localization",
      "                  ),",
      "                ],",
      "              ),",
      "",
      "              SizedBox(height: gap + 4),",
      "              FutureFeaturePlaceholderPanel(),",
      "            ],",
      "          ),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "class _KpiTile extends StatelessWidget {",
      "  final IconData icon;",
      "  final String label;",
      "  final String value;",
      "  final Color color;",
      "",
      "  const _KpiTile({",
      "    required this.icon,",
      "    required this.label,",
      "    required this.value,",
      "    required this.color,",
      "    Key? key,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final textColor = Theme.of(context).colorScheme.onSurface;",
      "    return Row(",
      "      mainAxisSize: MainAxisSize.min,",
      "      children: [",
      "        CircleAvatar(",
      "          backgroundColor: color.withOpacity(0.13),",
      "          child: Icon(icon, color: color),",
      "          radius: 18,",
      "        ),",
      "        const SizedBox(width: 8),",
      "        Column(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            Text(label,",
      "                style: TextStyle(",
      "                    fontSize: 13, color: textColor.withOpacity(0.72))),",
      "            Text(value,",
      "                style: TextStyle(",
      "                  fontWeight: FontWeight.bold,",
      "                  fontSize: 17,",
      "                  color: textColor,",
      "                )),",
      "          ],",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}",
      "",
      "class _StatusDot extends StatelessWidget {",
      "  final Color color;",
      "  const _StatusDot({required this.color, Key? key}) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return CircleAvatar(radius: 6, backgroundColor: color);",
      "  }",
      "}",
      "",
      "/// MULTI-BRAND / MULTI-FRANCHISE SNAPSHOT",
      "class MultiBrandOverviewPanel extends StatelessWidget {",
      "  const MultiBrandOverviewPanel({super.key});",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    print('[MultiBrandOverviewPanel] build called');",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    // TODO: Replace with real data stream",
      "    final brands = [",
      "      {'name': 'Doughboys', 'count': 7, 'revenue': 38000.0},",
      "      {'name': 'PastaKing', 'count': 4, 'revenue': 15289.2},",
      "    ];",
      "",
      "    return Card(",
      "      color: colorScheme.surfaceVariant,",
      "      elevation: DesignTokens.adminCardElevation,",
      "      shape: RoundedRectangleBorder(",
      "        borderRadius: BorderRadius.circular(DesignTokens.adminCardRadius),",
      "      ),",
      "      child: Padding(",
      "        padding: const EdgeInsets.all(18),",
      "        child: Column(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            Text(loc.multiBrandSnapshot ?? \"Multi-Brand Overview\",",
      "                style: Theme.of(context).textTheme.titleMedium),",
      "            const SizedBox(height: 8),",
      "            for (final brand in brands) ...[",
      "              Row(",
      "                children: [",
      "                  Icon(Icons.store_mall_directory, color: colorScheme.primary),",
      "                  const SizedBox(width: 6),",
      "                  Text(brand['name'] as String,",
      "                      style: const TextStyle(fontWeight: FontWeight.bold)),",
      "                  const SizedBox(width: 10),",
      "                  Text(\"${loc.locations ?? 'Stores'}: ${brand['count']}\"),",
      "                  const SizedBox(width: 14),",
      "                  Text(\"\\$${(brand['revenue'] as double).toStringAsFixed(0)}\",",
      "                      style: TextStyle(",
      "                          color: colorScheme.secondary,",
      "                          fontWeight: FontWeight.w600)),",
      "                ],",
      "              ),",
      "              const SizedBox(height: 6),",
      "            ],",
      "            if (brands.isEmpty)",
      "              Text(loc.noBrands ?? \"No additional brands linked.\",",
      "                  style: const TextStyle(color: Colors.grey)),",
      "            const SizedBox(height: 12),",
      "            OutlinedButton.icon(",
      "              icon: const Icon(Icons.swap_horiz),",
      "              label: Text(loc.switchBrand ?? \"Switch Brand\"),",
      "              onPressed: () {",
      "                // TODO: Implement brand switcher dialog",
      "              },",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "/// QUICK LINKS PANEL",
      "class QuickLinksPanel extends StatelessWidget {",
      "  const QuickLinksPanel({super.key});",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    print('[QuickLinksPanel] build called');",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    return Card(",
      "      color: colorScheme.surfaceVariant,",
      "      elevation: DesignTokens.adminCardElevation,",
      "      shape: RoundedRectangleBorder(",
      "        borderRadius: BorderRadius.circular(DesignTokens.adminCardRadius),",
      "      ),",
      "      child: Padding(",
      "        padding: const EdgeInsets.all(18),",
      "        child: Column(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            Text(loc.quickLinks ?? \"Quick Links\",",
      "                style: Theme.of(context).textTheme.titleMedium),",
      "            const SizedBox(height: 12),",
      "            Wrap(",
      "              spacing: 18,",
      "              runSpacing: 10,",
      "              children: [",
      "                _QuickLinkTile(",
      "                  icon: Icons.description,",
      "                  label: loc.viewInvoices ?? \"Invoices\",",
      "                  onTap: () {",
      "                    Navigator.of(context).pushNamed('/hq/invoices');",
      "                  },",
      "                  color: colorScheme.primary,",
      "                ),",
      "                _QuickLinkTile(",
      "                  icon: Icons.payments,",
      "                  label: loc.payoutStatus ?? \"Payouts\",",
      "                  onTap: () {",
      "                    Navigator.of(context).pushNamed('/hq/payouts');",
      "                  },",
      "                  color: colorScheme.secondary,",
      "                ),",
      "                _QuickLinkTile(",
      "                  icon: Icons.account_balance,",
      "                  label: loc.bankAccounts ?? \"Bank Accounts\",",
      "                  onTap: () {",
      "                    // TODO: Route to bank accounts screen",
      "                  },",
      "                  color: colorScheme.primaryContainer,",
      "                ),",
      "                _QuickLinkTile(",
      "                  icon: Icons.analytics,",
      "                  label: loc.reporting ?? \"Reports\",",
      "                  onTap: () {",
      "                    // TODO: Route to reports/analytics",
      "                  },",
      "                  color: colorScheme.secondaryContainer,",
      "                ),",
      "                _QuickLinkTile(",
      "                  icon: Icons.support_agent,",
      "                  label: loc.billingSupport ?? \"Billing Support\",",
      "                  onTap: () {",
      "                    // TODO: Route to support/chat",
      "                  },",
      "                  color: colorScheme.primary,",
      "                ),",
      "                _QuickLinkTile(",
      "                  icon: Icons.notifications,",
      "                  label: loc.franchiseAlerts ?? \"Alerts\",",
      "                  onTap: () => Navigator.of(context).pushNamed('/alerts'),",
      "                  color: colorScheme.primary,",
      "                ),",
      "                _QuickLinkTile(",
      "                  icon: Icons.credit_card,",
      "                  label: loc.viewPlatformPlans ?? \"Platform Plans\",",
      "                  onTap: () {",
      "                    Navigator.of(context)",
      "                        .pushNamed('/hq-owner/available-plans');",
      "                  },",
      "                  color: colorScheme.tertiary,",
      "                ),",
      "              ],",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "class _QuickLinkTile extends StatelessWidget {",
      "  final IconData icon;",
      "  final String label;",
      "  final VoidCallback onTap;",
      "  final Color color;",
      "  const _QuickLinkTile({",
      "    required this.icon,",
      "    required this.label,",
      "    required this.onTap,",
      "    required this.color,",
      "    Key? key,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    return GestureDetector(",
      "      onTap: onTap,",
      "      child: Chip(",
      "        avatar: Icon(icon, color: color),",
      "        label: Text(label),",
      "        backgroundColor: color.withOpacity(0.13),",
      "        labelStyle: TextStyle(",
      "            fontWeight: FontWeight.w500, color: colorScheme.onSurface),",
      "        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "/// FUTURE FEATURE PLACEHOLDER PANEL",
      "class FutureFeaturePlaceholderPanel extends StatelessWidget {",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    print('[FutureFeaturePlaceholderPanel] build called');",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "",
      "    // Placeholders for: Announcements, Tax Docs, Compliance, Bulk Ops, Custom Billing, Multi-Currency, Scheduled Reports, API Integrations, etc.",
      "    final futureFeatures = [",
      "      {",
      "        'icon': Icons.campaign_rounded,",
      "        'label': loc.announcements ?? \"HQ Announcements\",",
      "        'desc': loc.announcementsDesc ??",
      "            \"Coming soon: Company-wide bulletins and major updates.\",",
      "      },",
      "      {",
      "        'icon': Icons.document_scanner,",
      "        'label': loc.taxDocs ?? \"1099/W-9 Export\",",
      "        'desc': loc.taxDocsDesc ??",
      "            \"Generate and export annual payout tax forms for all franchisees.\",",
      "      },",
      "      {",
      "        'icon': Icons.language,",
      "        'label': loc.multiCurrency ?? \"Multi-Currency\",",
      "        'desc': loc.multiCurrencyDesc ??",
      "            \"Enable international/multi-currency payment support.\",",
      "      },",
      "      {",
      "        'icon': Icons.playlist_add_check_circle,",
      "        'label': loc.bulkOps ?? \"Bulk Operations\",",
      "        'desc': loc.bulkOpsDesc ??",
      "            \"Send invoices, set fees, or pause multiple stores at once.\",",
      "      },",
      "      {",
      "        'icon': Icons.integration_instructions,",
      "        'label': loc.integrations ?? \"Accounting/API Integrations\",",
      "        'desc': loc.integrationsDesc ??",
      "            \"Connect with QuickBooks, Xero, Sage, and more.\",",
      "      },",
      "      {",
      "        'icon': Icons.schedule,",
      "        'label': loc.scheduledReports ?? \"Scheduled Reports\",",
      "        'desc': loc.scheduledReportsDesc ??",
      "            \"Schedule, download, or auto-email custom finance reports.\",",
      "      },",
      "    ];",
      "",
      "    return Card(",
      "      color: colorScheme.surfaceVariant.withOpacity(0.85),",
      "      elevation: DesignTokens.adminCardElevation,",
      "      shape: RoundedRectangleBorder(",
      "        borderRadius: BorderRadius.circular(DesignTokens.adminCardRadius),",
      "      ),",
      "      child: Padding(",
      "        padding: const EdgeInsets.symmetric(vertical: 22, horizontal: 18),",
      "        child: Column(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            Text(loc.comingSoonFeatures ?? \"Future Features\",",
      "                style: Theme.of(context).textTheme.titleMedium),",
      "            const SizedBox(height: 10),",
      "            Wrap(",
      "              runSpacing: 14,",
      "              spacing: 24,",
      "              children: [",
      "                for (final feature in futureFeatures)",
      "                  Row(",
      "                    mainAxisSize: MainAxisSize.min,",
      "                    children: [",
      "                      Icon(feature['icon'] as IconData,",
      "                          color: colorScheme.outline, size: 28),",
      "                      const SizedBox(width: 10),",
      "                      Column(",
      "                        crossAxisAlignment: CrossAxisAlignment.start,",
      "                        children: [",
      "                          Text(feature['label'] as String,",
      "                              style: TextStyle(fontWeight: FontWeight.bold)),",
      "                          Text(feature['desc'] as String,",
      "                              style: TextStyle(",
      "                                  color: colorScheme.onSurfaceVariant,",
      "                                  fontSize: 13)),",
      "                        ],",
      "                      ),",
      "                    ],",
      "                  ),",
      "              ],",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 775,
      "file_size": 32603,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\hq_owner\\payout_list_screen.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/config/branding_config.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/admin/features/alerts/alerts_repository.dart';",
      "import 'package:franchise_admin_portal/core/models/alert_model.dart';",
      "import 'package:franchise_admin_portal/core/providers/user_profile_notifier.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/widgets/empty_state_widget.dart';",
      "import 'package:franchise_admin_portal/widgets/financials/payouts_filter_bar.dart';",
      "import 'package:franchise_admin_portal/widgets/financials/payout_detail_dialog.dart';",
      "import 'package:franchise_admin_portal/widgets/financials/payout_note_editor.dart';",
      "import 'package:franchise_admin_portal/admin/hq_owner/widgets/attachment_uploader.dart';",
      "import 'package:franchise_admin_portal/admin/hq_owner/widgets/bulk_ops_bar.dart';",
      "import 'package:franchise_admin_portal/core/providers/payout_filter_provider.dart';",
      "",
      "class PayoutListScreen extends StatefulWidget {",
      "  const PayoutListScreen({Key? key}) : super(key: key);",
      "",
      "  @override",
      "  State<PayoutListScreen> createState() => _PayoutListScreenState();",
      "}",
      "",
      "class _PayoutListScreenState extends State<PayoutListScreen> {",
      "  Set<String> _selectedPayoutIds = {};",
      "  bool _bulkLoading = false;",
      "  String? _bulkError;",
      "",
      "  void _retry() => setState(() {});",
      "",
      "  // --- BULK ACTIONS ---",
      "  Future<void> _bulkUpdateStatus(String status) async {",
      "    if (_selectedPayoutIds.isEmpty) return;",
      "    setState(() {",
      "      _bulkLoading = true;",
      "      _bulkError = null;",
      "    });",
      "    try {",
      "      await FirestoreService().bulkUpdatePayoutStatus(",
      "        _selectedPayoutIds.toList(),",
      "        status,",
      "      );",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(",
      "            content: Text(AppLocalizations.of(context)!.bulkStatusSuccess)),",
      "      );",
      "      setState(() {",
      "        _selectedPayoutIds.clear();",
      "        _bulkLoading = false;",
      "      });",
      "    } catch (e, stack) {",
      "      ErrorLogger.log(",
      "        message: 'Bulk update status failed: $e',",
      "        stack: stack.toString(),",
      "        source: 'PayoutListScreen',",
      "        screen: 'bulkUpdateStatus',",
      "        severity: 'error',",
      "      );",
      "      setState(() {",
      "        _bulkError = e.toString();",
      "        _bulkLoading = false;",
      "      });",
      "    }",
      "  }",
      "",
      "  Future<void> _exportSelectedPayouts() async {",
      "    try {",
      "      final franchiseId =",
      "          Provider.of<FranchiseProvider>(context, listen: false).franchiseId;",
      "      await FirestoreService().exportPayoutsToCsv(",
      "        franchiseId: franchiseId,",
      "      );",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(",
      "            content: Text(",
      "                AppLocalizations.of(context)!.featureComingSoon('Export'))),",
      "      );",
      "    } catch (e, stack) {",
      "      ErrorLogger.log(",
      "        message: 'Export payouts failed: $e',",
      "        stack: stack.toString(),",
      "        source: 'PayoutListScreen',",
      "        screen: 'exportSelectedPayouts',",
      "        severity: 'error',",
      "      );",
      "    }",
      "  }",
      "",
      "  Future<void> _deleteSelectedPayouts() async {",
      "    try {",
      "      for (final id in _selectedPayoutIds) {",
      "        await FirestoreService().deletePayout(id);",
      "      }",
      "      setState(() => _selectedPayoutIds.clear());",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(content: Text(AppLocalizations.of(context)!.deleteSuccess)),",
      "      );",
      "    } catch (e, stack) {",
      "      ErrorLogger.log(",
      "        message: 'Bulk delete payouts failed: $e',",
      "        stack: stack.toString(),",
      "        source: 'PayoutListScreen',",
      "        screen: 'deleteSelectedPayouts',",
      "        severity: 'error',",
      "      );",
      "    }",
      "  }",
      "",
      "  void _toggleRowSelected(String id, bool? selected) {",
      "    setState(() {",
      "      if (selected == true) {",
      "        _selectedPayoutIds.add(id);",
      "      } else {",
      "        _selectedPayoutIds.remove(id);",
      "      }",
      "    });",
      "  }",
      "",
      "  void _toggleSelectAll(List<dynamic> payouts, bool? selected) {",
      "    setState(() {",
      "      if (selected == true) {",
      "        _selectedPayoutIds =",
      "            payouts.map<String>((e) => e['id'] as String).toSet();",
      "      } else {",
      "        _selectedPayoutIds.clear();",
      "      }",
      "    });",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    try {",
      "      final loc = AppLocalizations.of(context);",
      "      if (loc == null) {",
      "        print(",
      "            '[YourWidget] loc is null! Localization not available for this context.');",
      "        // Handle gracefully or show fallback UI",
      "        return Scaffold(",
      "          body: Center(child: Text('Localization missing! [debug]')),",
      "        );",
      "      }",
      "      final theme = Theme.of(context);",
      "      final colorScheme = theme.colorScheme;",
      "      final filterProvider = Provider.of<PayoutFilterProvider>(context);",
      "      final filterStatus = filterProvider.status;",
      "      final filterSearch = filterProvider.searchQuery;",
      "",
      "      // PROVIDERS WITH SAFETY CHECKS",
      "      final userNotifier =",
      "          Provider.of<UserProfileNotifier?>(context, listen: true);",
      "      if (userNotifier == null) {",
      "        return EmptyStateWidget(",
      "          title: 'UserProfileNotifier not found',",
      "          message:",
      "              'UserProfileNotifier provider is missing from the widget tree.',",
      "          imageAsset: BrandingConfig.bannerPlaceholder,",
      "          onRetry: _retry,",
      "          buttonText: AppLocalizations.of(context)?.retry ?? 'Retry',",
      "        );",
      "      }",
      "      final user = userNotifier.user;",
      "      if (user == null) {",
      "        return EmptyStateWidget(",
      "          title: 'Not Authenticated',",
      "          message: 'User is not authenticated. Please log in again.',",
      "          imageAsset: BrandingConfig.bannerPlaceholder,",
      "          onRetry: _retry,",
      "          buttonText: AppLocalizations.of(context)?.retry ?? 'Retry',",
      "        );",
      "      }",
      "",
      "      final franchiseProvider =",
      "          Provider.of<FranchiseProvider?>(context, listen: true);",
      "      if (franchiseProvider == null) {",
      "        return EmptyStateWidget(",
      "          title: 'FranchiseProvider not found',",
      "          message: 'FranchiseProvider is missing from the widget tree.',",
      "          imageAsset: BrandingConfig.bannerPlaceholder,",
      "          onRetry: _retry,",
      "          buttonText: AppLocalizations.of(context)?.retry ?? 'Retry',",
      "        );",
      "      }",
      "      final franchiseId = franchiseProvider.franchiseId;",
      "      if (franchiseId == null || franchiseId.isEmpty) {",
      "        return EmptyStateWidget(",
      "          title: 'Franchise Not Selected',",
      "          message:",
      "              'No franchise is currently selected. Please choose a franchise and try again.',",
      "          imageAsset: BrandingConfig.bannerPlaceholder,",
      "          onRetry: _retry,",
      "          buttonText: AppLocalizations.of(context)?.retry ?? 'Retry',",
      "        );",
      "      }",
      "",
      "      final alertsRepo = AlertsRepository();",
      "      final allowedRoles = ['hq_owner', 'hq_manager', 'developer'];",
      "      if (!user.roles.any((role) => allowedRoles.contains(role))) {",
      "        Future.microtask(() async {",
      "          try {",
      "            await ErrorLogger.log(",
      "              message: \"Unauthorized PayoutListScreen access attempt.\",",
      "              source: \"PayoutListScreen\",",
      "              screen: \"PayoutListScreen\",",
      "              severity: \"warning\",",
      "              contextData: {",
      "                'roles': user.roles,",
      "                'attempt': 'access',",
      "                'userId': user.id ?? \"unknown\",",
      "              },",
      "            );",
      "          } catch (e) {}",
      "        });",
      "        return Scaffold(",
      "          body: Center(",
      "            child: Card(",
      "              color: colorScheme.errorContainer,",
      "              margin: const EdgeInsets.all(32),",
      "              child: Padding(",
      "                padding: const EdgeInsets.all(36),",
      "                child: Column(",
      "                  mainAxisSize: MainAxisSize.min,",
      "                  children: [",
      "                    Icon(Icons.lock, color: colorScheme.error, size: 48),",
      "                    const SizedBox(height: 18),",
      "                    Text(loc.unauthorizedAccessTitle,",
      "                        style: theme.textTheme.titleLarge?.copyWith(",
      "                            color: colorScheme.error,",
      "                            fontWeight: FontWeight.bold)),",
      "                    const SizedBox(height: 10),",
      "                    Text(loc.unauthorizedAccessMessage,",
      "                        style: theme.textTheme.bodyMedium",
      "                            ?.copyWith(color: colorScheme.onErrorContainer)),",
      "                    const SizedBox(height: 18),",
      "                    ElevatedButton.icon(",
      "                      icon: const Icon(Icons.home),",
      "                      onPressed: () => Navigator.of(context)",
      "                          .popUntil((route) => route.isFirst),",
      "                      label: Text(loc.returnHome),",
      "                    ),",
      "                  ],",
      "                ),",
      "              ),",
      "            ),",
      "          ),",
      "        );",
      "      }",
      "",
      "      // ------ MAIN UI -------",
      "      return Scaffold(",
      "        appBar: AppBar(",
      "          backgroundColor: const Color(0xFFD53417),",
      "          elevation: 0,",
      "          leading: Navigator.of(context).canPop()",
      "              ? IconButton(",
      "                  icon: const Icon(Icons.arrow_back, color: Colors.white),",
      "                  onPressed: () => Navigator.of(context).maybePop(),",
      "                )",
      "              : null,",
      "          title: Text(",
      "            loc.payoutStatus,",
      "            style: theme.textTheme.titleLarge",
      "                ?.copyWith(color: Colors.white, fontWeight: FontWeight.bold),",
      "          ),",
      "        ),",
      "        backgroundColor: colorScheme.background,",
      "        body: Padding(",
      "          padding: const EdgeInsets.all(24.0),",
      "          child: Column(",
      "            crossAxisAlignment: CrossAxisAlignment.start,",
      "            children: [",
      "              // --- Filter/Search Bar (PROVIDER CONTROLLED) ---",
      "              PayoutsFilterBar(",
      "                developerMode: user.roles.contains('developer'),",
      "              ),",
      "              const SizedBox(height: 10),",
      "",
      "              // --- BulkOpsBar (always visible) ---",
      "              BulkOpsBar(",
      "                selectedCount: _selectedPayoutIds.length,",
      "                onMarkSent: _selectedPayoutIds.isEmpty",
      "                    ? null",
      "                    : () => _bulkUpdateStatus('sent'),",
      "                onMarkFailed: _selectedPayoutIds.isEmpty",
      "                    ? null",
      "                    : () => _bulkUpdateStatus('failed'),",
      "                onResetPending: _selectedPayoutIds.isEmpty",
      "                    ? null",
      "                    : () => _bulkUpdateStatus('pending'),",
      "                onExport:",
      "                    _selectedPayoutIds.isEmpty ? null : _exportSelectedPayouts,",
      "                onDelete:",
      "                    _selectedPayoutIds.isEmpty ? null : _deleteSelectedPayouts,",
      "              ),",
      "              const SizedBox(height: 10),",
      "",
      "              // --- Alerts ---",
      "              StreamBuilder<List<AlertModel>>(",
      "                stream: alertsRepo",
      "                    .watchActiveAlerts(franchiseId: franchiseId)",
      "                    .map((alerts) => alerts",
      "                        .where((a) =>",
      "                            a.type == 'payout_failed' ||",
      "                            a.type == 'payout_pending')",
      "                        .toList()),",
      "                builder: (context, alertSnap) {",
      "                  final payoutAlerts = alertSnap.data ?? [];",
      "                  if (payoutAlerts.isNotEmpty) {",
      "                    final alert = payoutAlerts.first;",
      "                    final levelColor = alert.level == 'critical'",
      "                        ? colorScheme.error",
      "                        : (alert.level == 'warning'",
      "                            ? colorScheme.secondary",
      "                            : colorScheme.primary);",
      "                    return Card(",
      "                      color: levelColor.withOpacity(0.15),",
      "                      margin: const EdgeInsets.only(bottom: 18),",
      "                      shape: RoundedRectangleBorder(",
      "                        borderRadius:",
      "                            BorderRadius.circular(DesignTokens.adminCardRadius),",
      "                      ),",
      "                      child: ListTile(",
      "                        leading: Icon(Icons.warning_rounded, color: levelColor),",
      "                        title: Text(",
      "                          alert.title.isNotEmpty",
      "                              ? alert.title",
      "                              : (alert.body.isNotEmpty",
      "                                  ? alert.body",
      "                                  : loc.payoutAlert),",
      "                        ),",
      "                        subtitle: alert.body.isNotEmpty",
      "                            ? Text(alert.body)",
      "                            : (alert.createdAt != null",
      "                                ? Text(MaterialLocalizations.of(context)",
      "                                    .formatFullDate(alert.createdAt))",
      "                                : null),",
      "                        trailing: IconButton(",
      "                          icon: Icon(Icons.close, color: theme.disabledColor),",
      "                          onPressed: () {",
      "                            ScaffoldMessenger.of(context).showSnackBar(SnackBar(",
      "                                content:",
      "                                    Text(loc.featureComingSoon('Dismiss'))));",
      "                          },",
      "                        ),",
      "                      ),",
      "                    );",
      "                  }",
      "                  return const SizedBox.shrink();",
      "                },",
      "              ),",
      "",
      "              // --- Main Table Fills Height ---",
      "              Expanded(",
      "                child: Consumer<PayoutFilterProvider>(",
      "                  builder: (context, filterProvider, _) {",
      "                    return FutureBuilder<List<Map<String, dynamic>>>(",
      "                      future: FirestoreService().getPayoutsForFranchise(",
      "                        franchiseId: franchiseId,",
      "                        status: filterProvider.status == 'all'",
      "                            ? null",
      "                            : filterProvider.status,",
      "                        searchQuery: filterProvider.searchQuery.isNotEmpty",
      "                            ? filterProvider.searchQuery",
      "                            : null,",
      "                      ),",
      "                      builder: (context, snapshot) {",
      "                        if (snapshot.connectionState ==",
      "                            ConnectionState.waiting) {",
      "                          return const Center(",
      "                              child: CircularProgressIndicator());",
      "                        }",
      "                        if (snapshot.hasError) {",
      "                          try {",
      "                            ErrorLogger.log(",
      "                              message:",
      "                                  'PayoutListScreen: failed to load payouts\\n${snapshot.error}',",
      "                              stack: snapshot.stackTrace?.toString(),",
      "                            );",
      "                          } catch (e) {}",
      "                          return Center(",
      "                            child: Column(",
      "                              mainAxisAlignment: MainAxisAlignment.center,",
      "                              children: [",
      "                                Text(loc.failedToLoadSummary,",
      "                                    style: theme.textTheme.bodyMedium",
      "                                        ?.copyWith(color: colorScheme.error)),",
      "                                const SizedBox(height: 14),",
      "                                OutlinedButton.icon(",
      "                                  icon: const Icon(Icons.refresh),",
      "                                  label: Text(loc.retry),",
      "                                  onPressed: _retry,",
      "                                ),",
      "                              ],",
      "                            ),",
      "                          );",
      "                        }",
      "                        final payouts = snapshot.data ?? [];",
      "                        if (payouts.isEmpty) {",
      "                          return Center(",
      "                            child: Text(loc.noPayoutsFound ??",
      "                                \"No payouts match your filters.\"),",
      "                          );",
      "                        }",
      "",
      "                        final allRowsSelected = payouts.every(",
      "                                (p) => _selectedPayoutIds.contains(p['id'])) &&",
      "                            payouts.isNotEmpty;",
      "",
      "                        return SingleChildScrollView(",
      "                          scrollDirection: Axis.horizontal,",
      "                          child: DataTable(",
      "                            columns: [",
      "                              DataColumn(",
      "                                label: Checkbox(",
      "                                  value: allRowsSelected,",
      "                                  onChanged: (val) =>",
      "                                      _toggleSelectAll(payouts, val),",
      "                                ),",
      "                              ),",
      "                              DataColumn(",
      "                                  label: Text(loc.payoutId ?? \"Payout ID\")),",
      "                              DataColumn(label: Text(loc.status)),",
      "                              DataColumn(label: Text(loc.amount)),",
      "                              DataColumn(label: Text(loc.createdAt)),",
      "                              DataColumn(label: Text(loc.sentAt ?? \"Sent At\")),",
      "                              DataColumn(",
      "                                  label: Text(loc.failedAt ?? \"Failed At\")),",
      "                              DataColumn(",
      "                                  label: Text(loc.payoutMethod ?? \"Method\")),",
      "                              DataColumn(",
      "                                  label: Text(loc.bankAccount ?? \"Account\")),",
      "                              DataColumn(label: Text(loc.notes ?? \"Notes\")),",
      "                              DataColumn(label: Icon(Icons.attachment)),",
      "                              DataColumn(label: Icon(Icons.more_horiz)),",
      "                            ],",
      "                            rows: [",
      "                              for (final payout in payouts)",
      "                                DataRow(",
      "                                  selected:",
      "                                      _selectedPayoutIds.contains(payout['id']),",
      "                                  onSelectChanged: (selected) =>",
      "                                      _toggleRowSelected(",
      "                                          payout['id'], selected),",
      "                                  cells: [",
      "                                    DataCell(Checkbox(",
      "                                      value: _selectedPayoutIds",
      "                                          .contains(payout['id']),",
      "                                      onChanged: (selected) =>",
      "                                          _toggleRowSelected(",
      "                                              payout['id'], selected),",
      "                                    )),",
      "                                    DataCell(Text(payout['id'] ?? '')),",
      "                                    DataCell(_StatusChip(",
      "                                        status: payout['status'],",
      "                                        theme: theme,",
      "                                        loc: loc)),",
      "                                    DataCell(Text(",
      "                                        payout['amount']?.toStringAsFixed(2) ??",
      "                                            '')),",
      "                                    DataCell(Text(_formatDate(",
      "                                        payout['created_at'], context))),",
      "                                    DataCell(Text(_formatDate(",
      "                                        payout['sent_at'], context))),",
      "                                    DataCell(Text(_formatDate(",
      "                                        payout['failed_at'], context))),",
      "                                    DataCell(Text(payout['method'] ?? '')),",
      "                                    DataCell(Text(payout[",
      "                                                'bank_account_last4'] !=",
      "                                            null",
      "                                        ? '****${payout['bank_account_last4']}'",
      "                                        : '')),",
      "                                    DataCell(",
      "                                      payout['comments'] != null &&",
      "                                              payout['comments'].isNotEmpty",
      "                                          ? Row(",
      "                                              children: [",
      "                                                Icon(Icons.sticky_note_2,",
      "                                                    color: Colors.amber[800]),",
      "                                                SizedBox(width: 4),",
      "                                                Text(",
      "                                                    '${payout['comments'].length}'),",
      "                                              ],",
      "                                            )",
      "                                          : Icon(Icons.sticky_note_2_outlined,",
      "                                              color: Colors.grey),",
      "                                    ),",
      "                                    DataCell(",
      "                                      IconButton(",
      "                                        icon: const Icon(Icons.attach_file),",
      "                                        tooltip:",
      "                                            loc.attachments ?? \"Attachments\",",
      "                                        onPressed: () {",
      "                                          showDialog(",
      "                                            context: context,",
      "                                            builder: (ctx) => Dialog(",
      "                                              child: SizedBox(",
      "                                                width: 400,",
      "                                                child: AttachmentUploader(",
      "                                                  payoutId: payout['id'],",
      "                                                ),",
      "                                              ),",
      "                                            ),",
      "                                          );",
      "                                        },",
      "                                      ),",
      "                                    ),",
      "                                    DataCell(",
      "                                      PopupMenuButton<String>(",
      "                                        onSelected: (v) async {",
      "                                          if (v == 'Details') {",
      "                                            await showDialog(",
      "                                              context: context,",
      "                                              builder: (ctx) => Dialog(",
      "                                                child: SizedBox(",
      "                                                  width: 580,",
      "                                                  child: PayoutDetailDialog(",
      "                                                    payoutId: payout['id'],",
      "                                                  ),",
      "                                                ),",
      "                                              ),",
      "                                            );",
      "                                            _retry();",
      "                                          } else if (v == 'ResetPending') {",
      "                                            await FirestoreService()",
      "                                                .retryPayout(payout['id']);",
      "                                            _retry();",
      "                                          } else {",
      "                                            ScaffoldMessenger.of(context)",
      "                                                .showSnackBar(",
      "                                              SnackBar(",
      "                                                  content: Text(loc",
      "                                                      .featureComingSoon(v))),",
      "                                            );",
      "                                          }",
      "                                        },",
      "                                        itemBuilder: (ctx) => [",
      "                                          PopupMenuItem(",
      "                                            value: 'Export',",
      "                                            child: Row(",
      "                                              children: [",
      "                                                const Icon(Icons.download,",
      "                                                    size: 18),",
      "                                                const SizedBox(width: 6),",
      "                                                Text(loc.export ?? \"Export\"),",
      "                                              ],",
      "                                            ),",
      "                                          ),",
      "                                          PopupMenuItem(",
      "                                            value: 'Details',",
      "                                            child: Row(",
      "                                              children: [",
      "                                                const Icon(Icons.info_outline,",
      "                                                    size: 18),",
      "                                                const SizedBox(width: 6),",
      "                                                Text(loc.details ?? \"Details\"),",
      "                                              ],",
      "                                            ),",
      "                                          ),",
      "                                          PopupMenuItem(",
      "                                            value: 'ResetPending',",
      "                                            child: Row(",
      "                                              children: [",
      "                                                const Icon(Icons.restart_alt,",
      "                                                    size: 18,",
      "                                                    color: Colors.orange),",
      "                                                const SizedBox(width: 6),",
      "                                                Text(loc.resetToPending ??",
      "                                                    \"Reset to Pending\"),",
      "                                              ],",
      "                                            ),",
      "                                          ),",
      "                                        ],",
      "                                      ),",
      "                                    ),",
      "                                  ],",
      "                                ),",
      "                            ],",
      "                          ),",
      "                        );",
      "                      },",
      "                    );",
      "                  },",
      "                ),",
      "              ),",
      "              Padding(",
      "                padding: const EdgeInsets.only(top: 14),",
      "                child: Row(",
      "                  children: [",
      "                    OutlinedButton.icon(",
      "                      icon: const Icon(Icons.playlist_add_check_circle),",
      "                      label: Text(loc.featureComingSoon('Bulk Ops')),",
      "                      onPressed: () {",
      "                        ScaffoldMessenger.of(context).showSnackBar(",
      "                          SnackBar(",
      "                              content: Text(loc.featureComingSoon('Bulk Ops'))),",
      "                        );",
      "                      },",
      "                    ),",
      "                  ],",
      "                ),",
      "              ),",
      "            ],",
      "          ),",
      "        ),",
      "      );",
      "    } catch (e, stack) {",
      "      ErrorLogger.log(",
      "        message: 'Unexpected error in PayoutListScreen build: $e',",
      "        stack: stack.toString(),",
      "        source: 'PayoutListScreen',",
      "        screen: 'build',",
      "        severity: 'error',",
      "      );",
      "      return Center(",
      "        child: Text('Unexpected error loading screen. Please try again later.'),",
      "      );",
      "    }",
      "  }",
      "",
      "  static String _formatDate(dynamic value, BuildContext context) {",
      "    if (value == null) return '';",
      "    if (value is DateTime) {",
      "      return MaterialLocalizations.of(context).formatShortDate(value);",
      "    }",
      "    if (value is String) {",
      "      try {",
      "        final dt = DateTime.parse(value);",
      "        return MaterialLocalizations.of(context).formatShortDate(dt);",
      "      } catch (_) {",
      "        return value;",
      "      }",
      "    }",
      "    return value.toString();",
      "  }",
      "}",
      "",
      "class _StatusChip extends StatelessWidget {",
      "  final String? status;",
      "  final ThemeData theme;",
      "  final AppLocalizations loc;",
      "  const _StatusChip(",
      "      {required this.status, required this.theme, required this.loc});",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    Color chipColor;",
      "    String label;",
      "    switch (status) {",
      "      case 'pending':",
      "        chipColor = theme.colorScheme.primary;",
      "        label = loc.pending;",
      "        break;",
      "      case 'sent':",
      "        chipColor = theme.colorScheme.secondary;",
      "        label = loc.sent;",
      "        break;",
      "      case 'failed':",
      "        chipColor = theme.colorScheme.error;",
      "        label = loc.failed;",
      "        break;",
      "      default:",
      "        chipColor = theme.colorScheme.outline;",
      "        label = status ?? '';",
      "    }",
      "    return Chip(",
      "      label: Text(label, style: const TextStyle(color: Colors.white)),",
      "      backgroundColor: chipColor,",
      "      padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 3),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 673,
      "file_size": 29669,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\hq_owner\\dialogs\\confirm_plan_subscription_dialog.dart",
    "content": [
      "// 📁 lib/admin/hq_owner/dialogs/confirm_plan_subscription_dialog.dart",
      "",
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/models/platform_plan_model.dart';",
      "import 'package:franchise_admin_portal/core/services/franchise_subscription_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "",
      "class ConfirmPlanSubscriptionDialog extends StatelessWidget {",
      "  final PlatformPlan plan;",
      "  final String franchiseId;",
      "",
      "  const ConfirmPlanSubscriptionDialog({",
      "    super.key,",
      "    required this.plan,",
      "    required this.franchiseId,",
      "  });",
      "",
      "  static Future<void> show({",
      "    required BuildContext context,",
      "    required PlatformPlan plan,",
      "    required String franchiseId,",
      "  }) {",
      "    return showDialog(",
      "      context: context,",
      "      builder: (context) => ConfirmPlanSubscriptionDialog(",
      "        plan: plan,",
      "        franchiseId: franchiseId,",
      "      ),",
      "    );",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context)!;",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "",
      "    return AlertDialog(",
      "      shape: RoundedRectangleBorder(",
      "        borderRadius: BorderRadius.circular(DesignTokens.dialogBorderRadius),",
      "      ),",
      "      elevation: DesignTokens.adminDialogElevation,",
      "      title: Text(loc.confirmPlanSubscriptionTitle),",
      "      content: Column(",
      "        mainAxisSize: MainAxisSize.min,",
      "        crossAxisAlignment: CrossAxisAlignment.start,",
      "        children: [",
      "          Text(",
      "            plan.name,",
      "            style: theme.textTheme.titleMedium?.copyWith(",
      "              fontWeight: FontWeight.bold,",
      "            ),",
      "          ),",
      "          const SizedBox(height: 8),",
      "          Text(plan.description),",
      "          const SizedBox(height: 16),",
      "          Text('${loc.billingIntervalLabel}: ${plan.billingInterval}'),",
      "          Text(",
      "              '${loc.priceLabel}: ${plan.price.toStringAsFixed(2)} ${plan.currency}'),",
      "          const SizedBox(height: 16),",
      "          Text(loc.confirmPlanSubscriptionPrompt),",
      "        ],",
      "      ),",
      "      actions: [",
      "        TextButton(",
      "          onPressed: () => Navigator.of(context).pop(),",
      "          child: Text(loc.cancel),",
      "        ),",
      "        ElevatedButton(",
      "          style: ElevatedButton.styleFrom(",
      "            backgroundColor: colorScheme.primary,",
      "          ),",
      "          onPressed: () async {",
      "            Navigator.of(context).pop(); // Close dialog immediately",
      "            try {",
      "              await FranchiseSubscriptionService().subscribeFranchiseToPlan(",
      "                franchiseId: franchiseId,",
      "                plan: plan,",
      "              );",
      "              ScaffoldMessenger.of(context).showSnackBar(",
      "                SnackBar(content: Text(loc.subscriptionSuccessMessage)),",
      "              );",
      "            } catch (e, st) {",
      "              await ErrorLogger.log(",
      "                message: 'Subscription failed: $e',",
      "                stack: st.toString(),",
      "                source: 'ConfirmPlanSubscriptionDialog',",
      "                screen: 'available_platform_plans_screen',",
      "                severity: 'error',",
      "              );",
      "              ScaffoldMessenger.of(context).showSnackBar(",
      "                SnackBar(",
      "                  content: Text(loc.genericErrorOccurred),",
      "                  backgroundColor: colorScheme.error,",
      "                ),",
      "              );",
      "            }",
      "          },",
      "          child: Text(loc.confirm),",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 106,
      "file_size": 3625,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\hq_owner\\screens\\available_platform_plans_screen.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/services/franchise_subscription_service.dart';",
      "import 'package:franchise_admin_portal/core/models/platform_plan_model.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/core/utils/export_utils.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/platform_plan_selection_provider.dart';",
      "import 'package:franchise_admin_portal/core/services/franchise_onboarding_service.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_subscription_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/admin/hq_owner/widgets/active_plan_banner.dart';",
      "import 'package:franchise_admin_portal/admin/hq_owner/widgets/platform_plan_tile.dart';",
      "import 'package:franchise_admin_portal/core/providers/role_guard.dart';",
      "",
      "class AvailablePlatformPlansScreen extends StatefulWidget {",
      "  const AvailablePlatformPlansScreen({super.key});",
      "",
      "  @override",
      "  State<AvailablePlatformPlansScreen> createState() =>",
      "      _AvailablePlatformPlansScreenState();",
      "}",
      "",
      "class _AvailablePlatformPlansScreenState",
      "    extends State<AvailablePlatformPlansScreen> {",
      "  late Future<List<PlatformPlan>> _plansFuture;",
      "  int? _expandedIndex;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _plansFuture = _loadPlans();",
      "  }",
      "",
      "  Future<List<PlatformPlan>> _loadPlans() async {",
      "    try {",
      "      final plans = await FranchiseSubscriptionService().getPlatformPlans();",
      "      debugPrint(",
      "          '[DEBUG][AvailablePlatformPlansScreen] Loaded plans: ${plans.length}');",
      "      for (final p in plans) {",
      "        debugPrint('[DEBUG] Plan: ${p.name}, active: ${p.active}');",
      "      }",
      "      return plans;",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'platform_plans_load_error',",
      "        stack: stack.toString(),",
      "        source: 'AvailablePlatformPlansScreen',",
      "        screen: 'available_platform_plans_screen',",
      "        severity: 'error',",
      "      );",
      "      return [];",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final franchiseId = context.watch<FranchiseProvider>().franchiseId;",
      "    if (franchiseId == 'unknown' || franchiseId.isEmpty) {",
      "      debugPrint('[AvailablePlatformPlansScreen] franchiseId is still unknown');",
      "      return const Scaffold(",
      "        body: Center(child: CircularProgressIndicator()),",
      "      );",
      "    }",
      "",
      "    final loc = AppLocalizations.of(context)!;",
      "    final theme = Theme.of(context);",
      "",
      "    return RoleGuard(",
      "      allowedRoles: const [",
      "        'hq_owner',",
      "        'hq_manager',",
      "        'developer',",
      "        'platform_owner'",
      "      ],",
      "      child: Scaffold(",
      "        appBar: AppBar(title: Text(loc.platformPlansTitle)),",
      "        body: FutureBuilder<List<PlatformPlan>>(",
      "          future: _plansFuture,",
      "          builder: (context, snapshot) {",
      "            if (snapshot.connectionState != ConnectionState.done) {",
      "              return const Center(child: CircularProgressIndicator());",
      "            }",
      "",
      "            final allPlans = snapshot.data ?? [];",
      "            final planProvider = context.watch<PlatformPlanSelectionProvider>();",
      "            final subscriptionNotifier =",
      "                context.watch<FranchiseSubscriptionNotifier>();",
      "            final subscription = subscriptionNotifier.currentSubscription;",
      "",
      "            final currentPlanId =",
      "                planProvider.currentSubscription?.platformPlanId;",
      "            final filteredPlans = allPlans.where((plan) {",
      "              return plan.id != currentPlanId &&",
      "                  plan.id != subscription?.platformPlanId;",
      "            }).toList();",
      "",
      "            if (!subscriptionNotifier.hasLoaded) {",
      "              return const Center(child: CircularProgressIndicator());",
      "            }",
      "",
      "            return Column(",
      "              children: [",
      "                const Padding(",
      "                  padding: EdgeInsets.fromLTRB(16, 16, 16, 8),",
      "                  child: ActivePlanBanner(),",
      "                ),",
      "                if (filteredPlans.isEmpty)",
      "                  Padding(",
      "                    padding: const EdgeInsets.all(16),",
      "                    child: Text(",
      "                      loc.noPlansAvailable,",
      "                      style: theme.textTheme.bodyMedium,",
      "                    ),",
      "                  )",
      "                else",
      "                  Expanded(",
      "                    child: ListView.separated(",
      "                      padding: const EdgeInsets.all(16),",
      "                      itemCount: filteredPlans.length,",
      "                      separatorBuilder: (_, __) => const SizedBox(height: 16),",
      "                      itemBuilder: (context, index) {",
      "                        final plan = filteredPlans[index];",
      "                        return PlatformPlanTile(",
      "                          plan: plan,",
      "                          isExpanded: _expandedIndex == index,",
      "                          onExpand: () {",
      "                            setState(() {",
      "                              _expandedIndex =",
      "                                  _expandedIndex == index ? null : index;",
      "                            });",
      "                          },",
      "                          onPlanUpdated: () async {",
      "                            final franchiseId = context",
      "                                .read<AdminUserProvider>()",
      "                                .user",
      "                                ?.defaultFranchise;",
      "                            if (franchiseId != null) {",
      "                              await FranchiseOnboardingService()",
      "                                  .markOnboardingComplete(franchiseId);",
      "                              context",
      "                                  .read<FranchiseSubscriptionNotifier>()",
      "                                  .updateFranchiseId(franchiseId);",
      "                            }",
      "                            setState(() => _expandedIndex = null);",
      "                          },",
      "                        );",
      "                      },",
      "                    ),",
      "                  ),",
      "              ],",
      "            );",
      "          },",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 160,
      "file_size": 6473,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\hq_owner\\screens\\invoice_detail_screen.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "",
      "import 'package:franchise_admin_portal/core/models/invoice.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "",
      "/// InvoiceDetailScreen",
      "/// Displays full invoice detail: line items, totals, status, notes, audit trail.",
      "///",
      "/// Features:",
      "/// - Fetches invoice by ID via FirestoreService.",
      "/// - Shows detailed line items with quantities and prices.",
      "/// - Displays invoice metadata: invoice number, dates, status, totals.",
      "/// - Shows audit trail with timestamps and user actions.",
      "/// - Error handling and loading states with error logging.",
      "/// - Localized UI strings.",
      "/// - Styled using centralized DesignTokens.",
      "/// - Modular for future enhancements.",
      "",
      "class InvoiceDetailScreen extends StatefulWidget {",
      "  final String invoiceId;",
      "",
      "  const InvoiceDetailScreen({Key? key, required this.invoiceId})",
      "      : super(key: key);",
      "",
      "  @override",
      "  State<InvoiceDetailScreen> createState() => _InvoiceDetailScreenState();",
      "}",
      "",
      "class _InvoiceDetailScreenState extends State<InvoiceDetailScreen> {",
      "  final FirestoreService _firestoreService = FirestoreService();",
      "",
      "  late Future<Invoice?> _invoiceFuture;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _invoiceFuture = _firestoreService.getInvoiceById(widget.invoiceId);",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[InvoiceDetailScreen] loc is null! Localization not available for this context.');",
      "      return const SizedBox.shrink();",
      "    }",
      "",
      "    return Scaffold(",
      "      appBar: AppBar(",
      "        title: Text('${loc.invoice} ${widget.invoiceId}'),",
      "      ),",
      "      body: FutureBuilder<Invoice?>(",
      "        future: _invoiceFuture,",
      "        builder: (context, snapshot) {",
      "          if (snapshot.hasError) {",
      "            ErrorLogger.log(",
      "              message: snapshot.error.toString(),",
      "              source: 'InvoiceDetailScreen',",
      "              screen: 'FutureBuilder',",
      "              severity: 'error',",
      "              contextData: {'invoiceId': widget.invoiceId},",
      "            );",
      "            return Center(child: Text(loc.errorLoadingInvoice));",
      "          }",
      "          if (snapshot.connectionState == ConnectionState.waiting) {",
      "            return const Center(child: CircularProgressIndicator());",
      "          }",
      "          final invoice = snapshot.data;",
      "          if (invoice == null) {",
      "            return Center(child: Text(loc.invoiceNotFound));",
      "          }",
      "          return _buildInvoiceDetail(context, invoice, loc);",
      "        },",
      "      ),",
      "    );",
      "  }",
      "",
      "  Widget _buildInvoiceDetail(",
      "      BuildContext context, Invoice invoice, AppLocalizations loc) {",
      "    return SingleChildScrollView(",
      "      padding: const EdgeInsets.all(DesignTokens.paddingLg),",
      "      child: Column(",
      "        crossAxisAlignment: CrossAxisAlignment.start,",
      "        children: [",
      "          _buildInvoiceHeader(invoice, loc),",
      "          const SizedBox(height: DesignTokens.paddingMd),",
      "          _buildLineItemsList(invoice, loc),",
      "          const SizedBox(height: DesignTokens.paddingMd),",
      "          _buildTotalsSection(invoice, loc),",
      "          const SizedBox(height: DesignTokens.paddingMd),",
      "          _buildStatusSection(invoice, loc),",
      "          const SizedBox(height: DesignTokens.paddingMd),",
      "          _buildAuditTrail(invoice, loc),",
      "          const SizedBox(height: DesignTokens.paddingMd),",
      "          _buildSupportNotes(invoice, loc),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "",
      "  Widget _buildInvoiceHeader(Invoice invoice, AppLocalizations loc) {",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        Text('${loc.invoiceNumber}: ${invoice.invoiceNumber}',",
      "            style: _headerStyle()),",
      "        Text('${loc.issueDate}: ${_formatDate(invoice.issuedAt)}'),",
      "        Text('${loc.dueDate}: ${_formatDate(invoice.dueAt)}'),",
      "        Text('${loc.currency}: ${invoice.currency}'),",
      "      ],",
      "    );",
      "  }",
      "",
      "  Widget _buildLineItemsList(Invoice invoice, AppLocalizations loc) {",
      "    if (invoice.items.isEmpty) {",
      "      return Text(loc.noLineItems);",
      "    }",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        Text(loc.lineItems, style: _headerStyle()),",
      "        const SizedBox(height: 8),",
      "        ...invoice.items.map((item) => _buildLineItemRow(item, loc)).toList(),",
      "      ],",
      "    );",
      "  }",
      "",
      "  Widget _buildLineItemRow(InvoiceLineItem item, AppLocalizations loc) {",
      "    final total = (item.unitPrice * item.quantity) + (item.tax ?? 0.0);",
      "    return Padding(",
      "      padding: const EdgeInsets.symmetric(vertical: 4),",
      "      child: Row(",
      "        children: [",
      "          Expanded(flex: 4, child: Text(item.description)),",
      "          Expanded(flex: 1, child: Text('${item.quantity}')),",
      "          Expanded(flex: 2, child: Text(item.unitPrice.toStringAsFixed(2))),",
      "          Expanded(flex: 2, child: Text(total.toStringAsFixed(2))),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "",
      "  Widget _buildTotalsSection(Invoice invoice, AppLocalizations loc) {",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        Text(loc.totals, style: _headerStyle()),",
      "        const SizedBox(height: 8),",
      "        _buildTotalRow(loc.subtotal, invoice.subtotal),",
      "        _buildTotalRow(loc.tax, invoice.tax),",
      "        _buildTotalRow(loc.total, invoice.total, isBold: true),",
      "      ],",
      "    );",
      "  }",
      "",
      "  Widget _buildTotalRow(String label, double amount, {bool isBold = false}) {",
      "    final style = isBold",
      "        ? const TextStyle(fontWeight: FontWeight.bold, fontSize: 16)",
      "        : const TextStyle(fontSize: 14);",
      "    return Padding(",
      "      padding: const EdgeInsets.symmetric(vertical: 2),",
      "      child: Row(",
      "        mainAxisAlignment: MainAxisAlignment.spaceBetween,",
      "        children: [",
      "          Text(label, style: style),",
      "          Text(amount.toStringAsFixed(2), style: style),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "",
      "  Widget _buildStatusSection(Invoice invoice, AppLocalizations loc) {",
      "    return Row(",
      "      children: [",
      "        Text('${loc.status}: ', style: _headerStyle()),",
      "        _buildStatusChip(invoice.status, loc),",
      "      ],",
      "    );",
      "  }",
      "",
      "  Widget _buildStatusChip(InvoiceStatus status, AppLocalizations loc) {",
      "    final color = _statusColor(status);",
      "    final label = _localizedStatus(status, loc);",
      "    return Chip(",
      "      label: Text(label, style: const TextStyle(color: Colors.white)),",
      "      backgroundColor: color,",
      "    );",
      "  }",
      "",
      "  Widget _buildAuditTrail(Invoice invoice, AppLocalizations loc) {",
      "    if (invoice.auditTrail.isEmpty) {",
      "      return Text(loc.noAuditTrail);",
      "    }",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        Text(loc.auditTrail, style: _headerStyle()),",
      "        const SizedBox(height: 8),",
      "        ...invoice.auditTrail.map((event) => _buildAuditEventRow(event, loc)),",
      "      ],",
      "    );",
      "  }",
      "",
      "  Widget _buildAuditEventRow(InvoiceAuditEvent event, AppLocalizations loc) {",
      "    return Padding(",
      "      padding: const EdgeInsets.symmetric(vertical: 2),",
      "      child: Text(",
      "        '${_formatDateTime(event.timestamp)} - ${event.eventType} - ${event.userId} ${event.notes ?? ''}',",
      "        style: const TextStyle(fontSize: 12, color: Colors.black54),",
      "      ),",
      "    );",
      "  }",
      "",
      "  Widget _buildSupportNotes(Invoice invoice, AppLocalizations loc) {",
      "    if (invoice.supportNotes.isEmpty) {",
      "      return Text(loc.noSupportNotes);",
      "    }",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        Text(loc.supportNotes, style: _headerStyle()),",
      "        const SizedBox(height: 8),",
      "        ...invoice.supportNotes.map((note) => _buildSupportNoteRow(note, loc)),",
      "      ],",
      "    );",
      "  }",
      "",
      "  Widget _buildSupportNoteRow(InvoiceSupportNote note, AppLocalizations loc) {",
      "    return Padding(",
      "      padding: const EdgeInsets.symmetric(vertical: 2),",
      "      child: Text(",
      "        '${_formatDateTime(note.createdAt)} - ${note.userId}: ${note.content}',",
      "        style: const TextStyle(fontSize: 12, color: Colors.black87),",
      "      ),",
      "    );",
      "  }",
      "",
      "  TextStyle _headerStyle() =>",
      "      const TextStyle(fontSize: 18, fontWeight: FontWeight.bold);",
      "",
      "  String _formatDate(DateTime? date) {",
      "    if (date == null) return '';",
      "    return MaterialLocalizations.of(context).formatShortDate(date);",
      "  }",
      "",
      "  String _formatDateTime(DateTime dateTime) {",
      "    final local = dateTime.toLocal();",
      "    final dateStr = MaterialLocalizations.of(context).formatShortDate(local);",
      "    final timeStr = MaterialLocalizations.of(context).formatTimeOfDay(",
      "      TimeOfDay.fromDateTime(local),",
      "      alwaysUse24HourFormat: false,",
      "    );",
      "    return '$dateStr $timeStr';",
      "  }",
      "",
      "  Color _statusColor(InvoiceStatus status) {",
      "    switch (status) {",
      "      case InvoiceStatus.paid:",
      "        return Colors.green;",
      "      case InvoiceStatus.overdue:",
      "        return Colors.red;",
      "      case InvoiceStatus.sent:",
      "        return Colors.blue;",
      "      case InvoiceStatus.draft:",
      "        return Colors.grey;",
      "      case InvoiceStatus.refunded:",
      "        return Colors.orange;",
      "      case InvoiceStatus.voided:",
      "      case InvoiceStatus.failed:",
      "        return Colors.black45;",
      "      case InvoiceStatus.archived:",
      "        return Colors.grey.shade600;",
      "      case InvoiceStatus.viewed:",
      "        return Colors.lightBlue;",
      "      case InvoiceStatus.open: // <--- add this case",
      "        return Colors.teal;",
      "    }",
      "  }",
      "",
      "  String _localizedStatus(InvoiceStatus status, AppLocalizations loc) {",
      "    switch (status) {",
      "      case InvoiceStatus.paid:",
      "        return loc.paid;",
      "      case InvoiceStatus.overdue:",
      "        return loc.overdue;",
      "      case InvoiceStatus.sent:",
      "        return loc.sent;",
      "      case InvoiceStatus.draft:",
      "        return loc.draft;",
      "      case InvoiceStatus.refunded:",
      "        return loc.refunded;",
      "      case InvoiceStatus.voided:",
      "        return loc.voided;",
      "      case InvoiceStatus.failed:",
      "        return loc.failed;",
      "      case InvoiceStatus.archived:",
      "        return loc.archived;",
      "      case InvoiceStatus.viewed:",
      "        return loc.viewed;",
      "      case InvoiceStatus.open: // <--- add this case",
      "        return loc.open ?? \"Open\";",
      "    }",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 308,
      "file_size": 10442,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\hq_owner\\screens\\invoice_list_screen.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:url_launcher/url_launcher.dart';",
      "import 'package:franchise_admin_portal/core/models/platform_invoice.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/widgets/admin/admin_search_bar.dart';",
      "import 'package:franchise_admin_portal/widgets/admin/admin_empty_state_widget.dart';",
      "import 'package:franchise_admin_portal/admin/hq_owner/invoice_search_bar.dart';",
      "",
      "class InvoiceListScreen extends StatefulWidget {",
      "  const InvoiceListScreen({Key? key}) : super(key: key);",
      "",
      "  @override",
      "  State<InvoiceListScreen> createState() => _InvoiceListScreenState();",
      "}",
      "",
      "class _InvoiceListScreenState extends State<InvoiceListScreen> {",
      "  final FirestoreService _firestoreService = FirestoreService();",
      "  late final FranchiseProvider _franchiseProvider;",
      "  InvoiceSortOrder _selectedSortOrder = InvoiceSortOrder.dateDesc;",
      "",
      "  String? _searchTerm;",
      "  String? _statusFilter;",
      "",
      "  @override",
      "  void didChangeDependencies() {",
      "    super.didChangeDependencies();",
      "    _franchiseProvider = Provider.of<FranchiseProvider>(context);",
      "    print(",
      "        '[InvoiceListScreen] didChangeDependencies called, franchiseId=${_franchiseProvider.franchiseId}');",
      "  }",
      "",
      "  void _onSearchChanged(String value) {",
      "    print('[InvoiceListScreen] Search term changed: \"$value\"');",
      "    setState(() {",
      "      _searchTerm = value.trim().isEmpty ? null : value.trim();",
      "    });",
      "  }",
      "",
      "  void _onStatusFilterChanged(String? value) {",
      "    print('[InvoiceListScreen] Status filter changed: $value');",
      "    setState(() {",
      "      _statusFilter = value;",
      "    });",
      "  }",
      "",
      "  @override",
      "  void dispose() {",
      "    super.dispose();",
      "  }",
      "",
      "  List<PlatformInvoice> _applySearchFilter(List<PlatformInvoice> invoices) {",
      "    List<PlatformInvoice> filtered = invoices;",
      "",
      "    if (_searchTerm != null && _searchTerm!.isNotEmpty) {",
      "      final lowerSearch = _searchTerm!.toLowerCase();",
      "      filtered = filtered.where((inv) {",
      "        return inv.invoiceNumber.toLowerCase().contains(lowerSearch) ||",
      "            inv.status.toLowerCase().contains(lowerSearch);",
      "      }).toList();",
      "    }",
      "",
      "    filtered.sort((a, b) {",
      "      switch (_selectedSortOrder) {",
      "        case InvoiceSortOrder.dateAsc:",
      "          return a.createdAt.compareTo(b.createdAt);",
      "        case InvoiceSortOrder.dateDesc:",
      "          return b.createdAt.compareTo(a.createdAt);",
      "        case InvoiceSortOrder.totalAsc:",
      "          return a.amount.compareTo(b.amount);",
      "        case InvoiceSortOrder.totalDesc:",
      "          return b.amount.compareTo(a.amount);",
      "      }",
      "    });",
      "",
      "    return filtered;",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print('[InvoiceListScreen] loc is null!');",
      "      return const SizedBox.shrink();",
      "    }",
      "    final franchiseId = _franchiseProvider.franchiseId;",
      "    print(",
      "        '[InvoiceListScreen] build called with franchiseId=$franchiseId, searchTerm=$_searchTerm, statusFilter=$_statusFilter');",
      "",
      "    if (franchiseId == null) {",
      "      return Center(child: Text(loc.noFranchiseSelected));",
      "    }",
      "",
      "    return Scaffold(",
      "      appBar: AppBar(title: Text(loc.invoiceListTitle)),",
      "      body: Padding(",
      "        padding: const EdgeInsets.all(DesignTokens.paddingLg),",
      "        child: Column(",
      "          children: [",
      "            InvoiceSearchBar(",
      "              initialSearchTerm: _searchTerm,",
      "              initialStatusFilter: _statusFilter,",
      "              initialSortOrder: _selectedSortOrder,",
      "              onSearchChanged: (term) {",
      "                print('[InvoiceListScreen] onSearchChanged triggered: $term');",
      "                setState(() {",
      "                  _searchTerm = term;",
      "                });",
      "              },",
      "              onStatusFilterChanged: (status) {",
      "                print(",
      "                    '[InvoiceListScreen] onStatusFilterChanged triggered: $status');",
      "                setState(() {",
      "                  _statusFilter = status;",
      "                });",
      "              },",
      "              onSortOrderChanged: (order) {",
      "                print(",
      "                    '[InvoiceListScreen] onSortOrderChanged triggered: $order');",
      "                setState(() {",
      "                  _selectedSortOrder = order;",
      "                });",
      "              },",
      "            ),",
      "            const SizedBox(height: DesignTokens.paddingMd),",
      "            Expanded(",
      "              child: StreamBuilder<List<PlatformInvoice>>(",
      "                stream: _firestoreService.platformInvoicesStream(",
      "                  franchiseeId: franchiseId,",
      "                  status: _statusFilter,",
      "                ),",
      "                builder: (context, snapshot) {",
      "                  if (snapshot.hasError) {",
      "                    print(",
      "                        '[InvoiceListScreen] StreamBuilder error: ${snapshot.error}');",
      "                    ErrorLogger.log(",
      "                      message: snapshot.error.toString(),",
      "                      source: 'InvoiceListScreen',",
      "                      screen: 'StreamBuilder',",
      "                    );",
      "                    return Center(child: Text(loc.errorLoadingInvoices));",
      "                  }",
      "                  if (snapshot.connectionState == ConnectionState.waiting) {",
      "                    return const Center(child: CircularProgressIndicator());",
      "                  }",
      "",
      "                  final invoices = _applySearchFilter(snapshot.data ?? []);",
      "                  if (invoices.isEmpty) {",
      "                    return AdminEmptyStateWidget(",
      "                      title: loc.noInvoices,",
      "                      message: _searchTerm != null || _statusFilter != null",
      "                          ? loc.noMatchingInvoices",
      "                          : loc.noInvoicesFound,",
      "                    );",
      "                  }",
      "                  return _buildInvoiceListView(invoices, loc);",
      "                },",
      "              ),",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  Widget _buildInvoiceListView(",
      "      List<PlatformInvoice> invoices, AppLocalizations loc) {",
      "    return ListView.separated(",
      "      itemCount: invoices.length,",
      "      separatorBuilder: (_, __) => const Divider(),",
      "      itemBuilder: (context, index) {",
      "        final invoice = invoices[index];",
      "        return ListTile(",
      "          title: Text('${loc.invoiceNumber}: ${invoice.invoiceNumber}'),",
      "          subtitle: Column(",
      "            crossAxisAlignment: CrossAxisAlignment.start,",
      "            children: [",
      "              Text(",
      "                '${loc.status}: ${invoice.status}, ${loc.total}: ${invoice.amount.toStringAsFixed(2)} ${invoice.currency}',",
      "              ),",
      "              if (invoice.paymentMethod != null)",
      "                Text(",
      "                  '${loc.paymentMethod}: ${invoice.paymentMethod}',",
      "                  style: const TextStyle(fontSize: 12),",
      "                ),",
      "              if (invoice.receiptUrl != null)",
      "                Text(",
      "                  '${loc.receipt}: ${invoice.receiptUrl}',",
      "                  style: const TextStyle(",
      "                      fontSize: 12, fontStyle: FontStyle.italic),",
      "                ),",
      "            ],",
      "          ),",
      "          trailing: Column(",
      "            mainAxisSize: MainAxisSize.min,",
      "            crossAxisAlignment: CrossAxisAlignment.end,",
      "            children: [",
      "              _buildStatusChip(invoice.status, loc, dueDate: invoice.dueDate),",
      "              if (invoice.pdfUrl != null)",
      "                TextButton(",
      "                  onPressed: () async {",
      "                    final url = invoice.pdfUrl!;",
      "                    if (await canLaunchUrl(Uri.parse(url))) {",
      "                      await launchUrl(Uri.parse(url),",
      "                          mode: LaunchMode.externalApplication);",
      "                    } else {",
      "                      ErrorLogger.log(",
      "                        message: 'Could not launch PDF: $url',",
      "                        source: 'InvoiceListScreen',",
      "                        screen: '_buildInvoiceListView',",
      "                      );",
      "                    }",
      "                  },",
      "                  child: Text(loc.downloadPdf,",
      "                      style: const TextStyle(fontSize: 12)),",
      "                ),",
      "            ],",
      "          ),",
      "          onTap: () {",
      "            Navigator.of(context)",
      "                .pushNamed('/hq/invoice_detail', arguments: invoice.id);",
      "          },",
      "        );",
      "      },",
      "    );",
      "  }",
      "",
      "  Widget _buildStatusChip(String status, AppLocalizations loc,",
      "      {DateTime? dueDate}) {",
      "    final color = _statusColor(status, dueDate: dueDate);",
      "    final label = _localizedStatus(status, loc);",
      "    return Chip(",
      "      label: Text(label),",
      "      backgroundColor: color,",
      "      labelStyle: const TextStyle(color: Colors.white),",
      "    );",
      "  }",
      "",
      "  Color _statusColor(String status, {DateTime? dueDate}) {",
      "    final now = DateTime.now();",
      "    if (status.toLowerCase() == 'unpaid' &&",
      "        dueDate != null &&",
      "        dueDate.isBefore(now)) {",
      "      return Colors.redAccent;",
      "    }",
      "",
      "    switch (status.toLowerCase()) {",
      "      case 'paid':",
      "        return Colors.green;",
      "      case 'overdue':",
      "        return Colors.red;",
      "      case 'partial':",
      "        return Colors.orange;",
      "      case 'unpaid':",
      "        return Colors.grey;",
      "      default:",
      "        return Colors.blueGrey;",
      "    }",
      "  }",
      "",
      "  String _localizedStatus(String status, AppLocalizations loc) {",
      "    switch (status.toLowerCase()) {",
      "      case 'paid':",
      "        return loc.paid;",
      "      case 'overdue':",
      "        return loc.overdue;",
      "      case 'partial':",
      "        return loc.partial;",
      "      case 'unpaid':",
      "        return loc.unpaid;",
      "      default:",
      "        return status;",
      "    }",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 279,
      "file_size": 9994,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\hq_owner\\widgets\\active_plan_banner.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:intl/intl.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:provider/provider.dart';",
      "",
      "import 'package:franchise_admin_portal/core/services/franchise_subscription_service.dart';",
      "import 'package:franchise_admin_portal/core/models/platform_plan_model.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_subscription_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/role_guard.dart';",
      "import 'package:franchise_admin_portal/admin/hq_owner/widgets/tight_section_card.dart';",
      "",
      "class ActivePlanBanner extends StatefulWidget {",
      "  const ActivePlanBanner({Key? key}) : super(key: key);",
      "",
      "  @override",
      "  State<ActivePlanBanner> createState() => _ActivePlanBannerState();",
      "}",
      "",
      "class _ActivePlanBannerState extends State<ActivePlanBanner> {",
      "  bool _isExpanded = false;",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context)!;",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    final textTheme = Theme.of(context).textTheme;",
      "    final subscriptionNotifier = context.watch<FranchiseSubscriptionNotifier>();",
      "",
      "    if (!subscriptionNotifier.hasLoaded) {",
      "      return const LinearProgressIndicator();",
      "    }",
      "",
      "    final subscription = subscriptionNotifier.currentSubscription;",
      "    final plan = subscriptionNotifier.activePlatformPlan;",
      "",
      "    if (subscription == null || subscription.platformPlanId.isEmpty) {",
      "      return RoleGuard(",
      "        allowedRoles: const ['hq_owner', 'platform_owner', 'developer'],",
      "        child: TightSectionCard(",
      "          title: loc.currentPlatformPlan,",
      "          icon: Icons.verified,",
      "          builder: (context) => Text(",
      "            loc.noActivePlatformPlan,",
      "            style: textTheme.bodyMedium,",
      "          ),",
      "        ),",
      "      );",
      "    }",
      "",
      "    final snapshot = subscription.planSnapshot ?? {};",
      "    final name = snapshot['name'] ?? plan?.name ?? loc.unknownPlan;",
      "    final price = snapshot['price'] ?? plan?.price ?? 0;",
      "    final interval =",
      "        snapshot['billingInterval'] ?? plan?.billingInterval ?? 'monthly';",
      "    final features =",
      "        List<String>.from(snapshot['features'] ?? plan?.features ?? []);",
      "    final formattedNextBilling =",
      "        DateFormat.yMMMMd().format(subscription.nextBillingDate);",
      "    final formattedStartDate =",
      "        DateFormat.yMMMMd().format(subscription.startDate);",
      "",
      "    return RoleGuard(",
      "      allowedRoles: const ['hq_owner', 'platform_owner', 'developer'],",
      "      child: TightSectionCard(",
      "        title: loc.currentPlatformPlan,",
      "        icon: Icons.verified,",
      "        builder: (context) {",
      "          return Column(",
      "            crossAxisAlignment: CrossAxisAlignment.start,",
      "            children: [",
      "              // Row: Plan name + price + interval + chevron",
      "              Row(",
      "                mainAxisAlignment: MainAxisAlignment.spaceBetween,",
      "                children: [",
      "                  Text(",
      "                    '$name – \\$${price.toStringAsFixed(2)} / $interval',",
      "                    style: textTheme.titleMedium?.copyWith(",
      "                      fontWeight: FontWeight.bold,",
      "                    ),",
      "                  ),",
      "                  IconButton(",
      "                    icon: Icon(_isExpanded",
      "                        ? Icons.keyboard_arrow_up",
      "                        : Icons.keyboard_arrow_down),",
      "                    onPressed: () {",
      "                      setState(() => _isExpanded = !_isExpanded);",
      "                    },",
      "                  ),",
      "                ],",
      "              ),",
      "",
      "              const SizedBox(height: 8),",
      "              Text(",
      "                loc.nextBillingDate(formattedNextBilling),",
      "                style: textTheme.bodyMedium?.copyWith(",
      "                  color: colorScheme.onSurfaceVariant,",
      "                ),",
      "              ),",
      "",
      "              const SizedBox(height: 8),",
      "              Wrap(",
      "                spacing: 6,",
      "                runSpacing: -4,",
      "                children: features.map((f) {",
      "                  return Chip(",
      "                    label: Text(f, style: textTheme.labelSmall),",
      "                    backgroundColor: colorScheme.surfaceVariant,",
      "                    visualDensity: VisualDensity.compact,",
      "                    padding:",
      "                        const EdgeInsets.symmetric(horizontal: 6, vertical: 2),",
      "                  );",
      "                }).toList(),",
      "              ),",
      "",
      "              if (_isExpanded) ...[",
      "                const SizedBox(height: 12),",
      "                Divider(",
      "                    thickness: 1, color: colorScheme.outline.withOpacity(0.1)),",
      "                Text(",
      "                  '${loc.subscriptionStartDate(formattedStartDate)}',",
      "                  style: textTheme.bodyMedium,",
      "                ),",
      "                const SizedBox(height: 4),",
      "                Text(",
      "                  '${loc.status}: ${subscription.status}',",
      "                  style: textTheme.bodyMedium,",
      "                ),",
      "                const SizedBox(height: 4),",
      "                Text(",
      "                  '${loc.autoRenewLabel}: ${subscription.autoRenew ? loc.yes : loc.no}',",
      "                  style: textTheme.bodyMedium,",
      "                ),",
      "                const SizedBox(height: 4),",
      "                Text(",
      "                  '${loc.cancelAtPeriodEndLabel}: ${subscription.cancelAtPeriodEnd ? loc.yes : loc.no}',",
      "                  style: textTheme.bodyMedium,",
      "                ),",
      "                if (subscription.hasOverdueInvoice)",
      "                  Padding(",
      "                    padding: const EdgeInsets.only(top: 8.0),",
      "                    child: Text(",
      "                      loc.overduePaymentWarning,",
      "                      style: textTheme.bodyMedium?.copyWith(",
      "                        color: colorScheme.error,",
      "                        fontWeight: FontWeight.bold,",
      "                      ),",
      "                    ),",
      "                  ),",
      "                if (subscription.paymentStatus != null) ...[",
      "                  const SizedBox(height: 4),",
      "                  Text(",
      "                    '${loc.paymentStatusLabel}: ${subscription.paymentStatus}',",
      "                    style: textTheme.bodyMedium,",
      "                  ),",
      "                ],",
      "                if (subscription.cardLast4 != null &&",
      "                    subscription.cardBrand != null &&",
      "                    subscription.paymentTokenId != null) ...[",
      "                  const SizedBox(height: 4),",
      "                  Text(",
      "                    '${loc.cardOnFileLabel}: ${subscription.cardBrand} •••• ${subscription.cardLast4}',",
      "                    style: textTheme.bodyMedium,",
      "                  ),",
      "                ],",
      "                if (subscription.receiptUrl != null &&",
      "                    subscription.receiptUrl!.isNotEmpty) ...[",
      "                  const SizedBox(height: 4),",
      "                  GestureDetector(",
      "                    onTap: () {",
      "                      // Ideally you use `url_launcher` to open the receipt",
      "                    },",
      "                    child: Text(",
      "                      loc.viewLastReceipt,",
      "                      style: textTheme.bodyMedium?.copyWith(",
      "                        color: colorScheme.primary,",
      "                        decoration: TextDecoration.underline,",
      "                      ),",
      "                    ),",
      "                  ),",
      "                ],",
      "                if (subscription.gracePeriodEndsAt != null) ...[",
      "                  const SizedBox(height: 8),",
      "                  Text(",
      "                    '${loc.gracePeriodEndsAtLabel}: ${DateFormat.yMMMMd().format(subscription.gracePeriodEndsAt!)}',",
      "                    style: textTheme.bodyMedium?.copyWith(",
      "                      color: colorScheme.error,",
      "                    ),",
      "                  ),",
      "                ],",
      "              ],",
      "            ],",
      "          );",
      "        },",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 197,
      "file_size": 7876,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\hq_owner\\widgets\\alerts_card.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/core/models/alert_model.dart';",
      "import 'package:franchise_admin_portal/admin/features/alerts/alerts_repository.dart';",
      "import 'package:franchise_admin_portal/config/app_config.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class AlertsCard extends StatelessWidget {",
      "  final String franchiseId;",
      "  final String? locationId;",
      "  final String? userId;",
      "  final bool",
      "      developerMode; // Set true to show dev-only alerts, otherwise false.",
      "  final AlertsRepository? repository;",
      "",
      "  const AlertsCard({",
      "    Key? key,",
      "    required this.franchiseId,",
      "    this.locationId,",
      "    this.userId,",
      "    this.developerMode = false,",
      "    this.repository,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    print(",
      "        '[AlertsCard] build: franchiseId=$franchiseId, locationId=$locationId, userId=$userId, developerMode=$developerMode');",
      "",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "    final appConfig = AppConfig.instance;",
      "    final fireService = FirestoreService();",
      "",
      "    // --- ROLE/PERMISSION DEBUGGING ---",
      "    print(",
      "        '[AlertsCard] Checking access: userId=$userId, developerMode=$developerMode');",
      "",
      "    final showForDeveloper = developerMode;",
      "",
      "    final repo = repository ??",
      "        AlertsRepository(",
      "          firestoreService: fireService,",
      "          appConfig: appConfig,",
      "        );",
      "",
      "    return Card(",
      "      shape: RoundedRectangleBorder(",
      "        borderRadius: BorderRadius.circular(16),",
      "      ),",
      "      elevation: 2,",
      "      margin: const EdgeInsets.symmetric(vertical: 8, horizontal: 4),",
      "      child: Padding(",
      "        padding: const EdgeInsets.all(16),",
      "        child: Column(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            Row(",
      "              children: [",
      "                Icon(Icons.notifications, color: colorScheme.primary),",
      "                const SizedBox(width: 8),",
      "                Text(",
      "                  loc.dashboard_active_alerts,",
      "                  style: theme.textTheme.titleMedium?.copyWith(",
      "                    color: colorScheme.primary,",
      "                    fontWeight: FontWeight.w600,",
      "                  ),",
      "                ),",
      "                const Spacer(),",
      "                IconButton(",
      "                  icon: Icon(Icons.filter_alt_outlined,",
      "                      color: colorScheme.onSurface.withOpacity(0.45)),",
      "                  onPressed: null, // Placeholder for future filtering",
      "                  tooltip: loc.dashboard_alerts_filter_tooltip,",
      "                ),",
      "              ],",
      "            ),",
      "            const SizedBox(height: 10),",
      "            StreamBuilder<List<AlertModel>>(",
      "              stream: repo.watchActiveAlerts(",
      "                franchiseId: franchiseId,",
      "                locationId: locationId,",
      "                developerMode: showForDeveloper,",
      "              ),",
      "              builder: (context, snapshot) {",
      "                print(",
      "                    '[AlertsCard] StreamBuilder connectionState=${snapshot.connectionState}');",
      "                if (snapshot.hasError) {",
      "                  print('[AlertsCard] ERROR loading alerts: ${snapshot.error}');",
      "                  ErrorLogger.log(",
      "                    message: 'Failed to load active alerts: ${snapshot.error}',",
      "                    source: 'alerts_card',",
      "                    screen: 'AlertsCard',",
      "                    stack: snapshot.stackTrace?.toString(),",
      "                    severity: 'error',",
      "                    contextData: {",
      "                      'franchiseId': franchiseId,",
      "                      'locationId': locationId,",
      "                      'userId': userId,",
      "                      'developerMode': developerMode,",
      "                      'errorType': snapshot.error.runtimeType.toString(),",
      "                    },",
      "                  );",
      "                  return _AlertError(",
      "                    message: loc.dashboard_alerts_error,",
      "                    color: colorScheme.error,",
      "                  );",
      "                }",
      "                if (snapshot.connectionState == ConnectionState.waiting) {",
      "                  print('[AlertsCard] Loading alerts...');",
      "                  return _AlertLoading(color: colorScheme.primary);",
      "                }",
      "",
      "                final alerts = snapshot.data ?? [];",
      "                print('[AlertsCard] Alerts loaded: count=${alerts.length}');",
      "",
      "                if (alerts.isEmpty) {",
      "                  print('[AlertsCard] No active alerts.');",
      "                  return _AlertEmpty(message: loc.dashboard_no_active_alerts);",
      "                }",
      "",
      "                // Render list of active alerts",
      "                return Column(",
      "                  crossAxisAlignment: CrossAxisAlignment.start,",
      "                  children: [",
      "                    ...alerts.take(3).map(",
      "                      (alert) {",
      "                        print(",
      "                            '[AlertsCard] Rendering alert: id=${alert.id}, title=${alert.title}, level=${alert.level}');",
      "                        return _AlertItem(",
      "                          alert: alert,",
      "                          colorScheme: colorScheme,",
      "                          loc: loc,",
      "                        );",
      "                      },",
      "                    ),",
      "                    if (alerts.length > 3)",
      "                      TextButton(",
      "                        onPressed: () {",
      "                          print(",
      "                              '[AlertsCard] See all alerts tapped - navigating to /alerts');",
      "                          Navigator.of(context).pushNamed('/alerts');",
      "                        },",
      "                        child: Text(",
      "                          loc.dashboard_see_all_alerts,",
      "                          style: theme.textTheme.labelLarge?.copyWith(",
      "                            color: colorScheme.primary,",
      "                            fontWeight: FontWeight.bold,",
      "                          ),",
      "                        ),",
      "                      ),",
      "                  ],",
      "                );",
      "              },",
      "            ),",
      "            // 🔜 Future placeholders (filter, quick-dismiss, etc.)",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "class _AlertItem extends StatelessWidget {",
      "  final AlertModel alert;",
      "  final ColorScheme colorScheme;",
      "  final AppLocalizations loc;",
      "",
      "  const _AlertItem({",
      "    Key? key,",
      "    required this.alert,",
      "    required this.colorScheme,",
      "    required this.loc,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    Color iconColor;",
      "    IconData icon;",
      "    switch (alert.level) {",
      "      case 'warning':",
      "        iconColor = colorScheme.error;",
      "        icon = Icons.warning_amber_rounded;",
      "        break;",
      "      case 'error':",
      "        iconColor = colorScheme.error;",
      "        icon = Icons.error_rounded;",
      "        break;",
      "      case 'info':",
      "      default:",
      "        iconColor = colorScheme.primary;",
      "        icon = Icons.info_outline_rounded;",
      "    }",
      "",
      "    print(",
      "        '[AlertsCard] _AlertItem: id=${alert.id}, title=${alert.title}, level=${alert.level}');",
      "",
      "    return Padding(",
      "      padding: const EdgeInsets.symmetric(vertical: 6.0),",
      "      child: Row(",
      "        children: [",
      "          Icon(icon, color: iconColor, size: 26),",
      "          const SizedBox(width: 10),",
      "          Expanded(",
      "            child: Column(",
      "              crossAxisAlignment: CrossAxisAlignment.start,",
      "              children: [",
      "                Text(",
      "                  alert.title,",
      "                  style: Theme.of(context).textTheme.bodyLarge?.copyWith(",
      "                        fontWeight: FontWeight.w600,",
      "                      ),",
      "                ),",
      "                if (alert.body.isNotEmpty)",
      "                  Text(",
      "                    alert.body,",
      "                    style: Theme.of(context).textTheme.bodySmall?.copyWith(",
      "                          color: colorScheme.onSurface.withOpacity(0.8),",
      "                        ),",
      "                  ),",
      "              ],",
      "            ),",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "class _AlertEmpty extends StatelessWidget {",
      "  final String message;",
      "  const _AlertEmpty({Key? key, required this.message}) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) => Padding(",
      "        padding: const EdgeInsets.symmetric(vertical: 20),",
      "        child: Row(",
      "          children: [",
      "            Icon(Icons.check_circle_outline,",
      "                color: Theme.of(context).colorScheme.primary, size: 24),",
      "            const SizedBox(width: 8),",
      "            Text(",
      "              message,",
      "              style: Theme.of(context).textTheme.bodyMedium,",
      "            ),",
      "          ],",
      "        ),",
      "      );",
      "}",
      "",
      "class _AlertLoading extends StatelessWidget {",
      "  final Color color;",
      "  const _AlertLoading({Key? key, required this.color}) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) => Padding(",
      "        padding: const EdgeInsets.symmetric(vertical: 22),",
      "        child: Center(",
      "          child: CircularProgressIndicator(",
      "            color: color,",
      "            strokeWidth: 2.2,",
      "          ),",
      "        ),",
      "      );",
      "}",
      "",
      "class _AlertError extends StatelessWidget {",
      "  final String message;",
      "  final Color color;",
      "  const _AlertError({Key? key, required this.message, required this.color})",
      "      : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) => Padding(",
      "        padding: const EdgeInsets.symmetric(vertical: 16),",
      "        child: Row(",
      "          children: [",
      "            Icon(Icons.error_outline, color: color, size: 24),",
      "            const SizedBox(width: 10),",
      "            Text(",
      "              message,",
      "              style: Theme.of(context)",
      "                  .textTheme",
      "                  .bodyMedium",
      "                  ?.copyWith(color: color),",
      "            ),",
      "          ],",
      "        ),",
      "      );",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 299,
      "file_size": 10308,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\hq_owner\\widgets\\alert_detail_dialog.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/core/models/alert_model.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/config/app_config.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/admin/features/alerts/alerts_repository.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class AlertDetailDialog extends StatelessWidget {",
      "  final AlertModel alert;",
      "  final String franchiseId;",
      "  final bool canDismiss;",
      "  final AlertsRepository? repository;",
      "  final VoidCallback? onDismissed;",
      "  final VoidCallback? onAcknowledge; // For future: acknowledge flow",
      "",
      "  const AlertDetailDialog({",
      "    Key? key,",
      "    required this.alert,",
      "    required this.franchiseId,",
      "    this.canDismiss = true,",
      "    this.repository,",
      "    this.onDismissed,",
      "    this.onAcknowledge,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    final appConfig = AppConfig.instance;",
      "    final fireService = FirestoreService();",
      "    final user = Provider.of<AdminUserProvider>(context, listen: false).user;",
      "",
      "    final repo = repository ??",
      "        AlertsRepository(",
      "          firestoreService: fireService,",
      "          appConfig: appConfig,",
      "        );",
      "",
      "    return Dialog(",
      "      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),",
      "      backgroundColor: colorScheme.surface,",
      "      child: ConstrainedBox(",
      "        constraints: const BoxConstraints(maxWidth: 460),",
      "        child: Padding(",
      "          padding: const EdgeInsets.fromLTRB(22, 26, 22, 18),",
      "          child: Column(",
      "            mainAxisSize: MainAxisSize.min,",
      "            crossAxisAlignment: CrossAxisAlignment.start,",
      "            children: [",
      "              Row(",
      "                children: [",
      "                  _iconForLevel(alert.level, colorScheme),",
      "                  const SizedBox(width: 12),",
      "                  Expanded(",
      "                    child: Text(",
      "                      alert.title,",
      "                      style: Theme.of(context).textTheme.titleLarge?.copyWith(",
      "                            fontWeight: FontWeight.bold,",
      "                          ),",
      "                    ),",
      "                  ),",
      "                  IconButton(",
      "                    icon: const Icon(Icons.close),",
      "                    onPressed: () => Navigator.of(context).pop(),",
      "                  ),",
      "                ],",
      "              ),",
      "              if (alert.body.isNotEmpty) ...[",
      "                const SizedBox(height: 12),",
      "                Text(",
      "                  alert.body,",
      "                  style: Theme.of(context).textTheme.bodyMedium,",
      "                ),",
      "              ],",
      "              const SizedBox(height: 18),",
      "              _DetailLine(",
      "                icon: Icons.access_time,",
      "                label: loc.alert_time,",
      "                value: _formatDateTime(context, alert.createdAt),",
      "              ),",
      "              if (alert.dismissedAt != null)",
      "                _DetailLine(",
      "                  icon: Icons.check_circle_outline,",
      "                  label: loc.alert_dismissed_on,",
      "                  value: _formatDateTime(context, alert.dismissedAt!),",
      "                ),",
      "              _DetailLine(",
      "                icon: Icons.info_outline_rounded,",
      "                label: loc.alert_type,",
      "                value:",
      "                    alert.type.isNotEmpty ? alert.type : loc.alert_type_generic,",
      "              ),",
      "              if (alert.customFields.isNotEmpty)",
      "                Padding(",
      "                  padding: const EdgeInsets.symmetric(vertical: 8),",
      "                  child: Text(",
      "                    loc.alert_custom_fields,",
      "                    style: Theme.of(context).textTheme.titleSmall,",
      "                  ),",
      "                ),",
      "              ...alert.customFields.entries.map(",
      "                (e) => _DetailLine(",
      "                  icon: Icons.label_important_outline,",
      "                  label: e.key,",
      "                  value: e.value?.toString() ?? '',",
      "                ),",
      "              ),",
      "              const SizedBox(height: 18),",
      "              Row(",
      "                mainAxisAlignment: MainAxisAlignment.end,",
      "                children: [",
      "                  if (canDismiss && alert.dismissedAt == null)",
      "                    TextButton.icon(",
      "                      icon: const Icon(Icons.delete_outline),",
      "                      style: TextButton.styleFrom(",
      "                        foregroundColor: colorScheme.error,",
      "                      ),",
      "                      onPressed: () async {",
      "                        try {",
      "                          await repo.dismissAlert(",
      "                            franchiseId,",
      "                            alert.id,",
      "                            user?.id ?? '',",
      "                            screen: \"AlertDetailDialog\",",
      "                          );",
      "                          onDismissed?.call();",
      "                          Navigator.of(context).pop();",
      "                          ScaffoldMessenger.of(context).showSnackBar(",
      "                            SnackBar(",
      "                              content: Text(loc.alert_dismissed_success),",
      "                            ),",
      "                          );",
      "                        } catch (e, stack) {",
      "                          await ErrorLogger.log(",
      "                            message: 'Failed to dismiss alert: $e',",
      "                            stack: stack.toString(),",
      "                            source: 'alert_detail_dialog',",
      "                            screen: 'AlertDetailDialog',",
      "                            severity: 'error',",
      "                            contextData: {",
      "                              'franchiseId': franchiseId,",
      "                              'alertId': alert.id,",
      "                              'userId': user?.id,",
      "                            },",
      "                          );",
      "                          ScaffoldMessenger.of(context).showSnackBar(",
      "                            SnackBar(",
      "                              content: Text(loc.alert_dismissed_error),",
      "                            ),",
      "                          );",
      "                        }",
      "                      },",
      "                      label: Text(loc.alert_dismiss_button),",
      "                    ),",
      "                  // 🔜 Future: Acknowledge, view related invoice, etc.",
      "                  TextButton(",
      "                    onPressed: () => Navigator.of(context).pop(),",
      "                    child: Text(loc.close),",
      "                  ),",
      "                ],",
      "              ),",
      "            ],",
      "          ),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  static Widget _iconForLevel(String level, ColorScheme colorScheme) {",
      "    switch (level) {",
      "      case 'warning':",
      "        return Icon(Icons.warning_amber_rounded,",
      "            color: colorScheme.error, size: 32);",
      "      case 'error':",
      "        return Icon(Icons.error_rounded, color: colorScheme.error, size: 32);",
      "      case 'info':",
      "      default:",
      "        return Icon(Icons.info_outline_rounded,",
      "            color: colorScheme.primary, size: 32);",
      "    }",
      "  }",
      "",
      "  static String _formatDateTime(BuildContext context, DateTime dateTime) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[YourWidget] loc is null! Localization not available for this context.');",
      "      // Handle gracefully or show fallback string",
      "      return 'N/A'; // Or any suitable fallback string",
      "    }",
      "    final d = dateTime;",
      "    return \"${d.year}-${_two(d.month)}-${_two(d.day)} ${_two(d.hour)}:${_two(d.minute)}\";",
      "  }",
      "",
      "  static String _two(int n) => n.toString().padLeft(2, '0');",
      "}",
      "",
      "/// Simple detail line row for alert properties.",
      "class _DetailLine extends StatelessWidget {",
      "  final IconData icon;",
      "  final String label;",
      "  final String value;",
      "",
      "  const _DetailLine({",
      "    Key? key,",
      "    required this.icon,",
      "    required this.label,",
      "    required this.value,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) => Padding(",
      "        padding: const EdgeInsets.symmetric(vertical: 4.5),",
      "        child: Row(",
      "          children: [",
      "            Icon(icon, size: 18, color: Theme.of(context).colorScheme.primary),",
      "            const SizedBox(width: 9),",
      "            Text(",
      "              \"$label: \",",
      "              style: Theme.of(context).textTheme.bodySmall?.copyWith(",
      "                    fontWeight: FontWeight.bold,",
      "                  ),",
      "            ),",
      "            Expanded(",
      "              child: Text(",
      "                value,",
      "                style: Theme.of(context).textTheme.bodySmall,",
      "                overflow: TextOverflow.ellipsis,",
      "              ),",
      "            ),",
      "          ],",
      "        ),",
      "      );",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 245,
      "file_size": 9191,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\hq_owner\\widgets\\alert_list_screen.dart",
    "content": [
      "import 'package:franchise_admin_portal/admin/hq_owner/widgets/alert_detail_dialog.dart';",
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/admin/features/alerts/alerts_repository.dart';",
      "import 'package:franchise_admin_portal/core/models/alert_model.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/config/app_config.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/providers/role_guard.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class AlertListScreen extends StatelessWidget {",
      "  final String franchiseId;",
      "  final String? locationId;",
      "  final bool developerMode;",
      "",
      "  const AlertListScreen({",
      "    Key? key,",
      "    required this.franchiseId,",
      "    this.locationId,",
      "    this.developerMode = false,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "    final appConfig = AppConfig.instance;",
      "    final fireService = FirestoreService();",
      "    final user = Provider.of<AdminUserProvider>(context, listen: false).user;",
      "    final isDeveloper = user?.isDeveloper ?? false;",
      "",
      "    final repo = AlertsRepository(",
      "      firestoreService: fireService,",
      "      appConfig: appConfig,",
      "    );",
      "",
      "    return RoleGuard(",
      "      allowedRoles: [",
      "        'hq_owner',",
      "        'hq_manager',",
      "        'admin',",
      "        'owner',",
      "        'manager',",
      "        'developer'",
      "      ],",
      "      developerBypass: true,",
      "      featureName: 'Full Alert List',",
      "      child: Scaffold(",
      "        appBar: AppBar(",
      "          title: Text(loc.dashboard_active_alerts),",
      "          backgroundColor: colorScheme.primary,",
      "          foregroundColor: colorScheme.onPrimary,",
      "          actions: [",
      "            IconButton(",
      "              icon: const Icon(Icons.refresh),",
      "              tooltip: loc.dashboard_alerts_filter_tooltip,",
      "              onPressed: () {",
      "                // 🔜 Future: Add filter or refresh logic here",
      "              },",
      "            ),",
      "          ],",
      "        ),",
      "        body: SafeArea(",
      "          child: StreamBuilder<List<AlertModel>>(",
      "            stream: repo.watchActiveAlerts(",
      "              franchiseId: franchiseId,",
      "              locationId: locationId,",
      "              developerMode: developerMode || isDeveloper,",
      "            ),",
      "            builder: (context, snapshot) {",
      "              if (snapshot.hasError) {",
      "                ErrorLogger.log(",
      "                  message: 'Failed to load alert list: ${snapshot.error}',",
      "                  source: 'alert_list_screen',",
      "                  screen: 'AlertListScreen',",
      "                  stack: snapshot.stackTrace?.toString(),",
      "                  severity: 'error',",
      "                  contextData: {",
      "                    'franchiseId': franchiseId,",
      "                    'locationId': locationId,",
      "                    'userId': user?.id,",
      "                    'errorType': snapshot.error.runtimeType.toString(),",
      "                  },",
      "                );",
      "                return _AlertListError(",
      "                    message: loc.dashboard_alerts_error,",
      "                    color: colorScheme.error);",
      "              }",
      "              if (snapshot.connectionState == ConnectionState.waiting) {",
      "                return _AlertListLoading(color: colorScheme.primary);",
      "              }",
      "              final alerts = snapshot.data ?? [];",
      "",
      "              if (alerts.isEmpty) {",
      "                return Center(",
      "                  child: Text(",
      "                    loc.dashboard_no_active_alerts,",
      "                    style: theme.textTheme.bodyLarge,",
      "                  ),",
      "                );",
      "              }",
      "",
      "              return ListView.separated(",
      "                padding: const EdgeInsets.all(16),",
      "                itemCount: alerts.length,",
      "                separatorBuilder: (_, __) =>",
      "                    const Divider(height: 16, thickness: 0.4),",
      "                itemBuilder: (context, index) {",
      "                  final alert = alerts[index];",
      "                  return _AlertListTile(",
      "                    alert: alert,",
      "                    colorScheme: colorScheme,",
      "                    loc: loc,",
      "                    onDismiss: () async {",
      "                      try {",
      "                        await repo.dismissAlert(",
      "                          franchiseId,",
      "                          alert.id,",
      "                          user?.id ?? '',",
      "                          screen: 'AlertListScreen',",
      "                        );",
      "                        ScaffoldMessenger.of(context).showSnackBar(",
      "                          SnackBar(content: Text(loc.alert_dismissed_success)),",
      "                        );",
      "                      } catch (e, stack) {",
      "                        await ErrorLogger.log(",
      "                          message: 'Failed to dismiss alert: $e',",
      "                          source: 'alert_list_screen',",
      "                          screen: 'AlertListScreen',",
      "                          stack: stack.toString(),",
      "                          severity: 'error',",
      "                          contextData: {",
      "                            'franchiseId': franchiseId,",
      "                            'alertId': alert.id,",
      "                            'userId': user?.id,",
      "                            'errorType': e.runtimeType.toString(),",
      "                          },",
      "                        );",
      "                        ScaffoldMessenger.of(context).showSnackBar(",
      "                          SnackBar(content: Text(loc.alert_dismissed_error)),",
      "                        );",
      "                      }",
      "                    },",
      "                    onTap: () {",
      "                      showDialog(",
      "                        context: context,",
      "                        builder: (ctx) => AlertDetailDialog(",
      "                          alert: alert,",
      "                          franchiseId: franchiseId,",
      "                          canDismiss: true,",
      "                          onDismissed: () {",
      "                            // Optionally refresh or callback",
      "                          },",
      "                        ),",
      "                      );",
      "                    },",
      "                  );",
      "                },",
      "              );",
      "            },",
      "          ),",
      "        ),",
      "        floatingActionButton: FloatingActionButton.extended(",
      "          heroTag: 'alert_list_fab',",
      "          onPressed: () {",
      "            // 🔜 Future: Add alert filter dialog",
      "            ScaffoldMessenger.of(context).showSnackBar(",
      "              SnackBar(content: Text(loc.dashboard_alerts_filter_tooltip)),",
      "            );",
      "          },",
      "          label: Text(loc.dashboard_alerts_filter_tooltip),",
      "          icon: const Icon(Icons.filter_list),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "// Alert tile for list view.",
      "class _AlertListTile extends StatelessWidget {",
      "  final AlertModel alert;",
      "  final ColorScheme colorScheme;",
      "  final AppLocalizations loc;",
      "  final VoidCallback? onDismiss;",
      "  final VoidCallback? onTap;",
      "",
      "  const _AlertListTile({",
      "    Key? key,",
      "    required this.alert,",
      "    required this.colorScheme,",
      "    required this.loc,",
      "    this.onDismiss,",
      "    this.onTap,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    Color iconColor;",
      "    IconData icon;",
      "    switch (alert.level) {",
      "      case 'warning':",
      "        iconColor = colorScheme.error;",
      "        icon = Icons.warning_amber_rounded;",
      "        break;",
      "      case 'error':",
      "        iconColor = colorScheme.error;",
      "        icon = Icons.error_rounded;",
      "        break;",
      "      case 'info':",
      "      default:",
      "        iconColor = colorScheme.primary;",
      "        icon = Icons.info_outline_rounded;",
      "    }",
      "",
      "    return Card(",
      "      elevation: 1,",
      "      margin: EdgeInsets.zero,",
      "      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),",
      "      child: ListTile(",
      "        onTap: onTap,",
      "        leading: Icon(icon, color: iconColor, size: 32),",
      "        title: Text(alert.title, style: Theme.of(context).textTheme.titleSmall),",
      "        subtitle: alert.body.isNotEmpty",
      "            ? Text(alert.body, style: Theme.of(context).textTheme.bodySmall)",
      "            : null,",
      "        trailing: onDismiss != null",
      "            ? IconButton(",
      "                icon: const Icon(Icons.close),",
      "                color: colorScheme.error,",
      "                tooltip: loc.alert_dismiss_button,",
      "                onPressed: onDismiss,",
      "              )",
      "            : null,",
      "        // 🔜 Future: add onTap for detail dialog",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "// Loading state for alert list.",
      "class _AlertListLoading extends StatelessWidget {",
      "  final Color color;",
      "  const _AlertListLoading({Key? key, required this.color}) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) => Center(",
      "        child: Padding(",
      "          padding: const EdgeInsets.symmetric(vertical: 40),",
      "          child: CircularProgressIndicator(",
      "            color: color,",
      "            strokeWidth: 2.6,",
      "          ),",
      "        ),",
      "      );",
      "}",
      "",
      "// Error state for alert list.",
      "class _AlertListError extends StatelessWidget {",
      "  final String message;",
      "  final Color color;",
      "  const _AlertListError({Key? key, required this.message, required this.color})",
      "      : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) => Center(",
      "        child: Row(",
      "          mainAxisAlignment: MainAxisAlignment.center,",
      "          children: [",
      "            Icon(Icons.error_outline, color: color, size: 28),",
      "            const SizedBox(width: 12),",
      "            Text(",
      "              message,",
      "              style: Theme.of(context)",
      "                  .textTheme",
      "                  .bodyMedium",
      "                  ?.copyWith(color: color),",
      "            ),",
      "          ],",
      "        ),",
      "      );",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 291,
      "file_size": 10199,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\hq_owner\\widgets\\attachment_uploader.dart",
    "content": [
      "import 'dart:io';",
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:file_picker/file_picker.dart';",
      "import 'package:franchise_admin_portal/config/branding_config.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "",
      "/// AttachmentUploader",
      "/// For payout attachments (detail or bulk), reusable for other models.",
      "/// Accepts payoutId, existing attachments, and onUploaded/onDeleted callbacks.",
      "class AttachmentUploader extends StatefulWidget {",
      "  final String payoutId;",
      "  final List<Map<String, dynamic>> existingAttachments;",
      "  final VoidCallback? onUploaded;",
      "  final VoidCallback? onDeleted;",
      "  final bool developerMode;",
      "  final List<String>? allowedExtensions;",
      "",
      "  const AttachmentUploader({",
      "    Key? key,",
      "    required this.payoutId,",
      "    this.existingAttachments = const [],",
      "    this.onUploaded,",
      "    this.onDeleted,",
      "    this.developerMode = false,",
      "    this.allowedExtensions,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  State<AttachmentUploader> createState() => _AttachmentUploaderState();",
      "}",
      "",
      "class _AttachmentUploaderState extends State<AttachmentUploader> {",
      "  bool _uploading = false;",
      "  String? _error;",
      "",
      "  Future<void> _pickAndUpload() async {",
      "    setState(() {",
      "      _uploading = true;",
      "      _error = null;",
      "    });",
      "    try {",
      "      final result = await FilePicker.platform.pickFiles(",
      "        allowMultiple: false,",
      "        allowedExtensions: widget.allowedExtensions,",
      "        type: widget.allowedExtensions == null ? FileType.any : FileType.custom,",
      "      );",
      "      if (result == null || result.files.isEmpty) {",
      "        setState(() => _uploading = false);",
      "        return; // User cancelled",
      "      }",
      "      final file = result.files.first;",
      "",
      "      // (In a real app, upload to storage, get URL, etc. Here we just stub meta.)",
      "      final meta = {",
      "        'filename': file.name,",
      "        'size': file.size,",
      "        'uploadedAt': DateTime.now().toUtc().toIso8601String(),",
      "        // 'url': ..., // Add if implementing storage!",
      "      };",
      "",
      "      await FirestoreService().addAttachmentToPayout(widget.payoutId, meta);",
      "      widget.onUploaded?.call();",
      "      setState(() {",
      "        _uploading = false;",
      "        _error = null;",
      "      });",
      "    } catch (e, stack) {",
      "      ErrorLogger.log(",
      "        message: 'AttachmentUploader: Failed to upload - $e',",
      "        stack: stack.toString(),",
      "        source: 'AttachmentUploader',",
      "        screen: 'attachment_uploader.dart',",
      "        severity: 'error',",
      "      );",
      "      setState(() {",
      "        _uploading = false;",
      "        _error = e.toString();",
      "      });",
      "    }",
      "  }",
      "",
      "  Future<void> _deleteAttachment(Map<String, dynamic> att) async {",
      "    try {",
      "      await FirestoreService().removeAttachmentFromPayout(widget.payoutId, att);",
      "      widget.onDeleted?.call();",
      "    } catch (e, stack) {",
      "      ErrorLogger.log(",
      "        message: 'AttachmentUploader: Failed to delete attachment - $e',",
      "        stack: stack.toString(),",
      "        source: 'AttachmentUploader',",
      "        screen: 'attachment_uploader.dart',",
      "        severity: 'error',",
      "      );",
      "      setState(() {",
      "        _error = e.toString();",
      "      });",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "    final disabled = !widget.developerMode;",
      "",
      "    return Card(",
      "      color: colorScheme.surfaceVariant,",
      "      shape: RoundedRectangleBorder(",
      "        borderRadius: BorderRadius.circular(DesignTokens.adminCardRadius),",
      "      ),",
      "      margin: const EdgeInsets.symmetric(vertical: 12),",
      "      child: Padding(",
      "        padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 16),",
      "        child: Column(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            Text(loc.addAttachment, style: theme.textTheme.titleMedium),",
      "            const SizedBox(height: 10),",
      "            OutlinedButton.icon(",
      "              icon: _uploading",
      "                  ? const SizedBox(",
      "                      width: 18,",
      "                      height: 18,",
      "                      child: CircularProgressIndicator(strokeWidth: 2),",
      "                    )",
      "                  : const Icon(Icons.attach_file),",
      "              label: Text(",
      "                _uploading ? loc.uploading : loc.attachFile ?? \"Attach File\",",
      "              ),",
      "              onPressed: disabled || _uploading ? null : _pickAndUpload,",
      "              style: OutlinedButton.styleFrom(",
      "                foregroundColor: colorScheme.primary,",
      "                backgroundColor: colorScheme.background,",
      "                textStyle: theme.textTheme.bodyMedium,",
      "              ),",
      "            ),",
      "            if (_error != null) ...[",
      "              const SizedBox(height: 8),",
      "              Text(",
      "                _error!,",
      "                style: theme.textTheme.bodySmall",
      "                    ?.copyWith(color: colorScheme.error),",
      "              ),",
      "            ],",
      "            if (widget.existingAttachments.isNotEmpty) ...[",
      "              const SizedBox(height: 10),",
      "              Text(loc.attachments ?? 'Attachments:',",
      "                  style: theme.textTheme.bodySmall),",
      "              const SizedBox(height: 4),",
      "              for (final att in widget.existingAttachments)",
      "                ListTile(",
      "                  leading: const Icon(Icons.insert_drive_file),",
      "                  title: Text(att['filename'] ?? att['url'] ?? 'Attachment'),",
      "                  subtitle: Text(",
      "                    att['uploadedAt'] != null ? att['uploadedAt'] : '',",
      "                    style: theme.textTheme.labelSmall,",
      "                  ),",
      "                  trailing: IconButton(",
      "                    icon: const Icon(Icons.delete),",
      "                    tooltip: loc.removeAttachment ?? \"Remove\",",
      "                    onPressed: disabled ? null : () => _deleteAttachment(att),",
      "                  ),",
      "                ),",
      "            ],",
      "            if (disabled)",
      "              Padding(",
      "                padding: const EdgeInsets.only(top: 8),",
      "                child: Text(",
      "                  loc.featureDeveloperOnly,",
      "                  style: theme.textTheme.bodySmall",
      "                      ?.copyWith(color: colorScheme.outline),",
      "                ),",
      "              ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 190,
      "file_size": 6767,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\hq_owner\\widgets\\bulk_ops_bar.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/config/branding_config.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "/// BulkOpsBar: Modular bulk action bar for Payouts/Invoices/Admin Tables.",
      "/// Uses: Localization, Theme, Config tokens, ErrorLogger, Modular design, Developer access.",
      "class BulkOpsBar extends StatelessWidget {",
      "  final int selectedCount;",
      "  final bool developerMode;",
      "  final bool loading;",
      "  final VoidCallback? onExport;",
      "  final VoidCallback? onMarkSent;",
      "  final VoidCallback? onMarkFailed;",
      "  final VoidCallback? onDelete;",
      "  final VoidCallback? onAddAttachment;",
      "  final VoidCallback? onAddNote;",
      "  final VoidCallback? onApprove;",
      "  final VoidCallback? onCustomAction; // For future/feature toggles",
      "  final VoidCallback? onResetPending;",
      "",
      "  const BulkOpsBar({",
      "    Key? key,",
      "    required this.selectedCount,",
      "    this.developerMode = false,",
      "    this.loading = false,",
      "    this.onExport,",
      "    this.onMarkSent,",
      "    this.onMarkFailed,",
      "    this.onDelete,",
      "    this.onAddAttachment,",
      "    this.onAddNote,",
      "    this.onApprove,",
      "    this.onCustomAction,",
      "    this.onResetPending,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "",
      "    if (selectedCount == 0) {",
      "      // Placeholder for empty state (future: maybe show tips)",
      "      return const SizedBox.shrink();",
      "    }",
      "",
      "    return Card(",
      "      color: colorScheme.surfaceVariant,",
      "      elevation: 3,",
      "      margin: const EdgeInsets.symmetric(vertical: 10),",
      "      shape: RoundedRectangleBorder(",
      "        borderRadius: BorderRadius.circular(DesignTokens.adminCardRadius),",
      "      ),",
      "      child: Padding(",
      "        padding: const EdgeInsets.symmetric(vertical: 8, horizontal: 18),",
      "        child: Row(",
      "          children: [",
      "            Icon(Icons.playlist_add_check_circle, color: colorScheme.primary),",
      "            const SizedBox(width: 8),",
      "            Text(",
      "              loc.selectedItemsCount(selectedCount),",
      "              style: theme.textTheme.bodyMedium",
      "                  ?.copyWith(fontWeight: FontWeight.bold),",
      "            ),",
      "            const Spacer(),",
      "",
      "            // EXPORT",
      "            Tooltip(",
      "              message: loc.exportSelected,",
      "              child: IconButton(",
      "                icon: const Icon(Icons.file_download),",
      "                onPressed: onExport,",
      "              ),",
      "            ),",
      "            // MARK SENT",
      "            Tooltip(",
      "              message: loc.markAsSent,",
      "              child: IconButton(",
      "                icon: const Icon(Icons.send),",
      "                onPressed: onMarkSent,",
      "              ),",
      "            ),",
      "            // MARK FAILED",
      "            Tooltip(",
      "              message: loc.markAsFailed,",
      "              child: IconButton(",
      "                icon: const Icon(Icons.error),",
      "                onPressed: onMarkFailed,",
      "              ),",
      "            ),",
      "            Tooltip(",
      "              message: loc.resetToPending ?? \"Reset status to pending\",",
      "              child: IconButton(",
      "                icon: const Icon(Icons.restart_alt, color: Colors.orange),",
      "                onPressed: loading ? null : onResetPending,",
      "              ),",
      "            ),",
      "            // ADD ATTACHMENT",
      "            Tooltip(",
      "              message: loc.addAttachment,",
      "              child: IconButton(",
      "                icon: const Icon(Icons.attach_file),",
      "                onPressed: onAddAttachment,",
      "              ),",
      "            ),",
      "            // ADD NOTE",
      "            Tooltip(",
      "              message: loc.addNote,",
      "              child: IconButton(",
      "                icon: const Icon(Icons.sticky_note_2),",
      "                onPressed: onAddNote,",
      "              ),",
      "            ),",
      "            // APPROVE (toggle, only for developer/admin, guarded)",
      "            if (developerMode)",
      "              Tooltip(",
      "                message: loc.approveSelected,",
      "                child: IconButton(",
      "                  icon: const Icon(Icons.verified_user),",
      "                  onPressed: onApprove,",
      "                ),",
      "              ),",
      "            // DELETE",
      "            Tooltip(",
      "              message: loc.deleteSelected,",
      "              child: IconButton(",
      "                icon: const Icon(Icons.delete_forever),",
      "                color: colorScheme.error,",
      "                onPressed: onDelete,",
      "              ),",
      "            ),",
      "            // FUTURE FEATURE (placeholder for toggles)",
      "            if (onCustomAction != null)",
      "              Tooltip(",
      "                message: loc.featureComingSoon('Custom Action'),",
      "                child: IconButton(",
      "                  icon: const Icon(Icons.construction),",
      "                  onPressed: () {",
      "                    try {",
      "                      onCustomAction?.call();",
      "                    } catch (e, stack) {",
      "                      ErrorLogger.log(",
      "                        message: 'BulkOpsBar: CustomAction failed: $e',",
      "                        stack: stack.toString(),",
      "                        source: 'BulkOpsBar',",
      "                        screen: 'bulk_ops_bar.dart',",
      "                        severity: 'error',",
      "                      );",
      "                      ScaffoldMessenger.of(context).showSnackBar(",
      "                        SnackBar(",
      "                            content:",
      "                                Text(loc.featureComingSoon('Custom Action'))),",
      "                      );",
      "                    }",
      "                  },",
      "                ),",
      "              ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 173,
      "file_size": 5987,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\hq_owner\\widgets\\mock_payment_data.dart",
    "content": [
      "class MockPaymentData {",
      "  final String cardHolderName;",
      "  final String maskedCardString;",
      "  final String expiryDate;",
      "",
      "  MockPaymentData({",
      "    required this.cardHolderName,",
      "    required this.maskedCardString,",
      "    required this.expiryDate,",
      "  });",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 11,
      "file_size": 255,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\hq_owner\\widgets\\mock_payment_form.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter/services.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/admin/hq_owner/widgets/mock_payment_data.dart';",
      "import 'package:franchise_admin_portal/admin/hq_owner/widgets/tight_section_card.dart';",
      "import 'package:franchise_admin_portal/core/providers/role_guard.dart';",
      "import 'dart:math' as math;",
      "",
      "class MockPaymentForm extends StatefulWidget {",
      "  final Function(MockPaymentData payment) onValidated;",
      "",
      "  const MockPaymentForm({",
      "    Key? key,",
      "    required this.onValidated,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  State<MockPaymentForm> createState() => _MockPaymentFormState();",
      "}",
      "",
      "class _MockPaymentFormState extends State<MockPaymentForm> {",
      "  final _formKey = GlobalKey<FormState>();",
      "  final _nameController = TextEditingController();",
      "  final _cardController = TextEditingController();",
      "  final _expiryController = TextEditingController();",
      "  final _cvvController = TextEditingController();",
      "",
      "  String? _cardType;",
      "",
      "  @override",
      "  void dispose() {",
      "    _nameController.dispose();",
      "    _cardController.dispose();",
      "    _expiryController.dispose();",
      "    _cvvController.dispose();",
      "    super.dispose();",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context)!;",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "",
      "    return RoleGuard(",
      "      allowedRoles: const ['hq_owner', 'platform_owner', 'developer'],",
      "      child: TightSectionCard(",
      "        title: loc.mockPaymentHeader,",
      "        icon: Icons.credit_card,",
      "        builder: (context) => Form(",
      "          key: _formKey,",
      "          autovalidateMode: AutovalidateMode.onUserInteraction,",
      "          child: Column(",
      "            crossAxisAlignment: CrossAxisAlignment.start,",
      "            children: [",
      "              Text(",
      "                loc.mockPaymentDisclaimer,",
      "                style: Theme.of(context).textTheme.bodySmall?.copyWith(",
      "                      fontStyle: FontStyle.italic,",
      "                    ),",
      "              ),",
      "              const SizedBox(height: 16),",
      "              DropdownButtonFormField<String>(",
      "                value: _cardType,",
      "                decoration: InputDecoration(",
      "                  labelText: loc.cardType,",
      "                  border: const OutlineInputBorder(),",
      "                ),",
      "                items: ['Visa', 'Mastercard', 'Amex', 'Discover'].map((type) {",
      "                  return DropdownMenuItem(",
      "                    value: type,",
      "                    child: Text(type),",
      "                  );",
      "                }).toList(),",
      "                onChanged: (value) {",
      "                  setState(() {",
      "                    _cardType = value;",
      "                  });",
      "                },",
      "                validator: (value) => value == null ? loc.fieldRequired : null,",
      "              ),",
      "              const SizedBox(height: 16),",
      "              TextFormField(",
      "                controller: _nameController,",
      "                decoration: InputDecoration(",
      "                  labelText: loc.nameOnCard,",
      "                  border: const OutlineInputBorder(),",
      "                ),",
      "                validator: (value) => value == null || value.trim().isEmpty",
      "                    ? loc.fieldRequired",
      "                    : null,",
      "              ),",
      "              const SizedBox(height: 16),",
      "              TextFormField(",
      "                controller: _cardController,",
      "                decoration: InputDecoration(",
      "                  labelText: loc.cardNumber,",
      "                  border: const OutlineInputBorder(),",
      "                ),",
      "                keyboardType: TextInputType.number,",
      "                inputFormatters: [",
      "                  FilteringTextInputFormatter.digitsOnly,",
      "                  _CardNumberFormatter(),",
      "                ],",
      "                validator: (value) => value == null || value.trim().length < 16",
      "                    ? loc.invalidCardNumber",
      "                    : null,",
      "              ),",
      "              const SizedBox(height: 16),",
      "              Row(",
      "                children: [",
      "                  Expanded(",
      "                    flex: 2,",
      "                    child: TextFormField(",
      "                      controller: _expiryController,",
      "                      decoration: InputDecoration(",
      "                        labelText: loc.expiryDate,",
      "                        hintText: 'MM/YY',",
      "                        border: const OutlineInputBorder(),",
      "                      ),",
      "                      keyboardType: TextInputType.datetime,",
      "                      inputFormatters: [_ExpiryDateFormatter()],",
      "                      validator: (value) => value == null ||",
      "                              !RegExp(r\"^(0[1-9]|1[0-2])\\/\\d{2}$\")",
      "                                  .hasMatch(value)",
      "                          ? loc.invalidExpiryDate",
      "                          : null,",
      "                    ),",
      "                  ),",
      "                  const SizedBox(width: 16),",
      "                  Expanded(",
      "                    flex: 1,",
      "                    child: TextFormField(",
      "                      controller: _cvvController,",
      "                      decoration: InputDecoration(",
      "                        labelText: loc.cvv,",
      "                        border: const OutlineInputBorder(),",
      "                      ),",
      "                      keyboardType: TextInputType.number,",
      "                      inputFormatters: [LengthLimitingTextInputFormatter(3)],",
      "                      obscureText: true,",
      "                      validator: (value) => value == null || value.length != 3",
      "                          ? loc.invalidCvv",
      "                          : null,",
      "                    ),",
      "                  ),",
      "                ],",
      "              ),",
      "              const SizedBox(height: 16),",
      "              Align(",
      "                alignment: Alignment.centerRight,",
      "                child: ElevatedButton(",
      "                  onPressed: _handleValidate,",
      "                  child: Text(loc.validatePayment),",
      "                ),",
      "              ),",
      "            ],",
      "          ),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  void _handleValidate() {",
      "    final loc = AppLocalizations.of(context)!;",
      "    try {",
      "      if (_formKey.currentState!.validate()) {",
      "        final maskedCard = _cardController.text.replaceAll(RegExp(r'\\D'), '');",
      "        final last4 = maskedCard.length >= 4",
      "            ? maskedCard.substring(maskedCard.length - 4)",
      "            : '0000';",
      "        final paymentData = MockPaymentData(",
      "          cardHolderName: _nameController.text.trim(),",
      "          maskedCardString: '${_cardType ?? '****'} **** **** $last4',",
      "          expiryDate: _expiryController.text.trim(),",
      "        );",
      "",
      "        debugPrint('[MockPaymentForm] onValidated triggered with $maskedCard');",
      "",
      "        widget.onValidated(paymentData);",
      "",
      "        ScaffoldMessenger.of(context).showSnackBar(",
      "          SnackBar(content: Text(loc.mockPaymentValidated)),",
      "        );",
      "      }",
      "    } catch (e, stack) {",
      "      ErrorLogger.log(",
      "        message: 'Mock payment validation failed',",
      "        stack: stack.toString(),",
      "        source: 'MockPaymentForm',",
      "        screen: 'available_platform_plans_screen',",
      "        severity: 'warning',",
      "        contextData: {'exception': e.toString()},",
      "      );",
      "",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(",
      "          content: Text(loc.genericErrorOccurred),",
      "          backgroundColor: Theme.of(context).colorScheme.error,",
      "        ),",
      "      );",
      "    }",
      "  }",
      "}",
      "",
      "class _CardNumberFormatter extends TextInputFormatter {",
      "  @override",
      "  TextEditingValue formatEditUpdate(",
      "      TextEditingValue oldValue, TextEditingValue newValue) {",
      "    final digitsOnly = newValue.text.replaceAll(RegExp(r'\\D'), '');",
      "    final buffer = StringBuffer();",
      "",
      "    int selectionIndex = 0;",
      "    for (int i = 0; i < digitsOnly.length; i++) {",
      "      if (i > 0 && i % 4 == 0) {",
      "        buffer.write(' ');",
      "        if (i < newValue.selection.baseOffset) selectionIndex++;",
      "      }",
      "      buffer.write(digitsOnly[i]);",
      "      if (i < newValue.selection.baseOffset) selectionIndex++;",
      "    }",
      "",
      "    return TextEditingValue(",
      "      text: buffer.toString(),",
      "      selection: TextSelection.collapsed(offset: selectionIndex),",
      "    );",
      "  }",
      "}",
      "",
      "class _ExpiryDateFormatter extends TextInputFormatter {",
      "  @override",
      "  TextEditingValue formatEditUpdate(",
      "      TextEditingValue oldValue, TextEditingValue newValue) {",
      "    final rawText = newValue.text.replaceAll('/', '');",
      "    final buffer = StringBuffer();",
      "",
      "    int selectionIndex = newValue.selection.baseOffset;",
      "    for (int i = 0; i < rawText.length && i < 4; i++) {",
      "      if (i == 2) {",
      "        buffer.write('/');",
      "        if (i < selectionIndex) selectionIndex++;",
      "      }",
      "      buffer.write(rawText[i]);",
      "    }",
      "",
      "    final resultText = buffer.toString();",
      "    return TextEditingValue(",
      "      text: resultText,",
      "      selection: TextSelection.collapsed(offset: selectionIndex),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 253,
      "file_size": 9078,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\hq_owner\\widgets\\platform_plan_tile.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/models/platform_plan_model.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/admin/hq_owner/widgets/tight_section_card.dart';",
      "import 'package:franchise_admin_portal/core/providers/role_guard.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "import 'mock_payment_form.dart';",
      "import 'mock_payment_data.dart';",
      "import 'package:franchise_admin_portal/core/models/franchise_subscription_model.dart';",
      "import 'package:franchise_admin_portal/core/services/franchise_subscription_service.dart';",
      "",
      "class PlatformPlanTile extends StatefulWidget {",
      "  final PlatformPlan plan;",
      "  final bool isExpanded;",
      "  final VoidCallback onExpand;",
      "  final Function() onPlanUpdated;",
      "",
      "  const PlatformPlanTile({",
      "    Key? key,",
      "    required this.plan,",
      "    required this.isExpanded,",
      "    required this.onExpand,",
      "    required this.onPlanUpdated,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  State<PlatformPlanTile> createState() => _PlatformPlanTileState();",
      "}",
      "",
      "class _PlatformPlanTileState extends State<PlatformPlanTile> {",
      "  String? _selectedInterval;",
      "  MockPaymentData? _paymentInfo;",
      "  final _formKey = GlobalKey<FormState>();",
      "  bool _isSubmitting = false;",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context)!;",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    final textTheme = Theme.of(context).textTheme;",
      "",
      "    return RoleGuard(",
      "      allowedRoles: const ['hq_owner', 'platform_owner', 'developer'],",
      "      child: TightSectionCard(",
      "        title: widget.plan.name,",
      "        icon: Icons.credit_card,",
      "        builder: (context) => Column(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            _buildHeaderRow(loc, colorScheme, textTheme),",
      "            const SizedBox(height: 8),",
      "            _buildFeatureChips(colorScheme, textTheme),",
      "            if (widget.isExpanded) ...[",
      "              const SizedBox(height: 16),",
      "              Form(",
      "                key: _formKey,",
      "                child: Column(",
      "                  crossAxisAlignment: CrossAxisAlignment.start,",
      "                  children: [",
      "                    if (widget.plan.description.isNotEmpty)",
      "                      Padding(",
      "                        padding: const EdgeInsets.only(bottom: 12),",
      "                        child: Text(widget.plan.description,",
      "                            style: textTheme.bodyMedium),",
      "                      ),",
      "                    DropdownButtonFormField<String>(",
      "                      value: _selectedInterval,",
      "                      decoration: InputDecoration(",
      "                        labelText: loc.billingInterval,",
      "                        border: const OutlineInputBorder(),",
      "                      ),",
      "                      items: ['monthly', 'yearly'].map((interval) {",
      "                        return DropdownMenuItem(",
      "                          value: interval,",
      "                          child: Text(",
      "                              interval == 'monthly' ? loc.monthly : loc.yearly),",
      "                        );",
      "                      }).toList(),",
      "                      onChanged: (value) {",
      "                        setState(() {",
      "                          _selectedInterval = value;",
      "                        });",
      "                      },",
      "                      validator: (value) =>",
      "                          value == null ? loc.fieldRequired : null,",
      "                    ),",
      "                    const SizedBox(height: 14),",
      "                    Builder(",
      "                      builder: (context) {",
      "                        final showPaymentForm = widget.plan.requiresPayment &&",
      "                            _selectedInterval != null;",
      "                        debugPrint(",
      "                            'requiresPayment: ${widget.plan.requiresPayment}, interval: $_selectedInterval');",
      "",
      "                        return AnimatedSwitcher(",
      "                          duration: const Duration(milliseconds: 250),",
      "                          child: showPaymentForm",
      "                              ? Column(",
      "                                  key: const ValueKey('payment-form'),",
      "                                  children: [",
      "                                    MockPaymentForm(",
      "                                      onValidated: (paymentData) {",
      "                                        setState(() {",
      "                                          _paymentInfo = paymentData;",
      "                                        });",
      "                                      },",
      "                                    ),",
      "                                    if (_paymentInfo != null)",
      "                                      Padding(",
      "                                        padding: const EdgeInsets.only(top: 4),",
      "                                        child: Text(",
      "                                          '${AppLocalizations.of(context)!.paymentValidated}: ${_paymentInfo!.maskedCardString}',",
      "                                          style: Theme.of(context)",
      "                                              .textTheme",
      "                                              .bodySmall",
      "                                              ?.copyWith(",
      "                                                color: Theme.of(context)",
      "                                                    .colorScheme",
      "                                                    .secondary,",
      "                                                fontStyle: FontStyle.italic,",
      "                                              ),",
      "                                        ),",
      "                                      ),",
      "                                  ],",
      "                                )",
      "                              : const SizedBox.shrink(),",
      "                        );",
      "                      },",
      "                    ),",
      "                    Align(",
      "                      alignment: Alignment.centerRight,",
      "                      child: Tooltip(",
      "                        message: () {",
      "                          if (_selectedInterval == null) {",
      "                            return loc.selectBillingIntervalFirst;",
      "                          }",
      "                          if (widget.plan.requiresPayment &&",
      "                              _paymentInfo == null) {",
      "                            return loc.completePaymentToContinue;",
      "                          }",
      "                          return '';",
      "                        }(),",
      "                        child: ElevatedButton(",
      "                          onPressed: _isSubmitting || !_canSubmit()",
      "                              ? null",
      "                              : _submitSelectedPlan,",
      "                          child: _isSubmitting",
      "                              ? const CircularProgressIndicator.adaptive()",
      "                              : Text(loc.selectPlan),",
      "                        ),",
      "                      ),",
      "                    ),",
      "                  ],",
      "                ),",
      "              )",
      "            ],",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  Widget _buildHeaderRow(",
      "      AppLocalizations loc, ColorScheme colorScheme, TextTheme textTheme) {",
      "    return Row(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        Expanded(",
      "          child: Column(",
      "            crossAxisAlignment: CrossAxisAlignment.start,",
      "            children: [",
      "              Text(",
      "                '\\$${widget.plan.price.toStringAsFixed(2)} / ${widget.plan.billingInterval}',",
      "                style: textTheme.bodyMedium?.copyWith(",
      "                  fontWeight: FontWeight.w600,",
      "                  color: colorScheme.primary,",
      "                ),",
      "              ),",
      "            ],",
      "          ),",
      "        ),",
      "        if (widget.plan.isCustom)",
      "          Chip(",
      "            label: Text(loc.customPlan),",
      "            backgroundColor: colorScheme.secondaryContainer,",
      "          ),",
      "        IconButton(",
      "          onPressed: widget.onExpand,",
      "          icon: Icon(",
      "            widget.isExpanded ? Icons.expand_less : Icons.expand_more,",
      "          ),",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "",
      "  Widget _buildFeatureChips(ColorScheme colorScheme, TextTheme textTheme) {",
      "    return Wrap(",
      "      spacing: 6,",
      "      runSpacing: -4,",
      "      children: widget.plan.features",
      "          .map((feature) => Chip(",
      "                visualDensity: VisualDensity.compact,",
      "                label: Text(feature, style: textTheme.labelSmall),",
      "                backgroundColor: colorScheme.surfaceVariant,",
      "                side: BorderSide.none,",
      "                padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),",
      "              ))",
      "          .toList(),",
      "    );",
      "  }",
      "",
      "  bool _canSubmit() {",
      "    if (_selectedInterval == null) return false;",
      "    if (widget.plan.requiresPayment && _paymentInfo == null) return false;",
      "    return true;",
      "  }",
      "",
      "  Future<void> _submitSelectedPlan() async {",
      "    final loc = AppLocalizations.of(context)!;",
      "    final franchiseId =",
      "        context.read<AdminUserProvider>().user?.defaultFranchise;",
      "",
      "    if (!_formKey.currentState!.validate() || !_canSubmit()) return;",
      "",
      "    if (franchiseId == null || franchiseId.isEmpty) {",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(",
      "          content: Text(loc.genericErrorOccurred),",
      "          backgroundColor: Theme.of(context).colorScheme.error,",
      "        ),",
      "      );",
      "      return;",
      "    }",
      "",
      "    setState(() => _isSubmitting = true);",
      "",
      "    try {",
      "      final now = DateTime.now();",
      "      final nextBilling = now.add(const Duration(days: 30));",
      "      final billingCycleInDays = _selectedInterval == 'yearly' ? 365 : 30;",
      "",
      "      final subscription = FranchiseSubscription(",
      "        id: franchiseId,",
      "        franchiseId: franchiseId,",
      "        platformPlanId: widget.plan.id,",
      "        status: 'active',",
      "        startDate: now,",
      "        nextBillingDate: nextBilling,",
      "        billingCycleInDays: billingCycleInDays,",
      "        isTrial: false,",
      "        discountPercent: 0,",
      "        priceAtSubscription: widget.plan.price,",
      "        billingInterval: _selectedInterval!,",
      "        planSnapshot: {",
      "          'name': widget.plan.name,",
      "          'price': widget.plan.price,",
      "          'billingInterval': widget.plan.billingInterval,",
      "          'features': widget.plan.features,",
      "          'isCustom': widget.plan.isCustom,",
      "          'maskedCardString': _paymentInfo?.maskedCardString ?? '',",
      "        },",
      "        cancelAtPeriodEnd: false,",
      "        createdAt: now,",
      "        updatedAt: now,",
      "        subscribedAt: now,",
      "        lastInvoiceId: null,",
      "        trialEndsAt: null,",
      "        customQuoteDetails: null,",
      "        lastActivity: now,",
      "        autoRenew: true,",
      "        hasOverdueInvoice: false,",
      "      );",
      "",
      "      await FranchiseSubscriptionService().subscribeFranchiseToPlan(",
      "        franchiseId: franchiseId,",
      "        plan: widget.plan,",
      "      );",
      "",
      "      widget.onPlanUpdated();",
      "",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(content: Text(loc.subscriptionUpdated)),",
      "      );",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Plan subscription failed',",
      "        stack: stack.toString(),",
      "        source: 'PlatformPlanTile',",
      "        screen: 'available_platform_plans_screen',",
      "        severity: 'error',",
      "        contextData: {'exception': e.toString()},",
      "      );",
      "",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(",
      "          content: Text(loc.genericErrorOccurred),",
      "          backgroundColor: Theme.of(context).colorScheme.error,",
      "        ),",
      "      );",
      "    } finally {",
      "      setState(() => _isSubmitting = false);",
      "    }",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 309,
      "file_size": 11932,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\hq_owner\\widgets\\tight_section_card.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "",
      "class TightSectionCard extends StatelessWidget {",
      "  final String title;",
      "  final IconData? icon;",
      "  final WidgetBuilder builder;",
      "",
      "  const TightSectionCard({",
      "    Key? key,",
      "    required this.title,",
      "    required this.builder,",
      "    this.icon,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    final textTheme = Theme.of(context).textTheme;",
      "",
      "    return Container(",
      "      decoration: BoxDecoration(",
      "        color: colorScheme.surfaceVariant.withOpacity(0.1),",
      "        borderRadius: BorderRadius.circular(16),",
      "      ),",
      "      padding: const EdgeInsets.all(12),",
      "      child: Column(",
      "        crossAxisAlignment: CrossAxisAlignment.start,",
      "        children: [",
      "          Row(",
      "            children: [",
      "              if (icon != null)",
      "                Padding(",
      "                  padding: const EdgeInsets.only(right: 8.0),",
      "                  child: Icon(icon, size: 18, color: colorScheme.primary),",
      "                ),",
      "              Text(",
      "                title,",
      "                style: textTheme.labelLarge?.copyWith(",
      "                  fontWeight: FontWeight.w600,",
      "                  color: colorScheme.primary,",
      "                ),",
      "              ),",
      "            ],",
      "          ),",
      "          const SizedBox(height: 8),",
      "          builder(context),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 51,
      "file_size": 1424,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\inventory\\inventory_screen.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/models/inventory.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/config/branding_config.dart';",
      "import 'package:franchise_admin_portal/core/models/user.dart' as admin_user;",
      "import 'package:franchise_admin_portal/widgets/loading_shimmer_widget.dart';",
      "import 'package:franchise_admin_portal/widgets/empty_state_widget.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/widgets/subscription_access_guard.dart';",
      "import 'package:franchise_admin_portal/widgets/subscription/grace_period_banner.dart';",
      "import 'package:franchise_admin_portal/core/providers/role_guard.dart';",
      "",
      "class InventoryScreen extends StatefulWidget {",
      "  const InventoryScreen({super.key});",
      "",
      "  @override",
      "  State<InventoryScreen> createState() => _InventoryScreenState();",
      "}",
      "",
      "class _InventoryScreenState extends State<InventoryScreen> {",
      "  String _search = '';",
      "  Inventory? _lastDeleted;",
      "",
      "  void _onSearchChanged(String val) => setState(() => _search = val);",
      "",
      "  bool _canEdit(BuildContext context) {",
      "    final user = Provider.of<admin_user.User?>(context, listen: false);",
      "    if (user == null) return false;",
      "    return user.roles.contains('owner') ||",
      "        user.roles.contains('manager') ||",
      "        user.roles.contains('developer');",
      "  }",
      "",
      "  Future<void> _addOrEditInventory(String franchiseId, BuildContext context,",
      "      {Inventory? item}) async {",
      "    final firestore = Provider.of<FirestoreService>(context, listen: false);",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[YourWidget] loc is null! Localization not available for this context.');",
      "      // Optionally, show a SnackBar or dialog here",
      "      // ScaffoldMessenger.of(context).showSnackBar(",
      "      //   SnackBar(content: Text('Localization missing! [debug]'))",
      "      // );",
      "      return;",
      "    }",
      "    final nameController = TextEditingController(text: item?.name ?? '');",
      "    final skuController = TextEditingController(text: item?.sku ?? '');",
      "    final stockController =",
      "        TextEditingController(text: item?.stock.toString() ?? '0');",
      "    final thresholdController =",
      "        TextEditingController(text: item?.threshold.toString() ?? '0');",
      "    final unitTypeController =",
      "        TextEditingController(text: item?.unitType ?? '');",
      "    bool available = item?.available ?? true;",
      "",
      "    final result = await showDialog<bool>(",
      "      context: context,",
      "      builder: (_) => StatefulBuilder(",
      "        builder: (context, setDialogState) => AlertDialog(",
      "          title: Text(item == null ? (loc.addInventory) : (loc.editInventory)),",
      "          content: SingleChildScrollView(",
      "            child: Column(",
      "              mainAxisSize: MainAxisSize.min,",
      "              children: [",
      "                TextField(",
      "                  controller: nameController,",
      "                  decoration: InputDecoration(labelText: loc.name),",
      "                  autofocus: true,",
      "                ),",
      "                TextField(",
      "                  controller: skuController,",
      "                  decoration: InputDecoration(labelText: loc.sku),",
      "                ),",
      "                TextField(",
      "                  controller: stockController,",
      "                  decoration: InputDecoration(labelText: loc.stock),",
      "                  keyboardType: TextInputType.number,",
      "                ),",
      "                TextField(",
      "                  controller: thresholdController,",
      "                  decoration: InputDecoration(labelText: loc.threshold),",
      "                  keyboardType: TextInputType.number,",
      "                ),",
      "                TextField(",
      "                  controller: unitTypeController,",
      "                  decoration: InputDecoration(labelText: loc.unitType),",
      "                ),",
      "                SwitchListTile(",
      "                  value: available,",
      "                  onChanged: (val) => setDialogState(() => available = val),",
      "                  title: Text(loc.available),",
      "                ),",
      "              ],",
      "            ),",
      "          ),",
      "          actions: [",
      "            TextButton(",
      "              onPressed: () => Navigator.pop(context, false),",
      "              child: Text(loc.cancel),",
      "            ),",
      "            ElevatedButton(",
      "              onPressed: () => Navigator.pop(context, true),",
      "              child: Text(item == null ? loc.add : loc.save),",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "",
      "    if (result == true) {",
      "      final inventory = Inventory(",
      "        id: item?.id ?? '',",
      "        name: nameController.text.trim(),",
      "        sku: skuController.text.trim(),",
      "        stock: double.tryParse(stockController.text.trim()) ?? 0.0,",
      "        threshold: double.tryParse(thresholdController.text.trim()) ?? 0.0,",
      "        unitType: unitTypeController.text.trim(),",
      "        available: available,",
      "        lastUpdated: DateTime.now(),",
      "      );",
      "      if (item == null) {",
      "        await firestore.addInventory(franchiseId, inventory.copyWith(id: ''));",
      "        if (!mounted) return;",
      "        ScaffoldMessenger.of(context).showSnackBar(",
      "          SnackBar(content: Text(loc.inventoryAdded)),",
      "        );",
      "      } else {",
      "        await firestore.updateInventory(",
      "            franchiseId, inventory.copyWith(id: item.id));",
      "        if (!mounted) return;",
      "        ScaffoldMessenger.of(context).showSnackBar(",
      "          SnackBar(content: Text(loc.inventoryUpdated)),",
      "        );",
      "      }",
      "    }",
      "  }",
      "",
      "  Future<void> _deleteInventory(",
      "      String franchiseId, BuildContext context, Inventory item) async {",
      "    final firestore = Provider.of<FirestoreService>(context, listen: false);",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[YourWidget] loc is null! Localization not available for this context.');",
      "      // ScaffoldMessenger.of(context).showSnackBar(",
      "      //   SnackBar(content: Text('Localization missing! [debug]'))",
      "      // );",
      "      return;",
      "    }",
      "    final confirm = await showDialog<bool>(",
      "      context: context,",
      "      builder: (_) => AlertDialog(",
      "        backgroundColor: Theme.of(context).colorScheme.surface,",
      "        title: Text(",
      "          loc.deleteInventoryTitle,",
      "          style: TextStyle(color: Theme.of(context).colorScheme.onSurface),",
      "        ),",
      "        content: Text(",
      "          loc.deleteInventoryPrompt(item.name),",
      "          style: TextStyle(color: Theme.of(context).colorScheme.onSurface),",
      "        ),",
      "        actions: [",
      "          TextButton(",
      "            onPressed: () => Navigator.pop(context, false),",
      "            child: Text(",
      "              loc.cancel,",
      "              style: TextStyle(color: Theme.of(context).colorScheme.primary),",
      "            ),",
      "          ),",
      "          ElevatedButton(",
      "            onPressed: () => Navigator.pop(context, true),",
      "            style: ElevatedButton.styleFrom(",
      "              backgroundColor: Theme.of(context).colorScheme.error,",
      "              foregroundColor: Theme.of(context).colorScheme.onError,",
      "            ),",
      "            child: Text(loc.delete),",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "",
      "    if (confirm == true) {",
      "      await firestore.deleteInventory(franchiseId, item.id);",
      "      if (!mounted) return;",
      "      setState(() => _lastDeleted = item);",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(",
      "          content: Text(loc.inventoryDeleted),",
      "          action: SnackBarAction(",
      "            label: loc.undo,",
      "            onPressed: () async {",
      "              if (_lastDeleted != null) {",
      "                await firestore.addInventory(",
      "                    franchiseId, _lastDeleted!.copyWith(id: ''));",
      "                if (!mounted) return;",
      "                setState(() => _lastDeleted = null);",
      "              }",
      "            },",
      "          ),",
      "        ),",
      "      );",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final franchiseId = context.watch<FranchiseProvider>().franchiseId;",
      "    final firestore = Provider.of<FirestoreService>(context, listen: false);",
      "    final loc = AppLocalizations.of(context);",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    final canEdit = _canEdit(context);",
      "",
      "    return RoleGuard(",
      "      allowedRoles: const [",
      "        'platform_owner',",
      "        'hq_owner',",
      "        'manager',",
      "        'developer',",
      "        'admin'",
      "      ],",
      "      featureName: 'inventory_screen',",
      "      screen: 'InventoryScreen',",
      "      child: SubscriptionAccessGuard(",
      "        child: Scaffold(",
      "          backgroundColor: colorScheme.background,",
      "          body: Row(",
      "            crossAxisAlignment: CrossAxisAlignment.start,",
      "            children: [",
      "              // Main content column",
      "              Expanded(",
      "                flex: 11,",
      "                child: Padding(",
      "                  padding:",
      "                      const EdgeInsets.only(top: 24.0, left: 24.0, right: 24.0),",
      "                  child: Column(",
      "                    crossAxisAlignment: CrossAxisAlignment.start,",
      "                    children: [",
      "                      const GracePeriodBanner(),",
      "                      // Header row (matches Menu Editor & Category Management)",
      "                      Padding(",
      "                        padding: const EdgeInsets.only(bottom: 12.0),",
      "                        child: Row(",
      "                          crossAxisAlignment: CrossAxisAlignment.center,",
      "                          children: [",
      "                            Text(",
      "                              loc.inventory,",
      "                              style: TextStyle(",
      "                                color:",
      "                                    Theme.of(context).colorScheme.onBackground,",
      "                                fontWeight: FontWeight.bold,",
      "                                fontSize: 22,",
      "                              ),",
      "                            ),",
      "                            const Spacer(),",
      "                            IconButton(",
      "                              icon: Icon(Icons.add,",
      "                                  color: Theme.of(context)",
      "                                      .colorScheme",
      "                                      .onBackground",
      "                                      .withOpacity(0.87)),",
      "                              tooltip: loc.addInventory,",
      "                              onPressed: canEdit",
      "                                  ? () =>",
      "                                      _addOrEditInventory(franchiseId, context)",
      "                                  : null,",
      "                            ),",
      "                          ],",
      "                        ),",
      "                      ),",
      "                      // Search bar",
      "                      Padding(",
      "                        padding: const EdgeInsets.symmetric(",
      "                            horizontal: 0, vertical: 8),",
      "                        child: TextField(",
      "                          decoration: InputDecoration(",
      "                            hintText: loc.inventorySearchHint,",
      "                            prefixIcon: const Icon(Icons.search),",
      "                            border: OutlineInputBorder(",
      "                              borderRadius: BorderRadius.circular(12),",
      "                            ),",
      "                            isDense: true,",
      "                          ),",
      "                          onChanged: _onSearchChanged,",
      "                        ),",
      "                      ),",
      "                      // Inventory list",
      "                      Expanded(",
      "                        child: StreamBuilder<List<Inventory>>(",
      "                          stream: firestore.getInventory(franchiseId),",
      "                          builder: (context, snapshot) {",
      "                            if (snapshot.connectionState ==",
      "                                ConnectionState.waiting) {",
      "                              return const LoadingShimmerWidget();",
      "                            }",
      "                            if (snapshot.hasError) {",
      "                              return EmptyStateWidget(",
      "                                title: loc.errorLoadingInventory,",
      "                                message: snapshot.error.toString(),",
      "                              );",
      "                            }",
      "                            var items = snapshot.data ?? [];",
      "                            if (_search.isNotEmpty) {",
      "                              items = items",
      "                                  .where((inv) =>",
      "                                      inv.name",
      "                                          .toLowerCase()",
      "                                          .contains(_search.toLowerCase()) ||",
      "                                      (inv.sku",
      "                                          .toLowerCase()",
      "                                          .contains(_search.toLowerCase())))",
      "                                  .toList();",
      "                            }",
      "                            if (items.isEmpty) {",
      "                              return EmptyStateWidget(",
      "                                title: loc.noInventory,",
      "                                message: loc.noInventoryMsg,",
      "                              );",
      "                            }",
      "                            return ListView.separated(",
      "                              padding: const EdgeInsets.all(8),",
      "                              separatorBuilder: (_, __) =>",
      "                                  const Divider(height: 1),",
      "                              itemCount: items.length,",
      "                              itemBuilder: (context, idx) {",
      "                                final item = items[idx];",
      "                                return Card(",
      "                                  elevation: 2,",
      "                                  margin:",
      "                                      const EdgeInsets.symmetric(vertical: 4),",
      "                                  child: ListTile(",
      "                                    leading: Icon(",
      "                                      item.available",
      "                                          ? Icons.check_circle",
      "                                          : Icons.cancel,",
      "                                      color: item.available",
      "                                          ? Theme.of(context)",
      "                                              .colorScheme",
      "                                              .primary",
      "                                          : Theme.of(context).colorScheme.error,",
      "                                    ),",
      "                                    title: Text(",
      "                                      item.name,",
      "                                      style: TextStyle(",
      "                                        fontWeight: FontWeight.bold,",
      "                                        color: Theme.of(context)",
      "                                            .colorScheme",
      "                                            .onBackground,",
      "                                      ),",
      "                                    ),",
      "                                    subtitle: Text(",
      "                                      '${loc.sku}: ${item.sku}\\n'",
      "                                      '${loc.stock}: ${item.stock}\\n'",
      "                                      '${loc.threshold}: ${item.threshold}\\n'",
      "                                      '${loc.unitType}: ${item.unitType}',",
      "                                      style: TextStyle(",
      "                                        color: Theme.of(context)",
      "                                            .colorScheme",
      "                                            .onBackground",
      "                                            .withOpacity(0.8),",
      "                                      ),",
      "                                    ),",
      "                                    trailing: canEdit",
      "                                        ? Row(",
      "                                            mainAxisSize: MainAxisSize.min,",
      "                                            children: [",
      "                                              IconButton(",
      "                                                icon: Icon(Icons.edit,",
      "                                                    color: Theme.of(context)",
      "                                                        .colorScheme",
      "                                                        .secondary),",
      "                                                tooltip: loc.edit,",
      "                                                onPressed: () =>",
      "                                                    _addOrEditInventory(",
      "                                                        franchiseId, context,",
      "                                                        item: item),",
      "                                              ),",
      "                                              IconButton(",
      "                                                icon: Icon(Icons.delete,",
      "                                                    color: Theme.of(context)",
      "                                                        .colorScheme",
      "                                                        .error),",
      "                                                tooltip: loc.delete,",
      "                                                onPressed: () =>",
      "                                                    _deleteInventory(",
      "                                                        franchiseId,",
      "                                                        context,",
      "                                                        item),",
      "                                              ),",
      "                                            ],",
      "                                          )",
      "                                        : null,",
      "                                    onTap: canEdit",
      "                                        ? () => _addOrEditInventory(",
      "                                            franchiseId, context,",
      "                                            item: item)",
      "                                        : null,",
      "                                  ),",
      "                                );",
      "                              },",
      "                            );",
      "                          },",
      "                        ),",
      "                      ),",
      "                    ],",
      "                  ),",
      "                ),",
      "              ),",
      "              // Right panel placeholder",
      "              Expanded(",
      "                flex: 9,",
      "                child: Container(),",
      "              ),",
      "            ],",
      "          ),",
      "          floatingActionButton: canEdit",
      "              ? FloatingActionButton.extended(",
      "                  heroTag: 'inventory_fab',",
      "                  icon: const Icon(Icons.add),",
      "                  label: Text(loc.addInventory),",
      "                  backgroundColor: BrandingConfig.brandRed,",
      "                  onPressed: () => _addOrEditInventory(franchiseId, context),",
      "                )",
      "              : null,",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 439,
      "file_size": 19212,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\menu\\bulk_menu_upload_dialog.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/widgets/import_csv_file_button.dart';",
      "import 'package:franchise_admin_portal/core/models/category.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "",
      "class BulkMenuUploadDialog extends StatefulWidget {",
      "  final List<Category> categories;",
      "  final VoidCallback onComplete;",
      "  final String franchiseId;",
      "",
      "  const BulkMenuUploadDialog({",
      "    super.key,",
      "    required this.categories,",
      "    required this.onComplete,",
      "    required this.franchiseId,",
      "  });",
      "",
      "  @override",
      "  State<BulkMenuUploadDialog> createState() => _BulkMenuUploadDialogState();",
      "}",
      "",
      "class _BulkMenuUploadDialogState extends State<BulkMenuUploadDialog> {",
      "  static const String csvTemplate =",
      "      'category,name,price,description,imageUrl,available,sku,dietary,allergens\\n'",
      "      'Pizzas,Pepperoni Pizza,12.99,\"Classic pepperoni, cheese, and sauce\",https://img.url/pepperoni.jpg,true,SKU001,\"Vegetarian\",';",
      "",
      "  final TextEditingController _csvController = TextEditingController();",
      "  String? _error;",
      "  bool _loading = false;",
      "  bool _uploaded = false;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    // Preload with template if empty",
      "    if (_csvController.text.isEmpty) {",
      "      _csvController.text = csvTemplate;",
      "    }",
      "  }",
      "",
      "  @override",
      "  void dispose() {",
      "    _csvController.dispose();",
      "    super.dispose();",
      "  }",
      "",
      "  void _resetToTemplate() {",
      "    setState(() {",
      "      _csvController.text = csvTemplate;",
      "      _error = null;",
      "    });",
      "  }",
      "",
      "  void _onImportFilePressed() async {",
      "    // TODO: Implement file picker logic",
      "    // This is only a placeholder/snackbar for now",
      "    ScaffoldMessenger.of(context).showSnackBar(",
      "      SnackBar(",
      "          content: Text(AppLocalizations.of(context)!.importCSVPlaceholder)),",
      "    );",
      "  }",
      "",
      "  void _onSubmit() {",
      "    // TODO: Add actual CSV parsing/upload logic",
      "    // For now, just close and show success in UI (no actual import)",
      "    setState(() {",
      "      _uploaded = true;",
      "      _loading = false;",
      "      _error = null;",
      "    });",
      "    widget.onComplete();",
      "    Navigator.pop(context);",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "",
      "    return Dialog(",
      "      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),",
      "      child: Padding(",
      "        padding: const EdgeInsets.all(24.0),",
      "        child: SizedBox(",
      "          width: 520,",
      "          child: Column(",
      "            mainAxisSize: MainAxisSize.min,",
      "            crossAxisAlignment: CrossAxisAlignment.stretch,",
      "            children: [",
      "              Text(",
      "                loc.bulkImport,",
      "                style:",
      "                    const TextStyle(fontWeight: FontWeight.bold, fontSize: 20),",
      "              ),",
      "              const SizedBox(height: 12),",
      "              Text(",
      "                loc.bulkUploadInstructions,",
      "                style: const TextStyle(fontSize: 15),",
      "              ),",
      "              const SizedBox(height: 14),",
      "              Row(",
      "                children: [",
      "                  ImportCsvFileButton(",
      "                    label: loc.importCSV,",
      "                    onCsvPicked: (csvContent) {",
      "                      if (csvContent != null) {",
      "                        setState(() {",
      "                          _csvController.text = csvContent;",
      "                          // Optionally trigger CSV preview/parse if desired",
      "                          // _parseCsv();",
      "                        });",
      "                      } else {",
      "                        // User canceled, no action needed (optional: show a message)",
      "                      }",
      "                    },",
      "                  ),",
      "                  const SizedBox(width: 10),",
      "                  TextButton(",
      "                    onPressed: _resetToTemplate,",
      "                    child: Text(loc.resetTemplate),",
      "                  ),",
      "                ],",
      "              ),",
      "              const SizedBox(height: 12),",
      "              Expanded(",
      "                child: TextField(",
      "                  controller: _csvController,",
      "                  minLines: 8,",
      "                  maxLines: null,",
      "                  decoration: InputDecoration(",
      "                    labelText: loc.bulkUploadPasteCsv,",
      "                    border: const OutlineInputBorder(),",
      "                    hintText: csvTemplate,",
      "                  ),",
      "                  style: const TextStyle(fontFamily: 'monospace', fontSize: 13),",
      "                  onChanged: (_) {",
      "                    if (_error != null) setState(() => _error = null);",
      "                  },",
      "                ),",
      "              ),",
      "              if (_error != null)",
      "                Padding(",
      "                  padding: const EdgeInsets.only(top: 8.0),",
      "                  child: Text(",
      "                    _error!,",
      "                    style: const TextStyle(color: Colors.red),",
      "                  ),",
      "                ),",
      "              if (_uploaded)",
      "                Padding(",
      "                  padding: const EdgeInsets.only(top: 8.0),",
      "                  child: Text(",
      "                    loc.bulkImportSuccess,",
      "                    style: const TextStyle(color: Colors.green),",
      "                  ),",
      "                ),",
      "              const SizedBox(height: 16),",
      "              Row(",
      "                mainAxisAlignment: MainAxisAlignment.end,",
      "                children: [",
      "                  TextButton(",
      "                    onPressed: _loading ? null : () => Navigator.pop(context),",
      "                    child: Text(loc.cancel),",
      "                  ),",
      "                  const SizedBox(width: 10),",
      "                  ElevatedButton(",
      "                    onPressed: _loading",
      "                        ? null",
      "                        : () {",
      "                            setState(() => _loading = true);",
      "                            Future.delayed(",
      "                                const Duration(milliseconds: 400), _onSubmit);",
      "                          },",
      "                    child: _loading",
      "                        ? const SizedBox(",
      "                            width: 18,",
      "                            height: 18,",
      "                            child: CircularProgressIndicator(strokeWidth: 2))",
      "                        : Text(loc.upload),",
      "                  ),",
      "                ],",
      "              ),",
      "            ],",
      "          ),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 195,
      "file_size": 6598,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\menu\\customization_types.dart",
    "content": [
      "// lib/admin/menu_editor/customization_types.dart",
      "",
      "import 'package:franchise_admin_portal/core/models/customization.dart';",
      "",
      "/// Editable group of customizations for use in admin dialogs/screens.",
      "/// Fully supports multi/group/option types for franchise/SaaS, upcharges, portion, etc.",
      "class CustomizationGroup {",
      "  final String groupName;",
      "  final String type; // 'single', 'multi', 'quantity'",
      "  final int minSelect;",
      "  final int maxSelect;",
      "  final int? maxFree; // For \"first N free\" toppings (optional)",
      "  final List<CustomizationOption> options;",
      "  final bool allowExtra;",
      "  final bool allowSide;",
      "  final bool required;",
      "  final double? groupUpcharge; // Upcharge for picking from this group",
      "  final String? groupTag; // For grouping UI in admin",
      "",
      "  CustomizationGroup({",
      "    required this.groupName,",
      "    required this.type,",
      "    required this.minSelect,",
      "    required this.maxSelect,",
      "    this.maxFree,",
      "    required this.options,",
      "    this.allowExtra = false,",
      "    this.allowSide = false,",
      "    this.required = false,",
      "    this.groupUpcharge,",
      "    this.groupTag,",
      "  });",
      "}",
      "",
      "/// Editable single option inside a customization group.",
      "class CustomizationOption {",
      "  final String name;",
      "  final double price; // Base price/upcharge for this option",
      "  final Map<String, double>? upcharges; // Per-size upcharge (if any)",
      "  final bool isDefault;",
      "  final bool outOfStock;",
      "  final bool allowExtra;",
      "  final bool allowSide;",
      "  final int quantity;",
      "  final Portion portion;",
      "  final String? tag; // e.g., \"vegan\", \"spicy\"",
      "",
      "  CustomizationOption({",
      "    required this.name,",
      "    required this.price,",
      "    this.upcharges,",
      "    this.isDefault = false,",
      "    this.outOfStock = false,",
      "    this.allowExtra = false,",
      "    this.allowSide = false,",
      "    this.quantity = 1,",
      "    this.portion = Portion.whole,",
      "    this.tag,",
      "  });",
      "}",
      "",
      "/// Convert a [Customization] model (from DB) to [CustomizationGroup] for dialog editing.",
      "CustomizationGroup customizationToGroup(Customization c) {",
      "  return CustomizationGroup(",
      "    groupName: c.name,",
      "    type: (c.maxChoices ?? 1) > 1 ? 'multi' : 'single',",
      "    minSelect: c.minChoices ?? 1,",
      "    maxSelect: c.maxChoices ?? 1,",
      "    maxFree: c.maxFree,",
      "    allowExtra: c.allowExtra,",
      "    allowSide: c.allowSide,",
      "    required: c.required,",
      "    groupUpcharge: c.price > 0.0 ? c.price : null,",
      "    groupTag: c.group,",
      "    options: (c.options ?? [])",
      "        .map((o) => CustomizationOption(",
      "              name: o.name,",
      "              price: o.price,",
      "              upcharges: o.upcharges,",
      "              isDefault: o.isDefault,",
      "              outOfStock: o.outOfStock,",
      "              allowExtra: o.allowExtra,",
      "              allowSide: o.allowSide,",
      "              quantity: o.quantity,",
      "              portion: o.portion,",
      "              tag: o.group,",
      "            ))",
      "        .toList(),",
      "  );",
      "}",
      "",
      "/// Convert a [CustomizationGroup] (from admin dialog) back to [Customization] for saving to DB.",
      "Customization groupToCustomization(CustomizationGroup g) {",
      "  return Customization(",
      "    name: g.groupName,",
      "    isGroup: true,",
      "    price: g.groupUpcharge ?? 0.0,",
      "    required: g.required,",
      "    minChoices: g.minSelect,",
      "    maxChoices: g.maxSelect,",
      "    maxFree: g.maxFree,",
      "    group: g.groupTag,",
      "    allowExtra: g.allowExtra,",
      "    allowSide: g.allowSide,",
      "    options: g.options",
      "        .map((o) => Customization(",
      "              name: o.name,",
      "              isGroup: false,",
      "              price: o.price,",
      "              upcharges: o.upcharges,",
      "              isDefault: o.isDefault,",
      "              outOfStock: o.outOfStock,",
      "              allowExtra: o.allowExtra,",
      "              allowSide: o.allowSide,",
      "              quantity: o.quantity,",
      "              portion: o.portion,",
      "              group: o.tag,",
      "            ))",
      "        .toList(),",
      "  );",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 121,
      "file_size": 3791,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\menu\\dynamic_menu_item_editor_screen.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/widgets/header/franchise_app_bar.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/widgets/dynamic_form/dynamic_menu_item_form.dart';",
      "import 'package:franchise_admin_portal/widgets/empty_state_widget.dart';",
      "import 'package:franchise_admin_portal/widgets/delayed_loading_shimmer.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class DynamicMenuItemEditorScreen extends StatefulWidget {",
      "  final String franchiseId;",
      "  final String? initialCategoryId;",
      "  final VoidCallback? onCancel;",
      "  final ValueChanged<String>? onCategorySelected; // <-- Add this line",
      "",
      "  const DynamicMenuItemEditorScreen(",
      "      {super.key,",
      "      required this.franchiseId,",
      "      this.initialCategoryId,",
      "      this.onCancel,",
      "      this.onCategorySelected});",
      "",
      "  @override",
      "  State<DynamicMenuItemEditorScreen> createState() =>",
      "      _DynamicMenuItemEditorScreenState();",
      "}",
      "",
      "class _DynamicMenuItemEditorScreenState",
      "    extends State<DynamicMenuItemEditorScreen> {",
      "  String? _selectedCategoryId;",
      "  Map<String, dynamic>? _schema;",
      "  final Map<String, Map<String, dynamic>?> _schemaCache = {};",
      "  final ScrollController _scrollController = ScrollController();",
      "",
      "  @override",
      "  void didChangeDependencies() {",
      "    super.didChangeDependencies();",
      "    if (_selectedCategoryId != null && _schema == null) {",
      "      final franchiseId = widget.franchiseId;",
      "      _loadSchema(franchiseId, _selectedCategoryId!);",
      "    }",
      "  }",
      "",
      "  @override",
      "  void dispose() {",
      "    _scrollController.dispose();",
      "    super.dispose();",
      "  }",
      "",
      "  Future<void> _loadSchema(String franchiseId, String categoryId) async {",
      "    if (_schemaCache.containsKey(categoryId)) {",
      "      if (!mounted) return;",
      "      setState(() {",
      "        _selectedCategoryId = categoryId;",
      "        _schema = _schemaCache[categoryId];",
      "      });",
      "      return;",
      "    }",
      "",
      "    if (!mounted) return;",
      "    setState(() {",
      "      _selectedCategoryId = categoryId;",
      "      _schema = null;",
      "    });",
      "",
      "    final firestore = Provider.of<FirestoreService>(context, listen: false);",
      "",
      "    try {",
      "      final schema = await firestore.getCategorySchema(franchiseId, categoryId);",
      "",
      "      if (schema != null && schema['customizations'] is List) {",
      "        schema['customizations'] =",
      "            await _resolveCustomizations(franchiseId, schema['customizations']);",
      "      }",
      "      if (schema != null && schema['customizationGroups'] is List) {",
      "        schema['customizationGroups'] = List<Map<String, dynamic>>.from(",
      "          (schema['customizationGroups'] as List).map(",
      "            (e) => Map<String, dynamic>.from(e),",
      "          ),",
      "        );",
      "      }",
      "",
      "      if (!mounted) return;",
      "      setState(() {",
      "        _schemaCache[categoryId] = schema;",
      "        _schema = schema;",
      "        _selectedCategoryId = categoryId;",
      "      });",
      "    } catch (e) {",
      "      try {",
      "        final fallbackSchema =",
      "            await firestore.getCategorySchema(franchiseId, 'default');",
      "        if (!mounted) return;",
      "        setState(() {",
      "          _schemaCache[categoryId] = fallbackSchema;",
      "          _schema = fallbackSchema;",
      "          _selectedCategoryId = categoryId;",
      "        });",
      "",
      "        ScaffoldMessenger.of(context).showSnackBar(",
      "          SnackBar(",
      "            content: const Text('Using default fallback schema.'),",
      "            backgroundColor:",
      "                Theme.of(context).colorScheme.secondary.withOpacity(0.8),",
      "          ),",
      "        );",
      "      } catch (fallbackError) {",
      "        if (!mounted) return;",
      "        setState(() => _schema = null);",
      "        ScaffoldMessenger.of(context).showSnackBar(",
      "          SnackBar(",
      "            content: Text('Failed to load schema: $fallbackError'),",
      "            backgroundColor: Theme.of(context).colorScheme.error,",
      "          ),",
      "        );",
      "      }",
      "    }",
      "  }",
      "",
      "  Future<List<Map<String, dynamic>>> _resolveCustomizations(",
      "      String franchiseId, List<dynamic> rawCustomizations) async {",
      "    final firestore = Provider.of<FirestoreService>(context, listen: false);",
      "    final List<Map<String, dynamic>> resolved = [];",
      "",
      "    for (final entry in rawCustomizations) {",
      "      if (entry is Map<String, dynamic> && entry.containsKey('templateRef')) {",
      "        final templateId = entry['templateRef'];",
      "        try {",
      "          final template =",
      "              await firestore.getCustomizationTemplate(franchiseId, templateId);",
      "          if (template != null) {",
      "            resolved.add(template);",
      "          }",
      "        } catch (e) {",
      "          await firestore.logSchemaError(",
      "            franchiseId,",
      "            message: 'Failed to load customization template',",
      "            templateId: templateId,",
      "            stackTrace: e.toString(),",
      "          );",
      "        }",
      "      } else if (entry is Map<String, dynamic>) {",
      "        resolved.add(entry);",
      "      }",
      "    }",
      "    return resolved;",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final franchiseId = widget.franchiseId;",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    final firestore = Provider.of<FirestoreService>(context, listen: false);",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "",
      "    return FutureBuilder<List<String>>(",
      "      future: firestore.getAllCategorySchemaIds(franchiseId),",
      "      builder: (context, catSnapshot) {",
      "        if (catSnapshot.hasError || catSnapshot.data == null) {",
      "          return Center(",
      "            child: EmptyStateWidget(",
      "              title: loc.error,",
      "              message:",
      "                  catSnapshot.error?.toString() ?? loc.errorLoadingCategories,",
      "            ),",
      "          );",
      "        }",
      "",
      "        final allCategoryIds = catSnapshot.data!;",
      "",
      "        return ConstrainedBox(",
      "          constraints: const BoxConstraints(",
      "            maxWidth: 600,",
      "          ),",
      "          child: Column(",
      "            crossAxisAlignment: CrossAxisAlignment.stretch,",
      "            mainAxisSize: MainAxisSize.min, // Prevents infinite height!",
      "            children: [",
      "              if (_selectedCategoryId == null)",
      "                DropdownButtonFormField<String>(",
      "                  value: null,",
      "                  decoration: InputDecoration(",
      "                    labelText: loc.colCategory,",
      "                    border: const OutlineInputBorder(),",
      "                  ),",
      "                  style: TextStyle(",
      "                      color: colorScheme",
      "                          .onSurface), // <-- text color for selected value",
      "                  items: allCategoryIds.map((id) {",
      "                    return DropdownMenuItem<String>(",
      "                      value: id,",
      "                      child: Text(",
      "                        id.isNotEmpty",
      "                            ? id[0].toUpperCase() + id.substring(1)",
      "                            : '',",
      "                        style: TextStyle(",
      "                            color: colorScheme",
      "                                .onSurface), // <-- text color for dropdown items",
      "                      ),",
      "                    );",
      "                  }).toList(),",
      "                  onChanged: (v) {",
      "                    if (v != null) {",
      "                      print('Category selected: $v');",
      "                      widget.onCategorySelected?.call(v);",
      "                      final franchiseId = widget.franchiseId;",
      "                      _loadSchema(franchiseId, v);",
      "                    }",
      "                  },",
      "                  validator: (v) => v == null ? loc.requiredField : null,",
      "                ),",
      "              if (_selectedCategoryId == null) const SizedBox(height: 30),",
      "              if (_schema != null)",
      "                DynamicMenuItemForm(",
      "                  franchiseId: franchiseId,",
      "                  schema: _schema!,",
      "                  initialItem: null,",
      "                  onSave: (menuItem) async {",
      "                    try {",
      "                      await firestore.addMenuItem(franchiseId, menuItem);",
      "                      ScaffoldMessenger.of(context).showSnackBar(",
      "                        SnackBar(content: Text(loc.itemAdded)),",
      "                      );",
      "                      Navigator.pop(context);",
      "                    } catch (e, stack) {",
      "                      print('[ERROR] Failed to save item: $e');",
      "                      print(stack);",
      "                      ScaffoldMessenger.of(context).showSnackBar(",
      "                        SnackBar(content: Text('${loc.error}: $e')),",
      "                      );",
      "                    }",
      "                  },",
      "                  onCancel: () {",
      "                    if (widget.onCancel != null) {",
      "                      widget.onCancel!();",
      "                    }",
      "                  },",
      "                ),",
      "              if (_selectedCategoryId != null && _schema == null)",
      "                Padding(",
      "                  padding: const EdgeInsets.symmetric(vertical: 32),",
      "                  child: Center(child: CircularProgressIndicator()),",
      "                ),",
      "            ],",
      "          ),",
      "        );",
      "      },",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 260,
      "file_size": 9500,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\menu\\export_menu_dialog.dart",
    "content": [
      "import 'dart:convert';",
      "import 'dart:io'; // Will be ignored on web due to kIsWeb checks",
      "import 'package:flutter/foundation.dart' show kIsWeb;",
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/models/menu_item.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:permission_handler/permission_handler.dart';",
      "import 'package:path_provider/path_provider.dart';",
      "import 'package:share_plus/share_plus.dart';",
      "// Web-only import:",
      "import 'dart:html' as html;",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "",
      "class ExportMenuDialog extends StatefulWidget {",
      "  const ExportMenuDialog({Key? key}) : super(key: key);",
      "",
      "  @override",
      "  State<ExportMenuDialog> createState() => _ExportMenuDialogState();",
      "}",
      "",
      "class _ExportMenuDialogState extends State<ExportMenuDialog> {",
      "  String? _csvData;",
      "  bool _loading = false;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _exportMenu();",
      "  }",
      "",
      "  Future<void> _exportMenu() async {",
      "    setState(() => _loading = true);",
      "    final firestore = Provider.of<FirestoreService>(context, listen: false);",
      "    final franchiseId =",
      "        Provider.of<FranchiseProvider>(context, listen: false).franchiseId;",
      "    final List<MenuItem> items = await firestore.getMenuItemsOnce(franchiseId);",
      "",
      "    final header = [",
      "      'Category',",
      "      'Category ID',",
      "      'Name',",
      "      'Price',",
      "      'Description',",
      "      'Image',",
      "      'Tax Category',",
      "      'SKU',",
      "      'Available',",
      "      'Dietary Tags',",
      "      'Allergens',",
      "      'Prep Time',",
      "      'Nutrition (calories/fat/carbs/protein)',",
      "      'Customizations'",
      "    ];",
      "    final rows = items.map((i) {",
      "      final nutrition = i.nutrition != null",
      "          ? '${i.nutrition!.calories}/${i.nutrition!.fat}/${i.nutrition!.carbs}/${i.nutrition!.protein}'",
      "          : '';",
      "      final customizations = i.customizations.isNotEmpty",
      "          ? i.customizations.map((c) => '${c.name}:${c.price}').join(' | ')",
      "          : '';",
      "      return [",
      "        i.category,",
      "        i.categoryId ?? '',",
      "        i.name,",
      "        i.price.toString(),",
      "        i.description,",
      "        i.image ?? '',",
      "        i.taxCategory,",
      "        i.sku ?? '',",
      "        i.availability ? 'Yes' : 'No',",
      "        i.dietaryTags.join(';'),",
      "        i.allergens.join(';'),",
      "        i.prepTime?.toString() ?? '',",
      "        nutrition,",
      "        customizations,",
      "      ];",
      "    }).toList();",
      "",
      "    String escape(String s) {",
      "      if (s.contains(',') || s.contains('\"') || s.contains('\\n')) {",
      "        return '\"${s.replaceAll('\"', '\"\"')}\"';",
      "      }",
      "      return s;",
      "    }",
      "",
      "    final csv = StringBuffer();",
      "    csv.writeln(header.map(escape).join(','));",
      "    for (final row in rows) {",
      "      csv.writeln(row.map((col) => escape(col)).join(','));",
      "    }",
      "    setState(() {",
      "      _csvData = csv.toString();",
      "      _loading = false;",
      "    });",
      "  }",
      "",
      "  Future<void> _downloadCsv(BuildContext context, String csvData) async {",
      "    final localizations = AppLocalizations.of(context)!;",
      "    final fileName = \"menu_export_${DateTime.now().millisecondsSinceEpoch}.csv\";",
      "",
      "    if (kIsWeb) {",
      "      // --- WEB: Download via browser ---",
      "      final bytes = utf8.encode(csvData);",
      "      final blob = html.Blob([bytes]);",
      "      final url = html.Url.createObjectUrlFromBlob(blob);",
      "      final anchor = html.AnchorElement(href: url)",
      "        ..setAttribute(\"download\", fileName)",
      "        ..click();",
      "      html.Url.revokeObjectUrl(url);",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(",
      "            content:",
      "                Text('Download started. Check your browser\\'s downloads.')),",
      "      );",
      "      return;",
      "    }",
      "",
      "    // --- MOBILE / DESKTOP ---",
      "    try {",
      "      if (Platform.isAndroid) {",
      "        var status = await Permission.storage.request();",
      "        if (!status.isGranted) {",
      "          ScaffoldMessenger.of(context).showSnackBar(",
      "            SnackBar(content: Text(localizations.exportError)),",
      "          );",
      "          return;",
      "        }",
      "      }",
      "",
      "      Directory? directory;",
      "      if (Platform.isAndroid) {",
      "        directory = Directory('/storage/emulated/0/Download');",
      "        if (!await directory.exists()) {",
      "          directory = await getExternalStorageDirectory();",
      "        }",
      "      } else if (Platform.isIOS) {",
      "        directory = await getApplicationDocumentsDirectory();",
      "      }",
      "",
      "      if (directory == null) throw Exception('Cannot access file system');",
      "",
      "      final file = File('${directory.path}/$fileName');",
      "      await file.writeAsBytes(utf8.encode(csvData));",
      "      if (mounted) {",
      "        ScaffoldMessenger.of(context).showSnackBar(",
      "          SnackBar(content: Text('Saved to ${file.path}')),",
      "        );",
      "      }",
      "    } catch (e) {",
      "      if (mounted) {",
      "        ScaffoldMessenger.of(context).showSnackBar(",
      "          SnackBar(content: Text(localizations.exportError)),",
      "        );",
      "      }",
      "    }",
      "  }",
      "",
      "  Future<void> _shareCsv(BuildContext context) async {",
      "    if (_csvData == null) return;",
      "    if (kIsWeb) {",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(",
      "            content: Text(",
      "                'Sharing is not supported on web. Please download the file.')),",
      "      );",
      "      return;",
      "    }",
      "    try {",
      "      final tempDir = await getTemporaryDirectory();",
      "      final path =",
      "          '${tempDir.path}/menu_export_${DateTime.now().millisecondsSinceEpoch}.csv';",
      "      final file = File(path);",
      "      await file.writeAsString(_csvData!, flush: true);",
      "      await Share.shareXFiles([XFile(file.path)],",
      "          text: 'Doughboys Menu Export');",
      "    } catch (e) {",
      "      if (mounted) {",
      "        ScaffoldMessenger.of(context).showSnackBar(",
      "          SnackBar(content: Text(AppLocalizations.of(context)!.shareError)),",
      "        );",
      "      }",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final localizations = AppLocalizations.of(context)!;",
      "    return Dialog(",
      "      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),",
      "      child: Padding(",
      "        padding: const EdgeInsets.all(24.0),",
      "        child: SizedBox(",
      "          width: 600,",
      "          child: Column(",
      "            mainAxisSize: MainAxisSize.min,",
      "            children: [",
      "              Text(localizations.exportMenu,",
      "                  style: const TextStyle(",
      "                      fontWeight: FontWeight.bold, fontSize: 20)),",
      "              const SizedBox(height: 16),",
      "              if (_loading)",
      "                const CircularProgressIndicator()",
      "              else if (_csvData != null)",
      "                Column(",
      "                  crossAxisAlignment: CrossAxisAlignment.start,",
      "                  children: [",
      "                    Text(localizations.exportStarted,",
      "                        style: const TextStyle(color: Colors.green)),",
      "                    const SizedBox(height: 10),",
      "                    Container(",
      "                      decoration: BoxDecoration(",
      "                        border: Border.all(color: Colors.grey),",
      "                        borderRadius: BorderRadius.circular(8),",
      "                        color: Colors.grey[100],",
      "                      ),",
      "                      constraints: const BoxConstraints(maxHeight: 240),",
      "                      child: SingleChildScrollView(",
      "                        scrollDirection: Axis.horizontal,",
      "                        child: SelectableText(",
      "                          _csvData!,",
      "                          style: const TextStyle(",
      "                              fontFamily: 'monospace', fontSize: 12),",
      "                        ),",
      "                      ),",
      "                    ),",
      "                    const SizedBox(height: 20),",
      "                    Row(",
      "                      children: [",
      "                        ElevatedButton.icon(",
      "                          icon: const Icon(Icons.download),",
      "                          label: Text(localizations.download),",
      "                          onPressed: _csvData == null",
      "                              ? null",
      "                              : () => _downloadCsv(context, _csvData!),",
      "                        ),",
      "                        const SizedBox(width: 8),",
      "                        ElevatedButton.icon(",
      "                          icon: const Icon(Icons.share),",
      "                          label: Text(localizations.share),",
      "                          onPressed: _csvData == null",
      "                              ? null",
      "                              : () => _shareCsv(context),",
      "                        ),",
      "                        const Spacer(),",
      "                        ElevatedButton.icon(",
      "                          icon: const Icon(Icons.close),",
      "                          label: Text(localizations.close),",
      "                          onPressed: () => Navigator.pop(context),",
      "                          style: ElevatedButton.styleFrom(",
      "                            backgroundColor:",
      "                                Theme.of(context).colorScheme.primary,",
      "                            foregroundColor: Colors.white,",
      "                          ),",
      "                        ),",
      "                      ],",
      "                    ),",
      "                  ],",
      "                ),",
      "            ],",
      "          ),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 267,
      "file_size": 9335,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\menu\\menu_editor_screen.dart",
    "content": [
      "import 'package:franchise_admin_portal/admin/menu/menu_item_editor_panel.dart';",
      "import 'package:franchise_admin_portal/widgets/admin/admin_unauthorized_dialog.dart';",
      "import 'package:franchise_admin_portal/widgets/delayed_loading_shimmer.dart';",
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/core/providers/user_profile_notifier.dart';",
      "import 'package:franchise_admin_portal/admin/menu/dynamic_menu_item_editor_screen.dart';",
      "import 'package:franchise_admin_portal/widgets/admin/admin_menu_editor_popup_menu.dart';",
      "import 'package:franchise_admin_portal/widgets/header/franchise_app_bar.dart';",
      "import 'package:franchise_admin_portal/admin/menu/export_menu_dialog.dart';",
      "import 'package:franchise_admin_portal/widgets/admin/admin_bulk_selection_toolbar.dart';",
      "import 'package:franchise_admin_portal/widgets/status_chip.dart';",
      "import 'package:franchise_admin_portal/widgets/admin/admin_delete_confirm_dialog.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/models/menu_item.dart';",
      "import 'package:franchise_admin_portal/widgets/admin/admin_unauthorized_widget.dart';",
      "import 'package:franchise_admin_portal/core/models/category.dart';",
      "import 'package:franchise_admin_portal/widgets/dietary_allergen_chips_row.dart';",
      "import 'package:franchise_admin_portal/core/models/user.dart' as admin_user;",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/services/audit_log_service.dart';",
      "import 'package:franchise_admin_portal/widgets/loading_shimmer_widget.dart';",
      "import 'package:franchise_admin_portal/widgets/empty_state_widget.dart';",
      "import 'package:franchise_admin_portal/widgets/filter_dropdown.dart';",
      "import 'package:franchise_admin_portal/admin/menu/bulk_menu_upload_dialog.dart';",
      "import 'package:franchise_admin_portal/admin/menu/menu_item_customizations_dialog.dart';",
      "import 'package:franchise_admin_portal/admin/menu/customization_types.dart'",
      "    as ct;",
      "import 'package:franchise_admin_portal/config/branding_config.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/role_guard.dart';",
      "import 'package:franchise_admin_portal/core/utils/user_permissions.dart';",
      "import 'package:franchise_admin_portal/widgets/subscription_access_guard.dart';",
      "import 'package:franchise_admin_portal/widgets/subscription/grace_period_banner.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "",
      "const menuItemColumns = [",
      "  {\"key\": \"image\", \"width\": 56.0, \"header\": \"Image\"},",
      "  {\"key\": \"name\", \"flex\": 3, \"header\": \"Name\"},",
      "  {\"key\": \"category\", \"flex\": 2, \"header\": \"Category\"},",
      "  {\"key\": \"price\", \"flex\": 2, \"header\": \"Price\"},",
      "  {\"key\": \"available\", \"flex\": 2, \"header\": \"Available\"},",
      "  {\"key\": \"sku\", \"flex\": 2, \"header\": \"SKU\"},",
      "  {\"key\": \"dietary\", \"flex\": 3, \"header\": \"Dietary/Allergens\"},",
      "];",
      "",
      "class MenuEditorScreen extends StatelessWidget {",
      "  const MenuEditorScreen({super.key});",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return const MenuEditorScreenContent();",
      "  }",
      "}",
      "",
      "class MenuEditorScreenContent extends StatefulWidget {",
      "  const MenuEditorScreenContent({super.key});",
      "",
      "  @override",
      "  State<MenuEditorScreenContent> createState() =>",
      "      _MenuEditorScreenContentState();",
      "}",
      "",
      "class _MenuEditorScreenContentState extends State<MenuEditorScreenContent> {",
      "  final ValueNotifier<List<String>> _selectedIds =",
      "      ValueNotifier<List<String>>([]);",
      "",
      "  String _search = '';",
      "  String? _sortKey;",
      "  bool _sortAsc = true;",
      "  String? _categoryFilter;",
      "  bool _showDeleted = false;",
      "  MenuItem? _lastDeletedItem;",
      "",
      "  final ValueNotifier<String> _searchQuery = ValueNotifier<String>('');",
      "  final TextEditingController _searchController = TextEditingController();",
      "  String? _selectedCategoryForEditor;",
      "  // Panel state for add/edit",
      "  MenuItem? _editingMenuItem;",
      "  bool _showEditorPanel = false;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "  }",
      "",
      "  @override",
      "  void dispose() {",
      "    _searchQuery.dispose();",
      "    _selectedIds.dispose();",
      "    _searchController.dispose();",
      "    super.dispose();",
      "  }",
      "",
      "  void _onCategoryCleared() {",
      "    setState(() {",
      "      _editingMenuItem = null; // Clear editing item to reset categoryId",
      "      _showEditorPanel = true; // Keep panel open to show category picker",
      "    });",
      "  }",
      "",
      "  void _onCategorySelected(String categoryId) {",
      "    setState(() {",
      "      _selectedCategoryForEditor = categoryId;",
      "      _editingMenuItem = null; // Clear editing item to show new category form",
      "      _showEditorPanel = true; // Keep editor panel open",
      "    });",
      "  }",
      "",
      "  void _onSearchChanged(String value) => setState(() => _search = value);",
      "  void _onSortChanged(String sortKey, bool asc) => setState(() {",
      "        _sortKey = sortKey;",
      "        _sortAsc = asc;",
      "      });",
      "  void _clearSelection() {",
      "    _selectedIds.value = [];",
      "  }",
      "",
      "  Future<void> _addOrEditMenuItemPanel({MenuItem? item}) async {",
      "    setState(() {",
      "      _editingMenuItem = item;",
      "      _showEditorPanel = true;",
      "    });",
      "  }",
      "",
      "  Future<void> _saveOrCloseEditor() async {",
      "    setState(() {",
      "      _showEditorPanel = false;",
      "      _editingMenuItem = null;",
      "    });",
      "  }",
      "",
      "  void _showChooseColumnsDialog() {",
      "    // For future: column visibility settings.",
      "  }",
      "",
      "  Future<void> _bulkUpload(String franchiseId, BuildContext context,",
      "      List<Category> categories, admin_user.User user) async {",
      "    if (!UserPermissions.canDeleteMenu(user)) {",
      "      await _logUnauthorizedAttempt(",
      "          franchiseId, user, 'bulk_upload_menu_items');",
      "      _showUnauthorizedDialog();",
      "      return;",
      "    }",
      "    final result = await showDialog<bool>(",
      "      context: context,",
      "      builder: (_) => BulkMenuUploadDialog(",
      "        categories: categories,",
      "        franchiseId: context.read<FranchiseProvider>().franchiseId,",
      "        onComplete: () => Navigator.of(context).pop(true),",
      "      ),",
      "    );",
      "    if (result == true) {",
      "      await AuditLogService().addLog(",
      "        franchiseId: franchiseId,",
      "        userId: user.id,",
      "        action: 'bulk_upload_menu_items',",
      "        targetType: 'menu_item',",
      "        targetId: '',",
      "        details: {},",
      "      );",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(",
      "            content: Text(AppLocalizations.of(context)!.bulkImportSuccess)),",
      "      );",
      "    }",
      "  }",
      "",
      "  Future<void> _deleteMenuItems(String franchiseId, BuildContext context,",
      "      List<MenuItem> items, admin_user.User user) async {",
      "    final firestore = Provider.of<FirestoreService>(context, listen: false);",
      "    if (!UserPermissions.canDeleteMenu(user)) {",
      "      await _logUnauthorizedAttempt(franchiseId, user, 'delete_menu_items');",
      "      _showUnauthorizedDialog();",
      "      return;",
      "    }",
      "    final confirm = await showDialog<bool>(",
      "      context: context,",
      "      builder: (ctx) => AdminDeleteConfirmDialog(itemCount: items.length),",
      "    );",
      "",
      "    if (confirm == true) {",
      "      for (final item in items) {",
      "        await firestore.deleteMenuItem(franchiseId, item.id, userId: user.id);",
      "        await AuditLogService().addLog(",
      "          franchiseId: franchiseId,",
      "          userId: user.id,",
      "          action: 'delete_menu_item',",
      "          targetType: 'menu_item',",
      "          targetId: item.id,",
      "          details: {'name': item.name},",
      "        );",
      "      }",
      "      setState(() {",
      "        _lastDeletedItem = items.last;",
      "        _selectedIds.value = [];",
      "      });",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(",
      "          content: Text(AppLocalizations.of(context)!.itemDeleted),",
      "          action: SnackBarAction(",
      "            label: AppLocalizations.of(context)!.undo,",
      "            onPressed: () async {",
      "              if (_lastDeletedItem != null) {",
      "                await firestore.addMenuItem(franchiseId, _lastDeletedItem!,",
      "                    userId: user.id);",
      "                await AuditLogService().addLog(",
      "                  franchiseId: franchiseId,",
      "                  userId: user.id,",
      "                  action: 'undo_delete_menu_item',",
      "                  targetType: 'menu_item',",
      "                  targetId: _lastDeletedItem!.id,",
      "                  details: {'name': _lastDeletedItem!.name},",
      "                );",
      "                setState(() => _lastDeletedItem = null);",
      "              }",
      "            },",
      "          ),",
      "        ),",
      "      );",
      "    }",
      "  }",
      "",
      "  Future<void> _openCustomizations(String franchiseId, BuildContext context,",
      "      MenuItem item, admin_user.User user) async {",
      "    if (!UserPermissions.canEditMenu(user)) {",
      "      await _logUnauthorizedAttempt(",
      "          franchiseId, user, 'edit_customizations', item.id);",
      "      _showUnauthorizedDialog();",
      "      return;",
      "    }",
      "    final firestore = Provider.of<FirestoreService>(context, listen: false);",
      "",
      "    // Use shared mapping utilities",
      "    final List<ct.CustomizationGroup> groups =",
      "        item.customizations.map((c) => ct.customizationToGroup(c)).toList();",
      "",
      "    final result = await showDialog<List<ct.CustomizationGroup>>(",
      "      context: context,",
      "      builder: (_) => MenuItemCustomizationsDialog(",
      "        initialGroups: groups,",
      "      ),",
      "    );",
      "",
      "    if (result != null) {",
      "      final updatedCustomizations =",
      "          result.map((g) => ct.groupToCustomization(g)).toList();",
      "      await firestore.updateMenuItem(",
      "        franchiseId,",
      "        item.copyWith(customizations: updatedCustomizations),",
      "        userId: user.id,",
      "      );",
      "      await AuditLogService().addLog(",
      "        franchiseId: franchiseId,",
      "        userId: user.id,",
      "        action: 'update_customizations',",
      "        targetType: 'menu_item',",
      "        targetId: item.id,",
      "        details: {},",
      "      );",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(",
      "            content: Text(AppLocalizations.of(context)!.customizationsUpdated)),",
      "      );",
      "    }",
      "  }",
      "",
      "  Future<void> _exportToCSV(String franchiseId, BuildContext context,",
      "      List<MenuItem> items, admin_user.User user) async {",
      "    if (!UserPermissions.canDeleteMenu(user)) {",
      "      await _logUnauthorizedAttempt(franchiseId, user, 'export_menu_csv');",
      "      _showUnauthorizedDialog();",
      "      return;",
      "    }",
      "    // Export logic handled elsewhere",
      "    await AuditLogService().addLog(",
      "      franchiseId: franchiseId,",
      "      userId: user.id,",
      "      action: 'export_menu_csv',",
      "      targetType: 'menu_item',",
      "      targetId: '',",
      "      details: {'itemCount': items.length},",
      "    );",
      "    ScaffoldMessenger.of(context).showSnackBar(",
      "      SnackBar(content: Text(AppLocalizations.of(context)!.exportStarted)),",
      "    );",
      "  }",
      "",
      "  Future<void> _logUnauthorizedAttempt(",
      "      String franchiseId, admin_user.User user, String action,",
      "      [String? targetId]) async {",
      "    await AuditLogService().addLog(",
      "      franchiseId: franchiseId,",
      "      userId: user.id,",
      "      action: 'unauthorized_attempt',",
      "      targetType: 'menu_item',",
      "      targetId: targetId ?? '',",
      "      details: {'attemptedAction': action},",
      "    );",
      "  }",
      "",
      "  void _showUnauthorizedDialog() {",
      "    showDialog(",
      "      context: context,",
      "      builder: (_) => const AdminUnauthorizedDialog(),",
      "    );",
      "  }",
      "",
      "  Widget buildMenuHeaderRow(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    final textColor = Theme.of(context).colorScheme.onSurface;",
      "    return Padding(",
      "      padding: const EdgeInsets.symmetric(vertical: 8.0, horizontal: 4.0),",
      "      child: Row(",
      "        children: menuItemColumns.map((col) {",
      "          if (col.containsKey(\"width\")) {",
      "            return SizedBox(",
      "              width: col[\"width\"] as double,",
      "              child: Center(",
      "                child: Text(",
      "                  loc.tryString(col[\"header\"] as String? ?? \"\"),",
      "                  style:",
      "                      TextStyle(fontWeight: FontWeight.bold, color: textColor),",
      "                  textAlign: TextAlign.center,",
      "                ),",
      "              ),",
      "            );",
      "          } else {",
      "            return Expanded(",
      "              flex: col[\"flex\"] as int,",
      "              child: Text(",
      "                loc.tryString(col[\"header\"] as String? ?? \"\"),",
      "                style: TextStyle(",
      "                  fontWeight: FontWeight.bold,",
      "                  color: textColor,",
      "                ),",
      "              ),",
      "            );",
      "          }",
      "        }).toList(),",
      "      ),",
      "    );",
      "  }",
      "",
      "  Widget buildMenuDataRow(",
      "    String franchiseId,",
      "    BuildContext context,",
      "    MenuItem item,",
      "    List<Category> categories,",
      "    admin_user.User user,",
      "    bool isSelected,",
      "    bool canEdit,",
      "    bool canDeleteOrExport,",
      "  ) {",
      "    final cat = categories.firstWhere((c) => c.id == item.category,",
      "        orElse: () => Category(id: item.category, name: item.category));",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    final bool available = item.availability;",
      "    return InkWell(",
      "      onTap: () {",
      "        final cur = List<String>.from(_selectedIds.value);",
      "        isSelected ? cur.remove(item.id) : cur.add(item.id);",
      "        _selectedIds.value = cur;",
      "      },",
      "      child: Container(",
      "        color: isSelected",
      "            ? colorScheme.primary.withOpacity(0.08)",
      "            : colorScheme.background,",
      "        padding: const EdgeInsets.symmetric(vertical: 8.0, horizontal: 4.0),",
      "        child: Row(",
      "          children: menuItemColumns.map((col) {",
      "            switch (col[\"key\"]) {",
      "              case \"image\":",
      "                return SizedBox(",
      "                  width: col[\"width\"] as double,",
      "                  child: Center(",
      "                    child: (item.image != null && item.image!.isNotEmpty)",
      "                        ? ClipOval(",
      "                            child: Image.network(",
      "                              item.image!,",
      "                              width: 40,",
      "                              height: 40,",
      "                              fit: BoxFit.cover,",
      "                              errorBuilder: (_, __, ___) => Image.asset(",
      "                                BrandingConfig.defaultPizzaIcon,",
      "                                width: 40,",
      "                                height: 40,",
      "                              ),",
      "                            ),",
      "                          )",
      "                        : Image.asset(",
      "                            BrandingConfig.defaultPizzaIcon,",
      "                            width: 40,",
      "                            height: 40,",
      "                          ),",
      "                  ),",
      "                );",
      "              case \"name\":",
      "                return Expanded(",
      "                  flex: col[\"flex\"] as int,",
      "                  child: Text(",
      "                    item.name,",
      "                    style: TextStyle(color: colorScheme.onSurface),",
      "                  ),",
      "                );",
      "              case \"category\":",
      "                return Expanded(",
      "                  flex: col[\"flex\"] as int,",
      "                  child: Text(",
      "                    cat.name,",
      "                    style: TextStyle(color: colorScheme.onSurface),",
      "                  ),",
      "                );",
      "              case \"price\":",
      "                return Expanded(",
      "                  flex: col[\"flex\"] as int,",
      "                  child: Text(",
      "                    \"\\$${item.price.toStringAsFixed(2)}\",",
      "                    style: TextStyle(color: colorScheme.onSurface),",
      "                  ),",
      "                );",
      "              case \"available\":",
      "                return Expanded(",
      "                  flex: col[\"flex\"] as int,",
      "                  child: Row(",
      "                    children: [",
      "                      Container(",
      "                        width: 12,",
      "                        height: 12,",
      "                        decoration: BoxDecoration(",
      "                          color: available",
      "                              ? Colors.green",
      "                              : Theme.of(context).colorScheme.error,",
      "                          shape: BoxShape.circle,",
      "                        ),",
      "                      ),",
      "                      const SizedBox(width: 6),",
      "                      Text(",
      "                        available",
      "                            ? AppLocalizations.of(context)!.available",
      "                            : AppLocalizations.of(context)!.unavailable,",
      "                        style: TextStyle(",
      "                          color: available",
      "                              ? Colors.green",
      "                              : Theme.of(context).colorScheme.error,",
      "                          fontWeight: FontWeight.w500,",
      "                          fontSize: 14,",
      "                        ),",
      "                      ),",
      "                    ],",
      "                  ),",
      "                );",
      "              case \"sku\":",
      "                return Expanded(",
      "                  flex: col[\"flex\"] as int,",
      "                  child: Text(",
      "                    item.sku ?? '',",
      "                    style: TextStyle(color: colorScheme.onSurface),",
      "                  ),",
      "                );",
      "              case \"dietary\":",
      "                return Expanded(",
      "                  flex: col[\"flex\"] as int,",
      "                  child: DietaryAllergenChipsRow(",
      "                    dietaryTags: item.dietaryTags ?? [],",
      "                    allergens: item.allergens ?? [],",
      "                  ),",
      "                );",
      "              default:",
      "                return const SizedBox.shrink();",
      "            }",
      "          }).toList()",
      "            ..add(",
      "              SizedBox(",
      "                width: 42,",
      "                child: PopupMenuButton<String>(",
      "                  icon: const Icon(Icons.more_vert, size: 22),",
      "                  tooltip: \"More\",",
      "                  onSelected: (v) {",
      "                    switch (v) {",
      "                      case 'edit':",
      "                        _addOrEditMenuItemPanel(item: item);",
      "                        break;",
      "                      case 'customize':",
      "                        _openCustomizations(franchiseId, context, item, user);",
      "                        break;",
      "                      case 'delete':",
      "                        _deleteMenuItems(franchiseId, context, [item], user);",
      "                        break;",
      "                    }",
      "                  },",
      "                  itemBuilder: (_) => <PopupMenuEntry<String>>[",
      "                    if (canEdit)",
      "                      PopupMenuItem(",
      "                        value: 'edit',",
      "                        child: Text(AppLocalizations.of(context)!.edit),",
      "                      ),",
      "                    if (canEdit)",
      "                      PopupMenuItem(",
      "                        value: 'customize',",
      "                        child: Text(AppLocalizations.of(context)!.customize),",
      "                      ),",
      "                    if (canDeleteOrExport)",
      "                      PopupMenuItem(",
      "                        value: 'delete',",
      "                        child: Text(AppLocalizations.of(context)!.delete),",
      "                      ),",
      "                  ],",
      "                ),",
      "              ),",
      "            ),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final franchiseId = context.watch<FranchiseProvider>().franchiseId;",
      "    final firestore = Provider.of<FirestoreService>(context, listen: false);",
      "    final user = Provider.of<AdminUserProvider>(context).user;",
      "    final isLoading = context.watch<AdminUserProvider>().loading;",
      "    final loc = AppLocalizations.of(context);",
      "",
      "    debugPrint('[MenuEditorScreen] 🧭 Route Loaded');",
      "    debugPrint('[MenuEditorScreen] Franchise ID: $franchiseId');",
      "    debugPrint('[MenuEditorScreen] AdminUserProvider loading: $isLoading');",
      "    debugPrint(",
      "        '[MenuEditorScreen] Current user: ${user?.email}, roles: ${user?.roles}');",
      "",
      "    if (loc == null) {",
      "      debugPrint(",
      "          '[MenuEditorScreen] ❗ Localization is null — returning fallback UI');",
      "      return const Scaffold(",
      "        body: Center(child: Text('Localization missing!')),",
      "      );",
      "    }",
      "",
      "    if (user == null) {",
      "      if (isLoading) {",
      "        debugPrint('[MenuEditorScreen] ⏳ Admin user loading...');",
      "        return const Scaffold(",
      "          body: Center(child: CircularProgressIndicator()),",
      "        );",
      "      } else {",
      "        debugPrint(",
      "            '[MenuEditorScreen] ❌ No admin user loaded — aborting screen.');",
      "        return const Scaffold(",
      "          body: Center(child: Text('Unauthorized — No admin user')),",
      "        );",
      "      }",
      "    }",
      "",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    final canEdit = true;",
      "    final canDeleteOrExport = true;",
      "",
      "    return RoleGuard(",
      "      allowedRoles: const [",
      "        'platform_owner',",
      "        'hq_owner',",
      "        'manager',",
      "        'developer',",
      "        'admin'",
      "      ],",
      "      featureName: 'menu_editor_screen',",
      "      screen: 'MenuEditorScreen',",
      "      child: SubscriptionAccessGuard(",
      "        child: Scaffold(",
      "          backgroundColor: colorScheme.background,",
      "          body: Row(",
      "            crossAxisAlignment: CrossAxisAlignment.start,",
      "            children: [",
      "              Expanded(",
      "                flex: 11,",
      "                child: StreamBuilder<List<Category>>(",
      "                  stream: firestore.getCategories(franchiseId),",
      "                  builder: (context, catSnapshot) {",
      "                    return DelayedLoadingShimmer(",
      "                      loading: catSnapshot.connectionState ==",
      "                          ConnectionState.waiting,",
      "                      child: Builder(",
      "                        builder: (context) {",
      "                          if (catSnapshot.hasError) {",
      "                            return EmptyStateWidget(",
      "                              title: AppLocalizations.of(context)!",
      "                                  .errorLoadingCategories,",
      "                              message: catSnapshot.error.toString(),",
      "                            );",
      "                          }",
      "                          final categories = catSnapshot.data ?? [];",
      "                          if (categories.isEmpty) {",
      "                            return EmptyStateWidget(",
      "                              title: AppLocalizations.of(context)!.noCategories,",
      "                              message:",
      "                                  AppLocalizations.of(context)!.noCategoriesMsg,",
      "                            );",
      "                          }",
      "",
      "                          return StreamBuilder<List<MenuItem>>(",
      "                            stream: firestore.getMenuItems(franchiseId),",
      "                            builder: (context, itemSnapshot) {",
      "                              return DelayedLoadingShimmer(",
      "                                loading: itemSnapshot.connectionState ==",
      "                                    ConnectionState.waiting,",
      "                                child: Builder(",
      "                                  builder: (context) {",
      "                                    if (itemSnapshot.hasError) {",
      "                                      return EmptyStateWidget(",
      "                                        title: AppLocalizations.of(context)!",
      "                                            .errorLoadingMenu,",
      "                                        message: itemSnapshot.error.toString(),",
      "                                      );",
      "                                    }",
      "",
      "                                    var items = itemSnapshot.data ?? [];",
      "",
      "                                    if (_categoryFilter != null &&",
      "                                        _categoryFilter!.isNotEmpty) {",
      "                                      items = items",
      "                                          .where((i) =>",
      "                                              i.category == _categoryFilter)",
      "                                          .toList();",
      "                                    }",
      "",
      "                                    if (_search.isNotEmpty) {",
      "                                      items = items",
      "                                          .where((i) =>",
      "                                              i.name.toLowerCase().contains(",
      "                                                  _search.toLowerCase()) ||",
      "                                              (i.sku?.toLowerCase().contains(",
      "                                                      _search.toLowerCase()) ??",
      "                                                  false))",
      "                                          .toList();",
      "                                    }",
      "",
      "                                    if (_sortKey != null) {",
      "                                      items.sort((a, b) {",
      "                                        int cmp = 0;",
      "                                        switch (_sortKey) {",
      "                                          case 'name':",
      "                                            cmp = a.name.compareTo(b.name);",
      "                                            break;",
      "                                          case 'category':",
      "                                            cmp = a.category",
      "                                                .compareTo(b.category);",
      "                                            break;",
      "                                          case 'price':",
      "                                            cmp = a.price.compareTo(b.price);",
      "                                            break;",
      "                                          default:",
      "                                            cmp = 0;",
      "                                        }",
      "                                        return _sortAsc ? cmp : -cmp;",
      "                                      });",
      "                                    }",
      "",
      "                                    return Column(",
      "                                      crossAxisAlignment:",
      "                                          CrossAxisAlignment.stretch,",
      "                                      children: [",
      "                                        const GracePeriodBanner(),",
      "                                        Padding(",
      "                                          padding: const EdgeInsets.only(",
      "                                              top: 24,",
      "                                              left: 16,",
      "                                              right: 8,",
      "                                              bottom: 12),",
      "                                          child: Row(",
      "                                            children: [",
      "                                              Text(",
      "                                                AppLocalizations.of(context)!",
      "                                                    .menuEditorTitle,",
      "                                                style: TextStyle(",
      "                                                  color:",
      "                                                      colorScheme.onBackground,",
      "                                                  fontWeight: FontWeight.bold,",
      "                                                  fontSize: 22,",
      "                                                ),",
      "                                              ),",
      "                                              const Spacer(),",
      "                                              AdminMenuEditorPopupMenu(",
      "                                                showDeleted: _showDeleted,",
      "                                                canDeleteOrExport:",
      "                                                    canDeleteOrExport,",
      "                                                onShowColumns:",
      "                                                    _showChooseColumnsDialog,",
      "                                                onBulkUpload: () async {",
      "                                                  final cats = await firestore",
      "                                                      .getCategories(",
      "                                                          franchiseId)",
      "                                                      .first;",
      "                                                  _bulkUpload(franchiseId,",
      "                                                      context, cats, user);",
      "                                                },",
      "                                                onToggleShowDeleted: () {",
      "                                                  setState(() => _showDeleted =",
      "                                                      !_showDeleted);",
      "                                                },",
      "                                                onExportCSV: () {",
      "                                                  showDialog(",
      "                                                    context: context,",
      "                                                    builder: (_) =>",
      "                                                        const ExportMenuDialog(),",
      "                                                  );",
      "                                                },",
      "                                                columnsLabel: loc.colColumns,",
      "                                                importCSVLabel: loc.importCSV,",
      "                                                showDeletedLabel:",
      "                                                    loc.showDeleted,",
      "                                                exportCSVLabel: loc.exportCSV,",
      "                                              ),",
      "                                            ],",
      "                                          ),",
      "                                        ),",
      "                                        Padding(",
      "                                          padding: const EdgeInsets.symmetric(",
      "                                              horizontal: 8.0),",
      "                                          child: Row(",
      "                                            children: [",
      "                                              Expanded(",
      "                                                child: TextField(",
      "                                                  controller: _searchController,",
      "                                                  decoration: InputDecoration(",
      "                                                    hintText:",
      "                                                        AppLocalizations.of(",
      "                                                                context)!",
      "                                                            .adminSearchHint,",
      "                                                    prefixIcon: const Icon(",
      "                                                        Icons.search),",
      "                                                    border: OutlineInputBorder(",
      "                                                      borderRadius:",
      "                                                          BorderRadius.circular(",
      "                                                              24),",
      "                                                      borderSide:",
      "                                                          BorderSide.none,",
      "                                                    ),",
      "                                                    filled: true,",
      "                                                    fillColor:",
      "                                                        colorScheme.surface,",
      "                                                    contentPadding:",
      "                                                        const EdgeInsets",
      "                                                            .symmetric(",
      "                                                            horizontal: 16,",
      "                                                            vertical: 0),",
      "                                                  ),",
      "                                                  style: TextStyle(",
      "                                                      color: colorScheme",
      "                                                          .onSurface),",
      "                                                  onChanged: (q) {",
      "                                                    setState(() {",
      "                                                      _search = q;",
      "                                                    });",
      "                                                  },",
      "                                                ),",
      "                                              ),",
      "                                              const SizedBox(width: 12),",
      "                                              FilterDropdown<String>(",
      "                                                label: AppLocalizations.of(",
      "                                                        context)!",
      "                                                    .colCategory,",
      "                                                options: [''] +",
      "                                                    categories",
      "                                                        .map((cat) => cat.id)",
      "                                                        .toList(),",
      "                                                value: _categoryFilter ?? '',",
      "                                                onChanged: (value) {",
      "                                                  setState(() {",
      "                                                    _categoryFilter = (value !=",
      "                                                                null &&",
      "                                                            value.isNotEmpty)",
      "                                                        ? value",
      "                                                        : null;",
      "                                                  });",
      "                                                },",
      "                                                getLabel: (catId) {",
      "                                                  if (catId == '')",
      "                                                    return AppLocalizations.of(",
      "                                                            context)!",
      "                                                        .all;",
      "                                                  final match =",
      "                                                      categories.where(",
      "                                                          (c) => c.id == catId);",
      "                                                  return match.isNotEmpty",
      "                                                      ? match.first.name",
      "                                                      : catId;",
      "                                                },",
      "                                              ),",
      "                                            ],",
      "                                          ),",
      "                                        ),",
      "                                        const SizedBox(height: 6),",
      "                                        buildMenuHeaderRow(context),",
      "                                        const Divider(height: 1),",
      "                                        Expanded(",
      "                                          child: ValueListenableBuilder<",
      "                                              List<String>>(",
      "                                            valueListenable: _selectedIds,",
      "                                            builder: (context, selectedIds, _) {",
      "                                              if (items.isEmpty) {",
      "                                                return EmptyStateWidget(",
      "                                                  title: AppLocalizations.of(",
      "                                                          context)!",
      "                                                      .noMenuItems,",
      "                                                  message: AppLocalizations.of(",
      "                                                          context)!",
      "                                                      .noMenuItemsMsg,",
      "                                                );",
      "                                              }",
      "                                              return ListView.separated(",
      "                                                itemCount: items.length,",
      "                                                separatorBuilder: (_, __) =>",
      "                                                    Divider(",
      "                                                        height: 1,",
      "                                                        color: colorScheme",
      "                                                            .surface",
      "                                                            .withOpacity(0.6)),",
      "                                                itemBuilder: (ctx, idx) {",
      "                                                  final item = items[idx];",
      "                                                  final isSelected = selectedIds",
      "                                                      .contains(item.id);",
      "                                                  return buildMenuDataRow(",
      "                                                    franchiseId,",
      "                                                    ctx,",
      "                                                    item,",
      "                                                    categories,",
      "                                                    user,",
      "                                                    isSelected,",
      "                                                    canEdit,",
      "                                                    canDeleteOrExport,",
      "                                                  );",
      "                                                },",
      "                                              );",
      "                                            },",
      "                                          ),",
      "                                        ),",
      "                                        ValueListenableBuilder<List<String>>(",
      "                                          valueListenable: _selectedIds,",
      "                                          builder: (context, selectedIds, _) {",
      "                                            return (selectedIds.isNotEmpty &&",
      "                                                    canDeleteOrExport)",
      "                                                ? SafeArea(",
      "                                                    minimum:",
      "                                                        const EdgeInsets.only(",
      "                                                            bottom: 8),",
      "                                                    child: Padding(",
      "                                                      padding: EdgeInsets.only(",
      "                                                        bottom: MediaQuery.of(",
      "                                                                context)",
      "                                                            .viewPadding",
      "                                                            .bottom,",
      "                                                      ),",
      "                                                      child:",
      "                                                          AdminBulkSelectionToolbar(",
      "                                                        selectedCount:",
      "                                                            selectedIds.length,",
      "                                                        onDelete: () {",
      "                                                          final selectedItems = items",
      "                                                              .where((i) =>",
      "                                                                  selectedIds",
      "                                                                      .contains(",
      "                                                                          i.id))",
      "                                                              .toList();",
      "                                                          _deleteMenuItems(",
      "                                                            franchiseId,",
      "                                                            context,",
      "                                                            selectedItems,",
      "                                                            user,",
      "                                                          );",
      "                                                        },",
      "                                                        onClearSelection:",
      "                                                            _clearSelection,",
      "                                                        deleteLabel:",
      "                                                            AppLocalizations.of(",
      "                                                                    context)!",
      "                                                                .bulkDelete,",
      "                                                        clearSelectionTooltip:",
      "                                                            AppLocalizations.of(",
      "                                                                    context)!",
      "                                                                .clearSelection,",
      "                                                        selectedLabel:",
      "                                                            AppLocalizations.of(",
      "                                                                    context)!",
      "                                                                .bulkActionsSelected(",
      "                                                          selectedIds.length,",
      "                                                        ),",
      "                                                      ),",
      "                                                    ),",
      "                                                  )",
      "                                                : const SizedBox.shrink();",
      "                                          },",
      "                                        ),",
      "                                        if (canEdit)",
      "                                          Padding(",
      "                                            padding: const EdgeInsets.only(",
      "                                                right: 16, bottom: 16, top: 8),",
      "                                            child: Align(",
      "                                              alignment: Alignment.bottomRight,",
      "                                              child:",
      "                                                  FloatingActionButton.extended(",
      "                                                heroTag:",
      "                                                    'menu_editor_add_item_fab',",
      "                                                backgroundColor:",
      "                                                    Theme.of(context)",
      "                                                                .brightness ==",
      "                                                            Brightness.dark",
      "                                                        ? Colors.white",
      "                                                        : colorScheme.primary,",
      "                                                foregroundColor:",
      "                                                    Theme.of(context)",
      "                                                                .brightness ==",
      "                                                            Brightness.dark",
      "                                                        ? Colors.black",
      "                                                        : colorScheme.onPrimary,",
      "                                                icon: Icon(Icons.add),",
      "                                                label: Text(",
      "                                                  AppLocalizations.of(context)!",
      "                                                      .addItem,",
      "                                                  style: TextStyle(",
      "                                                    color: Theme.of(context)",
      "                                                                .brightness ==",
      "                                                            Brightness.dark",
      "                                                        ? Colors.black",
      "                                                        : colorScheme.onPrimary,",
      "                                                  ),",
      "                                                ),",
      "                                                onPressed: () =>",
      "                                                    _addOrEditMenuItemPanel(",
      "                                                        item: null),",
      "                                              ),",
      "                                            ),",
      "                                          ),",
      "                                      ],",
      "                                    );",
      "                                  },",
      "                                ),",
      "                              );",
      "                            },",
      "                          );",
      "                        },",
      "                      ),",
      "                    );",
      "                  },",
      "                ),",
      "              ),",
      "              Expanded(",
      "                flex: 9,",
      "                child: Offstage(",
      "                  offstage: !_showEditorPanel,",
      "                  child: MenuItemEditorPanel(",
      "                    isOpen: _showEditorPanel,",
      "                    initialCategoryId: _selectedCategoryForEditor,",
      "                    onClose: _saveOrCloseEditor,",
      "                    onCategoryCleared: _onCategoryCleared,",
      "                    onCategorySelected: (category) {",
      "                      setState(() {",
      "                        _editingMenuItem = null;",
      "                        _selectedCategoryForEditor = category;",
      "                        _showEditorPanel = true;",
      "                      });",
      "                    },",
      "                  ),",
      "                ),",
      "              ),",
      "            ],",
      "          ),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  Widget _unauthorizedScaffold() => const SizedBox.shrink();",
      "}",
      "",
      "// Extension to safely localize static header keys, fallback to the given string",
      "extension _LocTry on AppLocalizations {",
      "  String tryString(String header) {",
      "    switch (header) {",
      "      case \"Image\":",
      "        return colImage;",
      "      case \"Name\":",
      "        return colName;",
      "      case \"Category\":",
      "        return colCategory;",
      "      case \"Price\":",
      "        return colPrice;",
      "      case \"Available\":",
      "        return colAvailable;",
      "      case \"SKU\":",
      "        return colSKU;",
      "      case \"Dietary/Allergens\":",
      "        return \"Dietary/Allergens\";",
      "      default:",
      "        return header;",
      "    }",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 1004,
      "file_size": 46467,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\menu\\menu_item_customizations_dialog.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/models/customization.dart';",
      "import 'package:franchise_admin_portal/admin/menu/customization_types.dart';",
      "",
      "// Dialog for full-featured editing of menu customizations/groups/options.",
      "class MenuItemCustomizationsDialog extends StatefulWidget {",
      "  final List<CustomizationGroup> initialGroups;",
      "  final ValueChanged<List<CustomizationGroup>>? onSave;",
      "",
      "  const MenuItemCustomizationsDialog({",
      "    super.key,",
      "    required this.initialGroups,",
      "    this.onSave,",
      "  });",
      "",
      "  @override",
      "  State<MenuItemCustomizationsDialog> createState() =>",
      "      _MenuItemCustomizationsDialogState();",
      "}",
      "",
      "class _MenuItemCustomizationsDialogState",
      "    extends State<MenuItemCustomizationsDialog> {",
      "  late List<CustomizationGroup> _groups;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    // Deep copy for edit safety, include all advanced fields.",
      "    _groups = widget.initialGroups",
      "        .map((g) => CustomizationGroup(",
      "              groupName: g.groupName,",
      "              type: g.type,",
      "              minSelect: g.minSelect,",
      "              maxSelect: g.maxSelect,",
      "              maxFree: g.maxFree,",
      "              allowExtra: g.allowExtra,",
      "              allowSide: g.allowSide,",
      "              required: g.required,",
      "              groupUpcharge: g.groupUpcharge,",
      "              groupTag: g.groupTag,",
      "              options: g.options",
      "                  .map((o) => CustomizationOption(",
      "                        name: o.name,",
      "                        price: o.price,",
      "                        upcharges: o.upcharges,",
      "                        isDefault: o.isDefault,",
      "                        outOfStock: o.outOfStock,",
      "                        allowExtra: o.allowExtra,",
      "                        allowSide: o.allowSide,",
      "                        quantity: o.quantity,",
      "                        portion: o.portion,",
      "                        tag: o.tag,",
      "                      ))",
      "                  .toList(),",
      "            ))",
      "        .toList();",
      "  }",
      "",
      "  void _addGroup() {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[YourWidget] loc is null! Localization not available for this context.');",
      "      // Optionally, show a SnackBar or AlertDialog here if you want to warn the user.",
      "      // ScaffoldMessenger.of(context).showSnackBar(",
      "      //   SnackBar(content: Text('Localization missing! [debug]'))",
      "      // );",
      "      return; // Just exit the function early.",
      "    }",
      "    String groupName = '';",
      "    String type = 'single';",
      "    int minSelect = 1;",
      "    int maxSelect = 1;",
      "    int? maxFree;",
      "    bool allowExtra = false;",
      "    bool allowSide = false;",
      "    bool required = false;",
      "    double? groupUpcharge;",
      "    String? groupTag;",
      "    showDialog(",
      "      context: context,",
      "      builder: (ctx) => AlertDialog(",
      "        title: Text(loc.addCustomization),",
      "        content: StatefulBuilder(",
      "          builder: (context, setStateDialog) {",
      "            return SingleChildScrollView(",
      "              child: Column(",
      "                mainAxisSize: MainAxisSize.min,",
      "                children: [",
      "                  TextFormField(",
      "                    decoration:",
      "                        InputDecoration(labelText: loc.customizationName),",
      "                    onChanged: (v) => groupName = v,",
      "                    autofocus: true,",
      "                  ),",
      "                  DropdownButtonFormField<String>(",
      "                    value: type,",
      "                    decoration: InputDecoration(labelText: loc.type),",
      "                    items: [",
      "                      DropdownMenuItem(",
      "                          value: 'single', child: Text(loc.singleSelect)),",
      "                      DropdownMenuItem(",
      "                          value: 'multi', child: Text(loc.multiSelect)),",
      "                      DropdownMenuItem(",
      "                          value: 'quantity', child: Text(loc.quantitySelect)),",
      "                    ],",
      "                    onChanged: (v) =>",
      "                        setStateDialog(() => type = v ?? 'single'),",
      "                  ),",
      "                  Row(",
      "                    children: [",
      "                      Expanded(",
      "                        child: TextFormField(",
      "                          decoration: InputDecoration(labelText: loc.minSelect),",
      "                          keyboardType: TextInputType.number,",
      "                          onChanged: (v) => minSelect = int.tryParse(v) ?? 1,",
      "                        ),",
      "                      ),",
      "                      const SizedBox(width: 8),",
      "                      Expanded(",
      "                        child: TextFormField(",
      "                          decoration: InputDecoration(labelText: loc.maxSelect),",
      "                          keyboardType: TextInputType.number,",
      "                          onChanged: (v) => maxSelect = int.tryParse(v) ?? 1,",
      "                        ),",
      "                      ),",
      "                    ],",
      "                  ),",
      "                  TextFormField(",
      "                    decoration: InputDecoration(labelText: loc.firstNFreeLabel),",
      "                    keyboardType: TextInputType.number,",
      "                    onChanged: (v) => maxFree = int.tryParse(v),",
      "                  ),",
      "                  TextFormField(",
      "                    decoration: InputDecoration(labelText: loc.groupUpcharge),",
      "                    keyboardType: TextInputType.number,",
      "                    onChanged: (v) => groupUpcharge = double.tryParse(v),",
      "                  ),",
      "                  TextFormField(",
      "                    decoration: InputDecoration(labelText: loc.groupTag),",
      "                    onChanged: (v) => groupTag = v,",
      "                  ),",
      "                  SwitchListTile(",
      "                    title: Text(loc.allowExtra),",
      "                    value: allowExtra,",
      "                    onChanged: (v) => setStateDialog(() => allowExtra = v),",
      "                  ),",
      "                  SwitchListTile(",
      "                    title: Text(loc.allowSide),",
      "                    value: allowSide,",
      "                    onChanged: (v) => setStateDialog(() => allowSide = v),",
      "                  ),",
      "                  SwitchListTile(",
      "                    title: Text(loc.requiredField),",
      "                    value: required,",
      "                    onChanged: (v) => setStateDialog(() => required = v),",
      "                  ),",
      "                ],",
      "              ),",
      "            );",
      "          },",
      "        ),",
      "        actions: [",
      "          TextButton(",
      "            onPressed: () => Navigator.pop(ctx),",
      "            child: Text(loc.cancel),",
      "          ),",
      "          ElevatedButton(",
      "            onPressed: () {",
      "              if (groupName.trim().isNotEmpty) {",
      "                setState(() {",
      "                  _groups.add(CustomizationGroup(",
      "                    groupName: groupName,",
      "                    type: type,",
      "                    minSelect: minSelect,",
      "                    maxSelect: maxSelect,",
      "                    maxFree: maxFree,",
      "                    allowExtra: allowExtra,",
      "                    allowSide: allowSide,",
      "                    required: required,",
      "                    groupUpcharge: groupUpcharge,",
      "                    groupTag: groupTag,",
      "                    options: [],",
      "                  ));",
      "                });",
      "                Navigator.pop(ctx);",
      "              }",
      "            },",
      "            child: Text(loc.add),",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "",
      "  void _addOption(int groupIdx) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[YourWidget] loc is null! Localization not available for this context.');",
      "      // ScaffoldMessenger.of(context).showSnackBar(",
      "      //   SnackBar(content: Text('Localization missing! [debug]'))",
      "      // );",
      "      return;",
      "    }",
      "    String optName = '';",
      "    double optPrice = 0.0;",
      "    Map<String, double>? upcharges;",
      "    bool isDefault = false;",
      "    bool outOfStock = false;",
      "    bool allowExtra = false;",
      "    bool allowSide = false;",
      "    int quantity = 1;",
      "    Portion portion = Portion.whole;",
      "    String? tag;",
      "    showDialog(",
      "      context: context,",
      "      builder: (ctx) => AlertDialog(",
      "        title: Text(loc.addOption),",
      "        content: StatefulBuilder(",
      "          builder: (context, setStateDialog) {",
      "            return SingleChildScrollView(",
      "              child: Column(",
      "                mainAxisSize: MainAxisSize.min,",
      "                children: [",
      "                  TextFormField(",
      "                    decoration:",
      "                        InputDecoration(labelText: loc.customizationName),",
      "                    onChanged: (v) => optName = v,",
      "                    autofocus: true,",
      "                  ),",
      "                  TextFormField(",
      "                    decoration:",
      "                        InputDecoration(labelText: loc.customizationPrice),",
      "                    keyboardType: TextInputType.number,",
      "                    onChanged: (v) => optPrice = double.tryParse(v) ?? 0.0,",
      "                  ),",
      "                  TextFormField(",
      "                    decoration: InputDecoration(labelText: loc.upchargePerSize),",
      "                    keyboardType: TextInputType.text,",
      "                    onChanged: (v) {",
      "                      // Format: \"Small:1.5,Large:2.0\"",
      "                      upcharges = {};",
      "                      for (final entry in v.split(',')) {",
      "                        final parts = entry.split(':');",
      "                        if (parts.length == 2) {",
      "                          final key = parts[0].trim();",
      "                          final val = double.tryParse(parts[1].trim());",
      "                          if (key.isNotEmpty && val != null)",
      "                            upcharges![key] = val;",
      "                        }",
      "                      }",
      "                    },",
      "                  ),",
      "                  TextFormField(",
      "                    decoration: InputDecoration(labelText: loc.tag),",
      "                    onChanged: (v) => tag = v,",
      "                  ),",
      "                  Row(",
      "                    children: [",
      "                      Expanded(",
      "                        child: DropdownButtonFormField<Portion>(",
      "                          value: portion,",
      "                          decoration: InputDecoration(labelText: loc.portion),",
      "                          items: Portion.values",
      "                              .map((p) => DropdownMenuItem(",
      "                                    value: p,",
      "                                    child: Text(p.toString().split('.').last),",
      "                                  ))",
      "                              .toList(),",
      "                          onChanged: (v) => setStateDialog(",
      "                              () => portion = v ?? Portion.whole),",
      "                        ),",
      "                      ),",
      "                      Expanded(",
      "                        child: TextFormField(",
      "                          decoration: InputDecoration(labelText: loc.quantity),",
      "                          keyboardType: TextInputType.number,",
      "                          onChanged: (v) => quantity = int.tryParse(v) ?? 1,",
      "                        ),",
      "                      ),",
      "                    ],",
      "                  ),",
      "                  SwitchListTile(",
      "                    title: Text(loc.setAsDefault),",
      "                    value: isDefault,",
      "                    onChanged: (v) => setStateDialog(() => isDefault = v),",
      "                  ),",
      "                  SwitchListTile(",
      "                    title: Text(loc.outOfStock),",
      "                    value: outOfStock,",
      "                    onChanged: (v) => setStateDialog(() => outOfStock = v),",
      "                  ),",
      "                  SwitchListTile(",
      "                    title: Text(loc.allowExtra),",
      "                    value: allowExtra,",
      "                    onChanged: (v) => setStateDialog(() => allowExtra = v),",
      "                  ),",
      "                  SwitchListTile(",
      "                    title: Text(loc.allowSide),",
      "                    value: allowSide,",
      "                    onChanged: (v) => setStateDialog(() => allowSide = v),",
      "                  ),",
      "                ],",
      "              ),",
      "            );",
      "          },",
      "        ),",
      "        actions: [",
      "          TextButton(",
      "            onPressed: () => Navigator.pop(ctx),",
      "            child: Text(loc.cancel),",
      "          ),",
      "          ElevatedButton(",
      "            onPressed: () {",
      "              if (optName.trim().isNotEmpty) {",
      "                setState(() {",
      "                  _groups[groupIdx].options.add(CustomizationOption(",
      "                        name: optName,",
      "                        price: optPrice,",
      "                        upcharges: upcharges,",
      "                        isDefault: isDefault,",
      "                        outOfStock: outOfStock,",
      "                        allowExtra: allowExtra,",
      "                        allowSide: allowSide,",
      "                        quantity: quantity,",
      "                        portion: portion,",
      "                        tag: tag,",
      "                      ));",
      "                });",
      "                Navigator.pop(ctx);",
      "              }",
      "            },",
      "            child: Text(loc.add),",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "",
      "  void _editOption(int groupIdx, int optIdx) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[YourWidget] loc is null! Localization not available for this context.');",
      "      // ScaffoldMessenger.of(context).showSnackBar(",
      "      //   SnackBar(content: Text('Localization missing! [debug]'))",
      "      // );",
      "      return;",
      "    }",
      "    var opt = _groups[groupIdx].options[optIdx];",
      "    String optName = opt.name;",
      "    double optPrice = opt.price;",
      "    Map<String, double>? upcharges =",
      "        opt.upcharges != null ? Map.from(opt.upcharges!) : null;",
      "    bool isDefault = opt.isDefault;",
      "    bool outOfStock = opt.outOfStock;",
      "    bool allowExtra = opt.allowExtra;",
      "    bool allowSide = opt.allowSide;",
      "    int quantity = opt.quantity;",
      "    Portion portion = opt.portion;",
      "    String? tag = opt.tag;",
      "    showDialog(",
      "      context: context,",
      "      builder: (ctx) => AlertDialog(",
      "        title: Text(loc.editCustomization),",
      "        content: StatefulBuilder(",
      "          builder: (context, setStateDialog) {",
      "            return SingleChildScrollView(",
      "              child: Column(",
      "                mainAxisSize: MainAxisSize.min,",
      "                children: [",
      "                  TextFormField(",
      "                    initialValue: optName,",
      "                    decoration:",
      "                        InputDecoration(labelText: loc.customizationName),",
      "                    onChanged: (v) => optName = v,",
      "                    autofocus: true,",
      "                  ),",
      "                  TextFormField(",
      "                    initialValue: optPrice.toString(),",
      "                    decoration:",
      "                        InputDecoration(labelText: loc.customizationPrice),",
      "                    keyboardType: TextInputType.number,",
      "                    onChanged: (v) => optPrice = double.tryParse(v) ?? 0.0,",
      "                  ),",
      "                  TextFormField(",
      "                    initialValue: (upcharges?.entries ?? [])",
      "                        .map((e) => '${e.key}:${e.value}')",
      "                        .join(','),",
      "                    decoration: InputDecoration(labelText: loc.upchargePerSize),",
      "                    keyboardType: TextInputType.text,",
      "                    onChanged: (v) {",
      "                      upcharges = {};",
      "                      for (final entry in v.split(',')) {",
      "                        final parts = entry.split(':');",
      "                        if (parts.length == 2) {",
      "                          final key = parts[0].trim();",
      "                          final val = double.tryParse(parts[1].trim());",
      "                          if (key.isNotEmpty && val != null)",
      "                            upcharges![key] = val;",
      "                        }",
      "                      }",
      "                    },",
      "                  ),",
      "                  TextFormField(",
      "                    initialValue: tag ?? '',",
      "                    decoration: InputDecoration(labelText: loc.tag),",
      "                    onChanged: (v) => tag = v,",
      "                  ),",
      "                  Row(",
      "                    children: [",
      "                      Expanded(",
      "                        child: DropdownButtonFormField<Portion>(",
      "                          value: portion,",
      "                          decoration: InputDecoration(labelText: loc.portion),",
      "                          items: Portion.values",
      "                              .map((p) => DropdownMenuItem(",
      "                                    value: p,",
      "                                    child: Text(p.toString().split('.').last),",
      "                                  ))",
      "                              .toList(),",
      "                          onChanged: (v) => setStateDialog(",
      "                              () => portion = v ?? Portion.whole),",
      "                        ),",
      "                      ),",
      "                      Expanded(",
      "                        child: TextFormField(",
      "                          initialValue: quantity.toString(),",
      "                          decoration: InputDecoration(labelText: loc.quantity),",
      "                          keyboardType: TextInputType.number,",
      "                          onChanged: (v) => quantity = int.tryParse(v) ?? 1,",
      "                        ),",
      "                      ),",
      "                    ],",
      "                  ),",
      "                  SwitchListTile(",
      "                    title: Text(loc.setAsDefault),",
      "                    value: isDefault,",
      "                    onChanged: (v) => setStateDialog(() => isDefault = v),",
      "                  ),",
      "                  SwitchListTile(",
      "                    title: Text(loc.outOfStock),",
      "                    value: outOfStock,",
      "                    onChanged: (v) => setStateDialog(() => outOfStock = v),",
      "                  ),",
      "                  SwitchListTile(",
      "                    title: Text(loc.allowExtra),",
      "                    value: allowExtra,",
      "                    onChanged: (v) => setStateDialog(() => allowExtra = v),",
      "                  ),",
      "                  SwitchListTile(",
      "                    title: Text(loc.allowSide),",
      "                    value: allowSide,",
      "                    onChanged: (v) => setStateDialog(() => allowSide = v),",
      "                  ),",
      "                ],",
      "              ),",
      "            );",
      "          },",
      "        ),",
      "        actions: [",
      "          TextButton(",
      "            onPressed: () => Navigator.pop(ctx),",
      "            child: Text(loc.cancel),",
      "          ),",
      "          ElevatedButton(",
      "            onPressed: () {",
      "              if (optName.trim().isNotEmpty) {",
      "                setState(() {",
      "                  _groups[groupIdx].options[optIdx] = CustomizationOption(",
      "                    name: optName,",
      "                    price: optPrice,",
      "                    upcharges: upcharges,",
      "                    isDefault: isDefault,",
      "                    outOfStock: outOfStock,",
      "                    allowExtra: allowExtra,",
      "                    allowSide: allowSide,",
      "                    quantity: quantity,",
      "                    portion: portion,",
      "                    tag: tag,",
      "                  );",
      "                });",
      "                Navigator.pop(ctx);",
      "              }",
      "            },",
      "            child: Text(loc.save),",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "",
      "  void _removeOption(int groupIdx, int optIdx) {",
      "    setState(() {",
      "      _groups[groupIdx].options.removeAt(optIdx);",
      "    });",
      "  }",
      "",
      "  void _removeGroup(int idx) {",
      "    setState(() {",
      "      _groups.removeAt(idx);",
      "    });",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    return Dialog(",
      "      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),",
      "      child: SizedBox(",
      "        width: 500,",
      "        child: Padding(",
      "          padding: const EdgeInsets.all(24.0),",
      "          child: Column(",
      "            mainAxisSize: MainAxisSize.min,",
      "            children: [",
      "              Row(",
      "                children: [",
      "                  Expanded(",
      "                    child: Text(",
      "                      loc.customizations,",
      "                      style: const TextStyle(",
      "                        fontWeight: FontWeight.bold,",
      "                        fontSize: 18,",
      "                      ),",
      "                    ),",
      "                  ),",
      "                  IconButton(",
      "                    icon: const Icon(Icons.add),",
      "                    tooltip: loc.addCustomization,",
      "                    onPressed: _addGroup,",
      "                  )",
      "                ],",
      "              ),",
      "              const SizedBox(height: 10),",
      "              _groups.isEmpty",
      "                  ? Center(",
      "                      child: Text(",
      "                        loc.noCustomizations,",
      "                        style: const TextStyle(fontStyle: FontStyle.italic),",
      "                      ),",
      "                    )",
      "                  : ListView.builder(",
      "                      shrinkWrap: true,",
      "                      itemCount: _groups.length,",
      "                      itemBuilder: (context, groupIdx) {",
      "                        final g = _groups[groupIdx];",
      "                        return Card(",
      "                          margin: const EdgeInsets.symmetric(vertical: 8),",
      "                          child: ExpansionTile(",
      "                            title: Text('${g.groupName} (${g.type})'),",
      "                            subtitle: Text(",
      "                              '${loc.minSelect}: ${g.minSelect}, ${loc.maxSelect}: ${g.maxSelect}'",
      "                              '${g.maxFree != null ? ', ${loc.firstNFree}: ${g.maxFree}' : ''}'",
      "                              '${g.groupUpcharge != null ? ', ${loc.groupUpcharge}: \\$${g.groupUpcharge!.toStringAsFixed(2)}' : ''}',",
      "                            ),",
      "                            trailing: IconButton(",
      "                              icon: const Icon(Icons.delete, color: Colors.red),",
      "                              tooltip: loc.delete,",
      "                              onPressed: () => _removeGroup(groupIdx),",
      "                            ),",
      "                            children: [",
      "                              if (g.groupTag != null && g.groupTag!.isNotEmpty)",
      "                                Padding(",
      "                                  padding: const EdgeInsets.only(",
      "                                      left: 16, bottom: 8),",
      "                                  child: Row(",
      "                                    children: [",
      "                                      Text('${loc.tag}: ',",
      "                                          style: const TextStyle(",
      "                                              fontWeight: FontWeight.w600)),",
      "                                      Text(g.groupTag!),",
      "                                    ],",
      "                                  ),",
      "                                ),",
      "                              Row(",
      "                                children: [",
      "                                  if (g.allowExtra)",
      "                                    Chip(label: Text(loc.allowExtra)),",
      "                                  if (g.allowSide)",
      "                                    Chip(label: Text(loc.allowSide)),",
      "                                  if (g.required)",
      "                                    Chip(label: Text(loc.requiredField)),",
      "                                ],",
      "                              ),",
      "                              ListView.builder(",
      "                                shrinkWrap: true,",
      "                                physics: const NeverScrollableScrollPhysics(),",
      "                                itemCount: g.options.length,",
      "                                itemBuilder: (ctx, optIdx) {",
      "                                  final opt = g.options[optIdx];",
      "                                  return ListTile(",
      "                                    title: Text(",
      "                                        '${opt.name} (\\$${opt.price.toStringAsFixed(2)})'",
      "                                        '${opt.upcharges != null && opt.upcharges!.isNotEmpty ? ' [${loc.upchargePerSize}: ${opt.upcharges!.entries.map((e) => '${e.key}: \\$${e.value.toStringAsFixed(2)}').join(', ')}]' : ''}'),",
      "                                    subtitle: Text(",
      "                                        '${opt.tag != null && opt.tag!.isNotEmpty ? '${loc.tag}: ${opt.tag!} • ' : ''}'",
      "                                        '${loc.portion}: ${opt.portion.name}, '",
      "                                        '${loc.quantity}: ${opt.quantity}'",
      "                                        '${opt.outOfStock ? ' • ${loc.outOfStock}' : ''}'",
      "                                        '${opt.isDefault ? ' • ${loc.setAsDefault}' : ''}'),",
      "                                    trailing: Row(",
      "                                      mainAxisSize: MainAxisSize.min,",
      "                                      children: [",
      "                                        IconButton(",
      "                                          icon: const Icon(Icons.edit),",
      "                                          tooltip: loc.edit,",
      "                                          onPressed: () =>",
      "                                              _editOption(groupIdx, optIdx),",
      "                                        ),",
      "                                        IconButton(",
      "                                          icon: const Icon(Icons.delete,",
      "                                              color: Colors.red),",
      "                                          tooltip: loc.delete,",
      "                                          onPressed: () =>",
      "                                              _removeOption(groupIdx, optIdx),",
      "                                        ),",
      "                                      ],",
      "                                    ),",
      "                                  );",
      "                                },",
      "                              ),",
      "                              TextButton.icon(",
      "                                onPressed: () => _addOption(groupIdx),",
      "                                icon: const Icon(Icons.add),",
      "                                label: Text(loc.addOption),",
      "                              ),",
      "                            ],",
      "                          ),",
      "                        );",
      "                      },",
      "                    ),",
      "              const SizedBox(height: 16),",
      "              Row(",
      "                children: [",
      "                  ElevatedButton(",
      "                    onPressed: () {",
      "                      widget.onSave?.call(_groups);",
      "                      Navigator.pop(context, _groups);",
      "                    },",
      "                    child: Text(loc.save),",
      "                  ),",
      "                  const SizedBox(width: 12),",
      "                  TextButton(",
      "                    onPressed: () => Navigator.pop(context),",
      "                    child: Text(loc.cancel),",
      "                  ),",
      "                ],",
      "              ),",
      "            ],",
      "          ),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 665,
      "file_size": 27173,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\menu\\menu_item_editor_panel.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/admin/menu/dynamic_menu_item_editor_screen.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/config/branding_config.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:provider/provider.dart';",
      "",
      "class MenuItemEditorPanel extends StatefulWidget {",
      "  final bool isOpen;",
      "  final String? initialCategoryId;",
      "  final VoidCallback onClose;",
      "  final VoidCallback? onCategoryCleared;",
      "  final ValueChanged<String>? onCategorySelected; // <-- Add this",
      "",
      "  const MenuItemEditorPanel({",
      "    Key? key,",
      "    required this.isOpen,",
      "    this.initialCategoryId,",
      "    required this.onClose,",
      "    this.onCategoryCleared,",
      "    this.onCategorySelected, // <-- Add this",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  State<MenuItemEditorPanel> createState() => _MenuItemEditorPanelState();",
      "}",
      "",
      "class _MenuItemEditorPanelState extends State<MenuItemEditorPanel> {",
      "  String? _categoryId;",
      "",
      "  @override",
      "  void didUpdateWidget(MenuItemEditorPanel oldWidget) {",
      "    super.didUpdateWidget(oldWidget);",
      "    if (widget.initialCategoryId != oldWidget.initialCategoryId) {",
      "      setState(() {",
      "        _categoryId = widget.initialCategoryId;",
      "      });",
      "    }",
      "    if (!widget.isOpen) {",
      "      setState(() {",
      "        _categoryId = null;",
      "      });",
      "    }",
      "  }",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _categoryId = widget.initialCategoryId;",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    final theme = Theme.of(context);",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    return Container(",
      "      color: theme.colorScheme.surface,",
      "      child: LayoutBuilder(",
      "        builder: (context, constraints) {",
      "          return Column(",
      "            crossAxisAlignment: CrossAxisAlignment.start,",
      "            children: [",
      "              // Panel header with back button and close button",
      "              Container(",
      "                color: Colors.transparent,",
      "                padding:",
      "                    const EdgeInsets.symmetric(horizontal: 24, vertical: 18),",
      "                child: Row(",
      "                  children: [",
      "                    if (_categoryId != null)",
      "                      IconButton(",
      "                        icon:",
      "                            const Icon(Icons.arrow_back, color: Colors.black87),",
      "                        tooltip: 'Back',",
      "                        onPressed: () {",
      "                          setState(() {",
      "                            _categoryId = null; // Back to category picker",
      "                          });",
      "                          if (widget.onCategoryCleared != null) {",
      "                            widget.onCategoryCleared!();",
      "                          }",
      "                        },",
      "                      )",
      "                    else",
      "                      const SizedBox(width: 48), // maintain alignment",
      "",
      "                    Text(",
      "                      loc.addItem,",
      "                      style: TextStyle(",
      "                        color: Theme.of(context).brightness == Brightness.dark",
      "                            ? Colors.white",
      "                            : colorScheme.onSurface,",
      "                        fontWeight: FontWeight.bold,",
      "                        fontSize: 22,",
      "                      ),",
      "                    ),",
      "",
      "                    const Spacer(),",
      "                    IconButton(",
      "                      icon: const Icon(Icons.close, color: Colors.black87),",
      "                      tooltip: 'Close',",
      "                      onPressed: widget.onClose,",
      "                    ),",
      "                  ],",
      "                ),",
      "              ),",
      "",
      "              // Content area",
      "              Expanded(",
      "                child: SingleChildScrollView(",
      "                  padding:",
      "                      const EdgeInsets.symmetric(horizontal: 24, vertical: 18),",
      "                  child: ConstrainedBox(",
      "                    constraints: const BoxConstraints(maxWidth: 600),",
      "                    child: DynamicMenuItemEditorScreen(",
      "                      key: ValueKey(_categoryId),",
      "                      franchiseId:",
      "                          Provider.of<FranchiseProvider>(context, listen: false)",
      "                              .franchiseId,",
      "                      initialCategoryId: _categoryId,",
      "                      onCategorySelected: (selectedCategory) {",
      "                        setState(() {",
      "                          _categoryId = selectedCategory;",
      "                        });",
      "                        widget.onCategorySelected?.call(selectedCategory);",
      "                      },",
      "                      onCancel: () {",
      "                        if (_categoryId != null) {",
      "                          setState(() {",
      "                            _categoryId = null;",
      "                          });",
      "                          widget.onCategoryCleared?.call();",
      "                        } else {",
      "                          widget.onClose();",
      "                        }",
      "                      },",
      "                    ),",
      "                  ),",
      "                ),",
      "              ),",
      "            ],",
      "          );",
      "        },",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 155,
      "file_size": 5502,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\menu\\menu_item_form_dialog.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/core/models/menu_item.dart';",
      "import 'package:franchise_admin_portal/core/models/category.dart';",
      "import 'package:franchise_admin_portal/core/models/customization.dart';",
      "import 'package:franchise_admin_portal/core/models/nutrition_info.dart';",
      "import 'package:franchise_admin_portal/admin/menu/menu_item_customizations_dialog.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/admin/menu/customization_types.dart';",
      "",
      "class MenuItemFormDialog extends StatefulWidget {",
      "  final MenuItem? initialItem;",
      "  final List<Category> categories;",
      "  final void Function(MenuItem menuItem) onSave;",
      "",
      "  const MenuItemFormDialog({",
      "    super.key,",
      "    this.initialItem,",
      "    required this.categories,",
      "    required this.onSave,",
      "  });",
      "",
      "  @override",
      "  State<MenuItemFormDialog> createState() => _MenuItemFormDialogState();",
      "}",
      "",
      "class _MenuItemFormDialogState extends State<MenuItemFormDialog> {",
      "  final _formKey = GlobalKey<FormState>();",
      "  late String _name;",
      "  late String _category;",
      "  late double _price;",
      "  late String _description;",
      "  String? _image;",
      "  bool _availability = true;",
      "  String _taxCategory = '';",
      "  String _sku = '';",
      "  List<String> _dietaryTags = [];",
      "  List<String> _allergens = [];",
      "  int? _prepTime;",
      "  int _calories = 0;",
      "  double _fat = 0.0, _carbs = 0.0, _protein = 0.0;",
      "  List<Customization> _customizations = [];",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    final i = widget.initialItem;",
      "    _name = i?.name ?? '';",
      "    _category = i?.category ??",
      "        (widget.categories.isNotEmpty ? widget.categories.first.name : '');",
      "    _price = i?.price ?? 0.0;",
      "    _description = i?.description ?? '';",
      "    _image = i?.image ?? '';",
      "    _availability = i?.availability ?? true;",
      "    _taxCategory = i?.taxCategory ?? '';",
      "    _sku = i?.sku ?? '';",
      "    _dietaryTags = List<String>.from(i?.dietaryTags ?? []);",
      "    _allergens = List<String>.from(i?.allergens ?? []);",
      "    _prepTime = i?.prepTime;",
      "    _calories = i?.nutrition?.calories ?? 0;",
      "    _fat = i?.nutrition?.fat ?? 0.0;",
      "    _carbs = i?.nutrition?.carbs ?? 0.0;",
      "    _protein = i?.nutrition?.protein ?? 0.0;",
      "    _customizations = List<Customization>.from(i?.customizations ?? []);",
      "  }",
      "",
      "  Widget _buildChipInput({",
      "    required String label,",
      "    required List<String> values,",
      "    required ValueChanged<List<String>> onChanged,",
      "  }) {",
      "    final controller = TextEditingController();",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        Text(label, style: const TextStyle(fontWeight: FontWeight.bold)),",
      "        Wrap(",
      "          spacing: 6.0,",
      "          children: values",
      "              .map((tag) => Chip(",
      "                    label: Text(tag),",
      "                    onDeleted: () {",
      "                      final updated = List<String>.from(values)..remove(tag);",
      "                      onChanged(updated);",
      "                    },",
      "                  ))",
      "              .toList(),",
      "        ),",
      "        Row(",
      "          children: [",
      "            Expanded(",
      "              child: TextField(",
      "                controller: controller,",
      "                decoration: InputDecoration(",
      "                  hintText: AppLocalizations.of(context)?.addChipHint(label) ??",
      "                      'Add $label',",
      "                ),",
      "              ),",
      "            ),",
      "            IconButton(",
      "              icon: const Icon(Icons.add),",
      "              onPressed: () {",
      "                final text = controller.text.trim();",
      "                if (text.isNotEmpty && !values.contains(text)) {",
      "                  onChanged(List<String>.from(values)..add(text));",
      "                  controller.clear();",
      "                  setState(() {});",
      "                }",
      "              },",
      "            )",
      "          ],",
      "        )",
      "      ],",
      "    );",
      "  }",
      "",
      "  // ======= REVISED CONVERSION HELPERS =======",
      "  // Use new structure for customizations.",
      "  CustomizationGroup customizationToGroup(Customization c) =>",
      "      customizationToGroupFull(c);",
      "",
      "  Customization groupToCustomization(CustomizationGroup g) =>",
      "      groupToCustomizationFull(g);",
      "",
      "  CustomizationGroup customizationToGroupFull(Customization c) {",
      "    return CustomizationGroup(",
      "      groupName: c.name,",
      "      type: (c.maxChoices ?? 1) > 1 ? 'multi' : 'single',",
      "      minSelect: c.minChoices ?? 1,",
      "      maxSelect: c.maxChoices ?? 1,",
      "      maxFree: c.maxFree,",
      "      allowExtra: c.allowExtra,",
      "      allowSide: c.allowSide,",
      "      required: c.required,",
      "      groupUpcharge: c.price > 0.0 ? c.price : null,",
      "      groupTag: c.group,",
      "      options: (c.options ?? [])",
      "          .map((o) => CustomizationOption(",
      "                name: o.name,",
      "                price: o.price,",
      "                upcharges: o.upcharges,",
      "                isDefault: o.isDefault,",
      "                outOfStock: o.outOfStock,",
      "                allowExtra: o.allowExtra,",
      "                allowSide: o.allowSide,",
      "                quantity: o.quantity,",
      "                portion: o.portion,",
      "                tag: o.group,",
      "                // Removed: supportsExtra, sidesAllowed -- not standard",
      "              ))",
      "          .toList(),",
      "    );",
      "  }",
      "",
      "  Customization groupToCustomizationFull(CustomizationGroup g) {",
      "    return Customization(",
      "      name: g.groupName,",
      "      isGroup: true,",
      "      price: g.groupUpcharge ?? 0.0,",
      "      required: g.required,",
      "      minChoices: g.minSelect,",
      "      maxChoices: g.maxSelect,",
      "      maxFree: g.maxFree,",
      "      group: g.groupTag,",
      "      allowExtra: g.allowExtra,",
      "      allowSide: g.allowSide,",
      "      options: g.options",
      "          .map((o) => Customization(",
      "                name: o.name,",
      "                isGroup: false,",
      "                price: o.price,",
      "                upcharges: o.upcharges,",
      "                isDefault: o.isDefault,",
      "                outOfStock: o.outOfStock,",
      "                allowExtra: o.allowExtra,",
      "                allowSide: o.allowSide,",
      "                quantity: o.quantity,",
      "                portion: o.portion,",
      "                group: o.tag,",
      "                // Removed: supportsExtra, sidesAllowed -- not standard",
      "              ))",
      "          .toList(),",
      "    );",
      "  }",
      "",
      "  void _openCustomizationDialog() async {",
      "    final groups = _customizations.map(customizationToGroup).toList();",
      "    final result = await showDialog<List<CustomizationGroup>>(",
      "      context: context,",
      "      builder: (ctx) => MenuItemCustomizationsDialog(",
      "        initialGroups: groups,",
      "      ),",
      "    );",
      "    if (result != null) {",
      "      setState(",
      "          () => _customizations = result.map(groupToCustomization).toList());",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final localizations = AppLocalizations.of(context)!;",
      "    return Dialog(",
      "      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),",
      "      child: SizedBox(",
      "        width: 500,",
      "        child: SingleChildScrollView(",
      "          padding: const EdgeInsets.all(24),",
      "          child: Form(",
      "            key: _formKey,",
      "            child: Column(",
      "              mainAxisSize: MainAxisSize.min,",
      "              children: [",
      "                Text(",
      "                  widget.initialItem == null",
      "                      ? localizations.addItem",
      "                      : localizations.edit,",
      "                  style: const TextStyle(",
      "                      fontWeight: FontWeight.bold, fontSize: 20),",
      "                ),",
      "                const SizedBox(height: 16),",
      "                DropdownButtonFormField<String>(",
      "                  value: _category.isNotEmpty",
      "                      ? _category",
      "                      : (widget.categories.isNotEmpty",
      "                          ? widget.categories.first.name",
      "                          : null),",
      "                  decoration:",
      "                      InputDecoration(labelText: localizations.colCategory),",
      "                  items: widget.categories",
      "                      .map((c) => DropdownMenuItem(",
      "                            value: c.name,",
      "                            child: Text(c.name),",
      "                          ))",
      "                      .toList(),",
      "                  onChanged: (v) => setState(() => _category = v ?? ''),",
      "                  validator: (v) => (v == null || v.isEmpty)",
      "                      ? localizations.requiredField",
      "                      : null,",
      "                ),",
      "                TextFormField(",
      "                  initialValue: _name,",
      "                  decoration: InputDecoration(labelText: localizations.colName),",
      "                  validator: (v) => (v == null || v.trim().isEmpty)",
      "                      ? localizations.nameRequired",
      "                      : null,",
      "                  onChanged: (v) => setState(() => _name = v),",
      "                ),",
      "                TextFormField(",
      "                  initialValue: _description,",
      "                  decoration:",
      "                      InputDecoration(labelText: localizations.description),",
      "                  validator: (v) => (v == null || v.trim().isEmpty)",
      "                      ? localizations.requiredField",
      "                      : null,",
      "                  onChanged: (v) => setState(() => _description = v),",
      "                ),",
      "                TextFormField(",
      "                  initialValue: _image ?? '',",
      "                  decoration:",
      "                      InputDecoration(labelText: localizations.colImage),",
      "                  onChanged: (v) => setState(() => _image = v),",
      "                ),",
      "                TextFormField(",
      "                  initialValue: _price.toString(),",
      "                  decoration:",
      "                      InputDecoration(labelText: localizations.colPrice),",
      "                  keyboardType: TextInputType.number,",
      "                  validator: (v) {",
      "                    final value = double.tryParse(v ?? '');",
      "                    if (value == null || value < 0) {",
      "                      return localizations.requiredField;",
      "                    }",
      "                    return null;",
      "                  },",
      "                  onChanged: (v) =>",
      "                      setState(() => _price = double.tryParse(v) ?? 0.0),",
      "                ),",
      "                TextFormField(",
      "                  initialValue: _taxCategory,",
      "                  decoration: InputDecoration(labelText: localizations.tax),",
      "                  onChanged: (v) => setState(() => _taxCategory = v),",
      "                ),",
      "                TextFormField(",
      "                  initialValue: _sku,",
      "                  decoration: InputDecoration(labelText: localizations.colSKU),",
      "                  onChanged: (v) => setState(() => _sku = v),",
      "                ),",
      "                SwitchListTile(",
      "                  title: Text(localizations.colAvailable),",
      "                  value: _availability,",
      "                  onChanged: (v) => setState(() => _availability = v),",
      "                ),",
      "                TextFormField(",
      "                  initialValue: _prepTime?.toString() ?? '',",
      "                  decoration: InputDecoration(labelText: localizations.time),",
      "                  keyboardType: TextInputType.number,",
      "                  onChanged: (v) => setState(() => _prepTime = int.tryParse(v)),",
      "                ),",
      "                const SizedBox(height: 8),",
      "                Text(localizations.nutrition,",
      "                    style: const TextStyle(fontWeight: FontWeight.bold)),",
      "                Row(",
      "                  children: [",
      "                    Expanded(",
      "                      child: TextFormField(",
      "                        initialValue: _calories.toString(),",
      "                        decoration: InputDecoration(",
      "                            labelText: localizations.caloriesLabel),",
      "                        keyboardType: TextInputType.number,",
      "                        onChanged: (v) =>",
      "                            setState(() => _calories = int.tryParse(v) ?? 0),",
      "                      ),",
      "                    ),",
      "                    const SizedBox(width: 10),",
      "                    Expanded(",
      "                      child: TextFormField(",
      "                        initialValue: _fat.toString(),",
      "                        decoration:",
      "                            InputDecoration(labelText: localizations.fatLabel),",
      "                        keyboardType: TextInputType.number,",
      "                        onChanged: (v) =>",
      "                            setState(() => _fat = double.tryParse(v) ?? 0.0),",
      "                      ),",
      "                    ),",
      "                    const SizedBox(width: 10),",
      "                    Expanded(",
      "                      child: TextFormField(",
      "                        initialValue: _carbs.toString(),",
      "                        decoration: InputDecoration(",
      "                            labelText: localizations.carbsLabel),",
      "                        keyboardType: TextInputType.number,",
      "                        onChanged: (v) =>",
      "                            setState(() => _carbs = double.tryParse(v) ?? 0.0),",
      "                      ),",
      "                    ),",
      "                    const SizedBox(width: 10),",
      "                    Expanded(",
      "                      child: TextFormField(",
      "                        initialValue: _protein.toString(),",
      "                        decoration: InputDecoration(",
      "                            labelText: localizations.proteinLabel),",
      "                        keyboardType: TextInputType.number,",
      "                        onChanged: (v) => setState(",
      "                            () => _protein = double.tryParse(v) ?? 0.0),",
      "                      ),",
      "                    ),",
      "                  ],",
      "                ),",
      "                const SizedBox(height: 10),",
      "                _buildChipInput(",
      "                  label: localizations.colDietary,",
      "                  values: _dietaryTags,",
      "                  onChanged: (v) => setState(() => _dietaryTags = v),",
      "                ),",
      "                const SizedBox(height: 8),",
      "                _buildChipInput(",
      "                  label: localizations.colAllergens,",
      "                  values: _allergens,",
      "                  onChanged: (v) => setState(() => _allergens = v),",
      "                ),",
      "                const SizedBox(height: 8),",
      "                Row(",
      "                  mainAxisAlignment: MainAxisAlignment.spaceBetween,",
      "                  children: [",
      "                    Text(localizations.customizations,",
      "                        style: const TextStyle(fontWeight: FontWeight.bold)),",
      "                    IconButton(",
      "                      icon: const Icon(Icons.edit),",
      "                      tooltip: localizations.editCustomization,",
      "                      onPressed: _openCustomizationDialog,",
      "                    ),",
      "                  ],",
      "                ),",
      "                _customizations.isEmpty",
      "                    ? Padding(",
      "                        padding: const EdgeInsets.all(8.0),",
      "                        child: Text(",
      "                          localizations.noCustomizations,",
      "                          style: const TextStyle(fontStyle: FontStyle.italic),",
      "                        ),",
      "                      )",
      "                    : ListView.builder(",
      "                        shrinkWrap: true,",
      "                        physics: const NeverScrollableScrollPhysics(),",
      "                        itemCount: _customizations.length,",
      "                        itemBuilder: (context, idx) {",
      "                          final c = _customizations[idx];",
      "                          return ListTile(",
      "                            title: Text(",
      "                              '${c.name} ${(c.options != null && c.options!.isNotEmpty) ? '(${c.options!.length} options)' : ''}',",
      "                            ),",
      "                            subtitle: c.options != null && c.options!.isNotEmpty",
      "                                ? Text(c.options!.map((o) => o.name).join(', '))",
      "                                : null,",
      "                            trailing: IconButton(",
      "                              icon: const Icon(Icons.delete),",
      "                              onPressed: () {",
      "                                setState(() => _customizations.removeAt(idx));",
      "                              },",
      "                            ),",
      "                          );",
      "                        },",
      "                      ),",
      "                const SizedBox(height: 16),",
      "                Row(",
      "                  children: [",
      "                    ElevatedButton(",
      "                      onPressed: () {",
      "                        if (!_formKey.currentState!.validate()) return;",
      "                        final nutrition = NutritionInfo(",
      "                          calories: _calories,",
      "                          fat: _fat,",
      "                          carbs: _carbs,",
      "                          protein: _protein,",
      "                        );",
      "                        final selectedCategory = widget.categories.firstWhere(",
      "                          (c) => c.name == _category,",
      "                          orElse: () => widget.categories.first,",
      "                        );",
      "                        final menuItem = MenuItem(",
      "                          id: widget.initialItem?.id ?? '',",
      "                          available: _availability,",
      "                          category: _category,",
      "                          categoryId: selectedCategory.id,",
      "                          name: _name.trim(),",
      "                          price: _price,",
      "                          description: _description.trim(),",
      "                          customizationGroups: [],",
      "                          image: _image?.trim().isEmpty ?? true",
      "                              ? null",
      "                              : _image?.trim(),",
      "                          customizations: _customizations,",
      "                          taxCategory: _taxCategory,",
      "                          availability: _availability,",
      "                          sku: _sku.trim().isEmpty ? null : _sku.trim(),",
      "                          dietaryTags: _dietaryTags,",
      "                          allergens: _allergens,",
      "                          prepTime: _prepTime,",
      "                          nutrition: nutrition,",
      "                        );",
      "",
      "                        widget.onSave(menuItem);",
      "                        Navigator.pop(context);",
      "                      },",
      "                      child: Text(localizations.save),",
      "                    ),",
      "                    const SizedBox(width: 16),",
      "                    TextButton(",
      "                      onPressed: () => Navigator.pop(context),",
      "                      child: Text(localizations.cancel),",
      "                    ),",
      "                  ],",
      "                )",
      "              ],",
      "            ),",
      "          ),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 461,
      "file_size": 18594,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\orders\\analytics_screen.dart",
    "content": [
      "import 'package:franchise_admin_portal/core/providers/user_profile_notifier.dart';",
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/services/analytics_service.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/models/analytics_summary.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/widgets/loading_shimmer_widget.dart';",
      "import '../../widgets/orders/export_analytics_dialog.dart';",
      "import 'package:flutter/services.dart';",
      "import 'package:path_provider/path_provider.dart';",
      "import 'package:share_plus/share_plus.dart';",
      "import 'dart:io';",
      "import 'package:franchise_admin_portal/core/utils/export_utils.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "import 'package:franchise_admin_portal/widgets/orders/feedback_card.dart';",
      "",
      "class AnalyticsScreen extends StatefulWidget {",
      "  const AnalyticsScreen({super.key});",
      "",
      "  @override",
      "  State<AnalyticsScreen> createState() => _AnalyticsScreenState();",
      "}",
      "",
      "class _AnalyticsScreenState extends State<AnalyticsScreen> {",
      "  String? _selectedPeriod;",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    final userProvider = context.watch<AdminUserProvider>();",
      "    final franchiseId = context.watch<FranchiseProvider>().franchiseId;",
      "",
      "    return Scaffold(",
      "      backgroundColor: colorScheme.background,",
      "      body: Row(",
      "        crossAxisAlignment: CrossAxisAlignment.start,",
      "        children: [",
      "          Expanded(",
      "            flex: 11,",
      "            child: Padding(",
      "              padding:",
      "                  const EdgeInsets.symmetric(horizontal: 24.0, vertical: 24.0),",
      "              child: Column(",
      "                crossAxisAlignment: CrossAxisAlignment.start,",
      "                children: [",
      "                  Row(",
      "                    crossAxisAlignment: CrossAxisAlignment.center,",
      "                    children: [",
      "                      Text(",
      "                        \"Analytics Dashboard\",",
      "                        style: TextStyle(",
      "                          color: colorScheme.onBackground,",
      "                          fontWeight: FontWeight.bold,",
      "                          fontSize: 22,",
      "                        ),",
      "                      ),",
      "                      const Spacer(),",
      "                      IconButton(",
      "                        icon: Icon(Icons.download_rounded,",
      "                            color: colorScheme.onSurface),",
      "                        tooltip: \"Export Current Summary (CSV)\",",
      "                        onPressed: () async {",
      "                          if (_selectedPeriod == null) return;",
      "                          final summaries = await context",
      "                              .read<AnalyticsService>()",
      "                              .getAnalyticsSummaries(franchiseId);",
      "                          final current = summaries.firstWhere(",
      "                            (s) => s.period == _selectedPeriod,",
      "                            orElse: () => summaries.first,",
      "                          );",
      "                          if (current != null) {",
      "                            showDialog(",
      "                              context: context,",
      "                              builder: (_) =>",
      "                                  ExportAnalyticsDialogSingleSummary(",
      "                                      summary: current),",
      "                            );",
      "                          }",
      "                        },",
      "                      )",
      "                    ],",
      "                  ),",
      "                  const SizedBox(height: 16),",
      "                  Expanded(",
      "                    child: StreamBuilder<List<AnalyticsSummary>>(",
      "                      stream: context",
      "                          .read<AnalyticsService>()",
      "                          .getSummaryMetrics(franchiseId),",
      "                      builder: (context, snapshot) {",
      "                        if (snapshot.connectionState ==",
      "                            ConnectionState.waiting) {",
      "                          return const LoadingShimmerWidget();",
      "                        }",
      "                        if (snapshot.hasError) {",
      "                          return Center(",
      "                            child: Text(",
      "                              'Error loading analytics data.',",
      "                              style: TextStyle(color: colorScheme.error),",
      "                            ),",
      "                          );",
      "                        }",
      "                        final summaries = snapshot.data ?? [];",
      "                        if (summaries.isEmpty) {",
      "                          return Center(",
      "                            child: Text(",
      "                              'No analytics data available.',",
      "                              style: TextStyle(color: colorScheme.outline),",
      "                            ),",
      "                          );",
      "                        }",
      "",
      "                        final sorted = List<AnalyticsSummary>.from(summaries)",
      "                          ..sort((a, b) => b.period.compareTo(a.period));",
      "                        final periods =",
      "                            sorted.map((s) => s.period).toSet().toList();",
      "                        final selected = _selectedPeriod ?? periods.first;",
      "                        final summary = sorted.firstWhere(",
      "                            (s) => s.period == selected,",
      "                            orElse: () => sorted.first);",
      "",
      "                        return ListView(",
      "                          children: [",
      "                            Row(",
      "                              children: [",
      "                                Text(\"Period:\",",
      "                                    style: TextStyle(",
      "                                      fontWeight: FontWeight.bold,",
      "                                      fontSize: 16,",
      "                                      color: colorScheme.onBackground,",
      "                                    )),",
      "                                const SizedBox(width: 16),",
      "                                DropdownButton<String>(",
      "                                  value: selected,",
      "                                  items: periods",
      "                                      .map((p) => DropdownMenuItem(",
      "                                            value: p,",
      "                                            child: Text(p,",
      "                                                style: TextStyle(",
      "                                                    color:",
      "                                                        colorScheme.onSurface)),",
      "                                          ))",
      "                                      .toList(),",
      "                                  onChanged: (val) =>",
      "                                      setState(() => _selectedPeriod = val),",
      "                                )",
      "                              ],",
      "                            ),",
      "                            const SizedBox(height: 24),",
      "                            Text(",
      "                              \"Order & Sales Analytics\",",
      "                              style: TextStyle(",
      "                                color: colorScheme.primary,",
      "                                fontWeight: FontWeight.w800,",
      "                                fontSize: 20,",
      "                              ),",
      "                            ),",
      "                            const SizedBox(height: 12),",
      "                            ..._buildMetrics(summary, context),",
      "                            const SizedBox(height: 24),",
      "                            Text(",
      "                              \"Customer Feedback\",",
      "                              style: TextStyle(",
      "                                color: colorScheme.primary,",
      "                                fontWeight: FontWeight.w800,",
      "                                fontSize: 20,",
      "                              ),",
      "                            ),",
      "                            const SizedBox(height: 12),",
      "                            FeedbackCard(summary: summary),",
      "                          ],",
      "                        );",
      "                      },",
      "                    ),",
      "                  )",
      "                ],",
      "              ),",
      "            ),",
      "          ),",
      "          const Expanded(flex: 9, child: SizedBox()),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "",
      "  List<Widget> _buildMetrics(AnalyticsSummary summary, BuildContext context) {",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    final metrics = <String, dynamic>{",
      "      \"Total Orders\": summary.totalOrders,",
      "      \"Total Revenue\": summary.totalRevenue != null",
      "          ? \"\\$${summary.totalRevenue!.toStringAsFixed(2)}\"",
      "          : null,",
      "      \"Average Order Value\": summary.averageOrderValue != null",
      "          ? \"\\$${summary.averageOrderValue!.toStringAsFixed(2)}\"",
      "          : null,",
      "      \"Most Popular Item\": summary.mostPopularItem,",
      "      \"Retention Rate\": summary.retentionRate != null",
      "          ? \"${(summary.retentionRate! * 100).toStringAsFixed(1)}%\"",
      "          : null,",
      "      \"Unique Customers\": summary.uniqueCustomers,",
      "      \"Cancelled Orders\": summary.cancelledOrders,",
      "      \"Last Updated\": summary.updatedAt?.toString(),",
      "    };",
      "",
      "    return metrics.entries.map((e) {",
      "      return Card(",
      "        color: colorScheme.surface,",
      "        child: ListTile(",
      "          title: Text(e.key, style: TextStyle(color: colorScheme.onSurface)),",
      "          trailing: Text(e.value?.toString() ?? '-',",
      "              style: TextStyle(color: colorScheme.onSurface)),",
      "        ),",
      "      );",
      "    }).toList();",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 218,
      "file_size": 9765,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\orders\\order_management_screen.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/models/order.dart' as order_model;",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/models/user.dart' as admin_user;",
      "import 'package:franchise_admin_portal/widgets/loading_shimmer_widget.dart';",
      "import 'package:franchise_admin_portal/widgets/empty_state_widget.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/services/audit_log_service.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/user_profile_notifier.dart';",
      "import 'package:franchise_admin_portal/core/providers/role_guard.dart';",
      "import 'package:franchise_admin_portal/widgets/subscription_access_guard.dart';",
      "import 'package:franchise_admin_portal/widgets/subscription/grace_period_banner.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "import 'package:franchise_admin_portal/widgets/orders/order_detail_dialog.dart';",
      "",
      "class OrderManagementScreen extends StatelessWidget {",
      "  const OrderManagementScreen({super.key});",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return const RoleGuard(",
      "      allowedRoles: [",
      "        'platform_owner',",
      "        'hq_owner',",
      "        'manager',",
      "        'developer',",
      "        'admin',",
      "      ],",
      "      featureName: 'OrderManagementScreen',",
      "      child: _OrderManagementScreenContent(),",
      "    );",
      "  }",
      "}",
      "",
      "class _OrderManagementScreenContent extends StatefulWidget {",
      "  const _OrderManagementScreenContent();",
      "",
      "  @override",
      "  State<_OrderManagementScreenContent> createState() =>",
      "      _OrderManagementScreenContentState();",
      "}",
      "",
      "class _OrderManagementScreenContentState",
      "    extends State<_OrderManagementScreenContent> {",
      "  String _searchText = '';",
      "  String? _filterStatus;",
      "  DateTimeRange? _dateRange;",
      "  bool _showRefunded = true;",
      "  List<order_model.Order> _lastOrders = [];",
      "",
      "  Future<void> _updateOrderStatus(String franchiseId, order_model.Order order,",
      "      String newStatus, admin_user.User user) async {",
      "    await context",
      "        .read<FirestoreService>()",
      "        .updateOrderStatus(franchiseId, order.id, newStatus);",
      "    await AuditLogService().addLog(",
      "      franchiseId: franchiseId,",
      "      userId: user.id,",
      "      action: 'update_order_status',",
      "      targetType: 'order',",
      "      targetId: order.id,",
      "      details: {'newStatus': newStatus},",
      "    );",
      "  }",
      "",
      "  Future<void> _processRefund(String franchiseId, order_model.Order order,",
      "      double amount, admin_user.User user) async {",
      "    await context",
      "        .read<FirestoreService>()",
      "        .refundOrder(franchiseId, order.id, amount: amount);",
      "    await AuditLogService().addLog(",
      "      franchiseId: franchiseId,",
      "      userId: user.id,",
      "      action: 'refund_order',",
      "      targetType: 'order',",
      "      targetId: order.id,",
      "      details: {'refundAmount': amount},",
      "    );",
      "  }",
      "",
      "  void _showRefundDialog(order_model.Order order, admin_user.User user) {",
      "    final franchiseId = context.read<FranchiseProvider>().franchiseId;",
      "    final controller =",
      "        TextEditingController(text: order.total.toStringAsFixed(2));",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    showDialog(",
      "      context: context,",
      "      builder: (_) => AlertDialog(",
      "        title: const Text(\"Process Refund\"),",
      "        content: TextField(",
      "          controller: controller,",
      "          keyboardType: const TextInputType.numberWithOptions(decimal: true),",
      "          decoration: const InputDecoration(labelText: \"Refund Amount\"),",
      "        ),",
      "        actions: [",
      "          TextButton(",
      "            onPressed: () => Navigator.of(context).pop(),",
      "            child: Text(\"Cancel\", style: TextStyle(color: colorScheme.outline)),",
      "          ),",
      "          ElevatedButton(",
      "            onPressed: () {",
      "              final amount = double.tryParse(controller.text) ?? 0.0;",
      "              if (amount > 0 && amount <= order.total) {",
      "                Navigator.of(context).pop();",
      "                _processRefund(franchiseId, order, amount, user);",
      "              }",
      "            },",
      "            style:",
      "                ElevatedButton.styleFrom(backgroundColor: colorScheme.primary),",
      "            child: const Text(\"Refund\"),",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "",
      "  void _showStatusDialog(order_model.Order order, admin_user.User user) {",
      "    final franchiseId = context.read<FranchiseProvider>().franchiseId;",
      "    const allowedStatuses = [",
      "      'Placed',",
      "      'Preparing',",
      "      'Ready',",
      "      'Out for Delivery',",
      "      'Delivered',",
      "      'Picked Up',",
      "      'Refunded'",
      "    ];",
      "    String selected = order.status;",
      "    showDialog(",
      "      context: context,",
      "      builder: (_) => StatefulBuilder(",
      "        builder: (context, setStateDialog) => AlertDialog(",
      "          title: const Text(\"Update Order Status\"),",
      "          content: DropdownButton<String>(",
      "            value: selected,",
      "            items: allowedStatuses",
      "                .map((s) => DropdownMenuItem(value: s, child: Text(s)))",
      "                .toList(),",
      "            onChanged: (val) =>",
      "                setStateDialog(() => selected = val ?? order.status),",
      "          ),",
      "          actions: [",
      "            TextButton(",
      "              onPressed: () => Navigator.of(context).pop(),",
      "              child: const Text(\"Cancel\"),",
      "            ),",
      "            ElevatedButton(",
      "              onPressed: () {",
      "                Navigator.of(context).pop();",
      "                if (selected != order.status) {",
      "                  _updateOrderStatus(franchiseId, order, selected, user);",
      "                }",
      "              },",
      "              child: const Text(\"Update\"),",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  List<order_model.Order> _filterOrders(List<order_model.Order> orders) {",
      "    return orders.where((o) {",
      "      if (!_showRefunded && o.status == 'Refunded') return false;",
      "      if (_filterStatus != null && o.status != _filterStatus) return false;",
      "      if (_searchText.isNotEmpty &&",
      "          !(o.userNameDisplay",
      "                  .toLowerCase()",
      "                  .contains(_searchText.toLowerCase()) ||",
      "              o.id.toLowerCase().contains(_searchText.toLowerCase()))) {",
      "        return false;",
      "      }",
      "      if (_dateRange != null) {",
      "        if (o.timestamp.isBefore(_dateRange!.start) ||",
      "            o.timestamp.isAfter(_dateRange!.end)) {",
      "          return false;",
      "        }",
      "      }",
      "      return true;",
      "    }).toList();",
      "  }",
      "",
      "  void _showExportDialog(String franchiseId, List<order_model.Order> orders,",
      "      admin_user.User user) async {",
      "    await AuditLogService().addLog(",
      "      franchiseId: franchiseId,",
      "      userId: user.id,",
      "      action: 'export_orders',",
      "      targetType: 'order',",
      "      targetId: '',",
      "      details: {'count': orders.length},",
      "    );",
      "    ScaffoldMessenger.of(context).showSnackBar(",
      "      const SnackBar(",
      "          content: Text('Exported orders (CSV download logic goes here).')),",
      "    );",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final franchiseId = context.watch<FranchiseProvider>().franchiseId;",
      "    final user = context.watch<AdminUserProvider>().user;",
      "    final loading = context.watch<AdminUserProvider>().loading;",
      "    final firestoreService = context.read<FirestoreService>();",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "",
      "    if (user == null) {",
      "      return Scaffold(",
      "        body: Center(",
      "          child: loading",
      "              ? const CircularProgressIndicator()",
      "              : const Text('Unauthorized — No admin user'),",
      "        ),",
      "      );",
      "    }",
      "",
      "    return RoleGuard(",
      "      allowedRoles: ['hq_owner', 'manager', 'developer'],",
      "      child: SubscriptionAccessGuard(",
      "        child: Scaffold(",
      "          backgroundColor: colorScheme.background,",
      "          body: Column(",
      "            children: [",
      "              const GracePeriodBanner(),",
      "              Expanded(",
      "                child: Padding(",
      "                  padding:",
      "                      const EdgeInsets.symmetric(horizontal: 24, vertical: 24),",
      "                  child: Column(",
      "                    crossAxisAlignment: CrossAxisAlignment.start,",
      "                    children: [",
      "                      Row(",
      "                        children: [",
      "                          Text(\"Order Management\",",
      "                              style: TextStyle(",
      "                                  fontSize: 22,",
      "                                  fontWeight: FontWeight.bold,",
      "                                  color: colorScheme.onBackground)),",
      "                          const Spacer(),",
      "                          IconButton(",
      "                            icon: Icon(Icons.download,",
      "                                color: colorScheme.primary),",
      "                            tooltip: \"Export Orders\",",
      "                            onPressed: () => _showExportDialog(",
      "                                franchiseId, _lastOrders, user),",
      "                          ),",
      "                        ],",
      "                      ),",
      "                      const SizedBox(height: 8),",
      "                      Row(",
      "                        children: [",
      "                          Expanded(",
      "                            child: TextField(",
      "                              decoration: InputDecoration(",
      "                                labelText: \"Search by Order ID or Name\",",
      "                                prefixIcon: const Icon(Icons.search),",
      "                                border: const OutlineInputBorder(),",
      "                              ),",
      "                              onChanged: (val) =>",
      "                                  setState(() => _searchText = val.trim()),",
      "                            ),",
      "                          ),",
      "                          const SizedBox(width: 12),",
      "                          DropdownButton<String>(",
      "                            value: _filterStatus,",
      "                            hint: const Text(\"Status\"),",
      "                            items: [",
      "                              null,",
      "                              'Placed',",
      "                              'Preparing',",
      "                              'Ready',",
      "                              'Out for Delivery',",
      "                              'Delivered',",
      "                              'Picked Up',",
      "                              'Refunded'",
      "                            ]",
      "                                .map((s) => DropdownMenuItem(",
      "                                    value: s, child: Text(s ?? \"All\")))",
      "                                .toList(),",
      "                            onChanged: (val) =>",
      "                                setState(() => _filterStatus = val),",
      "                          ),",
      "                          const SizedBox(width: 12),",
      "                          IconButton(",
      "                            icon: const Icon(Icons.calendar_today),",
      "                            onPressed: () async {",
      "                              final range = await showDateRangePicker(",
      "                                context: context,",
      "                                firstDate: DateTime.now()",
      "                                    .subtract(const Duration(days: 365)),",
      "                                lastDate:",
      "                                    DateTime.now().add(const Duration(days: 1)),",
      "                              );",
      "                              if (range != null)",
      "                                setState(() => _dateRange = range);",
      "                            },",
      "                          ),",
      "                          Checkbox(",
      "                            value: _showRefunded,",
      "                            onChanged: (val) =>",
      "                                setState(() => _showRefunded = val ?? true),",
      "                          ),",
      "                          const Text(\"Show Refunded\"),",
      "                        ],",
      "                      ),",
      "                      const SizedBox(height: 16),",
      "                      Expanded(",
      "                        child: StreamBuilder<List<order_model.Order>>(",
      "                          stream:",
      "                              firestoreService.getAllOrdersStream(franchiseId),",
      "                          builder: (context, snapshot) {",
      "                            if (snapshot.connectionState ==",
      "                                ConnectionState.waiting) {",
      "                              return const LoadingShimmerWidget();",
      "                            }",
      "                            final orders = snapshot.data ?? [];",
      "                            final filtered = _filterOrders(orders);",
      "                            _lastOrders = filtered;",
      "",
      "                            if (filtered.isEmpty) {",
      "                              return const EmptyStateWidget(",
      "                                title: \"No Orders\",",
      "                                message: \"No orders found.\",",
      "                                iconData: Icons.receipt_long,",
      "                              );",
      "                            }",
      "",
      "                            return ListView.builder(",
      "                              itemCount: filtered.length,",
      "                              itemBuilder: (ctx, i) {",
      "                                final order = filtered[i];",
      "                                return Card(",
      "                                  margin:",
      "                                      const EdgeInsets.symmetric(vertical: 6),",
      "                                  child: ListTile(",
      "                                    leading: CircleAvatar(",
      "                                      backgroundColor:",
      "                                          order.status == 'Refunded'",
      "                                              ? Colors.redAccent",
      "                                              : DesignTokens.adminPrimaryColor,",
      "                                      child: Text(",
      "                                          order.userNameDisplay.isNotEmpty",
      "                                              ? order.userNameDisplay[0]",
      "                                                  .toUpperCase()",
      "                                              : '#'),",
      "                                    ),",
      "                                    title: Text(",
      "                                        \"${order.id} — ${order.userNameDisplay}\",",
      "                                        style: const TextStyle(",
      "                                            fontWeight: FontWeight.bold)),",
      "                                    subtitle: Column(",
      "                                      crossAxisAlignment:",
      "                                          CrossAxisAlignment.start,",
      "                                      children: [",
      "                                        Text(",
      "                                            \"Status: ${order.status} | \\$${order.total.toStringAsFixed(2)}\"),",
      "                                        Text(\"Placed: ${order.timestamp}\"),",
      "                                        if (order.refundStatus != null)",
      "                                          Text(\"Refund: ${order.refundStatus}\"),",
      "                                      ],",
      "                                    ),",
      "                                    trailing: PopupMenuButton<String>(",
      "                                      onSelected: (value) {",
      "                                        if (value == 'status') {",
      "                                          _showStatusDialog(order, user);",
      "                                        } else if (value == 'refund') {",
      "                                          _showRefundDialog(order, user);",
      "                                        }",
      "                                      },",
      "                                      itemBuilder: (context) {",
      "                                        final items =",
      "                                            <PopupMenuEntry<String>>[];",
      "                                        if (user.isOwner || user.isManager) {",
      "                                          items.add(const PopupMenuItem(",
      "                                              value: 'status',",
      "                                              child: Text(\"Update Status\")));",
      "                                          if (order.status != 'Refunded') {",
      "                                            items.add(const PopupMenuItem(",
      "                                                value: 'refund',",
      "                                                child: Text(\"Process Refund\")));",
      "                                          }",
      "                                        }",
      "                                        return items;",
      "                                      },",
      "                                    ),",
      "                                    onTap: () => showDialog(",
      "                                      context: context,",
      "                                      builder: (_) =>",
      "                                          OrderDetailDialog(order: order),",
      "                                    ),",
      "                                  ),",
      "                                );",
      "                              },",
      "                            );",
      "                          },",
      "                        ),",
      "                      ),",
      "                    ],",
      "                  ),",
      "                ),",
      "              ),",
      "            ],",
      "          ),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 412,
      "file_size": 17532,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\owner\\platform_owner_dashboard_screen.dart",
    "content": [
      "// File: lib/admin/owner/platform_owner_dashboard_screen.dart",
      "",
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/config/branding_config.dart';",
      "import 'package:franchise_admin_portal/core/models/user.dart' as app;",
      "import 'package:franchise_admin_portal/core/providers/user_profile_notifier.dart';",
      "import 'package:franchise_admin_portal/widgets/dashboard/dashboard_switcher_dropdown.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchisee_invitation_provider.dart';",
      "import 'package:franchise_admin_portal/widgets/financials/franchisee_invitation_service.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/widgets/dialogs/franchisee_invitation_dialog.dart';",
      "import 'package:franchise_admin_portal/widgets/financials/platform_revenue_summary_panel.dart';",
      "import 'package:franchise_admin_portal/core/providers/platform_financials_provider.dart';",
      "import 'package:franchise_admin_portal/widgets/profile/user_avatar_menu.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "import 'package:franchise_admin_portal/admin/owner/sections/platform_plans_summary_card.dart';",
      "import 'package:franchise_admin_portal/admin/owner/sections/franchise_subscription_summary_card.dart';",
      "import 'package:franchise_admin_portal/admin/owner/screens/full_platform_plans_screen.dart';",
      "import 'package:franchise_admin_portal/admin/owner/sections/quick_links_card.dart';",
      "import 'package:franchise_admin_portal/widgets/header/settings_icon_button.dart';",
      "import 'package:franchise_admin_portal/widgets/header/help_icon_button.dart';",
      "import 'package:franchise_admin_portal/widgets/header/notifications_icon_button.dart';",
      "",
      "class PlatformOwnerDashboardScreen extends StatelessWidget {",
      "  final String currentScreen;",
      "",
      "  const PlatformOwnerDashboardScreen({",
      "    Key? key,",
      "    required this.currentScreen,",
      "  }) : super(key: key);",
      "",
      "  bool _isPlatformOwner(app.User? user) {",
      "    // Adjust this logic as needed; assumes you have a 'platform_owner' or similar role.",
      "    return user != null &&",
      "        (user.roles.contains('platform_owner') ||",
      "            user.roles.contains('developer'));",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    print('[PlatformOwnerDashboardScreen] build called');",
      "    final adminUserProvider =",
      "        Provider.of<AdminUserProvider>(context, listen: false);",
      "    final user = adminUserProvider.user;",
      "    final loc = AppLocalizations.of(context);",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    print('[PlatformOwnerDashboardScreen] user: $user');",
      "    print('[PlatformOwnerDashboardScreen] loc: $loc');",
      "    if (user == null) {",
      "      print('[PlatformOwnerDashboardScreen] user is null! Returning error.');",
      "      return Scaffold(",
      "        body: Center(child: Text('User profile missing. [debug]')),",
      "      );",
      "    }",
      "    if (loc == null) {",
      "      print('[PlatformOwnerDashboardScreen] loc is null! Localization error.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    // === Platform Owner Access Guard ===",
      "    if (!_isPlatformOwner(user)) {",
      "      // Log unauthorized access attempt",
      "      ErrorLogger.log(",
      "        message: 'Unauthorized PlatformOwnerDashboardScreen access',",
      "        source: 'PlatformOwnerDashboardScreen',",
      "        screen: 'PlatformOwnerDashboardScreen',",
      "        severity: 'warning',",
      "        contextData: {",
      "          'userId': user?.id,",
      "          'roles': user?.roles,",
      "        },",
      "      );",
      "      return Center(",
      "        child: Card(",
      "          elevation: DesignTokens.adminCardElevation,",
      "          color: colorScheme.surface,",
      "          shape:",
      "              RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),",
      "          child: Padding(",
      "            padding: const EdgeInsets.symmetric(horizontal: 32, vertical: 44),",
      "            child: Column(",
      "              mainAxisSize: MainAxisSize.min,",
      "              children: [",
      "                Icon(Icons.lock_outline_rounded,",
      "                    color: colorScheme.error, size: 46),",
      "                const SizedBox(height: 18),",
      "                Text(",
      "                  loc.unauthorizedAccessTitle,",
      "                  style: Theme.of(context).textTheme.titleLarge?.copyWith(",
      "                        color: colorScheme.error,",
      "                        fontWeight: FontWeight.bold,",
      "                      ),",
      "                ),",
      "                const SizedBox(height: 10),",
      "                Text(",
      "                  loc.unauthorizedAccessMessage,",
      "                  style: Theme.of(context).textTheme.bodyMedium,",
      "                  textAlign: TextAlign.center,",
      "                ),",
      "                const SizedBox(height: 26),",
      "                ElevatedButton.icon(",
      "                  onPressed: () =>",
      "                      Navigator.of(context).popUntil((route) => route.isFirst),",
      "                  icon: const Icon(Icons.home_rounded),",
      "                  label: Text(loc.returnHome),",
      "                  style: ElevatedButton.styleFrom(",
      "                    backgroundColor: colorScheme.primary,",
      "                    foregroundColor: colorScheme.onPrimary,",
      "                  ),",
      "                ),",
      "              ],",
      "            ),",
      "          ),",
      "        ),",
      "      );",
      "    }",
      "",
      "    // === Main Dashboard Layout ===",
      "    final isWide = MediaQuery.of(context).size.width > 1200;",
      "    final hPadding = isWide ? 38.0 : 16.0;",
      "    final vPadding = isWide ? 28.0 : 14.0;",
      "",
      "    return ChangeNotifierProvider(",
      "        create: (_) => PlatformFinancialsProvider()..loadFinancials(),",
      "        child: Scaffold(",
      "          backgroundColor: colorScheme.background,",
      "          appBar: AppBar(",
      "            titleSpacing: 0,",
      "            elevation: 1,",
      "            title: Row(",
      "              children: [",
      "                const SizedBox(width: 8),",
      "                Image.network(",
      "                  BrandingConfig.logoUrl,",
      "                  height: 36,",
      "                  fit: BoxFit.contain,",
      "                  errorBuilder: (_, __, ___) => SizedBox(",
      "                    height: 36,",
      "                    child: Center(",
      "                      child:",
      "                          Icon(Icons.domain, size: 34, color: Colors.grey[400]),",
      "                    ),",
      "                  ),",
      "                ),",
      "                const SizedBox(width: 16),",
      "                Text(",
      "                  loc.platformOwnerDashboardTitle,",
      "                  style: Theme.of(context).textTheme.titleLarge?.copyWith(",
      "                        fontWeight: FontWeight.bold,",
      "                        color: colorScheme.onSurface,",
      "                      ),",
      "                ),",
      "              ],",
      "            ),",
      "            actions: [",
      "              DashboardSwitcherDropdown(",
      "                currentScreen: '/platform-owner/dashboard',",
      "                user: user,",
      "              ),",
      "              // Padding(",
      "              //   padding: const EdgeInsets.only(right: 16),",
      "              //   child: Chip(",
      "              //     label: Text(",
      "              //       loc.platformOwner,",
      "              //       style: TextStyle(",
      "              //         color: colorScheme.onPrimary,",
      "              //         fontWeight: FontWeight.w600,",
      "              //       ),",
      "              //     ),",
      "              //     backgroundColor: colorScheme.primary,",
      "              //     avatar: const Icon(Icons.verified_user,",
      "              //         color: Colors.white, size: 20),",
      "              //   ),",
      "              // ),",
      "              const SizedBox(width: 8),",
      "              NotificationsIconButton(),",
      "              const SizedBox(width: 8),",
      "              HelpIconButton(),",
      "              const SizedBox(width: 8),",
      "              SettingsIconButton(),",
      "              const SizedBox(width: 8),",
      "              UserAvatarMenu(size: 36),",
      "              const SizedBox(width: 8),",
      "            ],",
      "          ),",
      "          body: Padding(",
      "            padding:",
      "                EdgeInsets.symmetric(horizontal: hPadding, vertical: vPadding),",
      "            child: ListView(",
      "              children: [",
      "                // --- Quick Links Card ---",
      "                const QuickLinksCard(),",
      "",
      "                const SizedBox(height: 36),",
      "                // --- Franchise Invitation Panel ---",
      "                ChangeNotifierProvider(",
      "                  create: (context) => FranchiseeInvitationProvider(",
      "                    service: FranchiseeInvitationService(",
      "                      firestoreService:",
      "                          Provider.of<FirestoreService>(context, listen: false),",
      "                    ),",
      "                  )..fetchInvitations(),",
      "                  child: FranchiseInvitationPanel(",
      "                      loc: loc, colorScheme: colorScheme),",
      "                ),",
      "",
      "                const SizedBox(height: 36),",
      "",
      "                // --- Franchise List Panel ---",
      "                FranchiseListPanel(loc: loc, colorScheme: colorScheme),",
      "",
      "                const SizedBox(height: 36),",
      "",
      "                // --- Global Financial Panel ---",
      "                Padding(",
      "                  padding: const EdgeInsets.only(bottom: 36.0),",
      "                  child: Consumer<PlatformFinancialsProvider>(",
      "                    builder: (context, provider, _) {",
      "                      if (provider.loading) {",
      "                        return Center(child: CircularProgressIndicator());",
      "                      }",
      "                      if (provider.error != null) {",
      "                        return Card(",
      "                          color: colorScheme.errorContainer,",
      "                          shape: RoundedRectangleBorder(",
      "                            borderRadius: BorderRadius.circular(18),",
      "                          ),",
      "                          child: Padding(",
      "                            padding: const EdgeInsets.all(24),",
      "                            child: Column(",
      "                              children: [",
      "                                Icon(Icons.warning,",
      "                                    color: colorScheme.error, size: 32),",
      "                                const SizedBox(height: 8),",
      "                                Text(",
      "                                  AppLocalizations.of(context)!",
      "                                      .genericErrorOccurred,",
      "                                  style: TextStyle(",
      "                                    color: colorScheme.error,",
      "                                    fontWeight: FontWeight.bold,",
      "                                  ),",
      "                                ),",
      "                                const SizedBox(height: 8),",
      "                                Text(provider.error!),",
      "                                const SizedBox(height: 12),",
      "                                ElevatedButton(",
      "                                  onPressed: () => provider.refresh(),",
      "                                  child:",
      "                                      Text(AppLocalizations.of(context)!.retry),",
      "                                ),",
      "                              ],",
      "                            ),",
      "                          ),",
      "                        );",
      "                      }",
      "                      if (provider.overview == null || provider.kpis == null) {",
      "                        return Center(child: CircularProgressIndicator());",
      "                      }",
      "                      return PlatformRevenueSummaryPanel(",
      "                          // Optionally pass values if you want more fine-grained control",
      "                          // (If your PlatformRevenueSummaryPanel consumes the Provider directly, you don't need to pass anything)",
      "                          );",
      "                    },",
      "                  ),",
      "                ),",
      "",
      "                const SizedBox(height: 36),",
      "",
      "                // --- Platform Analytics Panel ---",
      "                PlatformAnalyticsPanel(loc: loc, colorScheme: colorScheme),",
      "",
      "                const SizedBox(height: 36),",
      "",
      "                // --- Platform plans summary card ---",
      "                const PlatformPlansSummaryCard(),",
      "",
      "                const SizedBox(height: 36),",
      "                // --- Franchise subscriptions summary card ---",
      "                const FranchiseSubscriptionSummaryCard(),",
      "",
      "                const SizedBox(height: 36),",
      "",
      "                // --- Platform Settings Panel ---",
      "                PlatformSettingsPanel(loc: loc, colorScheme: colorScheme),",
      "",
      "                const SizedBox(height: 36),",
      "",
      "                // --- Owner Announcements Panel ---",
      "                OwnerAnnouncementsPanel(loc: loc, colorScheme: colorScheme),",
      "",
      "                const SizedBox(height: 36),",
      "",
      "                // === Future Features Placeholder ===",
      "                _futureFeaturePlaceholder(context, loc, colorScheme),",
      "              ],",
      "            ),",
      "          ),",
      "        ));",
      "  }",
      "",
      "  Widget _futureFeaturePlaceholder(",
      "      BuildContext context, AppLocalizations loc, ColorScheme colorScheme) {",
      "    return Card(",
      "      color: colorScheme.surfaceVariant,",
      "      elevation: DesignTokens.adminCardElevation,",
      "      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),",
      "      child: Padding(",
      "        padding: const EdgeInsets.symmetric(vertical: 26, horizontal: 22),",
      "        child: Column(",
      "          children: [",
      "            Icon(Icons.new_releases, color: colorScheme.primary, size: 36),",
      "            const SizedBox(height: 12),",
      "            Text(",
      "              loc.futureFeaturesTitle,",
      "              style: TextStyle(",
      "                color: colorScheme.primary,",
      "                fontWeight: FontWeight.bold,",
      "                fontSize: 18,",
      "              ),",
      "            ),",
      "            const SizedBox(height: 7),",
      "            Text(",
      "              loc.futureFeaturesBody,",
      "              style: Theme.of(context).textTheme.bodyMedium?.copyWith(",
      "                    color: colorScheme.onSurface.withOpacity(0.8),",
      "                  ),",
      "              textAlign: TextAlign.center,",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "// === Modular Panels for Each Dashboard Section ===",
      "",
      "// 1. Franchise Invitations",
      "class FranchiseInvitationPanel extends StatelessWidget {",
      "  final AppLocalizations loc;",
      "  final ColorScheme colorScheme;",
      "  const FranchiseInvitationPanel(",
      "      {required this.loc, required this.colorScheme, Key? key})",
      "      : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    // TODO: Wire up real invite logic",
      "    return Card(",
      "      elevation: DesignTokens.adminCardElevation,",
      "      color: colorScheme.surface,",
      "      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(18)),",
      "      child: Padding(",
      "        padding: const EdgeInsets.symmetric(vertical: 26, horizontal: 24),",
      "        child: Column(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            Row(",
      "              children: [",
      "                Icon(Icons.mail_outline, color: colorScheme.primary),",
      "                const SizedBox(width: 10),",
      "                Text(",
      "                  loc.inviteFranchiseesTitle,",
      "                  style: Theme.of(context).textTheme.titleMedium?.copyWith(",
      "                        fontWeight: FontWeight.bold,",
      "                      ),",
      "                ),",
      "                const Spacer(),",
      "                ElevatedButton.icon(",
      "                  onPressed: () async {",
      "                    final result = await showDialog(",
      "                      context: context,",
      "                      builder: (_) => const FranchiseeInvitationDialog(),",
      "                    );",
      "                    if (result == true) {",
      "                      // Optionally refresh invitations or show a SnackBar",
      "                      Provider.of<FranchiseeInvitationProvider>(context,",
      "                              listen: false)",
      "                          .fetchInvitations();",
      "                      ScaffoldMessenger.of(context).showSnackBar(SnackBar(",
      "                        content:",
      "                            Text(AppLocalizations.of(context)!.invitationSent),",
      "                        backgroundColor: colorScheme.primary,",
      "                      ));",
      "                    }",
      "                  },",
      "                  icon: const Icon(Icons.person_add_alt_1),",
      "                  label: Text(loc.inviteFranchisee),",
      "                ),",
      "              ],",
      "            ),",
      "            const SizedBox(height: 16),",
      "            // Placeholder table for pending invitations",
      "            Text(",
      "              loc.pendingInvitations,",
      "              style: Theme.of(context)",
      "                  .textTheme",
      "                  .bodyMedium",
      "                  ?.copyWith(fontWeight: FontWeight.w600),",
      "            ),",
      "            const SizedBox(height: 8),",
      "            _pendingInvitesTable(context),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  Widget _pendingInvitesTable(BuildContext context) {",
      "    return Consumer<FranchiseeInvitationProvider>(",
      "      builder: (context, provider, child) {",
      "        if (provider.loading) {",
      "          return Center(child: CircularProgressIndicator());",
      "        }",
      "        final pendingInvites = provider.invitations",
      "            .where((invite) => invite.status == \"pending\")",
      "            .toList();",
      "        if (pendingInvites.isEmpty) {",
      "          return Text(",
      "            AppLocalizations.of(context)!.noPendingInvitations,",
      "            style: Theme.of(context).textTheme.bodyMedium?.copyWith(",
      "                  color: colorScheme.secondary,",
      "                ),",
      "          );",
      "        }",
      "        // Display as a table/list",
      "        return Column(",
      "          children: pendingInvites.map((invite) {",
      "            return ListTile(",
      "              leading: Icon(Icons.email_outlined, color: colorScheme.primary),",
      "              title: Text(invite.email),",
      "              subtitle: Text(\"${invite.role ?? ''} • ${invite.status}\"),",
      "              trailing: Row(",
      "                mainAxisSize: MainAxisSize.min,",
      "                children: [",
      "                  IconButton(",
      "                    icon: Icon(Icons.cancel, color: colorScheme.error),",
      "                    tooltip: loc.revokeInvitation,",
      "                    onPressed: () async {",
      "                      final confirm = await showDialog<bool>(",
      "                        context: context,",
      "                        builder: (_) => AlertDialog(",
      "                          title: Text(loc.revokeInvitation),",
      "                          content: Text(loc.confirmRevokeInvitation),",
      "                          actions: [",
      "                            TextButton(",
      "                              child: Text(loc.cancel),",
      "                              onPressed: () => Navigator.pop(context, false),",
      "                            ),",
      "                            ElevatedButton(",
      "                              child: Text(loc.revoke),",
      "                              onPressed: () => Navigator.pop(context, true),",
      "                            ),",
      "                          ],",
      "                        ),",
      "                      );",
      "                      if (confirm == true) {",
      "                        if (invite.token != null) {",
      "                          await provider.cancelInvitation(invite.token!);",
      "                        } else {",
      "                          // Handle gracefully (shouldn’t happen in valid UI)",
      "                          ScaffoldMessenger.of(context).showSnackBar(SnackBar(",
      "                            content: Text('Invalid invitation token.'),",
      "                            backgroundColor:",
      "                                Theme.of(context).colorScheme.error,",
      "                          ));",
      "                        }",
      "                      }",
      "                    },",
      "                  ),",
      "                  IconButton(",
      "                    icon: Icon(Icons.refresh, color: colorScheme.secondary),",
      "                    tooltip: loc.resendInvitation,",
      "                    onPressed: () async {",
      "                      // Optionally implement resend via provider",
      "                      // await provider.resendInvitation(invite.token);",
      "                      ScaffoldMessenger.of(context).showSnackBar(SnackBar(",
      "                        content:",
      "                            Text(loc.featureComingSoon(loc.resendInvitation)),",
      "                        backgroundColor: colorScheme.primary,",
      "                      ));",
      "                    },",
      "                  ),",
      "                ],",
      "              ),",
      "            );",
      "          }).toList(),",
      "        );",
      "      },",
      "    );",
      "  }",
      "}",
      "",
      "// 2. Franchise Network",
      "class FranchiseListPanel extends StatelessWidget {",
      "  final AppLocalizations loc;",
      "  final ColorScheme colorScheme;",
      "  const FranchiseListPanel(",
      "      {required this.loc, required this.colorScheme, Key? key})",
      "      : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    // TODO: Wire up real data table of franchises",
      "    return Card(",
      "      elevation: DesignTokens.adminCardElevation,",
      "      color: colorScheme.surface,",
      "      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(18)),",
      "      child: Padding(",
      "        padding: const EdgeInsets.symmetric(vertical: 26, horizontal: 24),",
      "        child: Column(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            Row(",
      "              children: [",
      "                Icon(Icons.business_rounded, color: colorScheme.primary),",
      "                const SizedBox(width: 10),",
      "                Text(",
      "                  loc.franchiseNetworkTitle,",
      "                  style: Theme.of(context).textTheme.titleMedium?.copyWith(",
      "                        fontWeight: FontWeight.bold,",
      "                      ),",
      "                ),",
      "                const Spacer(),",
      "                OutlinedButton.icon(",
      "                  onPressed: () {",
      "                    // TODO: Implement view all franchises action",
      "                    ScaffoldMessenger.of(context).showSnackBar(SnackBar(",
      "                      content: Text(",
      "                          loc.featureComingSoon(loc.franchiseNetworkTitle)),",
      "                      backgroundColor: colorScheme.primary,",
      "                    ));",
      "                  },",
      "                  icon: const Icon(Icons.list),",
      "                  label: Text(loc.viewAllFranchises),",
      "                ),",
      "              ],",
      "            ),",
      "            const SizedBox(height: 16),",
      "            _franchiseListTable(context),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  Widget _franchiseListTable(BuildContext context) {",
      "    // TODO: Replace with real data (fetch from Firestore/service)",
      "    return Container(",
      "      width: double.infinity,",
      "      padding: const EdgeInsets.symmetric(vertical: 12),",
      "      child: Text(",
      "        AppLocalizations.of(context)!.noFranchisesFound,",
      "        style: Theme.of(context).textTheme.bodyMedium?.copyWith(",
      "              color: colorScheme.secondary,",
      "            ),",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "// 3. Global Financials",
      "class GlobalFinancialPanel extends StatelessWidget {",
      "  final AppLocalizations loc;",
      "  final ColorScheme colorScheme;",
      "  const GlobalFinancialPanel(",
      "      {required this.loc, required this.colorScheme, Key? key})",
      "      : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    // TODO: Integrate real stats and tables",
      "    return Card(",
      "      elevation: DesignTokens.adminCardElevation,",
      "      color: colorScheme.surface,",
      "      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(18)),",
      "      child: Padding(",
      "        padding: const EdgeInsets.symmetric(vertical: 26, horizontal: 24),",
      "        child: Column(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            Row(",
      "              children: [",
      "                Icon(Icons.attach_money, color: colorScheme.primary),",
      "                const SizedBox(width: 10),",
      "                Text(",
      "                  loc.globalFinancialsTitle,",
      "                  style: Theme.of(context).textTheme.titleMedium?.copyWith(",
      "                        fontWeight: FontWeight.bold,",
      "                      ),",
      "                ),",
      "              ],",
      "            ),",
      "            const SizedBox(height: 16),",
      "            _financialSummary(context),",
      "            const SizedBox(height: 18),",
      "            _financialTable(context),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  Widget _financialSummary(BuildContext context) {",
      "    // TODO: Display MRR/ARR, total revenue, overdue",
      "    return Row(",
      "      children: [",
      "        _statCard(context, 'MRR', '--'),",
      "        const SizedBox(width: 24),",
      "        _statCard(context, 'ARR', '--'),",
      "        const SizedBox(width: 24),",
      "        _statCard(context, AppLocalizations.of(context)!.overdueInvoices, '--'),",
      "      ],",
      "    );",
      "  }",
      "",
      "  Widget _statCard(BuildContext context, String label, String value) {",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    return Card(",
      "      elevation: 0,",
      "      color: colorScheme.secondary.withOpacity(0.13),",
      "      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(14)),",
      "      child: Padding(",
      "        padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 10),",
      "        child: Column(",
      "          children: [",
      "            Text(value,",
      "                style: TextStyle(",
      "                    fontSize: 20,",
      "                    fontWeight: FontWeight.bold,",
      "                    color: colorScheme.primary)),",
      "            const SizedBox(height: 5),",
      "            Text(label,",
      "                style: TextStyle(",
      "                    fontSize: 14,",
      "                    color: colorScheme.onSurface.withOpacity(0.75))),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  Widget _financialTable(BuildContext context) {",
      "    // TODO: Implement invoices, payouts, fee schedules",
      "    return Container(",
      "      width: double.infinity,",
      "      padding: const EdgeInsets.symmetric(vertical: 10),",
      "      child: Text(",
      "        AppLocalizations.of(context)!.noFinancialData,",
      "        style: Theme.of(context).textTheme.bodyMedium?.copyWith(",
      "              color: colorScheme.secondary,",
      "            ),",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "// 4. Platform Analytics",
      "class PlatformAnalyticsPanel extends StatelessWidget {",
      "  final AppLocalizations loc;",
      "  final ColorScheme colorScheme;",
      "  const PlatformAnalyticsPanel(",
      "      {required this.loc, required this.colorScheme, Key? key})",
      "      : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    // TODO: Wire up real analytics and charting",
      "    return Card(",
      "      elevation: DesignTokens.adminCardElevation,",
      "      color: colorScheme.surface,",
      "      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(18)),",
      "      child: Padding(",
      "        padding: const EdgeInsets.symmetric(vertical: 26, horizontal: 24),",
      "        child: Column(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            Row(",
      "              children: [",
      "                Icon(Icons.bar_chart_rounded, color: colorScheme.primary),",
      "                const SizedBox(width: 10),",
      "                Text(",
      "                  loc.platformAnalyticsTitle,",
      "                  style: Theme.of(context).textTheme.titleMedium?.copyWith(",
      "                        fontWeight: FontWeight.bold,",
      "                      ),",
      "                ),",
      "              ],",
      "            ),",
      "            const SizedBox(height: 16),",
      "            // Placeholder for KPIs",
      "            Row(",
      "              children: [",
      "                _analyticsCard(context, loc.totalFranchises, '--'),",
      "                const SizedBox(width: 22),",
      "                _analyticsCard(context, loc.activeUsers, '--'),",
      "                const SizedBox(width: 22),",
      "                _analyticsCard(context, loc.totalOrders, '--'),",
      "              ],",
      "            ),",
      "            const SizedBox(height: 24),",
      "            // Placeholder for chart/graph",
      "            Container(",
      "              width: double.infinity,",
      "              height: 160,",
      "              color: colorScheme.surfaceVariant.withOpacity(0.34),",
      "              child: Center(",
      "                child: Text(",
      "                  loc.analyticsComingSoon,",
      "                  style: Theme.of(context).textTheme.bodyMedium?.copyWith(",
      "                        color: colorScheme.secondary,",
      "                      ),",
      "                ),",
      "              ),",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  Widget _analyticsCard(BuildContext context, String label, String value) {",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    return Card(",
      "      elevation: 0,",
      "      color: colorScheme.secondary.withOpacity(0.13),",
      "      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(14)),",
      "      child: Padding(",
      "        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),",
      "        child: Column(",
      "          children: [",
      "            Text(value,",
      "                style: TextStyle(",
      "                    fontSize: 18,",
      "                    fontWeight: FontWeight.bold,",
      "                    color: colorScheme.primary)),",
      "            const SizedBox(height: 4),",
      "            Text(label,",
      "                style: TextStyle(",
      "                    fontSize: 13,",
      "                    color: colorScheme.onSurface.withOpacity(0.75))),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "// 5. Platform Settings",
      "class PlatformSettingsPanel extends StatelessWidget {",
      "  final AppLocalizations loc;",
      "  final ColorScheme colorScheme;",
      "  const PlatformSettingsPanel(",
      "      {required this.loc, required this.colorScheme, Key? key})",
      "      : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    // TODO: Wire up real settings form and save logic",
      "    return Card(",
      "      elevation: DesignTokens.adminCardElevation,",
      "      color: colorScheme.surface,",
      "      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(18)),",
      "      child: Padding(",
      "        padding: const EdgeInsets.symmetric(vertical: 26, horizontal: 24),",
      "        child: Column(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            Row(",
      "              children: [",
      "                Icon(Icons.settings, color: colorScheme.primary),",
      "                const SizedBox(width: 10),",
      "                Text(",
      "                  loc.platformSettingsTitle,",
      "                  style: Theme.of(context).textTheme.titleMedium?.copyWith(",
      "                        fontWeight: FontWeight.bold,",
      "                      ),",
      "                ),",
      "              ],",
      "            ),",
      "            const SizedBox(height: 16),",
      "            Text(",
      "              loc.platformSettingsComingSoon,",
      "              style: Theme.of(context).textTheme.bodyMedium?.copyWith(",
      "                    color: colorScheme.secondary,",
      "                  ),",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "// 6. Owner Announcements",
      "class OwnerAnnouncementsPanel extends StatelessWidget {",
      "  final AppLocalizations loc;",
      "  final ColorScheme colorScheme;",
      "  const OwnerAnnouncementsPanel(",
      "      {required this.loc, required this.colorScheme, Key? key})",
      "      : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    // TODO: Wire up real announcements (compose and list)",
      "    return Card(",
      "      elevation: DesignTokens.adminCardElevation,",
      "      color: colorScheme.surface,",
      "      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(18)),",
      "      child: Padding(",
      "        padding: const EdgeInsets.symmetric(vertical: 26, horizontal: 24),",
      "        child: Column(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            Row(",
      "              children: [",
      "                Icon(Icons.announcement, color: colorScheme.primary),",
      "                const SizedBox(width: 10),",
      "                Text(",
      "                  loc.ownerAnnouncementsTitle,",
      "                  style: Theme.of(context).textTheme.titleMedium?.copyWith(",
      "                        fontWeight: FontWeight.bold,",
      "                      ),",
      "                ),",
      "                const Spacer(),",
      "                ElevatedButton.icon(",
      "                  onPressed: () {",
      "                    // TODO: Implement announcement compose dialog",
      "                    ScaffoldMessenger.of(context).showSnackBar(SnackBar(",
      "                      content: Text(",
      "                          loc.featureComingSoon(loc.ownerAnnouncementsTitle)),",
      "                      backgroundColor: colorScheme.primary,",
      "                    ));",
      "                  },",
      "                  icon: const Icon(Icons.add_alert),",
      "                  label: Text(loc.sendAnnouncement),",
      "                ),",
      "              ],",
      "            ),",
      "            const SizedBox(height: 16),",
      "            Container(",
      "              width: double.infinity,",
      "              padding: const EdgeInsets.symmetric(vertical: 12),",
      "              child: Text(",
      "                loc.noAnnouncements,",
      "                style: Theme.of(context).textTheme.bodyMedium?.copyWith(",
      "                      color: colorScheme.secondary,",
      "                    ),",
      "              ),",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 861,
      "file_size": 33203,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\owner\\screens\\full_franchise_subscription_list_screen.dart",
    "content": [
      "// 📄 lib/admin/owner/screens/full_franchise_subscription_list_screen.dart",
      "",
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/config/app_config.dart';",
      "import 'package:franchise_admin_portal/core/models/enriched/enriched_franchise_subscription.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/services/enrichment/franchise_subscription_enricher.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "import 'package:franchise_admin_portal/admin/developer/platform/franchise_subscription_editor_dialog.dart';",
      "import 'package:franchise_admin_portal/admin/owner/widgets/franchise_subscription_list_tile.dart';",
      "",
      "class FullFranchiseSubscriptionListScreen extends StatefulWidget {",
      "  const FullFranchiseSubscriptionListScreen({super.key});",
      "",
      "  @override",
      "  State<FullFranchiseSubscriptionListScreen> createState() =>",
      "      _FullFranchiseSubscriptionListScreenState();",
      "}",
      "",
      "class _FullFranchiseSubscriptionListScreenState",
      "    extends State<FullFranchiseSubscriptionListScreen> {",
      "  late Future<List<EnrichedFranchiseSubscription>> _enrichedSubsFuture;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _enrichedSubsFuture = _loadEnrichedSubscriptions();",
      "  }",
      "",
      "  Future<List<EnrichedFranchiseSubscription>>",
      "      _loadEnrichedSubscriptions() async {",
      "    try {",
      "      final firestore = context.read<FirestoreService>();",
      "      final enricher = FranchiseSubscriptionEnricher(firestore);",
      "      final enriched = await enricher.enrichAllSubscriptions();",
      "",
      "      // 🐞 Debug & duplicate detection",
      "      final seen = <String>{};",
      "      for (final e in enriched) {",
      "        final id = e.subscription.id;",
      "        final plan = e.planId;",
      "        final fid = e.franchiseId;",
      "",
      "        if (seen.contains(id)) {",
      "          debugPrint('[⚠️ DUPLICATE] FranchiseId: $fid, Plan: $plan, ID: $id');",
      "        } else {",
      "          seen.add(id);",
      "        }",
      "",
      "        debugPrint('[✅ Enriched] FranchiseId: $fid, Plan: $plan, ID: $id');",
      "      }",
      "",
      "      return enriched;",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'load_enriched_subscriptions_failed',",
      "        stack: stack.toString(),",
      "        source: 'FullFranchiseSubscriptionListScreen',",
      "        screen: 'full_franchise_subscription_list_screen',",
      "        severity: 'error',",
      "        contextData: {'exception': e.toString()},",
      "      );",
      "      return [];",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final user = context.watch<AdminUserProvider>().user;",
      "    final loc = AppLocalizations.of(context)!;",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "",
      "    final isAuthorized =",
      "        user?.isDeveloper == true || user?.isPlatformOwner == true;",
      "",
      "    if (!isAuthorized) {",
      "      return Scaffold(",
      "        appBar: AppBar(title: Text(loc.franchiseSubscriptionsTitle)),",
      "        body: Center(",
      "          child: Text(",
      "            loc.unauthorizedAccessMessage,",
      "            style:",
      "                theme.textTheme.bodyLarge?.copyWith(color: colorScheme.error),",
      "          ),",
      "        ),",
      "      );",
      "    }",
      "",
      "    return Scaffold(",
      "      appBar: AppBar(",
      "        title: Text(loc.franchiseSubscriptionsTitle),",
      "        backgroundColor: colorScheme.surface,",
      "      ),",
      "      body: Padding(",
      "        padding: const EdgeInsets.all(16.0),",
      "        child: FutureBuilder<List<EnrichedFranchiseSubscription>>(",
      "          future: _enrichedSubsFuture,",
      "          builder: (context, snapshot) {",
      "            if (snapshot.connectionState != ConnectionState.done) {",
      "              return const Center(child: CircularProgressIndicator());",
      "            }",
      "",
      "            final subs = snapshot.data ?? [];",
      "",
      "            if (subs.isEmpty) {",
      "              return Center(child: Text(loc.noSubscriptionsFound));",
      "            }",
      "",
      "            return ListView.separated(",
      "              itemCount: subs.length,",
      "              separatorBuilder: (_, __) => const SizedBox(height: 12),",
      "              itemBuilder: (context, index) {",
      "                final enriched = subs[index];",
      "",
      "                return FranchiseSubscriptionListTile(",
      "                  key: ValueKey(enriched.subscription.id),",
      "                  enriched: enriched,",
      "                  onRefreshRequested: () {",
      "                    setState(() {",
      "                      _enrichedSubsFuture = _loadEnrichedSubscriptions();",
      "                    });",
      "                  },",
      "                );",
      "              },",
      "            );",
      "          },",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 136,
      "file_size": 4865,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\owner\\screens\\full_platform_plans_screen.dart",
    "content": [
      "// 📁 File: lib/admin/owner/screens/full_platform_plans_screen.dart",
      "",
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/config/app_config.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "import 'package:franchise_admin_portal/core/models/platform_plan_model.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/core/services/franchise_subscription_service.dart';",
      "",
      "class FullPlatformPlansScreen extends StatefulWidget {",
      "  const FullPlatformPlansScreen({super.key});",
      "",
      "  @override",
      "  State<FullPlatformPlansScreen> createState() =>",
      "      _FullPlatformPlansScreenState();",
      "}",
      "",
      "class _FullPlatformPlansScreenState extends State<FullPlatformPlansScreen> {",
      "  late Future<List<PlatformPlan>> _plansFuture;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _plansFuture = _loadPlans();",
      "  }",
      "",
      "  Future<List<PlatformPlan>> _loadPlans() async {",
      "    try {",
      "      return await FranchiseSubscriptionService().getPlatformPlans();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'load_platform_plans_failed',",
      "        stack: stack.toString(),",
      "        source: 'FullPlatformPlansScreen',",
      "        screen: 'full_platform_plans_screen',",
      "        severity: 'error',",
      "        contextData: {'exception': e.toString()},",
      "      );",
      "      return [];",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final user = context.watch<AdminUserProvider>().user;",
      "    final loc = AppLocalizations.of(context)!;",
      "    final theme = Theme.of(context);",
      "",
      "    // 🔐 Developer-only access",
      "    if (!(user?.isDeveloper ?? false) && !(user?.isPlatformOwner ?? false)) {",
      "      return Scaffold(",
      "        appBar: AppBar(title: Text(loc.platformPlansTitle)),",
      "        body: Center(child: Text(loc.unauthorizedAccessMessage)),",
      "      );",
      "    }",
      "",
      "    return Scaffold(",
      "      appBar: AppBar(",
      "        title: Text(loc.platformPlansTitle),",
      "      ),",
      "      body: FutureBuilder<List<PlatformPlan>>(",
      "        future: _plansFuture,",
      "        builder: (context, snapshot) {",
      "          if (snapshot.connectionState != ConnectionState.done) {",
      "            return const Center(child: CircularProgressIndicator());",
      "          }",
      "",
      "          final plans = snapshot.data ?? [];",
      "",
      "          if (plans.isEmpty) {",
      "            return Padding(",
      "              padding: const EdgeInsets.all(16.0),",
      "              child:",
      "                  Text(loc.noPlansAvailable, style: theme.textTheme.bodyMedium),",
      "            );",
      "          }",
      "",
      "          return ListView.separated(",
      "            padding: const EdgeInsets.all(16),",
      "            itemCount: plans.length,",
      "            separatorBuilder: (_, __) => const SizedBox(height: 16),",
      "            itemBuilder: (context, index) {",
      "              final plan = plans[index];",
      "              return Card(",
      "                elevation: DesignTokens.adminCardElevation,",
      "                shape: RoundedRectangleBorder(",
      "                    borderRadius: BorderRadius.circular(14)),",
      "                color: plan.active",
      "                    ? theme.colorScheme.surface",
      "                    : theme.colorScheme.surfaceVariant.withOpacity(0.5),",
      "                child: Padding(",
      "                  padding: const EdgeInsets.all(16),",
      "                  child: Column(",
      "                    crossAxisAlignment: CrossAxisAlignment.start,",
      "                    children: [",
      "                      Row(",
      "                        children: [",
      "                          Text(",
      "                            plan.name,",
      "                            style: theme.textTheme.titleMedium?.copyWith(",
      "                              color: plan.active",
      "                                  ? theme.colorScheme.onSurface",
      "                                  : theme.colorScheme.onSurface",
      "                                      .withOpacity(0.6),",
      "                            ),",
      "                          ),",
      "                          const Spacer(),",
      "                          if (plan.isCustom)",
      "                            Chip(",
      "                              label: Text(loc.customPlan),",
      "                              backgroundColor:",
      "                                  theme.colorScheme.secondaryContainer,",
      "                            ),",
      "                          if (!plan.active)",
      "                            Padding(",
      "                              padding: const EdgeInsets.only(left: 8.0),",
      "                              child: Chip(",
      "                                label: Text(loc.inactive),",
      "                                backgroundColor:",
      "                                    theme.colorScheme.errorContainer,",
      "                              ),",
      "                            ),",
      "                        ],",
      "                      ),",
      "                      const SizedBox(height: 8),",
      "                      Text(",
      "                        '\\$${plan.price.toStringAsFixed(2)} / ${loc.perMonth}',",
      "                        style: theme.textTheme.bodyMedium,",
      "                      ),",
      "                      const SizedBox(height: 12),",
      "                      Wrap(",
      "                        spacing: 6,",
      "                        runSpacing: 6,",
      "                        children: plan.features",
      "                            .map(",
      "                              (feature) => Chip(",
      "                                label:",
      "                                    Text(AppConfig.featureDisplayName(feature)),",
      "                                backgroundColor:",
      "                                    theme.colorScheme.primaryContainer,",
      "                              ),",
      "                            )",
      "                            .toList(),",
      "                      ),",
      "                      const SizedBox(height: 12),",
      "                      Text(",
      "                        loc.featureComingSoon(loc.platformPlansTitle),",
      "                        style: theme.textTheme.labelSmall?.copyWith(",
      "                          color: theme.colorScheme.outline,",
      "                        ),",
      "                      )",
      "                    ],",
      "                  ),",
      "                ),",
      "              );",
      "            },",
      "          );",
      "        },",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 166,
      "file_size": 6451,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\owner\\sections\\franchise_subscription_summary_card.dart",
    "content": [
      "// 📁 Path: lib/admin/owner/sections/franchise_subscription_summary_card.dart",
      "",
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/models/franchise_subscription_model.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "",
      "class FranchiseSubscriptionSummaryCard extends StatelessWidget {",
      "  const FranchiseSubscriptionSummaryCard({super.key});",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final user = context.read<AdminUserProvider>().user;",
      "    if (!(user?.isPlatformOwner ?? false) && !(user?.isDeveloper ?? false)) {",
      "      return const SizedBox.shrink();",
      "    }",
      "",
      "    final loc = AppLocalizations.of(context)!;",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "",
      "    return FutureBuilder<List<FranchiseSubscription>>(",
      "      future: FirestoreService.getFranchiseSubscriptions(),",
      "      builder: (context, snapshot) {",
      "        if (snapshot.connectionState != ConnectionState.done) {",
      "          return const Center(child: CircularProgressIndicator());",
      "        }",
      "",
      "        if (snapshot.hasError) {",
      "          ErrorLogger.log(",
      "            message: 'franchise_subscription_summary_error',",
      "            source: 'FranchiseSubscriptionSummaryCard',",
      "            screen: 'platform_owner_dashboard',",
      "            severity: 'error',",
      "            contextData: {'error': snapshot.error.toString()},",
      "          );",
      "          return Padding(",
      "            padding: const EdgeInsets.all(16),",
      "            child: Text(loc.genericErrorOccurred,",
      "                style: theme.textTheme.bodyMedium",
      "                    ?.copyWith(color: colorScheme.error)),",
      "          );",
      "        }",
      "",
      "        final subs = snapshot.data ?? [];",
      "        final activeSubs = subs.where((s) => s.status == 'active').toList();",
      "",
      "        return Card(",
      "          elevation: DesignTokens.adminCardElevation,",
      "          shape:",
      "              RoundedRectangleBorder(borderRadius: BorderRadius.circular(18)),",
      "          color: colorScheme.surface,",
      "          child: Padding(",
      "            padding: const EdgeInsets.all(20),",
      "            child: Column(",
      "              crossAxisAlignment: CrossAxisAlignment.start,",
      "              children: [",
      "                Row(",
      "                  children: [",
      "                    Icon(Icons.subscriptions, color: colorScheme.primary),",
      "                    const SizedBox(width: 10),",
      "                    Text(loc.franchiseSubscriptionsTitle,",
      "                        style: theme.textTheme.titleMedium?.copyWith(",
      "                          fontWeight: FontWeight.bold,",
      "                        )),",
      "                    const Spacer(),",
      "                    OutlinedButton.icon(",
      "                      onPressed: () => Navigator.pushNamed(",
      "                          context, '/platform/subscriptions'),",
      "                      icon: const Icon(Icons.open_in_new),",
      "                      label: Text(loc.viewAll),",
      "                    ),",
      "                  ],",
      "                ),",
      "                const SizedBox(height: 12),",
      "                if (activeSubs.isEmpty)",
      "                  Text(loc.noSubscriptionsFound,",
      "                      style: theme.textTheme.bodyMedium?.copyWith(",
      "                        color: colorScheme.secondary,",
      "                      ))",
      "                else",
      "                  ...activeSubs.take(3).map((sub) => Padding(",
      "                        padding: const EdgeInsets.symmetric(vertical: 4),",
      "                        child: Row(",
      "                          children: [",
      "                            Icon(Icons.check_circle_outline,",
      "                                color: colorScheme.primary, size: 18),",
      "                            const SizedBox(width: 8),",
      "                            Expanded(",
      "                              child: Text(",
      "                                  'ID: ${sub.franchiseId} • ${sub.platformPlanId}',",
      "                                  style: theme.textTheme.bodyMedium),",
      "                            ),",
      "                          ],",
      "                        ),",
      "                      )),",
      "                const SizedBox(height: 8),",
      "                Text(loc.featureComingSoon('Subscription billing metrics'),",
      "                    style: theme.textTheme.labelSmall",
      "                        ?.copyWith(color: colorScheme.outline)),",
      "              ],",
      "            ),",
      "          ),",
      "        );",
      "      },",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 112,
      "file_size": 4713,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\owner\\sections\\platform_plans_summary_card.dart",
    "content": [
      "// 📁 Path: lib/admin/owner/sections/platform_plans_summary_card.dart",
      "",
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/models/platform_plan_model.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/config/app_config.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "import 'package:franchise_admin_portal/core/services/franchise_subscription_service.dart';",
      "",
      "class PlatformPlansSummaryCard extends StatelessWidget {",
      "  const PlatformPlansSummaryCard({super.key});",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final user = context.read<AdminUserProvider>().user;",
      "    if (!(user?.isPlatformOwner ?? false) && !(user?.isDeveloper ?? false)) {",
      "      return const SizedBox.shrink();",
      "    }",
      "",
      "    final loc = AppLocalizations.of(context)!;",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "",
      "    return FutureBuilder<List<PlatformPlan>>(",
      "      future: FranchiseSubscriptionService().getPlatformPlans(),",
      "      builder: (context, snapshot) {",
      "        if (snapshot.connectionState != ConnectionState.done) {",
      "          return const Center(child: CircularProgressIndicator());",
      "        }",
      "",
      "        if (snapshot.hasError) {",
      "          ErrorLogger.log(",
      "            message: 'platform_plans_summary_card_error',",
      "            source: 'PlatformPlansSummaryCard',",
      "            screen: 'platform_owner_dashboard',",
      "            severity: 'error',",
      "            contextData: {'error': snapshot.error.toString()},",
      "          );",
      "          return Padding(",
      "            padding: const EdgeInsets.all(16),",
      "            child: Text(loc.genericErrorOccurred,",
      "                style: theme.textTheme.bodyMedium",
      "                    ?.copyWith(color: colorScheme.error)),",
      "          );",
      "        }",
      "",
      "        final plans = snapshot.data ?? [];",
      "        final activePlans = plans.where((p) => p.active).toList();",
      "",
      "        return Card(",
      "          elevation: DesignTokens.adminCardElevation,",
      "          shape:",
      "              RoundedRectangleBorder(borderRadius: BorderRadius.circular(18)),",
      "          color: colorScheme.surface,",
      "          child: Padding(",
      "            padding: const EdgeInsets.all(20),",
      "            child: Column(",
      "              crossAxisAlignment: CrossAxisAlignment.start,",
      "              children: [",
      "                Row(",
      "                  children: [",
      "                    Icon(Icons.payment, color: colorScheme.primary),",
      "                    const SizedBox(width: 10),",
      "                    Text(loc.platformPlansTitle,",
      "                        style: theme.textTheme.titleMedium?.copyWith(",
      "                          fontWeight: FontWeight.bold,",
      "                        )),",
      "                    const Spacer(),",
      "                    OutlinedButton.icon(",
      "                      onPressed: () =>",
      "                          Navigator.pushNamed(context, '/platform/plans'),",
      "                      icon: const Icon(Icons.open_in_new),",
      "                      label: Text(loc.viewAll),",
      "                    ),",
      "                  ],",
      "                ),",
      "                const SizedBox(height: 12),",
      "                if (activePlans.isEmpty)",
      "                  Text(loc.noPlansAvailable,",
      "                      style: theme.textTheme.bodyMedium?.copyWith(",
      "                        color: colorScheme.secondary,",
      "                      ))",
      "                else",
      "                  ...activePlans.take(3).map((plan) => Padding(",
      "                        padding: const EdgeInsets.symmetric(vertical: 4),",
      "                        child: Row(",
      "                          children: [",
      "                            Icon(Icons.check_circle,",
      "                                color: colorScheme.primary, size: 18),",
      "                            const SizedBox(width: 8),",
      "                            Expanded(",
      "                              child: Text(",
      "                                  '${plan.name} • \\$${plan.price.toStringAsFixed(2)} / ${loc.perMonth}',",
      "                                  style: theme.textTheme.bodyMedium),",
      "                            ),",
      "                          ],",
      "                        ),",
      "                      )),",
      "                const SizedBox(height: 8),",
      "                Text(loc.featureComingSoon('Plan analytics'),",
      "                    style: theme.textTheme.labelSmall",
      "                        ?.copyWith(color: colorScheme.outline)),",
      "              ],",
      "            ),",
      "          ),",
      "        );",
      "      },",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 114,
      "file_size": 4787,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\owner\\sections\\quick_links_card.dart",
    "content": [
      "// 📁 lib/admin/owner/sections/quick_links_card.dart",
      "",
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/config/branding_config.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "import 'package:provider/provider.dart';",
      "",
      "class QuickLinksCard extends StatelessWidget {",
      "  const QuickLinksCard({super.key});",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final user = context.read<AdminUserProvider>().user;",
      "    if (!(user?.isPlatformOwner ?? false) && !(user?.isDeveloper ?? false)) {",
      "      return const SizedBox.shrink();",
      "    }",
      "",
      "    final loc = AppLocalizations.of(context)!;",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "",
      "    void _navigateSafely(String route) {",
      "      try {",
      "        Navigator.pushNamed(context, route);",
      "      } catch (e, stack) {",
      "        ErrorLogger.log(",
      "          message: 'quick_links_navigation_failed',",
      "          source: 'QuickLinksCard',",
      "          screen: 'platform_owner_dashboard',",
      "          severity: 'error',",
      "          contextData: {",
      "            'exception': e.toString(),",
      "            'stackTrace': stack.toString(),",
      "            'route': route,",
      "          },",
      "        );",
      "        ScaffoldMessenger.of(context).showSnackBar(",
      "          SnackBar(content: Text(loc.genericErrorOccurred)),",
      "        );",
      "      }",
      "    }",
      "",
      "    return Card(",
      "      elevation: DesignTokens.adminCardElevation,",
      "      shape: RoundedRectangleBorder(",
      "        borderRadius: BorderRadius.circular(18),",
      "      ),",
      "      color: colorScheme.surface,",
      "      child: Padding(",
      "        padding: const EdgeInsets.all(20),",
      "        child: Column(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            Row(",
      "              children: [",
      "                Icon(Icons.dashboard_customize, color: colorScheme.primary),",
      "                const SizedBox(width: 10),",
      "                Text(",
      "                  loc.quickLinksLabel,",
      "                  style: theme.textTheme.titleMedium?.copyWith(",
      "                    fontWeight: FontWeight.bold,",
      "                  ),",
      "                ),",
      "              ],",
      "            ),",
      "            const SizedBox(height: 16),",
      "            Wrap(",
      "              spacing: 16,",
      "              runSpacing: 12,",
      "              children: [",
      "                _QuickLinkTile(",
      "                  icon: Icons.payment,",
      "                  label: loc.platformPlansTitle,",
      "                  onTap: () => _navigateSafely('/platform/plans'),",
      "                ),",
      "                _QuickLinkTile(",
      "                  icon: Icons.subscriptions,",
      "                  label: loc.franchiseSubscriptionsTitle,",
      "                  onTap: () => _navigateSafely('/platform/subscriptions'),",
      "                ),",
      "              ],",
      "            ),",
      "            const SizedBox(height: 16),",
      "            Text(",
      "              loc.featureComingSoon('Add/remove dashboards, billing console'),",
      "              style: theme.textTheme.labelSmall?.copyWith(",
      "                color: colorScheme.outline,",
      "              ),",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "class _QuickLinkTile extends StatelessWidget {",
      "  final IconData icon;",
      "  final String label;",
      "  final VoidCallback onTap;",
      "",
      "  const _QuickLinkTile({",
      "    required this.icon,",
      "    required this.label,",
      "    required this.onTap,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "",
      "    return GestureDetector(",
      "      onTap: onTap,",
      "      child: Chip(",
      "        backgroundColor: colorScheme.secondaryContainer,",
      "        avatar: Icon(icon, color: colorScheme.onSecondaryContainer, size: 20),",
      "        label: Text(label),",
      "        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 125,
      "file_size": 4027,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\owner\\widgets\\franchise_subscription_expanded_detail.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/models/enriched/enriched_franchise_subscription.dart';",
      "import 'package:franchise_admin_portal/core/models/platform_invoice.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/config/app_config.dart';",
      "",
      "class FranchiseSubscriptionExpandedDetail extends StatefulWidget {",
      "  final EnrichedFranchiseSubscription enriched;",
      "",
      "  const FranchiseSubscriptionExpandedDetail({",
      "    super.key,",
      "    required this.enriched,",
      "  });",
      "",
      "  @override",
      "  State<FranchiseSubscriptionExpandedDetail> createState() =>",
      "      _FranchiseSubscriptionExpandedDetailState();",
      "}",
      "",
      "class _FranchiseSubscriptionExpandedDetailState",
      "    extends State<FranchiseSubscriptionExpandedDetail> {",
      "  List<PlatformInvoice> _invoices = [];",
      "  bool _loading = true;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _loadInvoices();",
      "  }",
      "",
      "  Future<void> _loadInvoices() async {",
      "    try {",
      "      final firestore = context.read<FirestoreService>();",
      "      final invoices = await firestore.getPlatformInvoicesForFranchisee(",
      "        widget.enriched.franchiseId,",
      "      );",
      "      setState(() {",
      "        _invoices = invoices;",
      "        _loading = false;",
      "      });",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'invoice_fetch_failed',",
      "        screen: 'franchise_subscription_expanded_detail',",
      "        source: 'ExpandedDetailInit',",
      "        stack: stack.toString(),",
      "        contextData: {",
      "          'franchiseId': widget.enriched.franchiseId,",
      "          'subscriptionId': widget.enriched.subscription.id,",
      "        },",
      "      );",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context)!;",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "    final enriched = widget.enriched;",
      "",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        const Divider(height: 30),",
      "        _infoRow(loc.ownerLabel, enriched.ownerName),",
      "        _infoRow(loc.contactEmailLabel, enriched.contactEmail),",
      "        _infoRow(loc.phoneNumberLabel, enriched.phoneNumber),",
      "        if (enriched.userId != null)",
      "          _infoRow(loc.linkedUserIdLabel, enriched.userId!),",
      "        _infoRow(loc.billingIntervalLabel,",
      "            enriched.subscription.billingInterval ?? '—'),",
      "        _infoRow(loc.statusLabel, enriched.subscriptionStatus),",
      "        _infoRow(loc.invoiceStatusLabel, _resolveInvoiceStatus(enriched)),",
      "        _infoRow(",
      "            loc.discountLabel, '${enriched.subscription.discountPercent}%'),",
      "        _infoRow(",
      "          loc.trialEndLabel,",
      "          enriched.subscription.trialEndsAt != null",
      "              ? AppConfig.formatDate(enriched.subscription.trialEndsAt)",
      "              : loc.notAvailable,",
      "        ),",
      "        _infoRow(",
      "          loc.nextBillingLabel,",
      "          AppConfig.formatDate(enriched.subscription.nextBillingDate),",
      "        ),",
      "        _infoRow(",
      "          loc.subscriptionCreated,",
      "          AppConfig.formatDate(enriched.subscription.startDate),",
      "        ),",
      "        const SizedBox(height: 12),",
      "        if (_loading)",
      "          const Padding(",
      "            padding: EdgeInsets.all(8),",
      "            child: LinearProgressIndicator(),",
      "          )",
      "        else",
      "          Column(",
      "            crossAxisAlignment: CrossAxisAlignment.start,",
      "            children: [",
      "              Text(loc.linkedInvoices, style: theme.textTheme.titleSmall),",
      "              const SizedBox(height: 8),",
      "              ..._invoices.map((inv) => ListTile(",
      "                    dense: true,",
      "                    visualDensity: VisualDensity.compact,",
      "                    title:",
      "                        Text('${loc.invoiceNumberLabel}: ${inv.invoiceNumber}'),",
      "                    subtitle: Text(",
      "                        '${loc.amountLabel}: \\$${inv.amount.toStringAsFixed(2)}'),",
      "                    trailing: Icon(Icons.receipt_long_outlined,",
      "                        color: colorScheme.primary),",
      "                    onTap: () {",
      "                      Navigator.pushNamed(",
      "                        context,",
      "                        '/hq/invoices/${inv.id}',",
      "                      );",
      "                    },",
      "                  )),",
      "            ],",
      "          ),",
      "        const SizedBox(height: 20),",
      "        Text(loc.featureComingSoon(loc.subscriptionAnalytics),",
      "            style: theme.textTheme.labelSmall",
      "                ?.copyWith(color: colorScheme.outline)),",
      "      ],",
      "    );",
      "  }",
      "",
      "  Widget _infoRow(String label, String value) {",
      "    final theme = Theme.of(context);",
      "    return Padding(",
      "      padding: const EdgeInsets.symmetric(vertical: 2),",
      "      child: Row(",
      "        children: [",
      "          Expanded(",
      "              flex: 4,",
      "              child: Text(label,",
      "                  style: theme.textTheme.bodySmall",
      "                      ?.copyWith(fontWeight: FontWeight.w600))),",
      "          Expanded(",
      "              flex: 6, child: Text(value, style: theme.textTheme.bodySmall)),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "",
      "  String _resolveInvoiceStatus(EnrichedFranchiseSubscription enriched) {",
      "    if (enriched.latestInvoice == null) return '—';",
      "    if (enriched.isInvoicePaid) return AppLocalizations.of(context)!.paid;",
      "    if (enriched.isInvoicePartial) return AppLocalizations.of(context)!.partial;",
      "    if (enriched.isInvoiceOverdue) return AppLocalizations.of(context)!.overdue;",
      "    if (enriched.isInvoiceUnpaid) return AppLocalizations.of(context)!.unpaid;",
      "    return enriched.latestInvoice!.status;",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 159,
      "file_size": 5874,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\owner\\widgets\\franchise_subscription_list_tile.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/config/app_config.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/models/enriched/enriched_franchise_subscription.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/admin/owner/widgets/franchise_subscription_summary.dart';",
      "import 'package:franchise_admin_portal/admin/owner/widgets/franchise_subscription_expanded_detail.dart';",
      "import 'package:franchise_admin_portal/admin/developer/platform/franchise_subscription_editor_dialog.dart';",
      "import 'package:provider/provider.dart';",
      "",
      "class FranchiseSubscriptionListTile extends StatefulWidget {",
      "  final EnrichedFranchiseSubscription enriched;",
      "  final VoidCallback? onRefreshRequested;",
      "",
      "  const FranchiseSubscriptionListTile({",
      "    super.key,",
      "    required this.enriched,",
      "    this.onRefreshRequested,",
      "  });",
      "",
      "  @override",
      "  State<FranchiseSubscriptionListTile> createState() =>",
      "      _FranchiseSubscriptionListTileState();",
      "}",
      "",
      "class _FranchiseSubscriptionListTileState",
      "    extends State<FranchiseSubscriptionListTile> {",
      "  bool _expanded = false;",
      "",
      "  void _toggleExpanded() => setState(() => _expanded = !_expanded);",
      "",
      "  Future<void> _editSubscription(BuildContext context) async {",
      "    final loc = AppLocalizations.of(context)!;",
      "    try {",
      "      final result = await showDialog<bool>(",
      "        context: context,",
      "        builder: (_) => FranchiseSubscriptionEditorDialog(",
      "          franchiseId: widget.enriched.franchiseId,",
      "          subscription: widget.enriched.subscription,",
      "        ),",
      "      );",
      "      if (result == true && widget.onRefreshRequested != null) {",
      "        widget.onRefreshRequested!();",
      "      }",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'edit_subscription_failed',",
      "        source: 'FranchiseSubscriptionListTile',",
      "        screen: 'franchise_subscription_list_screen',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "        contextData: {",
      "          'franchiseId': widget.enriched.franchiseId,",
      "          'subscriptionId': widget.enriched.subscription.id,",
      "        },",
      "      );",
      "      if (mounted) {",
      "        ScaffoldMessenger.of(context).showSnackBar(SnackBar(",
      "          content: Text(loc.editSubscriptionFailed),",
      "        ));",
      "      }",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final user = context.watch<AdminUserProvider>().user;",
      "    final loc = AppLocalizations.of(context)!;",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "",
      "    final isAuthorized =",
      "        user?.isDeveloper == true || user?.isPlatformOwner == true;",
      "    if (!isAuthorized) return const SizedBox.shrink();",
      "",
      "    final enriched = widget.enriched;",
      "",
      "    return Container(",
      "      decoration: BoxDecoration(",
      "        border: Border(",
      "          left: BorderSide(",
      "            color: enriched.isInvoiceOverdue",
      "                ? colorScheme.error",
      "                : Colors.transparent,",
      "            width: 4,",
      "          ),",
      "        ),",
      "      ),",
      "      child: Card(",
      "        margin: const EdgeInsets.symmetric(vertical: 6),",
      "        elevation: DesignTokens.adminCardElevation,",
      "        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),",
      "        color: colorScheme.surface,",
      "        child: Column(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            Padding(",
      "              padding: const EdgeInsets.fromLTRB(16, 16, 16, 8),",
      "              child: Row(",
      "                crossAxisAlignment: CrossAxisAlignment.start,",
      "                children: [",
      "                  // Summary + optional inline warning text",
      "                  Expanded(",
      "                    child: Column(",
      "                      crossAxisAlignment: CrossAxisAlignment.start,",
      "                      children: [",
      "                        FranchiseSubscriptionSummary(",
      "                          subscription: enriched.subscription,",
      "                        ),",
      "                        if (enriched.isInvoiceOverdue)",
      "                          Padding(",
      "                            padding: const EdgeInsets.only(top: 4),",
      "                            child: Text(",
      "                              loc.paymentOverdueWarning,",
      "                              style: theme.textTheme.labelMedium?.copyWith(",
      "                                color: colorScheme.error,",
      "                                fontWeight: FontWeight.bold,",
      "                              ),",
      "                            ),",
      "                          ),",
      "                      ],",
      "                    ),",
      "                  ),",
      "",
      "                  // Actions + badge",
      "                  Column(",
      "                    crossAxisAlignment: CrossAxisAlignment.end,",
      "                    children: [",
      "                      if (enriched.isInvoiceOverdue)",
      "                        Container(",
      "                          margin: const EdgeInsets.only(bottom: 8),",
      "                          padding: const EdgeInsets.symmetric(",
      "                            vertical: 4,",
      "                            horizontal: 8,",
      "                          ),",
      "                          decoration: BoxDecoration(",
      "                            color: colorScheme.error.withOpacity(0.1),",
      "                            borderRadius: BorderRadius.circular(16),",
      "                          ),",
      "                          child: Row(",
      "                            mainAxisSize: MainAxisSize.min,",
      "                            children: [",
      "                              Icon(Icons.warning_amber_rounded,",
      "                                  size: 16, color: colorScheme.error),",
      "                              const SizedBox(width: 4),",
      "                              Text(",
      "                                loc.overdueBadge, // \"Overdue\"",
      "                                style: theme.textTheme.labelSmall?.copyWith(",
      "                                  color: colorScheme.error,",
      "                                  fontWeight: FontWeight.w600,",
      "                                ),",
      "                              ),",
      "                            ],",
      "                          ),",
      "                        ),",
      "                      IconButton(",
      "                        icon: const Icon(Icons.edit),",
      "                        tooltip: loc.editSubscription,",
      "                        onPressed: () => _editSubscription(context),",
      "                      ),",
      "                      IconButton(",
      "                        icon: Icon(",
      "                          _expanded ? Icons.expand_less : Icons.expand_more,",
      "                          color: colorScheme.primary,",
      "                        ),",
      "                        tooltip: _expanded",
      "                            ? loc.hideDetailsTooltip",
      "                            : loc.showDetailsTooltip,",
      "                        onPressed: _toggleExpanded,",
      "                      ),",
      "                    ],",
      "                  ),",
      "                ],",
      "              ),",
      "            ),",
      "            if (_expanded)",
      "              Padding(",
      "                padding: const EdgeInsets.fromLTRB(16, 0, 16, 16),",
      "                child: FranchiseSubscriptionExpandedDetail(",
      "                  enriched: enriched,",
      "                ),",
      "              ),",
      "            if (!_expanded)",
      "              Padding(",
      "                padding: const EdgeInsets.only(left: 16, bottom: 16),",
      "                child: Text(",
      "                  loc.featureComingSoon(loc.subscriptionInsights),",
      "                  style: theme.textTheme.labelSmall?.copyWith(",
      "                    color: colorScheme.outline,",
      "                  ),",
      "                ),",
      "              ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 200,
      "file_size": 7885,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\owner\\widgets\\franchise_subscription_summary.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/models/franchise_subscription_model.dart';",
      "import 'package:franchise_admin_portal/config/app_config.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "",
      "class FranchiseSubscriptionSummary extends StatelessWidget {",
      "  final FranchiseSubscription subscription;",
      "",
      "  const FranchiseSubscriptionSummary({",
      "    super.key,",
      "    required this.subscription,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context)!;",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "    final user = context.read<AdminUserProvider>().user;",
      "",
      "    // 🔐 Access Control",
      "    final isDevOrOwner =",
      "        (user?.isDeveloper ?? false) || (user?.isPlatformOwner ?? false);",
      "    if (!isDevOrOwner) return const SizedBox.shrink();",
      "",
      "    try {",
      "      final planFeatures =",
      "          subscription.planSnapshot?['features'] as List<dynamic>? ?? [];",
      "      final planName =",
      "          subscription.planSnapshot?['name'] ?? subscription.platformPlanId;",
      "      final billingInterval = subscription.billingInterval ?? 'monthly';",
      "",
      "      final trialEndsSoon = subscription.isTrial &&",
      "          subscription.trialEndsAt != null &&",
      "          subscription.trialEndsAt!.difference(DateTime.now()).inDays <= 3;",
      "",
      "      final isPendingCancel = subscription.cancelAtPeriodEnd == true;",
      "",
      "      return Card(",
      "        margin: const EdgeInsets.symmetric(vertical: 6),",
      "        elevation: DesignTokens.adminCardElevation,",
      "        shape: RoundedRectangleBorder(",
      "          borderRadius: BorderRadius.circular(16),",
      "        ),",
      "        color: colorScheme.surface,",
      "        child: Padding(",
      "          padding: const EdgeInsets.all(16),",
      "          child: Column(",
      "            crossAxisAlignment: CrossAxisAlignment.start,",
      "            children: [",
      "              /// Franchise ID + Plan Name",
      "              Row(",
      "                children: [",
      "                  Icon(Icons.business, color: colorScheme.primary, size: 20),",
      "                  const SizedBox(width: 8),",
      "                  Expanded(",
      "                    child: Text(",
      "                      '${loc.franchiseIdLabel}: ${subscription.franchiseId}',",
      "                      style: theme.textTheme.titleSmall,",
      "                    ),",
      "                  ),",
      "                  if (isDevOrOwner)",
      "                    Chip(",
      "                      label: Text(loc.translateStatus(subscription.status)),",
      "                      backgroundColor:",
      "                          AppConfig.statusColor(subscription.status, theme),",
      "                      labelStyle: theme.textTheme.labelSmall",
      "                          ?.copyWith(color: colorScheme.onPrimary),",
      "                    ),",
      "                ],",
      "              ),",
      "",
      "              const SizedBox(height: 6),",
      "",
      "              /// Plan Details",
      "              Text(",
      "                '$planName • ${loc.perLabel(billingInterval)}',",
      "                style: theme.textTheme.bodyMedium?.copyWith(",
      "                  fontWeight: FontWeight.bold,",
      "                ),",
      "              ),",
      "",
      "              if (subscription.discountPercent > 0)",
      "                Padding(",
      "                  padding: const EdgeInsets.only(top: 4),",
      "                  child: Text(",
      "                    '${loc.discountLabel}: ${subscription.discountPercent}%',",
      "                    style: theme.textTheme.labelSmall",
      "                        ?.copyWith(color: colorScheme.secondary),",
      "                  ),",
      "                ),",
      "",
      "              if (subscription.customQuoteDetails != null)",
      "                Padding(",
      "                  padding: const EdgeInsets.only(top: 4),",
      "                  child: Text(",
      "                    '${loc.customQuote}: ${subscription.customQuoteDetails}',",
      "                    style: theme.textTheme.labelSmall",
      "                        ?.copyWith(color: colorScheme.tertiary),",
      "                  ),",
      "                ),",
      "",
      "              const SizedBox(height: 8),",
      "",
      "              /// Dates + Trial info",
      "              Text(",
      "                '${loc.nextBillingLabel}: ${AppConfig.formatDate(subscription.nextBillingDate)}',",
      "                style: theme.textTheme.bodySmall,",
      "              ),",
      "              Text(",
      "                '${loc.startDateLabel}: ${AppConfig.formatDate(subscription.startDate)}',",
      "                style: theme.textTheme.bodySmall,",
      "              ),",
      "",
      "              if (subscription.isTrial && subscription.trialEndsAt != null)",
      "                Text(",
      "                  '${loc.trialEndsLabel}: ${AppConfig.formatDate(subscription.trialEndsAt)}',",
      "                  style: theme.textTheme.bodySmall?.copyWith(",
      "                    color: trialEndsSoon",
      "                        ? colorScheme.error",
      "                        : colorScheme.secondary,",
      "                  ),",
      "                ),",
      "",
      "              if (isPendingCancel)",
      "                Padding(",
      "                  padding: const EdgeInsets.only(top: 6),",
      "                  child: Row(",
      "                    children: [",
      "                      Icon(Icons.warning_amber_outlined,",
      "                          size: 16, color: colorScheme.error),",
      "                      const SizedBox(width: 4),",
      "                      Text(",
      "                        loc.planCancelsAtPeriodEnd,",
      "                        style: theme.textTheme.labelSmall",
      "                            ?.copyWith(color: colorScheme.error),",
      "                      ),",
      "                    ],",
      "                  ),",
      "                ),",
      "",
      "              const SizedBox(height: 12),",
      "",
      "              /// Feature Set Preview",
      "              Wrap(",
      "                spacing: 6,",
      "                runSpacing: 6,",
      "                children: planFeatures",
      "                    .map((feature) => Chip(",
      "                          label: Text(",
      "                              AppConfig.featureDisplayName(feature.toString())),",
      "                          backgroundColor: colorScheme.primaryContainer,",
      "                          labelStyle: theme.textTheme.labelSmall,",
      "                        ))",
      "                    .toList(),",
      "              ),",
      "",
      "              const SizedBox(height: 10),",
      "              Text(",
      "                loc.featureComingSoon(loc.subscriptionBillingInsights),",
      "                style: theme.textTheme.labelSmall",
      "                    ?.copyWith(color: colorScheme.outline),",
      "              ),",
      "            ],",
      "          ),",
      "        ),",
      "      );",
      "    } catch (e, stack) {",
      "      ErrorLogger.log(",
      "        message: 'franchise_subscription_summary_render_error',",
      "        source: 'FranchiseSubscriptionSummary',",
      "        screen: 'franchise_subscription_list_screen',",
      "        severity: 'error',",
      "        contextData: {'exception': e.toString()},",
      "        stack: stack.toString(),",
      "      );",
      "      return const SizedBox.shrink();",
      "    }",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 184,
      "file_size": 7084,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\profile\\franchise_onboarding_screen.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/config/branding_config.dart';",
      "import 'package:franchise_admin_portal/widgets/dashboard/dashboard_section_card.dart';",
      "import 'package:franchise_admin_portal/widgets/business/business_hours_editor.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "import 'package:franchise_admin_portal/core/services/auth_service.dart';",
      "import 'dart:html' as html;",
      "import 'package:flutter/foundation.dart';",
      "import 'package:firebase_auth/firebase_auth.dart';",
      "import 'package:franchise_admin_portal/core/providers/user_profile_notifier.dart';",
      "import 'package:franchise_admin_portal/core/models/user.dart' as admin_user;",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/restaurant_type_provider.dart';",
      "import 'package:franchise_admin_portal/core/models/restaurant_type.dart';",
      "",
      "String roleToDashboardRoute(List<String> roles) {",
      "  if (roles.contains('platform_owner')) return '/platform-owner/dashboard';",
      "  if (roles.contains('hq_owner')) return '/hq-owner/dashboard';",
      "  if (roles.contains('developer')) return '/developer/dashboard';",
      "  return '/admin/dashboard';",
      "}",
      "",
      "class FranchiseOnboardingScreen extends StatefulWidget {",
      "  final String? inviteToken;",
      "  const FranchiseOnboardingScreen({super.key, this.inviteToken});",
      "",
      "  @override",
      "  State<FranchiseOnboardingScreen> createState() =>",
      "      _FranchiseOnboardingScreenState();",
      "}",
      "",
      "class _FranchiseOnboardingScreenState extends State<FranchiseOnboardingScreen> {",
      "  bool _loading = true;",
      "  String? _loadError;",
      "  Map<String, dynamic>? _inviteData;",
      "",
      "  // Franchise profile fields",
      "  late TextEditingController _nameController;",
      "  late TextEditingController _addressController;",
      "  late TextEditingController _cityController;",
      "  late TextEditingController _stateController;",
      "  late TextEditingController _zipController;",
      "  late TextEditingController _phoneController;",
      "  late TextEditingController _supportPhoneController;",
      "  late TextEditingController _emailController;",
      "  late TextEditingController _websiteController;",
      "  late TextEditingController _ownerController;",
      "  late TextEditingController _einController;",
      "  late TextEditingController _categoryController;",
      "  String? _logoUrl;",
      "  bool _saving = false;",
      "",
      "  List<Map<String, dynamic>> _businessHours = [];",
      "",
      "  String? _effectiveToken;",
      "  bool _didLoadToken = false;",
      "",
      "  @override",
      "  void didChangeDependencies() {",
      "    super.didChangeDependencies();",
      "    if (_didLoadToken) return;",
      "    _didLoadToken = true;",
      "    Provider.of<RestaurantTypeProvider>(context, listen: false).loadTypes();",
      "    _effectiveToken = widget.inviteToken;",
      "    if (_effectiveToken == null) {",
      "      final args = (ModalRoute.of(context)?.settings.arguments as Map?) ?? {};",
      "      _effectiveToken = args['token'] as String?;",
      "    }",
      "    _fetchInvite();",
      "  }",
      "",
      "  Future<void> _fetchInvite() async {",
      "    setState(() {",
      "      _loading = true;",
      "      _loadError = null;",
      "    });",
      "    if (_effectiveToken == null || _effectiveToken!.isEmpty) {",
      "      setState(() {",
      "        _loadError = \"No invite token found. Please use your invitation link.\";",
      "        _loading = false;",
      "      });",
      "      return;",
      "    }",
      "    try {",
      "      final fs = Provider.of<FirestoreService>(context, listen: false);",
      "      final invite = await fs.getFranchiseeInvitationByToken(_effectiveToken!);",
      "      if (invite == null) {",
      "        setState(() {",
      "          _loadError = AppLocalizations.of(context)!.unauthorized;",
      "          _loading = false;",
      "        });",
      "        return;",
      "      }",
      "      _inviteData = invite;",
      "",
      "      // Prefill all fields with whatever is available",
      "      _nameController =",
      "          TextEditingController(text: invite['franchiseName'] ?? '');",
      "      _addressController = TextEditingController(text: invite['address'] ?? '');",
      "      _cityController = TextEditingController(text: invite['city'] ?? '');",
      "      _stateController = TextEditingController(text: invite['state'] ?? '');",
      "      _zipController = TextEditingController(text: invite['zip'] ?? '');",
      "      _phoneController = TextEditingController(",
      "          text: invite['phone'] ?? invite['contact'] ?? '');",
      "      _supportPhoneController =",
      "          TextEditingController(text: invite['supportPhone'] ?? '');",
      "      _emailController = TextEditingController(",
      "          text: invite['businessEmail'] ?? invite['email'] ?? '');",
      "      _websiteController = TextEditingController(text: invite['website'] ?? '');",
      "      _ownerController = TextEditingController(text: invite['ownerName'] ?? '');",
      "      _einController = TextEditingController(text: invite['EIN'] ?? '');",
      "      _categoryController =",
      "          TextEditingController(text: invite['category'] ?? '');",
      "",
      "      // If franchiseId is pre-assigned, try to fetch hours for it",
      "      final franchiseId = invite['franchiseId'] ?? '';",
      "      if (franchiseId != null && franchiseId.toString().isNotEmpty) {",
      "        _businessHours = await fs.getFranchiseBusinessHours(franchiseId);",
      "      } else {",
      "        _businessHours = [];",
      "      }",
      "",
      "      setState(() => _loading = false);",
      "    } catch (e, st) {",
      "      await ErrorLogger.log(",
      "        message: 'Error loading invite: $e',",
      "        stack: st.toString(),",
      "        source: 'FranchiseOnboardingScreen',",
      "        screen: 'franchise_onboarding',",
      "        severity: 'error',",
      "      );",
      "      setState(() {",
      "        _loadError = AppLocalizations.of(context)!.failedToLoadData;",
      "        _loading = false;",
      "      });",
      "    }",
      "  }",
      "",
      "  Future<void> _saveProfile() async {",
      "    print('[FranchiseOnboardingScreen] _saveProfile: BEGIN');",
      "    setState(() {",
      "      _saving = true;",
      "      _loadError = null;",
      "    });",
      "",
      "    try {",
      "      final firestore = Provider.of<FirestoreService>(context, listen: false);",
      "      final userId = _inviteData?['invitedUserId'] as String?;",
      "      if (userId == null) throw Exception('No user linked to invite.');",
      "",
      "      print(",
      "          '[FranchiseOnboardingScreen] Preparing franchiseData for userId=$userId');",
      "",
      "      final franchiseData = {",
      "        'name': _nameController.text.trim(),",
      "        'address': {",
      "          'street': _addressController.text.trim(),",
      "          'city': _cityController.text.trim(),",
      "          'state': _stateController.text.trim(),",
      "          'zip': _zipController.text.trim(),",
      "        },",
      "        'phone': _phoneController.text.trim(),",
      "        'supportPhone': _supportPhoneController.text.trim(),",
      "        'businessEmail': _emailController.text.trim(),",
      "        'website': _websiteController.text.trim(),",
      "        'ownerName': _ownerController.text.trim(),",
      "        'EIN': _einController.text.trim(),",
      "        'category': _categoryController.text.trim(),",
      "        'logoUrl': _logoUrl ?? '',",
      "        'ownerId': userId,",
      "        'createdAt': DateTime.now().toUtc().toIso8601String(),",
      "      };",
      "",
      "      print(",
      "          '[FranchiseOnboardingScreen] Calling createFranchiseProfile with: $franchiseData');",
      "      final franchiseId = await firestore.createFranchiseProfile(",
      "        franchiseData: franchiseData,",
      "        invitedUserId: userId,",
      "      );",
      "      print('[FranchiseOnboardingScreen] Franchise created: $franchiseId');",
      "",
      "      await firestore.saveFranchiseBusinessHours(",
      "        franchiseId: franchiseId,",
      "        hours: _businessHours,",
      "      );",
      "      print(",
      "          '[FranchiseOnboardingScreen] Business hours saved for $franchiseId');",
      "",
      "      await firestore.callAcceptInvitationFunction(_effectiveToken ?? '');",
      "      print(",
      "          '[FranchiseOnboardingScreen] Invitation accepted for token $_effectiveToken');",
      "",
      "      await firestore.updateUserClaims(",
      "        uid: userId,",
      "        franchiseIds: [franchiseId],",
      "        roles: null,",
      "        additionalClaims: {'defaultFranchise': franchiseId},",
      "      );",
      "      print('[FranchiseOnboardingScreen] Custom claims updated for $userId');",
      "",
      "      // ✅ Set FranchiseProvider immediately",
      "      await Provider.of<FranchiseProvider>(context, listen: false)",
      "          .setInitialFranchiseId(franchiseId);",
      "      print(",
      "          '[FranchiseOnboardingScreen] FranchiseProvider updated to: $franchiseId');",
      "",
      "      final userUpdate = {",
      "        'completeProfile': true,",
      "        'isActive': true,",
      "        'status': 'active',",
      "        'franchiseIds': [franchiseId],",
      "        'defaultFranchise': franchiseId,",
      "      };",
      "",
      "      print(",
      "          '[FranchiseOnboardingScreen] Updating Firestore user profile: $userUpdate');",
      "      await firestore.updateUserProfile(userId, userUpdate);",
      "",
      "      final fbUser = FirebaseAuth.instance.currentUser;",
      "      if (fbUser == null) {",
      "        throw Exception(\"Firebase user unexpectedly null after onboarding\");",
      "      }",
      "",
      "      print(",
      "          '[FranchiseOnboardingScreen] Waiting for custom claims to propagate...');",
      "      int retryCount = 0;",
      "      Map<String, dynamic> claims = {};",
      "",
      "      while (retryCount < 10) {",
      "        final idToken = await fbUser.getIdTokenResult(true);",
      "        claims = idToken.claims ?? {};",
      "        final rolesFromToken = (claims['roles'] as List?)?.cast<String>() ?? [];",
      "        print(",
      "            '[FranchiseOnboardingScreen] Token claims (attempt $retryCount): roles=$rolesFromToken');",
      "",
      "        if (rolesFromToken.isNotEmpty) break;",
      "        retryCount++;",
      "        await Future.delayed(const Duration(milliseconds: 300));",
      "      }",
      "",
      "      final roles = (claims['roles'] as List?)?.cast<String>() ?? [];",
      "      if (!roles.contains('hq_owner')) {",
      "        print(",
      "            '[FranchiseOnboardingScreen] ⚠️ Custom claim \"hq_owner\" not found after retrying.');",
      "      }",
      "",
      "      // 🕓 Poll Firestore until roles are updated",
      "      admin_user.User? updatedUser;",
      "      int attempt = 0;",
      "      while (attempt < 10) {",
      "        updatedUser = await firestore.getUser(userId);",
      "        final loadedRoles = updatedUser?.roles ?? [];",
      "        print(",
      "            '[FranchiseOnboardingScreen] Firestore getUser (attempt $attempt): roles=$loadedRoles');",
      "        if (loadedRoles.isNotEmpty) break;",
      "        attempt++;",
      "        await Future.delayed(const Duration(milliseconds: 300));",
      "      }",
      "",
      "      if ((updatedUser?.roles ?? []).isEmpty) {",
      "        print(",
      "            '[FranchiseOnboardingScreen] ⚠️ Firestore user.roles still empty after retries.');",
      "      }",
      "",
      "      if (updatedUser != null) {",
      "        Provider.of<AdminUserProvider>(context, listen: false).user =",
      "            updatedUser;",
      "        Provider.of<UserProfileNotifier>(context, listen: false).reload();",
      "",
      "        // Optional: double sync FranchiseProvider if defaultFranchise is found",
      "        if (updatedUser.defaultFranchise != null &&",
      "            updatedUser.defaultFranchise!.isNotEmpty) {",
      "          await Provider.of<FranchiseProvider>(context, listen: false)",
      "              .setInitialFranchiseId(updatedUser.defaultFranchise!);",
      "        }",
      "      }",
      "",
      "      Provider.of<AuthService>(context, listen: false).clearInviteToken();",
      "      print(",
      "          '[FranchiseOnboardingScreen] Invite token cleared from localStorage');",
      "",
      "      if (mounted) {",
      "        final dashboardRoute = roleToDashboardRoute(updatedUser?.roles ?? []);",
      "        print(",
      "            '[FranchiseOnboardingScreen] Routing to dashboard: $dashboardRoute');",
      "",
      "        showDialog(",
      "          context: context,",
      "          builder: (_) => AlertDialog(",
      "            title: Text(AppLocalizations.of(context)!.account),",
      "            content:",
      "                Text(AppLocalizations.of(context)!.profileEditContactSupport),",
      "            actions: [",
      "              TextButton(",
      "                onPressed: () {",
      "                  if (kIsWeb) html.window.location.hash = '';",
      "                  Navigator.of(context).pushReplacementNamed(dashboardRoute);",
      "                },",
      "                child: Text(AppLocalizations.of(context)!.continueLabel),",
      "              ),",
      "            ],",
      "          ),",
      "        );",
      "      }",
      "    } catch (e, st) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to save franchise profile: $e',",
      "        stack: st.toString(),",
      "        source: 'FranchiseOnboardingScreen',",
      "        screen: 'franchise_onboarding',",
      "        severity: 'error',",
      "      );",
      "      print('[FranchiseOnboardingScreen] ERROR: $e\\n$st');",
      "      setState(() {",
      "        _loadError = e.toString();",
      "      });",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(content: Text('Failed to save profile: ${_loadError ?? e}')),",
      "      );",
      "    } finally {",
      "      print('[FranchiseOnboardingScreen] _saveProfile: END');",
      "      setState(() => _saving = false);",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "",
      "    return Scaffold(",
      "      backgroundColor: colorScheme.background,",
      "      appBar: AppBar(",
      "        title: Text(loc.account),",
      "        backgroundColor: colorScheme.surface,",
      "        elevation: 1,",
      "      ),",
      "      body: _loading",
      "          ? const Center(child: CircularProgressIndicator())",
      "          : _loadError != null",
      "              ? Center(",
      "                  child: Text(",
      "                    _loadError!,",
      "                    style: TextStyle(color: colorScheme.error),",
      "                  ),",
      "                )",
      "              : Padding(",
      "                  padding: const EdgeInsets.all(28.0),",
      "                  child: ListView(",
      "                    children: [",
      "                      DashboardSectionCard(",
      "                        title: loc.accountDetails,",
      "                        icon: Icons.store_mall_directory,",
      "                        builder: (context) => _buildForm(context, loc),",
      "                        showFuturePlaceholders: false,",
      "                      ),",
      "                      const SizedBox(height: 30),",
      "                      _buildFutureFeaturesPlaceholder(",
      "                          context, loc, colorScheme),",
      "                    ],",
      "                  ),",
      "                ),",
      "    );",
      "  }",
      "",
      "  Widget _buildForm(BuildContext context, AppLocalizations loc) {",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        Text(loc.account,",
      "            style: Theme.of(context)",
      "                .textTheme",
      "                .titleMedium",
      "                ?.copyWith(color: colorScheme.primary)),",
      "        const SizedBox(height: 10),",
      "        TextFormField(",
      "          controller: _nameController,",
      "          decoration: InputDecoration(",
      "            labelText: loc.name,",
      "            prefixIcon: const Icon(Icons.business),",
      "          ),",
      "        ),",
      "        const SizedBox(height: 12),",
      "        TextFormField(",
      "          controller: _addressController,",
      "          decoration: InputDecoration(",
      "            labelText: loc.streetAddress ?? \"Street Address\",",
      "            prefixIcon: const Icon(Icons.location_on_outlined),",
      "          ),",
      "        ),",
      "        const SizedBox(height: 12),",
      "        Row(",
      "          children: [",
      "            Expanded(",
      "              child: TextFormField(",
      "                controller: _cityController,",
      "                decoration: InputDecoration(",
      "                  labelText: loc.city,",
      "                  prefixIcon: const Icon(Icons.location_city),",
      "                ),",
      "              ),",
      "            ),",
      "            const SizedBox(width: 8),",
      "            Expanded(",
      "              child: TextFormField(",
      "                controller: _stateController,",
      "                decoration: InputDecoration(",
      "                  labelText: loc.state,",
      "                  prefixIcon: const Icon(Icons.map),",
      "                ),",
      "              ),",
      "            ),",
      "            const SizedBox(width: 8),",
      "            Expanded(",
      "              child: TextFormField(",
      "                controller: _zipController,",
      "                decoration: InputDecoration(",
      "                  labelText: loc.zip,",
      "                  prefixIcon: const Icon(Icons.local_post_office),",
      "                ),",
      "              ),",
      "            ),",
      "          ],",
      "        ),",
      "        const SizedBox(height: 12),",
      "        TextFormField(",
      "          controller: _phoneController,",
      "          decoration: InputDecoration(",
      "            labelText: loc.phone ?? \"Primary Phone\",",
      "            prefixIcon: const Icon(Icons.phone),",
      "          ),",
      "        ),",
      "        const SizedBox(height: 12),",
      "        TextFormField(",
      "          controller: _supportPhoneController,",
      "          decoration: InputDecoration(",
      "            labelText: loc.contactSupport,",
      "            prefixIcon: const Icon(Icons.support_agent),",
      "          ),",
      "        ),",
      "        const SizedBox(height: 12),",
      "        TextFormField(",
      "          controller: _emailController,",
      "          decoration: InputDecoration(",
      "            labelText: loc.businessEmail ?? \"Business Email\",",
      "            prefixIcon: const Icon(Icons.email_outlined),",
      "          ),",
      "        ),",
      "        const SizedBox(height: 12),",
      "        TextFormField(",
      "          controller: _websiteController,",
      "          decoration: InputDecoration(",
      "            labelText: loc.website ?? \"Website\",",
      "            prefixIcon: const Icon(Icons.public),",
      "          ),",
      "        ),",
      "        const SizedBox(height: 12),",
      "        TextFormField(",
      "          controller: _ownerController,",
      "          decoration: InputDecoration(",
      "            labelText: loc.ownerName ?? \"Owner Name\",",
      "            prefixIcon: const Icon(Icons.person_outline),",
      "          ),",
      "        ),",
      "        const SizedBox(height: 12),",
      "        TextFormField(",
      "          controller: _einController,",
      "          decoration: InputDecoration(",
      "            labelText: loc.taxIdEIN ?? \"Tax ID (EIN)\",",
      "            prefixIcon: const Icon(Icons.badge),",
      "          ),",
      "        ),",
      "        const SizedBox(height: 12),",
      "        Consumer<RestaurantTypeProvider>(",
      "          builder: (context, typeProvider, _) {",
      "            final types = typeProvider.types;",
      "            final selectedType = _categoryController.text;",
      "",
      "            return DropdownButtonFormField<String>(",
      "              value: selectedType.isNotEmpty ? selectedType : null,",
      "              decoration: InputDecoration(",
      "                labelText: loc.businessType ?? \"Business Category\",",
      "                prefixIcon: const Icon(Icons.category),",
      "              ),",
      "              items: types",
      "                  .map((type) => DropdownMenuItem<String>(",
      "                        value: type.name,",
      "                        child: Text(type.name),",
      "                      ))",
      "                  .toList(),",
      "              onChanged: (value) {",
      "                setState(() {",
      "                  _categoryController.text = value ?? '';",
      "                });",
      "              },",
      "            );",
      "          },",
      "        ),",
      "",
      "        const SizedBox(height: 24),",
      "        Text(loc.hours ?? \"Business Hours\",",
      "            style: Theme.of(context)",
      "                .textTheme",
      "                .titleMedium",
      "                ?.copyWith(color: colorScheme.primary)),",
      "        const SizedBox(height: 10),",
      "        // --- The business hours editor widget ---",
      "        BusinessHoursEditor(",
      "          initialHours: _businessHours,",
      "          onChanged: (val) => _businessHours = val,",
      "        ),",
      "        const SizedBox(height: 24),",
      "        // --- Logo upload/preview would go here ---",
      "        // (Placeholder for future image upload)",
      "        _saving",
      "            ? const CircularProgressIndicator()",
      "            : ElevatedButton.icon(",
      "                icon: const Icon(Icons.check_circle),",
      "                label: Text(loc.save),",
      "                style: ElevatedButton.styleFrom(",
      "                  backgroundColor: Theme.of(context).colorScheme.primary,",
      "                  foregroundColor: Colors.white,",
      "                ),",
      "                onPressed: _saveProfile,",
      "              ),",
      "        if (_loadError != null)",
      "          Padding(",
      "            padding: const EdgeInsets.only(top: 10),",
      "            child: Text(",
      "              _loadError!,",
      "              style: TextStyle(color: Theme.of(context).colorScheme.error),",
      "            ),",
      "          ),",
      "      ],",
      "    );",
      "  }",
      "",
      "  Widget _buildFutureFeaturesPlaceholder(",
      "      BuildContext context, AppLocalizations loc, ColorScheme colorScheme) {",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        Text(loc.futureFeatures,",
      "            style: Theme.of(context).textTheme.bodyLarge?.copyWith(",
      "                  color: colorScheme.primary,",
      "                  fontWeight: FontWeight.bold,",
      "                )),",
      "        const SizedBox(height: 7),",
      "        Text(loc.paymentMethodManagementComing,",
      "            style: TextStyle(color: colorScheme.onSurface)),",
      "        Text(loc.downloadReceiptsExportComing,",
      "            style: TextStyle(color: colorScheme.onSurface)),",
      "        Text(loc.upgradePlanAddOnsComing,",
      "            style: TextStyle(color: colorScheme.onSurface)),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 571,
      "file_size": 21402,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\profile\\universal_profile_screen.dart",
    "content": [
      "// File: lib/widgets/profile/universal_profile_screen.dart",
      "",
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/widgets/dashboard/dashboard_section_card.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/config/branding_config.dart';",
      "import 'package:franchise_admin_portal/core/providers/user_profile_notifier.dart';",
      "import 'package:franchise_admin_portal/widgets/profile/account_details_panel.dart';",
      "import 'package:franchise_admin_portal/widgets/financials/franchisee_invoice_list.dart';",
      "import 'package:franchise_admin_portal/widgets/financials/franchisee_payment_list.dart';",
      "import 'package:franchise_admin_portal/core/models/platform_payment.dart';",
      "import 'package:franchise_admin_portal/core/models/platform_invoice.dart';",
      "import 'package:franchise_admin_portal/widgets/financials/pay_invoice_dialog.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "",
      "// FUTURE: Modular import for payment methods and plan management",
      "// import 'package:franchise_admin_portal/widgets/financials/payment_method_manager.dart';",
      "// import 'package:franchise_admin_portal/widgets/support/support_contact_panel.dart';",
      "",
      "class UniversalProfileScreen extends StatefulWidget {",
      "  const UniversalProfileScreen({super.key});",
      "",
      "  @override",
      "  State<UniversalProfileScreen> createState() => _UniversalProfileScreenState();",
      "}",
      "",
      "class _UniversalProfileScreenState extends State<UniversalProfileScreen> {",
      "  bool _loading = false;",
      "  dynamic _billingData;",
      "  String? _loadError;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _fetchBilling();",
      "  }",
      "",
      "  Future<void> _fetchBilling() async {",
      "    setState(() {",
      "      _loading = true;",
      "      _loadError = null;",
      "    });",
      "",
      "    try {",
      "      final user = Provider.of<AdminUserProvider>(context, listen: false).user;",
      "      final firestore = Provider.of<FirestoreService>(context, listen: false);",
      "",
      "      if (user == null) {",
      "        setState(() {",
      "          _billingData = null;",
      "          _loadError = null;",
      "          _loading = false;",
      "        });",
      "        return;",
      "      }",
      "",
      "      // Role logic: get correct billing info",
      "      if (user.isPlatformOwner == true) {",
      "        // Platform owner: no personal billing, but could show org-wide info",
      "        setState(() => _billingData = null);",
      "      } else if (user.isFranchisee == true || user.roles.contains('hq_owner')) {",
      "        // Franchisee or HQ Owner: show platform_invoices, platform_payments",
      "        final invoices = await firestore.getPlatformInvoicesForUser(user.id);",
      "        final payments = await firestore.getPlatformPaymentsForUser(user.id);",
      "        setState(() => _billingData = {",
      "              'invoices': invoices,",
      "              'payments': payments,",
      "            });",
      "        debugPrint(",
      "            '[UniversalProfileScreen] Loaded invoices: $invoices'); // << ADD THIS",
      "        debugPrint(",
      "            '[UniversalProfileScreen] Loaded payments: $payments'); // << ADD THIS",
      "      } else if (user.isStoreOwner == true) {",
      "        // Store owner: show direct store invoices/payments",
      "        final invoices = await firestore.getStoreInvoicesForUser(user.id);",
      "        setState(() => _billingData = {",
      "              'invoices': invoices,",
      "            });",
      "      } else {",
      "        setState(() => _billingData = null);",
      "      }",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: e.toString(),",
      "        stack: stack.toString(),",
      "        source: 'UniversalProfileScreen',",
      "        screen: 'profile',",
      "        severity: 'error',",
      "      );",
      "      setState(() {",
      "        _loadError = AppLocalizations.of(context)!.failedToLoadData;",
      "      });",
      "    } finally {",
      "      setState(() => _loading = false);",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    final user = Provider.of<AdminUserProvider>(context).user;",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    final isDark = Theme.of(context).brightness == Brightness.dark;",
      "",
      "    // Access control: Developer/admin/platform only",
      "    if (user == null) {",
      "      return Scaffold(",
      "        appBar: AppBar(title: Text(loc.account)),",
      "        body: Center(child: Text(loc.unauthorized)),",
      "      );",
      "    }",
      "",
      "    return Scaffold(",
      "      appBar: AppBar(",
      "        title: Text(loc.account),",
      "        actions: [",
      "          // Avatar",
      "          Padding(",
      "            padding: const EdgeInsets.symmetric(horizontal: 14),",
      "            child: CircleAvatar(",
      "              radius: 20,",
      "              backgroundImage:",
      "                  user.avatarUrl != null && user.avatarUrl!.isNotEmpty",
      "                      ? NetworkImage(user.avatarUrl!)",
      "                      : null,",
      "              child: user.avatarUrl == null || user.avatarUrl!.isEmpty",
      "                  ? Icon(Icons.person, color: colorScheme.onPrimary)",
      "                  : null,",
      "            ),",
      "          ),",
      "        ],",
      "      ),",
      "      body: _loading",
      "          ? const Center(child: CircularProgressIndicator())",
      "          : _buildProfileBody(context, user, loc, colorScheme, isDark),",
      "    );",
      "  }",
      "",
      "  Widget _buildProfileBody(BuildContext context, dynamic user,",
      "      AppLocalizations loc, ColorScheme colorScheme, bool isDark) {",
      "    // Modular dashboard sections",
      "    return ListView(",
      "      padding: const EdgeInsets.all(24),",
      "      children: [",
      "        AccountDetailsPanel(",
      "          user: user,",
      "          onProfileUpdated: () async {",
      "            // Refresh user data from Firestore after save.",
      "            final provider =",
      "                Provider.of<AdminUserProvider>(context, listen: false);",
      "            provider.listenToAdminUser(",
      "              Provider.of<FirestoreService>(context, listen: false),",
      "              user.id,",
      "              Provider.of<FranchiseProvider>(context, listen: false),",
      "            );",
      "          },",
      "        ),",
      "        const SizedBox(height: 28),",
      "",
      "        // Role-based billing section",
      "        if (user.isPlatformOwner == true)",
      "          DashboardSectionCard(",
      "            title: loc.platformOwner,",
      "            icon: Icons.workspace_premium,",
      "            builder: (context) =>",
      "                _platformOwnerPanel(context, user, loc, colorScheme),",
      "          ),",
      "        if (user.isFranchisee == true || user.roles.contains('hq_owner'))",
      "          DashboardSectionCard(",
      "            title: loc.billingAndPayments,",
      "            icon: Icons.receipt_long,",
      "            builder: (context) =>",
      "                _franchiseeBillingPanel(context, user, loc, colorScheme),",
      "          ),",
      "        if (user.isStoreOwner == true)",
      "          DashboardSectionCard(",
      "            title: loc.storeBilling,",
      "            icon: Icons.store_mall_directory,",
      "            builder: (context) =>",
      "                _storeOwnerBillingPanel(context, user, loc, colorScheme),",
      "          ),",
      "",
      "        const SizedBox(height: 24),",
      "        DashboardSectionCard(",
      "          title: loc.securitySettings,",
      "          icon: Icons.security,",
      "          builder: (context) => _securityPanel(context, user, loc, colorScheme),",
      "        ),",
      "        const SizedBox(height: 24),",
      "        DashboardSectionCard(",
      "          title: loc.support,",
      "          icon: Icons.support_agent,",
      "          builder: (context) => _supportPanel(context, user, loc, colorScheme),",
      "        ),",
      "",
      "        // ---- Future Feature Placeholders ----",
      "        const SizedBox(height: 40),",
      "        _futureFeaturesPanel(context, loc, colorScheme),",
      "      ],",
      "    );",
      "  }",
      "",
      "  // ------------------ Profile Panels -------------------",
      "",
      "  Widget _platformOwnerPanel(BuildContext context, dynamic user,",
      "      AppLocalizations loc, ColorScheme colorScheme) {",
      "    // FUTURE: Platform metrics, manage org, link to admin/finance screens.",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        Text(loc.platformOwnerDescription,",
      "            style: TextStyle(fontSize: 16, color: colorScheme.onSurface)),",
      "        const SizedBox(height: 12),",
      "        ElevatedButton.icon(",
      "          onPressed: () =>",
      "              Navigator.pushNamed(context, '/platform-owner/dashboard'),",
      "          icon: const Icon(Icons.workspace_premium),",
      "          label: Text(loc.goToPlatformAdmin),",
      "        ),",
      "        // Future: add org billing/metrics",
      "      ],",
      "    );",
      "  }",
      "",
      "  Widget _franchiseeBillingPanel(BuildContext context, dynamic user,",
      "      AppLocalizations loc, ColorScheme colorScheme) {",
      "    // Show platform_invoices & platform_payments for this franchisee",
      "    final invoices = (_billingData?['invoices'] as List?) ?? [];",
      "    final payments = (_billingData?['payments'] as List?) ?? [];",
      "",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        FranchiseeInvoiceList(",
      "          invoices: invoices",
      "              .map((data) => PlatformInvoice.fromMap(data['id'], data))",
      "              .toList(),",
      "        ),",
      "        const SizedBox(height: 14),",
      "        FranchiseePaymentList(",
      "          payments: payments",
      "              .map((data) => PlatformPayment.fromMap(data['id'], data))",
      "              .toList(),",
      "        ),",
      "        // Future: payment methods, disputes, receipts",
      "      ],",
      "    );",
      "  }",
      "",
      "  Widget _storeOwnerBillingPanel(BuildContext context, dynamic user,",
      "      AppLocalizations loc, ColorScheme colorScheme) {",
      "    // Show store_invoices",
      "    final invoices = (_billingData?['invoices'] as List?) ?? [];",
      "",
      "    return invoices.isEmpty",
      "        ? Text(loc.noBillingRecords,",
      "            style: TextStyle(color: colorScheme.onSurface.withOpacity(0.7)))",
      "        : _invoiceListPanel(context, invoices, loc, colorScheme);",
      "  }",
      "",
      "  Widget _invoiceListPanel(BuildContext context, List invoices,",
      "      AppLocalizations loc, ColorScheme colorScheme) {",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        Text(",
      "          loc.invoices,",
      "          style: TextStyle(fontWeight: FontWeight.bold, fontSize: 15),",
      "        ),",
      "        const SizedBox(height: 6),",
      "        ...invoices.map((inv) => ListTile(",
      "            leading: Icon(Icons.receipt_long, color: colorScheme.primary),",
      "            title: Text(",
      "                '${loc.amount}: \\$${inv['amount_due'] ?? inv['amount'] ?? '-'}'),",
      "            subtitle: Text('${loc.status}: ${inv['status'] ?? '-'}'),",
      "            trailing: Icon(Icons.arrow_forward_ios,",
      "                size: 16, color: colorScheme.secondary),",
      "            onTap: () {",
      "              final parsedInvoice = PlatformInvoice.fromMap(inv, inv['id']);",
      "              debugPrint(",
      "                  '[PayInvoiceDialog] Opening dialog for invoice: ${parsedInvoice.invoiceNumber} (${parsedInvoice.id})');",
      "",
      "              showDialog(",
      "                context: context,",
      "                builder: (context) {",
      "                  debugPrint('[PayInvoiceDialog] showDialog builder called');",
      "                  return PayInvoiceDialog(invoice: parsedInvoice);",
      "                },",
      "              );",
      "            })),",
      "      ],",
      "    );",
      "  }",
      "",
      "  Widget _securityPanel(BuildContext context, dynamic user,",
      "      AppLocalizations loc, ColorScheme colorScheme) {",
      "    // Security: password, login info, etc.",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        Text(loc.securityFeaturesComingSoon,",
      "            style: TextStyle(color: colorScheme.onSurface)),",
      "        const SizedBox(height: 10),",
      "        // Future: change password, MFA, sessions, etc.",
      "        OutlinedButton.icon(",
      "          icon: const Icon(Icons.lock_reset),",
      "          label: Text(loc.resetPassword),",
      "          onPressed: () {",
      "            // TODO: Implement password reset/modal",
      "          },",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "",
      "  Widget _supportPanel(BuildContext context, dynamic user, AppLocalizations loc,",
      "      ColorScheme colorScheme) {",
      "    // Support: contact, help links",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        Text(loc.needHelpContact,",
      "            style: TextStyle(color: colorScheme.onSurface)),",
      "        const SizedBox(height: 10),",
      "        OutlinedButton.icon(",
      "          icon: const Icon(Icons.support_agent),",
      "          label: Text(loc.contactSupport),",
      "          onPressed: () {",
      "            // TODO: Show support dialog or open mailto:",
      "          },",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "",
      "  Widget _futureFeaturesPanel(",
      "      BuildContext context, AppLocalizations loc, ColorScheme colorScheme) {",
      "    // Placeholders for expansion",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        Text(loc.futureFeatures, style: TextStyle(fontWeight: FontWeight.bold)),",
      "        const SizedBox(height: 10),",
      "        Text(loc.paymentMethodManagementComing,",
      "            style: TextStyle(color: colorScheme.onSurface)),",
      "        Text(loc.downloadReceiptsExportComing,",
      "            style: TextStyle(color: colorScheme.onSurface)),",
      "        Text(loc.upgradePlanAddOnsComing,",
      "            style: TextStyle(color: colorScheme.onSurface)),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 365,
      "file_size": 13661,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\promo\\promo_bulk_upload_dialog.dart",
    "content": [
      "import 'dart:convert';",
      "import 'dart:io';",
      "import 'package:flutter/material.dart';",
      "import 'package:file_picker/file_picker.dart';",
      "import 'package:franchise_admin_portal/core/models/promo.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/widgets/confirmation_dialog.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:provider/provider.dart';",
      "",
      "class PromoBulkUploadDialog extends StatefulWidget {",
      "  final VoidCallback? onUploadComplete;",
      "  const PromoBulkUploadDialog({super.key, this.onUploadComplete});",
      "",
      "  @override",
      "  State<PromoBulkUploadDialog> createState() => _PromoBulkUploadDialogState();",
      "}",
      "",
      "class _PromoBulkUploadDialogState extends State<PromoBulkUploadDialog> {",
      "  bool isLoading = false;",
      "  String? errorMsg;",
      "  List<Promo> previewPromos = [];",
      "",
      "  Future<void> _pickAndParseFile() async {",
      "    setState(() => errorMsg = null);",
      "    final result = await FilePicker.platform",
      "        .pickFiles(type: FileType.custom, allowedExtensions: ['json', 'csv']);",
      "    if (result == null || result.files.isEmpty) return;",
      "",
      "    try {",
      "      final file = File(result.files.single.path!);",
      "      final content = await file.readAsString();",
      "      if (result.files.single.extension == 'json') {",
      "        final List<dynamic> data = json.decode(content);",
      "        previewPromos =",
      "            data.map((e) => Promo.fromFirestore(e, e['id'] ?? '')).toList();",
      "      } else if (result.files.single.extension == 'csv') {",
      "        // TODO: Add CSV parsing logic (headers must match Promo fields)",
      "        throw UnimplementedError('CSV import not implemented.');",
      "      }",
      "      setState(() {});",
      "    } catch (e) {",
      "      setState(() => errorMsg = 'Failed to parse file: $e');",
      "    }",
      "  }",
      "",
      "  Future<void> _uploadAll() async {",
      "    final franchiseId =",
      "        Provider.of<FranchiseProvider>(context, listen: false).franchiseId;",
      "",
      "    setState(() => isLoading = true);",
      "    for (final promo in previewPromos) {",
      "      await FirestoreService().addPromo(franchiseId, promo);",
      "    }",
      "    setState(() => isLoading = false);",
      "    if (widget.onUploadComplete != null) widget.onUploadComplete!();",
      "    Navigator.of(context).pop();",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return AlertDialog(",
      "      title: const Text('Bulk Upload Promos'),",
      "      content: Column(",
      "        mainAxisSize: MainAxisSize.min,",
      "        children: [",
      "          ElevatedButton.icon(",
      "            icon: const Icon(Icons.upload_file),",
      "            label: const Text('Choose File (JSON/CSV)'),",
      "            onPressed: _pickAndParseFile,",
      "          ),",
      "          if (errorMsg != null)",
      "            Padding(",
      "              padding: const EdgeInsets.all(8.0),",
      "              child: Text(errorMsg!, style: const TextStyle(color: Colors.red)),",
      "            ),",
      "          if (previewPromos.isNotEmpty)",
      "            Text('Preview (${previewPromos.length} items):'),",
      "          if (previewPromos.isNotEmpty)",
      "            SizedBox(",
      "              height: 180,",
      "              child: ListView(",
      "                children: previewPromos",
      "                    .take(5)",
      "                    .map((promo) => ListTile(",
      "                          title: Text('${promo.type} (${promo.discount})'),",
      "                          subtitle: Text(",
      "                              'Active: ${promo.active}, Ends: ${promo.endDate}'),",
      "                        ))",
      "                    .toList(),",
      "              ),",
      "            ),",
      "        ],",
      "      ),",
      "      actions: [",
      "        TextButton(",
      "            onPressed: () => Navigator.pop(context),",
      "            child: const Text('Cancel')),",
      "        if (previewPromos.isNotEmpty)",
      "          ElevatedButton(",
      "            onPressed: isLoading ? null : _uploadAll,",
      "            child: isLoading",
      "                ? const CircularProgressIndicator()",
      "                : const Text('Upload All'),",
      "          ),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 109,
      "file_size": 3967,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\promo\\promo_export_dialog.dart",
    "content": [
      "// ignore: unused_import",
      "import 'package:flutter/foundation.dart' show kIsWeb;",
      "import 'dart:convert';",
      "import 'package:flutter/material.dart';",
      "// Don't import dart:io at top-level if you want to build for web.",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:path_provider/path_provider.dart'",
      "    if (dart.library.io) 'package:path_provider/path_provider.dart';",
      "import 'dart:io' if (dart.library.io) 'dart:io';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'dart:html' as html; // For web file download",
      "",
      "class PromoExportDialog extends StatefulWidget {",
      "  const PromoExportDialog({Key? key}) : super(key: key);",
      "",
      "  @override",
      "  State<PromoExportDialog> createState() => _PromoExportDialogState();",
      "}",
      "",
      "class _PromoExportDialogState extends State<PromoExportDialog> {",
      "  bool isExporting = false;",
      "  String? downloadPath;",
      "",
      "  Future<void> _exportPromos() async {",
      "    final franchiseId =",
      "        Provider.of<FranchiseProvider>(context, listen: false).franchiseId;",
      "    setState(() => isExporting = true);",
      "    final promos = await FirestoreService().getPromos(franchiseId).first;",
      "    final csvHeader = [/* ... */];",
      "    final csvRows = [/* ... */];",
      "    final csvContent = '${csvHeader.join(',')}\\n${csvRows.join('\\n')}';",
      "",
      "    if (kIsWeb) {",
      "      // Web: Offer download via AnchorElement",
      "      final bytes = utf8.encode(csvContent);",
      "      final blob = html.Blob([bytes]);",
      "      final url = html.Url.createObjectUrlFromBlob(blob);",
      "      final anchor = html.AnchorElement(href: url)",
      "        ..setAttribute(\"download\", \"promos_export.csv\")",
      "        ..click();",
      "      html.Url.revokeObjectUrl(url);",
      "      setState(() {",
      "        downloadPath = \"Download started (browser)\";",
      "        isExporting = false;",
      "      });",
      "    } else {",
      "      // Mobile/Desktop: Write to file",
      "      final dir = await getApplicationDocumentsDirectory();",
      "      final file = File(",
      "          '${dir.path}/promos_export_${DateTime.now().millisecondsSinceEpoch}.csv');",
      "      await file.writeAsString(csvContent);",
      "",
      "      setState(() {",
      "        downloadPath = file.path;",
      "        isExporting = false;",
      "      });",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return AlertDialog(",
      "      title: const Text('Export Promos'),",
      "      content: isExporting",
      "          ? const Center(child: CircularProgressIndicator())",
      "          : downloadPath != null",
      "              ? SelectableText('Exported to: $downloadPath')",
      "              : const Text('Export all active promos to CSV.'),",
      "      actions: [",
      "        TextButton(",
      "            onPressed: () => Navigator.pop(context),",
      "            child: const Text('Close')),",
      "        if (downloadPath == null && !isExporting)",
      "          ElevatedButton(onPressed: _exportPromos, child: const Text('Export')),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 79,
      "file_size": 2914,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\promo\\promo_form_dialog.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/core/models/promo.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "",
      "class PromoFormDialog extends StatefulWidget {",
      "  final Promo? promo;",
      "  final Future<void> Function(Promo)? onSave; // <-- FIXED",
      "",
      "  const PromoFormDialog({super.key, this.promo, this.onSave}); // <-- FIXED",
      "",
      "  @override",
      "  State<PromoFormDialog> createState() => _PromoFormDialogState();",
      "}",
      "",
      "class _PromoFormDialogState extends State<PromoFormDialog> {",
      "  final _formKey = GlobalKey<FormState>();",
      "",
      "  late String name;",
      "  late String description;",
      "  late String code;",
      "  late String type;",
      "  late double discount;",
      "  late int maxUses;",
      "  late String maxUsesType;",
      "  late double minOrderValue;",
      "  late DateTime startDate;",
      "  late DateTime endDate;",
      "  late bool active;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    name = widget.promo?.name ?? '';",
      "    description = widget.promo?.description ?? '';",
      "    code = widget.promo?.code ?? '';",
      "    type = widget.promo?.type ?? '';",
      "    discount = widget.promo?.discount ?? 0.0;",
      "    maxUses = widget.promo?.maxUses ?? 0;",
      "    maxUsesType = widget.promo?.maxUsesType ?? 'total';",
      "    minOrderValue = widget.promo?.minOrderValue ?? 0.0;",
      "    startDate = widget.promo?.startDate ?? DateTime.now();",
      "    endDate =",
      "        widget.promo?.endDate ?? DateTime.now().add(const Duration(days: 30));",
      "    active = widget.promo?.active ?? true;",
      "  }",
      "",
      "  Future<void> _save() async {",
      "    final franchiseId =",
      "        Provider.of<FranchiseProvider>(context, listen: false).franchiseId;",
      "    if (!_formKey.currentState!.validate()) return;",
      "    _formKey.currentState!.save();",
      "",
      "    final promo = Promo(",
      "      id: widget.promo?.id ?? UniqueKey().toString(),",
      "      name: name,",
      "      description: description,",
      "      code: code,",
      "      type: type,",
      "      items: widget.promo?.items ?? [],",
      "      discount: discount,",
      "      maxUses: maxUses,",
      "      maxUsesType: maxUsesType,",
      "      minOrderValue: minOrderValue,",
      "      startDate: startDate,",
      "      endDate: endDate,",
      "      active: active,",
      "      target: widget.promo?.target,",
      "      timeRules: widget.promo?.timeRules,",
      "    );",
      "",
      "    if (widget.onSave != null) {",
      "      await widget.onSave!(promo); // Safe to await: always Future",
      "    } else {",
      "      // Fallback: Dialog saves directly if no callback supplied (legacy usage)",
      "      if (widget.promo != null) {",
      "        await FirestoreService().updatePromo(franchiseId, promo);",
      "      } else {",
      "        await FirestoreService().addPromo(franchiseId, promo);",
      "      }",
      "    }",
      "    if (mounted) Navigator.of(context).pop();",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return AlertDialog(",
      "      title: Text(widget.promo == null ? 'Create Promo' : 'Edit Promo'),",
      "      content: SingleChildScrollView(",
      "        child: Form(",
      "          key: _formKey,",
      "          child: Column(",
      "            children: [",
      "              TextFormField(",
      "                initialValue: name,",
      "                decoration: const InputDecoration(labelText: 'Name'),",
      "                onSaved: (v) => name = v ?? '',",
      "                validator: (v) => v == null || v.isEmpty ? 'Required' : null,",
      "              ),",
      "              TextFormField(",
      "                initialValue: description,",
      "                decoration: const InputDecoration(labelText: 'Description'),",
      "                onSaved: (v) => description = v ?? '',",
      "                validator: (v) => v == null || v.isEmpty ? 'Required' : null,",
      "              ),",
      "              TextFormField(",
      "                initialValue: code,",
      "                decoration: const InputDecoration(labelText: 'Promo Code'),",
      "                onSaved: (v) => code = v ?? '',",
      "                validator: (v) => v == null || v.isEmpty ? 'Required' : null,",
      "              ),",
      "              TextFormField(",
      "                initialValue: type,",
      "                decoration: const InputDecoration(labelText: 'Type'),",
      "                onSaved: (v) => type = v ?? '',",
      "                validator: (v) => v == null || v.isEmpty ? 'Required' : null,",
      "              ),",
      "              TextFormField(",
      "                initialValue: discount.toString(),",
      "                decoration: const InputDecoration(labelText: 'Discount'),",
      "                keyboardType: TextInputType.number,",
      "                onSaved: (v) => discount = double.tryParse(v ?? '0') ?? 0,",
      "                validator: (v) => v == null || v.isEmpty ? 'Required' : null,",
      "              ),",
      "              TextFormField(",
      "                initialValue: maxUses.toString(),",
      "                decoration: const InputDecoration(labelText: 'Max Uses'),",
      "                keyboardType: TextInputType.number,",
      "                onSaved: (v) => maxUses = int.tryParse(v ?? '0') ?? 0,",
      "                validator: (v) => v == null || v.isEmpty ? 'Required' : null,",
      "              ),",
      "              TextFormField(",
      "                initialValue: maxUsesType,",
      "                decoration: const InputDecoration(labelText: 'Max Uses Type'),",
      "                onSaved: (v) => maxUsesType = v ?? 'total',",
      "                validator: (v) => v == null || v.isEmpty ? 'Required' : null,",
      "              ),",
      "              TextFormField(",
      "                initialValue: minOrderValue.toString(),",
      "                decoration: const InputDecoration(labelText: 'Min Order Value'),",
      "                keyboardType: TextInputType.number,",
      "                onSaved: (v) => minOrderValue = double.tryParse(v ?? '0') ?? 0,",
      "                validator: (v) => v == null || v.isEmpty ? 'Required' : null,",
      "              ),",
      "              SwitchListTile(",
      "                value: active,",
      "                title: const Text('Active'),",
      "                onChanged: (v) => setState(() => active = v),",
      "              ),",
      "              ListTile(",
      "                title: Text(",
      "                    'Start Date: ${startDate.toLocal().toString().split(' ')[0]}'),",
      "                trailing: const Icon(Icons.calendar_today),",
      "                onTap: () async {",
      "                  final picked = await showDatePicker(",
      "                    context: context,",
      "                    initialDate: startDate,",
      "                    firstDate: DateTime(2022),",
      "                    lastDate: DateTime(2100),",
      "                  );",
      "                  if (picked != null) setState(() => startDate = picked);",
      "                },",
      "              ),",
      "              ListTile(",
      "                title: Text(",
      "                    'End Date: ${endDate.toLocal().toString().split(' ')[0]}'),",
      "                trailing: const Icon(Icons.calendar_today),",
      "                onTap: () async {",
      "                  final picked = await showDatePicker(",
      "                    context: context,",
      "                    initialDate: endDate,",
      "                    firstDate: DateTime(2022),",
      "                    lastDate: DateTime(2100),",
      "                  );",
      "                  if (picked != null) setState(() => endDate = picked);",
      "                },",
      "              ),",
      "            ],",
      "          ),",
      "        ),",
      "      ),",
      "      actions: [",
      "        TextButton(",
      "          onPressed: () => Navigator.pop(context),",
      "          child: const Text('Cancel'),",
      "        ),",
      "        ElevatedButton(",
      "          onPressed: _save,",
      "          child: const Text('Save'),",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 195,
      "file_size": 7443,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\promo\\promo_management_screen.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/models/promo.dart';",
      "import 'package:franchise_admin_portal/core/models/user.dart' as admin_user;",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/services/audit_log_service.dart';",
      "import 'package:franchise_admin_portal/widgets/loading_shimmer_widget.dart';",
      "import 'package:franchise_admin_portal/widgets/empty_state_widget.dart';",
      "import 'package:franchise_admin_portal/admin/promo/promo_form_dialog.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/user_profile_notifier.dart';",
      "import 'package:franchise_admin_portal/core/utils/user_permissions.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/widgets/admin/admin_unauthorized_widget.dart';",
      "import 'package:franchise_admin_portal/core/providers/role_guard.dart';",
      "import 'package:franchise_admin_portal/widgets/subscription_access_guard.dart';",
      "import 'package:franchise_admin_portal/widgets/subscription/grace_period_banner.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "",
      "class PromoManagementScreen extends StatelessWidget {",
      "  const PromoManagementScreen({super.key});",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "    final franchiseId = context.watch<FranchiseProvider>().franchiseId;",
      "    final firestoreService =",
      "        Provider.of<FirestoreService>(context, listen: false);",
      "    final userProvider = context.watch<AdminUserProvider>();",
      "    final user = userProvider.user;",
      "    final loading = userProvider.loading;",
      "",
      "    if (user == null) {",
      "      if (loading) {",
      "        return const Scaffold(body: Center(child: CircularProgressIndicator()));",
      "      } else {",
      "        return const Scaffold(",
      "            body: Center(child: Text('Unauthorized — No admin user')));",
      "      }",
      "    }",
      "",
      "    final canEdit = true;",
      "",
      "    return RoleGuard(",
      "      allowedRoles: const [",
      "        'platform_owner',",
      "        'hq_owner',",
      "        'manager',",
      "        'developer',",
      "        'admin'",
      "      ],",
      "      featureName: 'promo_management_screen',",
      "      screen: 'PromoManagementScreen',",
      "      child: SubscriptionAccessGuard(",
      "        child: Scaffold(",
      "          backgroundColor: colorScheme.background,",
      "          body: Row(",
      "            crossAxisAlignment: CrossAxisAlignment.start,",
      "            children: [",
      "              Expanded(",
      "                flex: 11,",
      "                child: Padding(",
      "                  padding:",
      "                      const EdgeInsets.only(top: 24.0, left: 24.0, right: 24.0),",
      "                  child: Column(",
      "                    crossAxisAlignment: CrossAxisAlignment.start,",
      "                    children: [",
      "                      const GracePeriodBanner(),",
      "                      Padding(",
      "                        padding: const EdgeInsets.only(bottom: 12.0),",
      "                        child: Row(",
      "                          crossAxisAlignment: CrossAxisAlignment.center,",
      "                          children: [",
      "                            Text(",
      "                              \"Promo Management\",",
      "                              style: TextStyle(",
      "                                color: colorScheme.onBackground,",
      "                                fontWeight: FontWeight.bold,",
      "                                fontSize: 22,",
      "                              ),",
      "                            ),",
      "                            const Spacer(),",
      "                            if (canEdit)",
      "                              IconButton(",
      "                                icon: Icon(Icons.add,",
      "                                    color: colorScheme.onSurface),",
      "                                tooltip: \"Add Promotion\",",
      "                                onPressed: () {",
      "                                  showDialog(",
      "                                    context: context,",
      "                                    builder: (_) => PromoFormDialog(",
      "                                      onSave: (promo) async {",
      "                                        try {",
      "                                          await firestoreService.addPromo(",
      "                                              franchiseId, promo);",
      "                                          await AuditLogService().addLog(",
      "                                            franchiseId: franchiseId,",
      "                                            userId: user.id,",
      "                                            action: 'add_promo',",
      "                                            targetType: 'promo',",
      "                                            targetId: promo.id,",
      "                                            details: {'name': promo.name},",
      "                                          );",
      "                                        } catch (e, stack) {",
      "                                          await ErrorLogger.log(",
      "                                            message: e.toString(),",
      "                                            source: 'promo_management_screen',",
      "                                            screen: 'PromoManagementScreen',",
      "                                            stack: stack.toString(),",
      "                                            contextData: {",
      "                                              'franchiseId': franchiseId,",
      "                                              'userId': user.id,",
      "                                              'promoId': promo.id,",
      "                                              'operation': 'add',",
      "                                            },",
      "                                          );",
      "                                        }",
      "                                      },",
      "                                    ),",
      "                                  );",
      "                                },",
      "                              ),",
      "                          ],",
      "                        ),",
      "                      ),",
      "                      Expanded(",
      "                        child: StreamBuilder<List<Promo>>(",
      "                          stream: firestoreService.getPromos(franchiseId),",
      "                          builder: (context, snapshot) {",
      "                            if (snapshot.connectionState ==",
      "                                ConnectionState.waiting) {",
      "                              return const LoadingShimmerWidget();",
      "                            }",
      "                            if (snapshot.hasError) {",
      "                              return const EmptyStateWidget(",
      "                                title: \"Error loading promos\",",
      "                                message: \"Please try again later.\",",
      "                              );",
      "                            }",
      "                            if (!snapshot.hasData || snapshot.data!.isEmpty) {",
      "                              return const EmptyStateWidget(",
      "                                title: \"No Promotions\",",
      "                                message: \"No promotions yet.\",",
      "                              );",
      "                            }",
      "                            final promos = snapshot.data!;",
      "                            return ListView.separated(",
      "                              itemCount: promos.length,",
      "                              separatorBuilder: (_, __) =>",
      "                                  Divider(color: colorScheme.outline),",
      "                              itemBuilder: (context, i) {",
      "                                final promo = promos[i];",
      "                                return ListTile(",
      "                                  title: Text(",
      "                                    promo.name.isNotEmpty",
      "                                        ? promo.name",
      "                                        : 'Untitled Promo',",
      "                                    style:",
      "                                        TextStyle(color: colorScheme.onSurface),",
      "                                  ),",
      "                                  subtitle: Text(",
      "                                    promo.description,",
      "                                    style: TextStyle(",
      "                                        color: colorScheme.onSurfaceVariant),",
      "                                  ),",
      "                                  trailing: Row(",
      "                                    mainAxisSize: MainAxisSize.min,",
      "                                    children: [",
      "                                      if (canEdit)",
      "                                        IconButton(",
      "                                          icon: const Icon(Icons.edit,",
      "                                              color: Colors.blue),",
      "                                          onPressed: () {",
      "                                            showDialog(",
      "                                              context: context,",
      "                                              builder: (_) => PromoFormDialog(",
      "                                                promo: promo,",
      "                                                onSave: (updated) async {",
      "                                                  try {",
      "                                                    await firestoreService",
      "                                                        .updatePromo(",
      "                                                            franchiseId,",
      "                                                            updated);",
      "                                                    await AuditLogService()",
      "                                                        .addLog(",
      "                                                      franchiseId: franchiseId,",
      "                                                      userId: user.id,",
      "                                                      action: 'update_promo',",
      "                                                      targetType: 'promo',",
      "                                                      targetId: updated.id,",
      "                                                      details: {",
      "                                                        'name': updated.name",
      "                                                      },",
      "                                                    );",
      "                                                  } catch (e, stack) {",
      "                                                    await ErrorLogger.log(",
      "                                                      message: e.toString(),",
      "                                                      source:",
      "                                                          'promo_management_screen',",
      "                                                      screen:",
      "                                                          'PromoManagementScreen',",
      "                                                      stack: stack.toString(),",
      "                                                      contextData: {",
      "                                                        'franchiseId':",
      "                                                            franchiseId,",
      "                                                        'userId': user.id,",
      "                                                        'promoId': updated.id,",
      "                                                        'operation': 'update',",
      "                                                      },",
      "                                                    );",
      "                                                  }",
      "                                                },",
      "                                              ),",
      "                                            );",
      "                                          },",
      "                                        ),",
      "                                      if (canEdit)",
      "                                        IconButton(",
      "                                          icon: const Icon(Icons.delete,",
      "                                              color: Colors.red),",
      "                                          onPressed: () => _confirmDelete(",
      "                                            context,",
      "                                            firestoreService,",
      "                                            promo.id,",
      "                                            user,",
      "                                          ),",
      "                                        ),",
      "                                    ],",
      "                                  ),",
      "                                );",
      "                              },",
      "                            );",
      "                          },",
      "                        ),",
      "                      ),",
      "                    ],",
      "                  ),",
      "                ),",
      "              ),",
      "              const Expanded(flex: 9, child: SizedBox()),",
      "            ],",
      "          ),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  void _confirmDelete(BuildContext context, FirestoreService service,",
      "      String promoId, admin_user.User user) {",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "    showDialog(",
      "      context: context,",
      "      builder: (_) => AlertDialog(",
      "        title: Text(\"Delete Promotion\",",
      "            style: TextStyle(color: colorScheme.onSurface)),",
      "        content: Text(\"Are you sure you want to delete this promotion?\",",
      "            style: TextStyle(color: colorScheme.onSurfaceVariant)),",
      "        actions: [",
      "          TextButton(",
      "            onPressed: () => Navigator.pop(context),",
      "            child: Text(\"Cancel\", style: TextStyle(color: colorScheme.primary)),",
      "          ),",
      "          ElevatedButton(",
      "            onPressed: () async {",
      "              final franchiseId =",
      "                  Provider.of<FranchiseProvider>(context, listen: false)",
      "                      .franchiseId;",
      "              try {",
      "                await service.deletePromo(franchiseId, promoId);",
      "                await AuditLogService().addLog(",
      "                  franchiseId: franchiseId,",
      "                  userId: user.id,",
      "                  action: 'delete_promo',",
      "                  targetType: 'promo',",
      "                  targetId: promoId,",
      "                  details: {},",
      "                );",
      "              } catch (e, stack) {",
      "                await ErrorLogger.log(",
      "                  message: e.toString(),",
      "                  source: 'promo_management_screen',",
      "                  screen: 'PromoManagementScreen',",
      "                  stack: stack.toString(),",
      "                  contextData: {",
      "                    'franchiseId': franchiseId,",
      "                    'userId': user.id,",
      "                    'promoId': promoId,",
      "                    'operation': 'delete',",
      "                  },",
      "                );",
      "              }",
      "              if (!context.mounted) return;",
      "              Navigator.pop(context);",
      "            },",
      "            style: ElevatedButton.styleFrom(backgroundColor: Colors.red),",
      "            child: const Text(\"Delete\"),",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 305,
      "file_size": 15086,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\sign_in\\sign_in_screen.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:firebase_auth/firebase_auth.dart';",
      "import 'package:franchise_admin_portal/core/services/auth_service.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/config/branding_config.dart';",
      "import 'package:franchise_admin_portal/widgets/social_sign_in_buttons.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:cloud_functions/cloud_functions.dart';",
      "import 'package:franchise_admin_portal/core/providers/user_profile_notifier.dart';",
      "",
      "class SignInScreen extends StatefulWidget {",
      "  const SignInScreen({super.key});",
      "",
      "  @override",
      "  State<SignInScreen> createState() => _SignInScreenState();",
      "}",
      "",
      "class _SignInScreenState extends State<SignInScreen> {",
      "  bool _isLoading = false;",
      "  String? _errorMessage;",
      "",
      "  Future<void> _callSetClaimsForExistingUsers() async {",
      "    setState(() => _isLoading = true);",
      "    try {",
      "      final HttpsCallable callable = FirebaseFunctions.instance.httpsCallable(",
      "        'setClaimsForExistingUsers',",
      "        options: HttpsCallableOptions(",
      "          timeout: const Duration(seconds: 30),",
      "        ),",
      "      );",
      "      final result = await callable.call(<String, dynamic>{});",
      "      setState(() {",
      "        _errorMessage = \"Claims sync OK: ${result.data}\";",
      "      });",
      "    } catch (e) {",
      "      setState(() {",
      "        _errorMessage = \"Sync claims failed: $e\";",
      "      });",
      "    } finally {",
      "      setState(() => _isLoading = false);",
      "    }",
      "  }",
      "",
      "  void _setLoading(bool value) {",
      "    setState(() {",
      "      _isLoading = value;",
      "      _errorMessage = null;",
      "    });",
      "  }",
      "",
      "  void _handleSuccess(User? user) async {",
      "    if (user != null) {",
      "      await user.getIdToken(true);",
      "      debugPrint('User signed in: ${user.email}');",
      "      final firestoreService =",
      "          Provider.of<FirestoreService>(context, listen: false);",
      "",
      "      // --- NEW: Check Firestore user status ---",
      "      final userDoc = await firestoreService.getUser(user.uid);",
      "      if (userDoc == null) {",
      "        // Not invited or user doc deleted",
      "        await FirebaseAuth.instance.signOut();",
      "        setState(() {",
      "          _errorMessage = \"Your account is not authorized. Contact your admin.\";",
      "        });",
      "        return;",
      "      }",
      "      if (userDoc.status != \"active\" && userDoc.status != \"invited\") {",
      "        await FirebaseAuth.instance.signOut();",
      "        setState(() {",
      "          _errorMessage =",
      "              \"Your account is not active. Status: ${userDoc.status}\";",
      "        });",
      "        return;",
      "      }",
      "",
      "      // Existing logic:",
      "      final userProfileNotifier =",
      "          Provider.of<UserProfileNotifier>(context, listen: false);",
      "      userProfileNotifier.listenToUser(firestoreService, user.uid);",
      "",
      "      final token =",
      "          Provider.of<AuthService>(context, listen: false).getInviteToken();",
      "      if (token != null) {",
      "        debugPrint(",
      "            '[SignInScreen] Navigating to onboarding, token=$token'); // <-- ADD THIS LINE",
      "        Provider.of<AuthService>(context, listen: false).clearInviteToken();",
      "        Navigator.pushReplacementNamed(context, '/franchise-onboarding',",
      "            arguments: {'token': token});",
      "        return;",
      "      }",
      "      // Go to dashboard, etc.",
      "    }",
      "  }",
      "",
      "  void _handleError(String error) {",
      "    setState(() => _errorMessage = error);",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    print('[sign_in_screen.dart] build: Sign-in screen showing');",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    final theme = Theme.of(context);",
      "",
      "    // --- Email/password fields state ---",
      "    final emailController = TextEditingController();",
      "    final passwordController = TextEditingController();",
      "    bool obscurePassword = true;",
      "    String? emailError;",
      "    String? passwordError;",
      "",
      "    return Scaffold(",
      "      backgroundColor: DesignTokens.backgroundColor,",
      "      body: Center(",
      "        child: SingleChildScrollView(",
      "          padding: const EdgeInsets.symmetric(horizontal: 32.0, vertical: 24.0),",
      "          child: StatefulBuilder(builder: (context, setDialogState) {",
      "            return Column(",
      "              mainAxisSize: MainAxisSize.min,",
      "              crossAxisAlignment: CrossAxisAlignment.center,",
      "              children: [",
      "                Image.asset(",
      "                  BrandingConfig.logoMain,",
      "                  height: 80,",
      "                ),",
      "                const SizedBox(height: 24),",
      "                Text(",
      "                  loc.adminSignInTitle,",
      "                  style: theme.textTheme.headlineSmall?.copyWith(",
      "                    fontWeight: FontWeight.bold,",
      "                  ),",
      "                ),",
      "                const SizedBox(height: 16),",
      "                Text(",
      "                  loc.adminSignInDescription,",
      "                  textAlign: TextAlign.center,",
      "                  style: theme.textTheme.bodyMedium,",
      "                ),",
      "                const SizedBox(height: 32),",
      "                if (_errorMessage != null)",
      "                  Padding(",
      "                    padding: const EdgeInsets.only(bottom: 16.0),",
      "                    child: Text(",
      "                      _errorMessage!,",
      "                      style: const TextStyle(",
      "                        color: Colors.red,",
      "                        fontWeight: FontWeight.w600,",
      "                      ),",
      "                    ),",
      "                  ),",
      "                // --- EMAIL/PASSWORD SIGN-IN SECTION ---",
      "                TextField(",
      "                  controller: emailController,",
      "                  decoration: InputDecoration(",
      "                    labelText: loc.emailLabel ?? \"Email\",",
      "                    errorText: emailError,",
      "                    prefixIcon: const Icon(Icons.email_outlined),",
      "                    border: const OutlineInputBorder(),",
      "                  ),",
      "                  keyboardType: TextInputType.emailAddress,",
      "                  enabled: !_isLoading,",
      "                  autofillHints: const [AutofillHints.email],",
      "                ),",
      "                const SizedBox(height: 12),",
      "                TextField(",
      "                  controller: passwordController,",
      "                  decoration: InputDecoration(",
      "                    labelText: loc.password ?? \"Password\",",
      "                    errorText: passwordError,",
      "                    prefixIcon: const Icon(Icons.lock_outline),",
      "                    border: const OutlineInputBorder(),",
      "                    suffixIcon: IconButton(",
      "                      icon: Icon(obscurePassword",
      "                          ? Icons.visibility_off",
      "                          : Icons.visibility),",
      "                      onPressed: () {",
      "                        setDialogState(() {",
      "                          obscurePassword = !obscurePassword;",
      "                        });",
      "                      },",
      "                    ),",
      "                  ),",
      "                  obscureText: obscurePassword,",
      "                  enabled: !_isLoading,",
      "                  autofillHints: const [AutofillHints.password],",
      "                ),",
      "                const SizedBox(height: 10),",
      "                SizedBox(",
      "                  width: double.infinity,",
      "                  child: ElevatedButton(",
      "                    onPressed: _isLoading",
      "                        ? null",
      "                        : () async {",
      "                            setState(() {",
      "                              _isLoading = true;",
      "                              _errorMessage = null;",
      "                              emailError = null;",
      "                              passwordError = null;",
      "                            });",
      "                            final email = emailController.text.trim();",
      "                            final password = passwordController.text;",
      "                            // --- Simple validation",
      "                            if (email.isEmpty || !email.contains('@')) {",
      "                              setDialogState(() {",
      "                                emailError =",
      "                                    loc.emailRequired ?? \"Email required\";",
      "                              });",
      "                              setState(() => _isLoading = false);",
      "                              return;",
      "                            }",
      "                            if (password.isEmpty || password.length < 6) {",
      "                              setDialogState(() {",
      "                                passwordError = loc.passwordTooShort ??",
      "                                    \"Password required (min 6 chars)\";",
      "                              });",
      "                              setState(() => _isLoading = false);",
      "                              return;",
      "                            }",
      "                            try {",
      "                              final authService = Provider.of<AuthService>(",
      "                                  context,",
      "                                  listen: false);",
      "                              final user = await authService.signInWithEmail(",
      "                                  email, password);",
      "                              if (user != null) {",
      "                                _handleSuccess(user);",
      "                              } else {",
      "                                setState(() => _errorMessage =",
      "                                    \"Sign in failed. Check your credentials.\");",
      "                              }",
      "                            } catch (e) {",
      "                              setState(() => _errorMessage = e.toString());",
      "                            }",
      "                            setState(() => _isLoading = false);",
      "                          },",
      "                    child: _isLoading",
      "                        ? const SizedBox(",
      "                            width: 18,",
      "                            height: 18,",
      "                            child: CircularProgressIndicator(strokeWidth: 2))",
      "                        : Text(",
      "                            loc.signInWithEmailButton ?? \"Sign in with Email\"),",
      "                  ),",
      "                ),",
      "                // --- FORGOT PASSWORD ---",
      "                Align(",
      "                  alignment: Alignment.centerRight,",
      "                  child: TextButton(",
      "                    onPressed: _isLoading",
      "                        ? null",
      "                        : () async {",
      "                            final email = emailController.text.trim();",
      "                            if (email.isEmpty || !email.contains('@')) {",
      "                              setDialogState(() {",
      "                                emailError = loc.emailRequired ??",
      "                                    \"Enter your email above.\";",
      "                              });",
      "                              return;",
      "                            }",
      "                            try {",
      "                              final authService = Provider.of<AuthService>(",
      "                                  context,",
      "                                  listen: false);",
      "                              await authService.resetPassword(email);",
      "                              setState(() {",
      "                                _errorMessage = \"Password reset email sent!\";",
      "                              });",
      "                            } catch (e) {",
      "                              setState(() {",
      "                                _errorMessage =",
      "                                    \"Failed to send reset email: $e\";",
      "                              });",
      "                            }",
      "                          },",
      "                    child: Text(loc.forgotPassword ?? \"Forgot password?\"),",
      "                  ),",
      "                ),",
      "                // --- DIVIDER ---",
      "                Row(",
      "                  children: [",
      "                    const Expanded(child: Divider()),",
      "                    Padding(",
      "                      padding: const EdgeInsets.symmetric(horizontal: 8),",
      "                      child: Text(loc.orDivider ?? \"OR\"),",
      "                    ),",
      "                    const Expanded(child: Divider()),",
      "                  ],",
      "                ),",
      "                const SizedBox(height: 10),",
      "                // --- SOCIAL SIGN-IN BUTTONS ---",
      "                SocialSignInButtons(",
      "                  isLoading: _isLoading,",
      "                  setLoading: _setLoading,",
      "                  onSuccess: _handleSuccess,",
      "                  onError: _handleError,",
      "                ),",
      "                const SizedBox(height: 16),",
      "                Text(",
      "                  loc.adminOnlyNotice,",
      "                  textAlign: TextAlign.center,",
      "                  style: theme.textTheme.bodySmall?.copyWith(",
      "                    color: DesignTokens.hintTextColor,",
      "                  ),",
      "                ),",
      "              ],",
      "            );",
      "          }),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 322,
      "file_size": 13019,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\staff\\staff_access_screen.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/models/user.dart' as admin_user;",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/user_permissions.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/config/branding_config.dart';",
      "import 'package:franchise_admin_portal/widgets/loading_shimmer_widget.dart';",
      "import 'package:franchise_admin_portal/widgets/empty_state_widget.dart';",
      "import 'package:franchise_admin_portal/core/providers/user_profile_notifier.dart';",
      "import 'package:franchise_admin_portal/widgets/admin/admin_unauthorized_widget.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/role_guard.dart';",
      "import 'package:franchise_admin_portal/widgets/subscription_access_guard.dart';",
      "import 'package:franchise_admin_portal/widgets/subscription/grace_period_banner.dart';",
      "import 'package:franchise_admin_portal/widgets/staff/show_add_staff_dialog.dart';",
      "",
      "class StaffAccessScreen extends StatefulWidget {",
      "  const StaffAccessScreen({super.key});",
      "",
      "  @override",
      "  State<StaffAccessScreen> createState() => _StaffAccessScreenState();",
      "}",
      "",
      "class _StaffAccessScreenState extends State<StaffAccessScreen> {",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final firestoreService =",
      "        Provider.of<FirestoreService>(context, listen: false);",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      return const Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "",
      "    final franchiseId = context.watch<FranchiseProvider>().franchiseId;",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "",
      "    return RoleGuard(",
      "      allowedRoles: const [",
      "        'platform_owner',",
      "        'hq_owner',",
      "        'manager',",
      "        'developer',",
      "        'admin'",
      "      ],",
      "      featureName: 'staff_access_screen',",
      "      screen: 'StaffAccessScreen',",
      "      child: SubscriptionAccessGuard(",
      "        child: Scaffold(",
      "          backgroundColor: colorScheme.background,",
      "          body: Row(",
      "            crossAxisAlignment: CrossAxisAlignment.start,",
      "            children: [",
      "              Expanded(",
      "                flex: 11,",
      "                child: Padding(",
      "                  padding:",
      "                      const EdgeInsets.only(top: 24.0, left: 24.0, right: 24.0),",
      "                  child: Column(",
      "                    crossAxisAlignment: CrossAxisAlignment.start,",
      "                    children: [",
      "                      const GracePeriodBanner(),",
      "                      Padding(",
      "                        padding: const EdgeInsets.only(bottom: 12.0),",
      "                        child: Row(",
      "                          crossAxisAlignment: CrossAxisAlignment.center,",
      "                          children: [",
      "                            Text(",
      "                              loc.staffAccessTitle,",
      "                              style: TextStyle(",
      "                                color: colorScheme.onBackground,",
      "                                fontWeight: FontWeight.bold,",
      "                                fontSize: 22,",
      "                              ),",
      "                            ),",
      "                            const Spacer(),",
      "                            FloatingActionButton(",
      "                              heroTag: \"addStaffBtn\",",
      "                              mini: true,",
      "                              backgroundColor: colorScheme.primary,",
      "                              child: const Icon(Icons.person_add),",
      "                              tooltip: loc.staffAddStaffTooltip,",
      "                              onPressed: () async {",
      "                                final parentLoc = AppLocalizations.of(context);",
      "                                if (parentLoc == null) {",
      "                                  await ErrorLogger.log(",
      "                                    message:",
      "                                        'AppLocalizations.of(context) returned null.',",
      "                                    source: 'staff_access_screen',",
      "                                    screen: 'StaffAccessScreen',",
      "                                    severity: 'error',",
      "                                    contextData: {",
      "                                      'widget': 'FloatingActionButton',",
      "                                      'event': 'open_add_staff_dialog',",
      "                                    },",
      "                                  );",
      "                                  return;",
      "                                }",
      "",
      "                                await showDialog(",
      "                                  context: context,",
      "                                  barrierDismissible: true,",
      "                                  builder: (BuildContext dialogContext) {",
      "                                    return Localizations.override(",
      "                                      context: context,",
      "                                      child: Builder(",
      "                                        builder: (innerContext) {",
      "                                          final loc =",
      "                                              AppLocalizations.of(innerContext);",
      "                                          if (loc == null) {",
      "                                            ErrorLogger.log(",
      "                                              message:",
      "                                                  'Localization still null after Localizations.override.',",
      "                                              source: 'staff_access_screen',",
      "                                              screen: 'StaffAccessScreen',",
      "                                              severity: 'error',",
      "                                              contextData: {",
      "                                                'widget': 'AddStaffDialog',",
      "                                                'issue':",
      "                                                    'AppLocalizations.of(innerContext) returned null',",
      "                                              },",
      "                                            );",
      "                                            return const AlertDialog(",
      "                                              content: Text(",
      "                                                  'Localization failed [AddStaffDialog]'),",
      "                                            );",
      "                                          }",
      "                                          return AddStaffDialog(loc: loc);",
      "                                        },",
      "                                      ),",
      "                                    );",
      "                                  },",
      "                                );",
      "                              },",
      "                            ),",
      "                          ],",
      "                        ),",
      "                      ),",
      "                      Expanded(",
      "                        child: StreamBuilder<List<admin_user.User>>(",
      "                          stream: firestoreService.getStaffUsers(franchiseId),",
      "                          builder: (context, snapshot) {",
      "                            if (snapshot.connectionState ==",
      "                                ConnectionState.waiting) {",
      "                              return const LoadingShimmerWidget();",
      "                            }",
      "                            if (!snapshot.hasData || snapshot.data!.isEmpty) {",
      "                              return EmptyStateWidget(",
      "                                title: loc.staffNoStaffTitle,",
      "                                message: loc.staffNoStaffMessage,",
      "                                imageAsset: BrandingConfig.adminEmptyStateImage,",
      "                                isAdmin: true,",
      "                              );",
      "                            }",
      "                            final staff = snapshot.data!;",
      "                            return ListView.separated(",
      "                              padding: const EdgeInsets.all(16),",
      "                              itemCount: staff.length,",
      "                              separatorBuilder: (_, __) => const Divider(),",
      "                              itemBuilder: (context, i) {",
      "                                final user = staff[i];",
      "                                return ListTile(",
      "                                  leading: CircleAvatar(",
      "                                    backgroundColor: colorScheme.secondary,",
      "                                    child: Text(",
      "                                      user.name.isNotEmpty ? user.name[0] : '?',",
      "                                      style: TextStyle(",
      "                                          color: colorScheme.onSecondary),",
      "                                    ),",
      "                                  ),",
      "                                  title: Text(",
      "                                    user.name,",
      "                                    style: TextStyle(",
      "                                      color: colorScheme.onBackground,",
      "                                      fontWeight: FontWeight.bold,",
      "                                    ),",
      "                                  ),",
      "                                  subtitle: Text(",
      "                                    '${user.email} • ${user.roles.join(\", \")}',",
      "                                    style: TextStyle(",
      "                                        color: colorScheme.onBackground",
      "                                            .withOpacity(0.75)),",
      "                                  ),",
      "                                  trailing: IconButton(",
      "                                    icon: Icon(Icons.delete,",
      "                                        color: colorScheme.error),",
      "                                    tooltip: loc.staffRemoveTooltip,",
      "                                    onPressed: () => _confirmRemoveStaff(",
      "                                        context, firestoreService, user, loc),",
      "                                  ),",
      "                                );",
      "                              },",
      "                            );",
      "                          },",
      "                        ),",
      "                      ),",
      "                    ],",
      "                  ),",
      "                ),",
      "              ),",
      "              const Expanded(flex: 9, child: SizedBox()),",
      "            ],",
      "          ),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  void _confirmRemoveStaff(BuildContext context, FirestoreService service,",
      "      admin_user.User user, AppLocalizations loc) {",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    showDialog(",
      "      context: context,",
      "      builder: (_) => AlertDialog(",
      "        title: Text(loc.staffRemoveDialogTitle),",
      "        content:",
      "            Text('${loc.staffRemoveDialogBody}\\n${user.name} (${user.email})'),",
      "        actions: [",
      "          TextButton(",
      "            onPressed: () => Navigator.of(context).pop(),",
      "            child: Text(loc.cancelButton),",
      "          ),",
      "          ElevatedButton(",
      "            style: ElevatedButton.styleFrom(",
      "              backgroundColor: colorScheme.error,",
      "              foregroundColor: colorScheme.onError,",
      "            ),",
      "            onPressed: () async {",
      "              final franchiseId =",
      "                  Provider.of<FranchiseProvider>(context, listen: false)",
      "                      .franchiseId;",
      "              try {",
      "                await service.removeStaffUser(user.id);",
      "                if (!context.mounted) return;",
      "                Navigator.of(context).pop();",
      "              } catch (e, stack) {",
      "                await ErrorLogger.log(",
      "                  message: e.toString(),",
      "                  stack: stack.toString(),",
      "                  source: 'staff_access_screen',",
      "                  screen: 'StaffAccessScreen',",
      "                  severity: 'error',",
      "                  contextData: {",
      "                    'franchiseId': franchiseId,",
      "                    'userId': user.id,",
      "                    'name': user.name,",
      "                    'email': user.email,",
      "                    'operation': 'remove_staff',",
      "                  },",
      "                );",
      "              }",
      "            },",
      "            child: Text(loc.staffRemoveButton),",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 263,
      "file_size": 12423,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\admin\\staff\\staff_directory_screen.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/models/user.dart' as admin_user;",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:provider/provider.dart';",
      "",
      "class StaffDirectoryScreen extends StatefulWidget {",
      "  const StaffDirectoryScreen({Key? key}) : super(key: key);",
      "",
      "  @override",
      "  State<StaffDirectoryScreen> createState() => _StaffDirectoryScreenState();",
      "}",
      "",
      "class _StaffDirectoryScreenState extends State<StaffDirectoryScreen> {",
      "  late Future<List<admin_user.User>> _staffFuture;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    final franchiseId = context.read<FranchiseProvider>().franchiseId;",
      "    final firestoreService = context.read<FirestoreService>();",
      "    _staffFuture = firestoreService.allUsers(franchiseId: franchiseId).first;",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    final theme = Theme.of(context);",
      "",
      "    return Scaffold(",
      "      appBar: AppBar(title: Text(loc.staffDirectory)),",
      "      body: FutureBuilder<List<admin_user.User>>(",
      "        future: _staffFuture,",
      "        builder: (context, snapshot) {",
      "          if (snapshot.connectionState == ConnectionState.waiting) {",
      "            return const Center(child: CircularProgressIndicator());",
      "          } else if (snapshot.hasError) {",
      "            return Center(child: Text(loc.errorLoadingStaff));",
      "          } else if (!snapshot.hasData || snapshot.data!.isEmpty) {",
      "            return Center(child: Text(loc.noStaffFound));",
      "          }",
      "",
      "          final staff = snapshot.data!;",
      "          return ListView.separated(",
      "            padding: const EdgeInsets.all(16.0),",
      "            itemCount: staff.length,",
      "            separatorBuilder: (_, __) => const Divider(height: 16),",
      "            itemBuilder: (context, index) {",
      "              final user = staff[index];",
      "              return ListTile(",
      "                leading: CircleAvatar(",
      "                  child: Text(user.name.isNotEmpty ? user.name[0] : '?'),",
      "                ),",
      "                title: Text(user.name),",
      "                subtitle: Text(user.email),",
      "                trailing: Text(user.roles.join(\", \")),",
      "                onTap: () {",
      "                  // TODO: Future enhancement - navigate to staff detail / edit screen",
      "                },",
      "              );",
      "            },",
      "          );",
      "        },",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 75,
      "file_size": 2828,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\config\\app_config.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "",
      "class AppConfig {",
      "  // ===== FIRESTORE COLLECTION NAMES =====",
      "  static const String usersCollection = 'users';",
      "  static const String menuItemsCollection = 'menu_items';",
      "  static const String ordersCollection = 'orders';",
      "  static const String categoriesCollection = 'categories';",
      "  static const String cartCollection = 'cart';",
      "  static const String bannersCollection = 'banners';",
      "  static const String feedbackCollection = 'feedback';",
      "  static const String inventoryCollection = 'inventory_transactions';",
      "  static const String supportChatsCollection = 'support_chats';",
      "  static const String promotionsCollection = 'promotions';",
      "  static const String configCollection = 'config';",
      "  static const String auditLogCollection = 'audit_logs';",
      "",
      "  // ===== SUBCOLLECTION NAMES =====",
      "  static const String addressesSubcollection = 'addresses';",
      "  static const String favoriteOrdersSubcollection = 'favorite_orders';",
      "",
      "  // ===== FAVORITE MENU ITEM LIMIT (Firestore best practice) =====",
      "  static const int maxFavoriteMenuItemsLookup = 10;",
      "",
      "  // ===== UTILITY CONSTANTS =====",
      "  static const Duration toastDuration = Duration(seconds: 2);",
      "",
      "  // ===== SCHEDULED ORDERS =====",
      "  static const String scheduledOrdersCollection = 'scheduledOrders';",
      "",
      "  // ===== FOOTER, LEGAL, & STATIC TEXT =====",
      "  static const String poweredBy = \"Powered by Dough Boys Tech\";",
      "",
      "  // ===== MENU EDITOR & BULK ACTIONS =====",
      "  static const int menuItemMaxImageSizeMB = 2;",
      "  static const int menuItemImageDim = 1200;",
      "  static const int bulkUploadMaxRows = 100;",
      "  static const List<String> allowedImageFormats = ['jpeg', 'jpg', 'png'];",
      "  static const bool enableAuditLogs = true;",
      "  static const bool enableCSVExport = true;",
      "  static const List<String> dietaryTags = [",
      "    'Vegan',",
      "    'Vegetarian',",
      "    'Gluten-Free',",
      "    'Dairy-Free',",
      "    'Nut-Free',",
      "    'Halal',",
      "    'Kosher'",
      "  ];",
      "  static const List<String> allergenTags = [",
      "    'Milk',",
      "    'Eggs',",
      "    'Fish',",
      "    'Shellfish',",
      "    'Tree Nuts',",
      "    'Peanuts',",
      "    'Wheat',",
      "    'Soy'",
      "  ];",
      "",
      "  // ===== ADMIN DASHBOARD FEATURES =====",
      "",
      "  static const String adminEmptyStateImage = 'assets/images/admin_empty.png';",
      "  static const String promoExportDir = 'exports/promos';",
      "  static const String analyticsExportDir = 'exports/analytics';",
      "  static const String dateFormat =",
      "      'yyyy-MM-dd'; // For date pickers if not set elsewhere",
      "",
      "  // Example fields - adapt as needed",
      "  final String apiBaseUrl;",
      "  final String brandingColor;",
      "  final bool isProduction;",
      "",
      "  // 1. Singleton instance",
      "  static final AppConfig instance = AppConfig._internal(",
      "    apiBaseUrl: 'https://api.yourdomain.com',",
      "    brandingColor: '#C62828',",
      "    isProduction: true,",
      "  );",
      "",
      "  // 2. Private named constructor",
      "  const AppConfig._internal({",
      "    required this.apiBaseUrl,",
      "    required this.brandingColor,",
      "    required this.isProduction,",
      "  });",
      "",
      "  /// Converts internal feature keys into display-friendly names.",
      "  /// TODO: Replace with localized strings or a proper feature map.",
      "  static String featureDisplayName(String featureKey) {",
      "    switch (featureKey) {",
      "      case 'mobile_app':",
      "        return 'Mobile App';",
      "      case 'web_ordering':",
      "        return 'Web Ordering';",
      "      case 'multi_location':",
      "        return 'Multi-location Support';",
      "      case 'custom_branding':",
      "        return 'Custom Branding';",
      "      case 'priority_support':",
      "        return 'Priority Support';",
      "      case 'analytics_dashboard':",
      "        return 'Analytics Dashboard';",
      "      case 'coupon_management':",
      "        return 'Coupon Management';",
      "      case 'loyalty_program':",
      "        return 'Loyalty Program';",
      "      case 'pos_integration':",
      "        return 'POS Integration';",
      "      case 'custom_plan':",
      "        return 'Custom Plan Features';",
      "      default:",
      "        return featureKey;",
      "    }",
      "  }",
      "",
      "  /// Maps subscription statuses to corresponding display colors.",
      "  static Color statusColor(String status, ThemeData theme) {",
      "    switch (status) {",
      "      case 'active':",
      "        return theme.colorScheme.primaryContainer;",
      "      case 'paused':",
      "        return theme.colorScheme.secondaryContainer;",
      "      case 'trialing':",
      "        return theme.colorScheme.tertiaryContainer;",
      "      case 'canceled':",
      "        return theme.colorScheme.errorContainer;",
      "      default:",
      "        return theme.colorScheme.outlineVariant;",
      "    }",
      "  }",
      "",
      "  /// Formats a DateTime object into a readable string using default dateFormat.",
      "  static String formatDate(DateTime? date) {",
      "    if (date == null) return '';",
      "    return '${date.year.toString().padLeft(4, '0')}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')}';",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 138,
      "file_size": 4725,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\config\\branding_config.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "",
      "class BrandingConfig {",
      "  // --------- Franchise Details ---------",
      "  static const String franchiseName = \"Doughboys Pizzeria\";",
      "  static const String franchiseAddress = \"123 Main St, City, State\";",
      "  static const String franchisePhone = \"(555) 123-4567\";",
      "  static const String poweredBy = \"Powered by Dough Boys Tech\";",
      "",
      "  // --------- Logos ---------",
      "  static const String logoMain = 'assets/images/logo.png';",
      "  static const String logoSmall = 'assets/images/logo_small.png';",
      "  static const String logoLarge = 'assets/logo/logo_large.png';",
      "  static const String logoLargeLegacy = 'assets/images/logo_large.png';",
      "",
      "  // --------- Icons & Images ---------",
      "  static const String defaultPizzaIcon = 'assets/icons/pizza.png';",
      "  static const String defaultPizzaIconLegacy =",
      "      'assets/images/default_pizza_icon.png';",
      "  static const String defaultCategoryIcon =",
      "      'assets/images/default_category_icon.png';",
      "  static const String bannerPlaceholder =",
      "      'assets/images/banner_placeholder.png';",
      "  static const String fallbackAppIcon = 'assets/images/pizza_icon.png';",
      "",
      "  // --------- Admin/Editor Assets ---------",
      "  static const String adminEmptyStateImage = 'assets/images/admin_empty.png';",
      "  static const String menuItemPlaceholderImage =",
      "      'assets/images/menu_item_placeholder.png';",
      "  static const Color brandRed = Color(0xFFD23215); // Dough Boys Pizzeria Red",
      "",
      "  // --------- Bulk Upload, Export, Misc ---------",
      "  static const String bulkUploadCSVIcon = 'assets/icons/csv_upload.png';",
      "  static const String exportCSVIcon = 'assets/icons/export_csv.png';",
      "",
      "  // --------- Legal/Docs ---------",
      "  static const String termsOfServiceUrl = 'https://doughboys.com/terms';",
      "  static const String privacyPolicyUrl = 'https://doughboys.com/privacy';",
      "",
      "  // app bar",
      "",
      "  static const String appBarLogoAsset =",
      "      'assets/images/logo.png'; // Path to logo",
      "  static const bool showLogoInAppBar = false; // Default to false",
      "  static const String appBarTitle = 'Menu Categories';",
      "",
      "  // Profile Page",
      "  static const String defaultProfileIcon = 'assets/images/default_profile.png';",
      "",
      "  // kpi",
      "  static Color brandColorFor(String brandId) {",
      "    // Extend this logic if brand-specific colors are used",
      "    return brandRed; // fallback to default brand color",
      "  }",
      "",
      "  // Recommended dashboard card background (adjust to your design, e.g. neutral surface or white)",
      "  static const Color dashboardCardColor = Colors.white;",
      "",
      "// Accent color (typically your brand color or another action/CTA color)",
      "  static const Color accentColor = brandRed;",
      "  // landing page",
      "  static const String heroScreenshot =",
      "      'https://via.placeholder.com/640x300.png?text=Landing+Hero';",
      "  static const String adminDashboardScreenshot =",
      "      'https://via.placeholder.com/480x240.png?text=Admin+Dashboard';",
      "  static const String mobileAppScreenshot =",
      "      'https://via.placeholder.com/240x480.png?text=Mobile+App';",
      "  static const String menuEditorScreenshot =",
      "      'https://via.placeholder.com/480x240.png?text=Menu+Editor';",
      "  static const String demoVideoUrl =",
      "      'https://www.youtube.com/watch?v=yourdemo'; // or leave blank if not available",
      "  static const String logoUrl =",
      "      'https://via.placeholder.com/256x64.png?text=Logo';",
      "  static const String primaryContact =",
      "      'support@doughboyspizzeria.com'; // or your real contact email",
      "  static const String ingredientPlaceholder =",
      "      'assets/images/ingredient_placeholder.png';",
      "",
      "  // ======================",
      "  // === FUTURE TOKENS ====",
      "  // ======================",
      "  // static const String instagramHandle = \"@doughboys\";",
      "  // static const String franchiseEmail = \"contact@doughboys.com\";",
      "  // static const String franchiseSlogan = \"Slice of Heaven Since 1999\";",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 85,
      "file_size": 3803,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\config\\design_tokens.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "",
      "/// =======================",
      "/// DesignTokens",
      "/// =======================",
      "/// - All visual/UX tokens: colors, spacing, typography, radii, elevations",
      "/// - Used everywhere for theme, UI styling, layout",
      "/// - No asset/image paths, brand/legal, or Firestore config",
      "/// - Future tokens reserved for forward compatibility",
      "/// =======================",
      "class DesignTokens {",
      "  // ----------- Core Theme Colors -----------",
      "  static const Color primaryColor = Color(0xFFD23215); // Brand red",
      "  static const Color secondaryColor = Color(0xFF506A48); // Olive green",
      "  static const Color accentColor = Color(0xFF00A7A7); // Teal",
      "  static const Color errorColor = Color(0xFFE53935);",
      "  static const Color dangerColor = errorColor;",
      "  static const Color successColor = Colors.green;",
      "  static const Color highlightColor = primaryColor;",
      "  static const Color backgroundColor = Color(0xFFF9F9F9); // App bg",
      "  static const Color surfaceColor = Colors.white;",
      "",
      "  // ----------- Base Text Colors -----------",
      "  static const Color textColor = Colors.black;",
      "  static const Color secondaryTextColor = Colors.black54;",
      "  static const Color errorTextColor = errorColor;",
      "  static const Color successTextColor = successColor;",
      "  static const Color disabledTextColor = Colors.grey;",
      "  static const Color linkTextColor = Colors.blue;",
      "  static const Color hintTextColor = Colors.black38;",
      "  static const Color foregroundColor = Colors.white;",
      "",
      "  // ----------- Dark Mode Variants -----------",
      "  static const Color textColorDark = Color(0xFFE4E6EB);",
      "  static const Color foregroundColorDark = Colors.white;",
      "  static const Color surfaceColorDark = Color(0xFF242526);",
      "  static const Color backgroundColorDark = Color(0xFF18191A);",
      "",
      "  // ----------- Dark AppBar and Foreground for Hybrid Approach -----------",
      "  static const Color appBarBackgroundColorDark =",
      "      Color(0xFF18191A); // Match background or a dark surface",
      "  static const Color appBarForegroundColorDark =",
      "      Color(0xFFE4E6EB); // Light text for dark app bar",
      "",
      "// ----------- Optional: Muted Brand Red for Action in Dark (if you want softer buttons) -----------",
      "  static const Color primaryColorDark =",
      "      Color(0xFF9A2412); // Optional: a darker or muted version of brand red",
      "",
      "// ----------- Divider for dark mode -----------",
      "  static const Color dividerColorDark =",
      "      Colors.white12; // Or your preferred divider color",
      "",
      "// ----------- Update to hintTextColor -----------",
      "  static const Color hintTextColorDark =",
      "      Color(0xFFB0B3B8); // For input hints in dark mode",
      "",
      "  // ----------- Social Icon Colors -----------",
      "  static const Color googleColor = Color(0xFF4285F4);",
      "  static const Color facebookColor = Color(0xFF1877F3);",
      "  static const Color appleColor = Colors.black;",
      "  static const Color phoneColor = Colors.green;",
      "",
      "  // ----------- Overlay Colors & Opacity -----------",
      "  static const Color bannerOverlayColor = Colors.black;",
      "  static const int bannerOverlayAlpha = 128;",
      "  static const Color gridCardOverlayColor = Colors.black;",
      "  static const int gridCardOverlayAlpha = 80;",
      "",
      "  // ----------- Shimmer & Loading -----------",
      "  static const Color shimmerBaseColor = Color(0xFFE0E0E0);",
      "  static const Color shimmerHighlightColor = Color(0xFFF5F5F5);",
      "",
      "  // ----------- Radii / BorderRadius -----------",
      "  static const double cardRadius = 8.0;",
      "  static const double buttonRadius = 24.0;",
      "  static const double dialogRadius = 16.0;",
      "  static const double chipRadius = 32.0;",
      "  static const double imageRadius = 12.0;",
      "  static const double formFieldRadius = 12.0;",
      "  static const double badgeRadius = 10.0;",
      "  static const double cardBorderRadiusLarge = 24.0;",
      "  static const double cardBorderRadiusSmall = 10.0;",
      "  // ----------- Sizing / Borders -----------",
      "  static const double iconSize = 24.0;",
      "  static const double cardBorderWidth = 2.0;",
      "  static const double categoryCardBorderWidth = 2.0;",
      "",
      "  // ----------- Spacing, Elevation, Aspect Ratio -----------",
      "  static const double gridSpacing = 8.0;",
      "  static const double cardElevation = 4.0;",
      "  static const double buttonElevation = 2.0;",
      "  static const double badgeMinSize = 16.0;",
      "  static const double cartBadgePadding = 2.0;",
      "  static const double gridCardAspectRatio = 1.0;",
      "",
      "  // ----------- Padding Defaults -----------",
      "  static const EdgeInsets gridPadding = EdgeInsets.all(8.0);",
      "  static const EdgeInsets cardPadding = EdgeInsets.all(12.0);",
      "  static const EdgeInsets buttonPadding =",
      "      EdgeInsets.symmetric(horizontal: 20.0, vertical: 12.0);",
      "",
      "  // ----------- Banner/Carousel Tokens -----------",
      "  static const double bannerHeight = 200.0;",
      "  static const double bannerBorderRadius = 12.0;",
      "  static const Duration bannerAutoPlayInterval = Duration(seconds: 5);",
      "",
      "  // ----------- Menu Item Images -----------",
      "  static const double menuItemImageWidth = 100.0;",
      "  static const double menuItemImageHeight = 100.0;",
      "",
      "  // ----------- Logo Sizing -----------",
      "  static const double logoHeightSmall = 40.0;",
      "  static const double logoHeightMedium = 70.0;",
      "  static const double logoHeightLarge = 80.0;",
      "",
      "  // ----------- Typography Tokens -----------",
      "  static const String fontFamily = 'Montserrat';",
      "  static const double captionFontSize = 12.0;",
      "  static const double bodyFontSize = 16.0;",
      "  static const double titleFontSize = 20.0;",
      "  static const FontWeight titleFontWeight = FontWeight.bold;",
      "  static const FontWeight bodyFontWeight = FontWeight.normal;",
      "",
      "  // ----------- Animation & Timing -----------",
      "  static const Duration toastDuration = Duration(seconds: 2);",
      "  static const Duration animationDuration = Duration(milliseconds: 300);",
      "",
      "  // ----------- Icons -----------",
      "  static const double iconSizeLarge = 40.0;",
      "  static const double iconSizeXLarge = 80.0;",
      "",
      "  static const IconData favoriteIcon = Icons.favorite;",
      "  static const IconData favoriteBorderIcon = Icons.favorite_border;",
      "  static const IconData cartIcon = Icons.shopping_cart;",
      "  static const IconData errorIcon = Icons.wifi_off;",
      "  static const IconData refreshIcon = Icons.refresh;",
      "  static const IconData addIcon = Icons.add;",
      "  static const IconData removeIcon = Icons.remove;",
      "  static const IconData appleIcon = Icons.apple;",
      "  static const IconData visibilityIcon = Icons.visibility;",
      "  static const IconData visibilityOffIcon = Icons.visibility_off;",
      "  static const IconData emailIcon = Icons.email;",
      "  static const IconData lockIcon = Icons.lock;",
      "",
      "  // ----------- Miscellaneous -----------",
      "  static const Color warningColor = Colors.orange; // For password strength",
      "",
      "  // ======================",
      "  // === ADMIN-SPECIFIC ===",
      "  // ======================",
      "  // These tokens are appended for Admin/Editor UI consistency",
      "  static const Color adminPrimaryColor = primaryColor;",
      "  static const Color adminSecondaryColor = secondaryColor;",
      "  static const Color adminBackground = backgroundColor;",
      "  static const Color adminSurface = surfaceColor;",
      "  static const double adminTitleFontSize = 20.0;",
      "  static const double adminBodyFontSize = 16.0;",
      "  static const double adminCaptionFontSize = 14.0;",
      "  static const double adminButtonFontSize = 16.0;",
      "  static const double adminTableFontSize = 15.0;",
      "  static const double adminGridPadding = 16.0;",
      "  static const double adminCardSpacing = 8.0;",
      "  static const double adminCardRadius = 10.0;",
      "  static const double adminButtonRadius = 8.0;",
      "  static const double adminCardElevation = 2.0;",
      "  static const double adminButtonElevation = 1.0;",
      "",
      "  static const Color adminAccentColor =",
      "      Color(0xFFD23215); // For critical admin actions",
      "  static const double adminDialogRadius = 12.0;",
      "  static const double adminDialogElevation = 4.0;",
      "  static const double adminSpacing = 16.0;",
      "",
      "  static const Color cardBorderColor =",
      "      Color(0xFFE0E0E0); // or any color you prefer",
      "",
      "  static const Color errorBgColor =",
      "      Color(0xFFFFE5E5); // Light red background for errors",
      "",
      "  static const Color appBarBackgroundColor = Color(0xFFD23215); // Example red",
      "  static const Color appBarForegroundColor = Color(0xFFFFFFFF); // Example white",
      "  static const Color appBarIconColor = Color(0xFFFFFFFF);",
      "  static const double appBarElevation = 0;",
      "  static const double appBarTitleFontSize = 20.0;",
      "  static const FontWeight appBarTitleFontWeight = FontWeight.bold;",
      "  static const String appBarFontFamily = 'YourFontFamily';",
      "  static const double appBarLogoHeight = 40.0;",
      "",
      "  // ----------- Feature dialogue tokens -----------",
      "  static const double dialogBorderRadius = 16.0;",
      "  static const double inputBorderRadius = 12.0;",
      "  static const double buttonBorderRadius = 12.0;",
      "",
      "  // ----------- Error Log/Chip Severity Tokens -----------",
      "  static const Color errorChipColor = Color(0xFFFDEAEA);",
      "  static const Color errorChipTextColor = Color(0xFFD23215);",
      "",
      "  static const Color warningChipColor = Color(0xFFFFF8E1);",
      "  static const Color warningChipTextColor = Color(0xFFF9A825);",
      "",
      "  static const Color infoChipColor = Color(0xFFE3F2FD);",
      "  static const Color infoChipTextColor = Color(0xFF1976D2);",
      "",
      "  static const Color neutralChipColor = Color(0xFFF4F4F4);",
      "  static const Color neutralChipTextColor = Color(0xFF606060);",
      "",
      "  // Border radius",
      "  static const double radiusSm = 4.0;",
      "  static const double radiusMd = 8.0;",
      "  static const double radiusLg = 16.0;",
      "",
      "  static const double radius2xl = 32.0;",
      "  static const double paddingLg = 24.0;",
      "",
      "  // KPI widget",
      "  // Example for soft shadow (update to match your style)",
      "  static const List<BoxShadow> softShadow = [",
      "    BoxShadow(",
      "      color: Color(0x11000000), // Subtle shadow",
      "      blurRadius: 16,",
      "      spreadRadius: 2,",
      "      offset: Offset(0, 4),",
      "    ),",
      "  ];",
      "",
      "  static const double paddingMd = 16.0;",
      "",
      "  // ======================",
      "  // === FUTURE TOKENS ====",
      "  // ======================",
      "  // Keep all future tokens here, *do not remove*.",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 232,
      "file_size": 9887,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\config\\feature_config.dart",
    "content": [
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "import 'package:logging/logging.dart';",
      "",
      "/// Centralized feature toggle loader and runtime flags for app-wide features.",
      "/// Populates from Firestore on startup for SaaS/franchise modularity.",
      "class FeatureConfig {",
      "  static final Logger _logger = Logger('FeatureConfig');",
      "",
      "  // Singleton",
      "  FeatureConfig._();",
      "  static final FeatureConfig instance = FeatureConfig._();",
      "",
      "  // ===== Feature Toggles (Firestore driven) =====",
      "  bool loyaltyEnabled = false;",
      "  bool inventoryEnabled = false;",
      "  bool statusEnabled = false;",
      "  bool segmentationEnabled = false;",
      "  bool dynamicPricingEnabled = false;",
      "  bool nutritionEnabled = false;",
      "  bool recurrenceEnabled = false;",
      "  bool languageEnabled = false;",
      "  bool supportEnabled = false;",
      "  bool trackOrderEnabled = true;",
      "",
      "  // ===== Auth Toggles =====",
      "  bool enableGuestMode = true;",
      "  bool enableDemoMode = false;",
      "  bool forceLogin = false;",
      "  bool googleAuthEnabled = true;",
      "  bool facebookAuthEnabled = true;",
      "  bool appleAuthEnabled = false;",
      "  bool phoneAuthEnabled = true;",
      "",
      "  // ===== Admin/Analytics/Promo Toggles =====",
      "  bool adminDashboardEnabled = true;",
      "  bool bannerPromoManagementEnabled = true;",
      "  bool feedbackManagementEnabled = true;",
      "  bool analyticsDashboardEnabled = true;",
      "  bool staffAccessEnabled = true;",
      "  bool featureToggleUIEnabled = true;",
      "  bool chatManagementEnabled = true;",
      "  bool promoBulkUploadEnabled = true;",
      "  bool promoExportEnabled = true;",
      "  bool analyticsExportEnabled = true;",
      "",
      "  /// Loads toggles from Firestore (`config/features` doc).",
      "  Future<Map<String, bool>> load(String franchiseId) async {",
      "    try {",
      "      final doc = await FirebaseFirestore.instance",
      "          .collection('franchises')",
      "          .doc(franchiseId)",
      "          .collection('config')",
      "          .doc('features')",
      "          .get();",
      "      final data = doc.data() ?? {};",
      "",
      "      loyaltyEnabled = data['loyaltyEnabled'] ?? loyaltyEnabled;",
      "      inventoryEnabled = data['inventoryEnabled'] ?? inventoryEnabled;",
      "      statusEnabled = data['statusEnabled'] ?? statusEnabled;",
      "      segmentationEnabled = data['segmentationEnabled'] ?? segmentationEnabled;",
      "      dynamicPricingEnabled =",
      "          data['dynamicPricingEnabled'] ?? dynamicPricingEnabled;",
      "      nutritionEnabled = data['nutritionEnabled'] ?? nutritionEnabled;",
      "      recurrenceEnabled = data['recurrenceEnabled'] ?? recurrenceEnabled;",
      "      languageEnabled = data['languageEnabled'] ?? languageEnabled;",
      "      supportEnabled = data['supportEnabled'] ?? supportEnabled;",
      "      trackOrderEnabled = data['trackOrderEnabled'] ?? trackOrderEnabled;",
      "",
      "      enableGuestMode = data['enableGuestMode'] ?? enableGuestMode;",
      "      enableDemoMode = data['enableDemoMode'] ?? enableDemoMode;",
      "      forceLogin = data['forceLogin'] ?? forceLogin;",
      "      googleAuthEnabled = data['googleAuthEnabled'] ?? googleAuthEnabled;",
      "      facebookAuthEnabled = data['facebookAuthEnabled'] ?? facebookAuthEnabled;",
      "      appleAuthEnabled = data['appleAuthEnabled'] ?? appleAuthEnabled;",
      "      phoneAuthEnabled = data['phoneAuthEnabled'] ?? phoneAuthEnabled;",
      "",
      "      adminDashboardEnabled =",
      "          data['adminDashboardEnabled'] ?? adminDashboardEnabled;",
      "      bannerPromoManagementEnabled =",
      "          data['bannerPromoManagementEnabled'] ?? bannerPromoManagementEnabled;",
      "      feedbackManagementEnabled =",
      "          data['feedbackManagementEnabled'] ?? feedbackManagementEnabled;",
      "      analyticsDashboardEnabled =",
      "          data['analyticsDashboardEnabled'] ?? analyticsDashboardEnabled;",
      "      staffAccessEnabled = data['staffAccessEnabled'] ?? staffAccessEnabled;",
      "      featureToggleUIEnabled =",
      "          data['featureToggleUIEnabled'] ?? featureToggleUIEnabled;",
      "      chatManagementEnabled =",
      "          data['chatManagementEnabled'] ?? chatManagementEnabled;",
      "      promoBulkUploadEnabled =",
      "          data['promoBulkUploadEnabled'] ?? promoBulkUploadEnabled;",
      "      promoExportEnabled = data['promoExportEnabled'] ?? promoExportEnabled;",
      "      analyticsExportEnabled =",
      "          data['analyticsExportEnabled'] ?? analyticsExportEnabled;",
      "",
      "      // Business rule: demo and guest cannot both be true",
      "      if (enableDemoMode && enableGuestMode) {",
      "        enableGuestMode = false;",
      "      }",
      "    } catch (e, stk) {",
      "      _logger.severe('Error loading feature toggles', e, stk);",
      "      // Retain existing defaults",
      "    }",
      "    return asMap;",
      "  }",
      "",
      "  /// Optional runtime debug map",
      "  Map<String, bool> get asMap => {",
      "        'loyaltyEnabled': loyaltyEnabled,",
      "        'inventoryEnabled': inventoryEnabled,",
      "        'statusEnabled': statusEnabled,",
      "        'segmentationEnabled': segmentationEnabled,",
      "        'dynamicPricingEnabled': dynamicPricingEnabled,",
      "        'nutritionEnabled': nutritionEnabled,",
      "        'recurrenceEnabled': recurrenceEnabled,",
      "        'languageEnabled': languageEnabled,",
      "        'supportEnabled': supportEnabled,",
      "        'trackOrderEnabled': trackOrderEnabled,",
      "        'enableGuestMode': enableGuestMode,",
      "        'enableDemoMode': enableDemoMode,",
      "        'forceLogin': forceLogin,",
      "        'googleAuthEnabled': googleAuthEnabled,",
      "        'facebookAuthEnabled': facebookAuthEnabled,",
      "        'appleAuthEnabled': appleAuthEnabled,",
      "        'phoneAuthEnabled': phoneAuthEnabled,",
      "        'adminDashboardEnabled': adminDashboardEnabled,",
      "        'bannerPromoManagementEnabled': bannerPromoManagementEnabled,",
      "        'feedbackManagementEnabled': feedbackManagementEnabled,",
      "        'analyticsDashboardEnabled': analyticsDashboardEnabled,",
      "        'staffAccessEnabled': staffAccessEnabled,",
      "        'featureToggleUIEnabled': featureToggleUIEnabled,",
      "        'chatManagementEnabled': chatManagementEnabled,",
      "        'promoBulkUploadEnabled': promoBulkUploadEnabled,",
      "        'promoExportEnabled': promoExportEnabled,",
      "        'analyticsExportEnabled': analyticsExportEnabled,",
      "      };",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 137,
      "file_size": 5908,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\section_registry.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "// Import ALL your admin sections (ensure these files exist!)",
      "import 'package:franchise_admin_portal/admin/dashboard/dashboard_home_screen.dart';",
      "import 'package:franchise_admin_portal/admin/menu/menu_editor_screen.dart';",
      "import 'package:franchise_admin_portal/admin/categories/category_management_screen.dart';",
      "import 'package:franchise_admin_portal/admin/inventory/inventory_screen.dart';",
      "import 'package:franchise_admin_portal/admin/orders/analytics_screen.dart';",
      "import 'package:franchise_admin_portal/admin/orders/order_management_screen.dart';",
      "import 'package:franchise_admin_portal/admin/feedback/feedback_management_screen.dart';",
      "import 'package:franchise_admin_portal/admin/promo/promo_management_screen.dart';",
      "import 'package:franchise_admin_portal/admin/staff/staff_access_screen.dart';",
      "import 'package:franchise_admin_portal/admin/features/feature_settings_screen.dart';",
      "import 'package:franchise_admin_portal/admin/chat/chat_management_screen.dart';",
      "import 'package:franchise_admin_portal/admin/error_logs/error_logs_screen.dart';",
      "import 'package:franchise_admin_portal/admin/developer/platform/platform_plans_section.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/screens/onboarding_categories_screen.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/screens/onboarding_ingredients_screen.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/screens/onboarding_menu_items_screen.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/screens/onboarding_menu_screen.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/screens/onboarding_review_screen.dart';",
      "import 'package:franchise_admin_portal/core/models/dashboard_section.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/screens/onboarding_ingredient_type_screen.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/screens/onboarding_feature_setup_screen.dart';",
      "import 'package:franchise_admin_portal/admin/dashboard/onboarding/screens/menu_item_editor_screen.dart';",
      "// Any new (plugin/module) screens can be imported and registered here",
      "",
      "// ==== UNIFIED SECTION REGISTRY (ALL MAIN + ONBOARDING) ====",
      "final List<DashboardSection> sectionRegistry = [",
      "  // ---- Core dashboard sections ----",
      "  DashboardSection(",
      "    key: 'dashboardHome',",
      "    title: 'Dashboard',",
      "    icon: Icons.dashboard,",
      "    builder: (_) => const DashboardHomeScreen(),",
      "    sidebarOrder: 0,",
      "    showInSidebar: true,",
      "  ),",
      "  DashboardSection(",
      "    key: 'menuEditor',",
      "    title: 'Menu',",
      "    icon: Icons.local_pizza,",
      "    builder: (_) => const MenuEditorScreen(),",
      "    sidebarOrder: 1,",
      "    showInSidebar: true,",
      "  ),",
      "  DashboardSection(",
      "    key: 'categoryManagement',",
      "    title: 'Categories',",
      "    icon: Icons.category_outlined,",
      "    builder: (_) => const CategoryManagementScreen(),",
      "    sidebarOrder: 2,",
      "    showInSidebar: true,",
      "  ),",
      "  DashboardSection(",
      "    key: 'inventoryManagement',",
      "    title: 'Inventory',",
      "    icon: Icons.inventory,",
      "    builder: (_) => const InventoryScreen(),",
      "    sidebarOrder: 3,",
      "    showInSidebar: true,",
      "  ),",
      "  DashboardSection(",
      "    key: 'orderAnalytics',",
      "    title: 'Order Analytics',",
      "    icon: Icons.analytics_outlined,",
      "    builder: (_) => const AnalyticsScreen(),",
      "    sidebarOrder: 4,",
      "    showInSidebar: true,",
      "  ),",
      "  DashboardSection(",
      "    key: 'orderManagement',",
      "    title: 'Orders',",
      "    icon: Icons.receipt_long_outlined,",
      "    builder: (_) => const OrderManagementScreen(),",
      "    sidebarOrder: 5,",
      "    showInSidebar: true,",
      "  ),",
      "  DashboardSection(",
      "    key: 'feedbackManagement',",
      "    title: 'Feedback',",
      "    icon: Icons.feedback_outlined,",
      "    builder: (_) => const FeedbackManagementScreen(),",
      "    sidebarOrder: 6,",
      "    showInSidebar: true,",
      "  ),",
      "  DashboardSection(",
      "    key: 'promoManagement',",
      "    title: 'Promotions',",
      "    icon: Icons.card_giftcard_outlined,",
      "    builder: (_) => const PromoManagementScreen(),",
      "    sidebarOrder: 7,",
      "    showInSidebar: true,",
      "  ),",
      "  DashboardSection(",
      "    key: 'staffAccess',",
      "    title: 'Staff',",
      "    icon: Icons.people_outline,",
      "    builder: (_) => const StaffAccessScreen(),",
      "    sidebarOrder: 8,",
      "    showInSidebar: true,",
      "  ),",
      "  DashboardSection(",
      "    key: 'chatManagement',",
      "    title: 'Support Chat',",
      "    icon: Icons.chat_bubble_outline,",
      "    builder: (_) => const ChatManagementScreen(),",
      "    sidebarOrder: 10,",
      "    showInSidebar: true,",
      "  ),",
      "  // Hidden editor screen (utility, not in sidebar)",
      "  DashboardSection(",
      "    key: 'menuItemEditor',",
      "    title: 'Menu Item Editor',",
      "    icon: Icons.edit_note_rounded,",
      "    builder: (_) => const MenuItemEditorScreen(),",
      "    sidebarOrder: 11,",
      "    showInSidebar: false,",
      "  ),",
      "",
      "  // ---- Onboarding Steps (now unified, sidebarOrder >= 100 for grouping) ----",
      "  DashboardSection(",
      "    key: 'onboardingMenu',",
      "    title: 'Overview',",
      "    icon: Icons.list_alt_outlined,",
      "    builder: (_) => const OnboardingMenuScreen(),",
      "    sidebarOrder: 100,",
      "    showInSidebar: true,",
      "  ),",
      "  DashboardSection(",
      "    key: 'onboarding_feature_setup',",
      "    title: 'Step 1: Feature Setup',",
      "    icon: Icons.tune,",
      "    builder: (_) => OnboardingFeatureSetupScreen(),",
      "    sidebarOrder: 101,",
      "    showInSidebar: true,",
      "  ),",
      "  DashboardSection(",
      "    key: 'onboardingIngredientTypes',",
      "    title: 'Step 2: Ingredient Types',",
      "    icon: Icons.category_outlined,",
      "    builder: (_) => const IngredientTypeManagementScreen(),",
      "    sidebarOrder: 102,",
      "    showInSidebar: true,",
      "  ),",
      "  DashboardSection(",
      "    key: 'onboardingIngredients',",
      "    title: 'Step 3: Ingredients',",
      "    icon: Icons.kitchen_outlined,",
      "    builder: (_) => const OnboardingIngredientsScreen(),",
      "    sidebarOrder: 103,",
      "    showInSidebar: true,",
      "  ),",
      "  DashboardSection(",
      "    key: 'onboardingCategories',",
      "    title: 'Step 4: Categories',",
      "    icon: Icons.category_outlined,",
      "    builder: (_) => const OnboardingCategoriesScreen(),",
      "    sidebarOrder: 104,",
      "    showInSidebar: true,",
      "  ),",
      "  DashboardSection(",
      "    key: 'onboardingMenuItems',",
      "    title: 'Step 5: Menu Items',",
      "    icon: Icons.local_pizza_outlined,",
      "    builder: (_) => const OnboardingMenuItemsScreen(),",
      "    sidebarOrder: 105,",
      "    showInSidebar: true,",
      "  ),",
      "  DashboardSection(",
      "    key: 'onboardingReview',",
      "    title: 'Review & Publish',",
      "    icon: Icons.check_circle_outline,",
      "    builder: (_) => const OnboardingReviewScreen(),",
      "    sidebarOrder: 106,",
      "    showInSidebar: true,",
      "  ),",
      "  // Add further onboarding/future steps here...",
      "];",
      "",
      "// ---- Sidebar and Section List Utilities ----",
      "",
      "/// Only sections with showInSidebar==true, sorted by sidebarOrder.",
      "List<DashboardSection> getSidebarSections() =>",
      "    sectionRegistry.where((s) => s.showInSidebar).toList()",
      "      ..sort((a, b) => a.sidebarOrder.compareTo(b.sidebarOrder));",
      "",
      "/// All sections (for routing, content stack, and selection), sorted by sidebarOrder.",
      "List<DashboardSection> getAllDashboardSections() => sectionRegistry.toList()",
      "  ..sort((a, b) => a.sidebarOrder.compareTo(b.sidebarOrder));"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 190,
      "file_size": 7163,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\theme_provider.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:shared_preferences/shared_preferences.dart';",
      "",
      "class ThemeProvider extends ChangeNotifier {",
      "  static const _prefKey = 'theme_mode';",
      "",
      "  ThemeMode _themeMode = ThemeMode.system;",
      "  ThemeMode get themeMode => _themeMode;",
      "",
      "  ThemeProvider() {",
      "    _loadThemeMode();",
      "  }",
      "",
      "  /// Call this to update the theme mode and persist selection",
      "  void setThemeMode(ThemeMode mode) async {",
      "    _themeMode = mode;",
      "    notifyListeners();",
      "    final prefs = await SharedPreferences.getInstance();",
      "    await prefs.setInt(_prefKey, _themeMode.index);",
      "  }",
      "",
      "  /// Loads saved theme mode from storage (called on construction)",
      "  Future<void> _loadThemeMode() async {",
      "    final prefs = await SharedPreferences.getInstance();",
      "    final index = prefs.getInt(_prefKey);",
      "    if (index != null && index >= 0 && index < ThemeMode.values.length) {",
      "      _themeMode = ThemeMode.values[index];",
      "      notifyListeners();",
      "    }",
      "  }",
      "",
      "  /// Optional: Toggle between light/dark only (for old usage)",
      "  void toggleTheme([bool? dark]) {",
      "    if (dark == null) {",
      "      _themeMode =",
      "          _themeMode == ThemeMode.dark ? ThemeMode.light : ThemeMode.dark;",
      "    } else {",
      "      _themeMode = dark ? ThemeMode.dark : ThemeMode.light;",
      "    }",
      "    setThemeMode(_themeMode);",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 42,
      "file_size": 1320,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\constants\\invoice_status.dart",
    "content": [
      "// lib/core/constants/invoice_status.dart",
      "enum InvoiceStatus {",
      "  unpaid,",
      "  paid,",
      "  overdue,",
      "  partial,",
      "  refunded,",
      "  voided,",
      "  failed,",
      "  draft,",
      "  sent,",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 12,
      "file_size": 166,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\models\\address.dart",
    "content": [
      "class Address {",
      "  final String id;",
      "  final String street;",
      "  final String city;",
      "  final String state;",
      "  final String zip;",
      "  final String label; // e.g., \"Home\", \"Work\"",
      "  final String? name; // e.g., \"John Doe\" (Recipient Name, Optional)",
      "",
      "  Address({",
      "    required this.id,",
      "    required this.street,",
      "    required this.city,",
      "    required this.state,",
      "    required this.zip,",
      "    required this.label,",
      "    this.name,",
      "  });",
      "",
      "  factory Address.fromMap(Map<String, dynamic> data) {",
      "    return Address(",
      "      id: data['id'] ?? '',",
      "      street: data['street'] ?? '',",
      "      city: data['city'] ?? '',",
      "      state: data['state'] ?? '',",
      "      zip: data['zip'] ?? '',",
      "      label: data['label'] ?? '',",
      "      name: data['name'],",
      "    );",
      "  }",
      "",
      "  Map<String, dynamic> toMap() {",
      "    return {",
      "      'id': id,",
      "      'street': street,",
      "      'city': city,",
      "      'state': state,",
      "      'zip': zip,",
      "      'label': label,",
      "      if (name != null) 'name': name,",
      "    };",
      "  }",
      "",
      "  /// Firestore integration",
      "  static Address fromFirestore(Map<String, dynamic> data, String docId) {",
      "    return Address.fromMap({...data, 'id': docId});",
      "  }",
      "",
      "  Map<String, dynamic> toFirestore() {",
      "    return toMap();",
      "  }",
      "",
      "  /// Fallback for name display (for admin usage): name > label",
      "  String get nameDisplay => name?.isNotEmpty == true ? name! : label;",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 55,
      "file_size": 1355,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\models\\alert_model.dart",
    "content": [
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "",
      "class AlertModel {",
      "  final String id;",
      "  final String title;",
      "  final String body;",
      "  final String type;",
      "  final String level;",
      "  final String icon;",
      "  final DateTime createdAt;",
      "  final DateTime? dismissedAt;",
      "  final String franchiseId;",
      "  final String? locationId;",
      "  final Map<String, dynamic> customFields;",
      "  final List<String> seenBy;",
      "",
      "  AlertModel({",
      "    required this.id,",
      "    required this.title,",
      "    required this.body,",
      "    required this.type,",
      "    required this.level,",
      "    required this.icon,",
      "    required this.createdAt,",
      "    required this.franchiseId,",
      "    this.locationId,",
      "    this.dismissedAt,",
      "    this.customFields = const {},",
      "    this.seenBy = const [],",
      "  });",
      "",
      "  factory AlertModel.fromFirestore(DocumentSnapshot doc) {",
      "    final data = doc.data() as Map<String, dynamic>;",
      "    return AlertModel(",
      "      id: doc.id,",
      "      title: data['title'] ?? '',",
      "      body: data['body'] ?? '',",
      "      type: data['type'] ?? '',",
      "      level: data['level'] ?? 'info',",
      "      icon: data['icon'] ?? 'info',",
      "      createdAt: (data['created_at'] as Timestamp).toDate(),",
      "      dismissedAt: data['dismissed_at'] != null",
      "          ? (data['dismissed_at'] as Timestamp).toDate()",
      "          : null,",
      "      franchiseId: _extractIdFromDocRef(data['franchiseId']),",
      "      locationId: data['locationId'] != null",
      "          ? _extractIdFromDocRef(data['locationId'])",
      "          : null,",
      "      customFields: Map<String, dynamic>.from(data['custom_fields'] ?? {}),",
      "      seenBy: (data['seen_by'] as List<dynamic>? ?? [])",
      "          .map((e) => e.toString())",
      "          .toList(),",
      "    );",
      "  }",
      "",
      "  static String _extractIdFromDocRef(dynamic ref) {",
      "    if (ref == null) return '';",
      "    if (ref is String) return ref;",
      "    if (ref is Map && ref.containsKey('path')) {",
      "      return ref['path'].split('/').last;",
      "    }",
      "    return '';",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 64,
      "file_size": 1909,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\models\\analytics_summary.dart",
    "content": [
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "",
      "class AnalyticsSummary {",
      "  final String franchiseId;",
      "  final String period;",
      "  final int totalOrders;",
      "  final double retentionRate;",
      "  final double totalRevenue;",
      "  final double averageOrderValue;",
      "  final String mostPopularItem;",
      "  final int cancelledOrders;",
      "  final Map<String, int> orderStatusBreakdown;",
      "  final int uniqueCustomers;",
      "  final DateTime? updatedAt;",
      "  final Map<String, int> addOnCounts;",
      "  final double addOnRevenue;",
      "  final Map<String, int> comboCounts;",
      "  final Map<String, int> toppingCounts;",
      "  final Map<String, dynamic>? feedbackStats;",
      "  double get retention => retentionRate;",
      "",
      "  AnalyticsSummary({",
      "    required this.franchiseId,",
      "    required this.period,",
      "    required this.totalOrders,",
      "    required this.retentionRate,",
      "    required this.totalRevenue,",
      "    required this.averageOrderValue,",
      "    required this.mostPopularItem,",
      "    required this.cancelledOrders,",
      "    required this.orderStatusBreakdown,",
      "    required this.uniqueCustomers,",
      "    this.updatedAt,",
      "    required this.addOnCounts,",
      "    required this.addOnRevenue,",
      "    required this.comboCounts,",
      "    required this.toppingCounts,",
      "    this.feedbackStats,",
      "  });",
      "",
      "  factory AnalyticsSummary.fromFirestore(Map<String, dynamic> data, String id) {",
      "    return AnalyticsSummary(",
      "      franchiseId: data['franchiseId'] ?? 'default',",
      "      period: data['period'] ?? '',",
      "      totalOrders: (data['totalOrders'] ?? 0) as int,",
      "      retentionRate: (data['retentionRate'] ?? 0.0).toDouble(),",
      "      totalRevenue: (data['totalRevenue'] ?? 0.0).toDouble(),",
      "      averageOrderValue: (data['averageOrderValue'] ?? 0.0).toDouble(),",
      "      mostPopularItem: data['mostPopularItem'] ?? '-',",
      "      cancelledOrders: (data['cancelledOrders'] ?? 0) as int,",
      "      orderStatusBreakdown:",
      "          (data['orderStatusBreakdown'] as Map<String, dynamic>?)",
      "                  ?.map((k, v) => MapEntry(k, (v as num).toInt())) ??",
      "              {},",
      "      uniqueCustomers: (data['uniqueCustomers'] ?? 0) as int,",
      "      updatedAt: data['updatedAt'] is Timestamp",
      "          ? (data['updatedAt'] as Timestamp).toDate()",
      "          : null,",
      "      addOnCounts: (data['addOnCounts'] as Map<String, dynamic>?)",
      "              ?.map((k, v) => MapEntry(k, (v as num).toInt())) ??",
      "          {},",
      "      addOnRevenue: (data['addOnRevenue'] ?? 0.0).toDouble(),",
      "      comboCounts: (data['comboCounts'] as Map<String, dynamic>?)",
      "              ?.map((k, v) => MapEntry(k, (v as num).toInt())) ??",
      "          {},",
      "      toppingCounts: (data['toppingCounts'] as Map<String, dynamic>?)",
      "              ?.map((k, v) => MapEntry(k, (v as num).toInt())) ??",
      "          {},",
      "      feedbackStats: data['feedbackStats'] != null",
      "          ? Map<String, dynamic>.from(data['feedbackStats'] as Map)",
      "          : null,",
      "    );",
      "  }",
      "",
      "  Map<String, dynamic> toFirestore() {",
      "    return {",
      "      'franchiseId': franchiseId,",
      "      'period': period,",
      "      'totalOrders': totalOrders,",
      "      'totalRevenue': totalRevenue,",
      "      'averageOrderValue': averageOrderValue,",
      "      'mostPopularItem': mostPopularItem,",
      "      'cancelledOrders': cancelledOrders,",
      "      'orderStatusBreakdown': orderStatusBreakdown,",
      "      'uniqueCustomers': uniqueCustomers,",
      "      'updatedAt': updatedAt,",
      "      'addOnCounts': addOnCounts,",
      "      'addOnRevenue': addOnRevenue,",
      "      'comboCounts': comboCounts,",
      "      'toppingCounts': toppingCounts,",
      "      if (feedbackStats != null) 'feedbackStats': feedbackStats,",
      "    };",
      "  }",
      "",
      "  // === COMPATIBILITY GETTERS (optional, for legacy code) ===",
      "",
      "  int get orderVolume => totalOrders;",
      "  double get revenue => totalRevenue;",
      "",
      "  /// Returns the item name with the highest count in toppingCounts, or '-' if none.",
      "  String get mostPopular => mostPopularItem.isNotEmpty ? mostPopularItem : '-';",
      "",
      "  /// For UI compatibility: Returns orderStatusBreakdown[\"Placed\"] if available.",
      "  int get placedOrders => orderStatusBreakdown[\"Placed\"] ?? 0;",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 105,
      "file_size": 3978,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\models\\audit_log.dart",
    "content": [
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "import 'dart:convert';",
      "",
      "class AuditLog {",
      "  final String id;",
      "  final String action;",
      "  final String userId;",
      "  final String? userEmail;",
      "  final String targetType;",
      "  final String targetId;",
      "  final String? details; // Stored as JSON string if export snapshot",
      "  final DateTime timestamp;",
      "  final String? ipAddress;",
      "",
      "  AuditLog({",
      "    required this.id,",
      "    required this.action,",
      "    required this.userId,",
      "    this.userEmail,",
      "    required this.targetType,",
      "    required this.targetId,",
      "    this.details,",
      "    required this.timestamp,",
      "    this.ipAddress,",
      "  });",
      "",
      "  factory AuditLog.fromFirestore(Map<String, dynamic> data, String id) {",
      "    return AuditLog(",
      "      id: id,",
      "      action: data['action'] ?? '',",
      "      userId: data['userId'] ?? '',",
      "      userEmail: data['userEmail'],",
      "      targetType: data['targetType'] ?? '',",
      "      targetId: data['targetId'] ?? '',",
      "      details: data['details'],",
      "      timestamp: (data['timestamp'] is Timestamp)",
      "          ? (data['timestamp'] as Timestamp).toDate()",
      "          : (data['timestamp'] is String)",
      "              ? DateTime.tryParse(data['timestamp']) ?? DateTime.now()",
      "              : DateTime.now(),",
      "      ipAddress: data['ipAddress'],",
      "    );",
      "  }",
      "",
      "  Map<String, dynamic> toFirestore() {",
      "    return {",
      "      'action': action,",
      "      'userId': userId,",
      "      'userEmail': userEmail,",
      "      'targetType': targetType,",
      "      'targetId': targetId,",
      "      'details': details,",
      "      'timestamp': Timestamp.fromDate(timestamp),",
      "      'ipAddress': ipAddress,",
      "    };",
      "  }",
      "",
      "  // === UI/Widget Support Getters ===",
      "",
      "  /// For widget compatibility, eventType resolves to action.",
      "  String get eventType => action;",
      "",
      "  /// For audit trail widget (named createdAt for UI consistency).",
      "  DateTime get createdAt => timestamp;",
      "",
      "  /// For audit trail, fallback to userEmail if you have no user name.",
      "  String? get userName =>",
      "      userEmail; // Extend to use actual names if/when you store them",
      "",
      "  /// Decodes exportSnapshot if details contains JSON. Returns null if not a JSON export.",
      "  Map<String, dynamic>? get exportSnapshot {",
      "    if (details == null) return null;",
      "    try {",
      "      final map = jsonDecode(details!);",
      "      if (map is Map<String, dynamic>) return map;",
      "    } catch (_) {}",
      "    return null;",
      "  }",
      "}",
      "",
      "class AuditLogEventType {",
      "  static const publishOnboarding = 'onboarding_publish';",
      "  static const cancelOnboarding = 'onboarding_cancel';",
      "  static const editOnboarding = 'onboarding_edit';",
      "  // Add more if your app emits more audit event types",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 86,
      "file_size": 2602,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\models\\bank_account.dart",
    "content": [
      "// lib/core/models/bank_account.dart",
      "",
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "",
      "class BankAccount {",
      "  final String id;",
      "  final DocumentReference franchiseRef;",
      "  final DocumentReference locationRef;",
      "  final DocumentReference ownerRef;",
      "  final String bankName;",
      "  final String accountLast4;",
      "  final String accountType; // e.g., 'business', 'personal'",
      "  final String currency;",
      "  final String country;",
      "  final bool verified;",
      "  final String plaidStatus;",
      "  final String stripeStatus;",
      "  final String integration; // e.g., 'plaid', 'stripe'",
      "  final DateTime? addedAt;",
      "  final DateTime? removedAt;",
      "  final Map<String, dynamic> customFields;",
      "",
      "  BankAccount({",
      "    required this.id,",
      "    required this.franchiseRef,",
      "    required this.locationRef,",
      "    required this.ownerRef,",
      "    required this.bankName,",
      "    required this.accountLast4,",
      "    required this.accountType,",
      "    required this.currency,",
      "    required this.country,",
      "    required this.verified,",
      "    required this.plaidStatus,",
      "    required this.stripeStatus,",
      "    required this.integration,",
      "    this.addedAt,",
      "    this.removedAt,",
      "    this.customFields = const {},",
      "  });",
      "",
      "  factory BankAccount.fromFirestore(Map<String, dynamic> data, String id) {",
      "    return BankAccount(",
      "      id: id,",
      "      franchiseRef: data['franchiseId'] as DocumentReference,",
      "      locationRef: data['locationId'] as DocumentReference,",
      "      ownerRef: data['owner_id'] as DocumentReference,",
      "      bankName: data['bank_name'] ?? '',",
      "      accountLast4: data['account_last4'] ?? '',",
      "      accountType: data['account_type'] ?? '',",
      "      currency: data['currency'] ?? '',",
      "      country: data['country'] ?? '',",
      "      verified: data['verified'] ?? false,",
      "      plaidStatus: data['plaid_status'] ?? '',",
      "      stripeStatus: data['stripe_status'] ?? '',",
      "      integration: data['integration'] ?? '',",
      "      addedAt: (data['added_at'] as Timestamp?)?.toDate(),",
      "      removedAt: (data['removed_at'] as Timestamp?)?.toDate(),",
      "      customFields: data['custom_fields'] ?? {},",
      "    );",
      "  }",
      "",
      "  Map<String, dynamic> toFirestore() {",
      "    return {",
      "      'franchiseId': franchiseRef,",
      "      'locationId': locationRef,",
      "      'owner_id': ownerRef,",
      "      'bank_name': bankName,",
      "      'account_last4': accountLast4,",
      "      'account_type': accountType,",
      "      'currency': currency,",
      "      'country': country,",
      "      'verified': verified,",
      "      'plaid_status': plaidStatus,",
      "      'stripe_status': stripeStatus,",
      "      'integration': integration,",
      "      'added_at': addedAt != null ? Timestamp.fromDate(addedAt!) : null,",
      "      'removed_at': removedAt != null ? Timestamp.fromDate(removedAt!) : null,",
      "      'custom_fields': customFields,",
      "    };",
      "  }",
      "",
      "  BankAccount copyWith({",
      "    String? id,",
      "    DocumentReference? franchiseRef,",
      "    DocumentReference? locationRef,",
      "    DocumentReference? ownerRef,",
      "    String? bankName,",
      "    String? accountLast4,",
      "    String? accountType,",
      "    String? currency,",
      "    String? country,",
      "    bool? verified,",
      "    String? plaidStatus,",
      "    String? stripeStatus,",
      "    String? integration,",
      "    DateTime? addedAt,",
      "    DateTime? removedAt,",
      "    Map<String, dynamic>? customFields,",
      "  }) {",
      "    return BankAccount(",
      "      id: id ?? this.id,",
      "      franchiseRef: franchiseRef ?? this.franchiseRef,",
      "      locationRef: locationRef ?? this.locationRef,",
      "      ownerRef: ownerRef ?? this.ownerRef,",
      "      bankName: bankName ?? this.bankName,",
      "      accountLast4: accountLast4 ?? this.accountLast4,",
      "      accountType: accountType ?? this.accountType,",
      "      currency: currency ?? this.currency,",
      "      country: country ?? this.country,",
      "      verified: verified ?? this.verified,",
      "      plaidStatus: plaidStatus ?? this.plaidStatus,",
      "      stripeStatus: stripeStatus ?? this.stripeStatus,",
      "      integration: integration ?? this.integration,",
      "      addedAt: addedAt ?? this.addedAt,",
      "      removedAt: removedAt ?? this.removedAt,",
      "      customFields: customFields ?? this.customFields,",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 120,
      "file_size": 3996,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\models\\banner.dart",
    "content": [
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "",
      "class Banner {",
      "  final String id;",
      "  final String title;",
      "  final String subtitle;",
      "  final String image;",
      "  final Action action;",
      "  final DateTime startDate;",
      "  final DateTime endDate;",
      "  final bool active;",
      "",
      "  Banner({",
      "    required this.id,",
      "    required this.title,",
      "    required this.subtitle,",
      "    required this.image,",
      "    required this.action,",
      "    required this.startDate,",
      "    required this.endDate,",
      "    required this.active,",
      "  });",
      "",
      "  factory Banner.fromFirestore(Map<String, dynamic> data, String id) {",
      "    return Banner(",
      "      id: id,",
      "      title: data['title'] ?? '',",
      "      subtitle: data['subtitle'] ?? '',",
      "      image: data['image'] ?? '',",
      "      action: Action.fromMap(data['action'] ?? {}),",
      "      startDate: (data['startDate'] as Timestamp?)?.toDate() ?? DateTime.now(),",
      "      endDate: (data['endDate'] as Timestamp?)?.toDate() ?? DateTime.now(),",
      "      active: data['active'] ?? false,",
      "    );",
      "  }",
      "",
      "  Map<String, dynamic> toFirestore() {",
      "    return {",
      "      'title': title,",
      "      'subtitle': subtitle,",
      "      'image': image,",
      "      'action': action.toMap(),",
      "      'startDate': Timestamp.fromDate(startDate),",
      "      'endDate': Timestamp.fromDate(endDate),",
      "      'active': active,",
      "    };",
      "  }",
      "}",
      "",
      "class Action {",
      "  final String type;",
      "  final String? value;",
      "  final String? ctaText; // <-- Modular CTA text",
      "",
      "  Action({",
      "    required this.type,",
      "    this.value,",
      "    this.ctaText,",
      "  });",
      "",
      "  factory Action.fromMap(Map<String, dynamic> data) {",
      "    return Action(",
      "      type: data['type'] ?? 'none',",
      "      value: data['value'],",
      "      ctaText: data['ctaText'],",
      "    );",
      "  }",
      "",
      "  Map<String, dynamic> toMap() {",
      "    return {",
      "      'type': type,",
      "      'value': value,",
      "      if (ctaText != null && ctaText!.isNotEmpty) 'ctaText': ctaText,",
      "    };",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 76,
      "file_size": 1858,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\models\\cash_flow_forecast.dart",
    "content": [
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "",
      "class CashFlowForecast {",
      "  final String franchiseId;",
      "  final String period; // e.g. \"2025-07\", \"2025-Q3\"",
      "  final double openingBalance;",
      "  final double projectedInflow;",
      "  final double projectedOutflow;",
      "  final double projectedClosingBalance;",
      "  final Timestamp? createdAt;",
      "",
      "  CashFlowForecast({",
      "    required this.franchiseId,",
      "    required this.period,",
      "    required this.openingBalance,",
      "    required this.projectedInflow,",
      "    required this.projectedOutflow,",
      "    required this.projectedClosingBalance,",
      "    this.createdAt,",
      "  });",
      "",
      "  factory CashFlowForecast.fromFirestore(Map<String, dynamic> data, String id) {",
      "    num toNum(dynamic v) => v is num ? v : 0;",
      "    print('fromFirestore got data: $data');",
      "    return CashFlowForecast(",
      "      franchiseId: data['franchiseId'] ?? id,",
      "      period: data['period'] ?? '',",
      "      openingBalance: toNum(data['openingBalance']).toDouble(),",
      "      projectedInflow: toNum(data['projectedInflow']).toDouble(),",
      "      projectedOutflow: toNum(data['projectedOutflow']).toDouble(),",
      "      projectedClosingBalance:",
      "          toNum(data['projectedClosingBalance']).toDouble(),",
      "      createdAt: data['createdAt'],",
      "    );",
      "  }",
      "",
      "  Map<String, dynamic> toFirestore() => {",
      "        'franchiseId': franchiseId,",
      "        'period': period,",
      "        'openingBalance': openingBalance,",
      "        'projectedInflow': projectedInflow,",
      "        'projectedOutflow': projectedOutflow,",
      "        'projectedClosingBalance': projectedClosingBalance,",
      "        'createdAt': createdAt,",
      "      };",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 46,
      "file_size": 1586,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\models\\category.dart",
    "content": [
      "// lib/core/models/category_model.dart",
      "import 'dart:convert';",
      "import 'package:flutter/foundation.dart';",
      "import 'package:collection/collection.dart';",
      "",
      "@immutable",
      "class Category {",
      "  /// Unique Firestore doc ID for this category (immutable, not written back).",
      "  final String id;",
      "",
      "  /// Display name for the category (e.g., \"Pizzas\", \"Salads\").",
      "  final String name;",
      "",
      "  /// Optional image URL (network) or asset path for category icon/thumbnails.",
      "  /// If missing or blank, UI should use a branded fallback asset.",
      "  final String? image;",
      "",
      "  /// Optional description of the category (for admin/backend/future use).",
      "  final String? description;",
      "",
      "  ///Sort order",
      "  final int? sortOrder;",
      "",
      "  const Category({",
      "    required this.id,",
      "    required this.name,",
      "    this.image,",
      "    this.description,",
      "    this.sortOrder,",
      "  });",
      "",
      "  /// Creates a Category from Firestore document data plus its doc ID.",
      "  factory Category.fromFirestore(Map<String, dynamic> data, String id) {",
      "    final cat = Category(",
      "      id: id,",
      "      name: (data['name'] as String?)?.trim() ?? '',",
      "      image: (data['image'] as String?)?.trim(),",
      "      description: (data['description'] as String?)?.trim(),",
      "      sortOrder: data['sortOrder'] is int ? data['sortOrder'] : null,",
      "    );",
      "    if (cat.schemaWarning != null) {",
      "      print('[Category.fromFirestore] WARNING: ${cat.schemaWarning}');",
      "    }",
      "    return cat;",
      "  }",
      "",
      "  /// Creates a Category from JSON-decoded map data (used in import dialogs)",
      "  static Category fromMap(Map<String, dynamic> data) {",
      "    final cat = Category(",
      "      id: data['id'] as String? ?? '',",
      "      name: data['name'] as String? ?? '',",
      "      image: data['image'] as String?,",
      "      description: data['description'] as String?,",
      "      sortOrder: data['sortOrder'] is int ? data['sortOrder'] : null,",
      "    );",
      "    if (cat.schemaWarning != null) {",
      "      print('[Category.fromMap] WARNING: ${cat.schemaWarning}');",
      "    }",
      "    return cat;",
      "  }",
      "",
      "  /// Serializes this Category for writing to Firestore.",
      "  Map<String, dynamic> toFirestore() {",
      "    return {",
      "      'name': name,",
      "      if (image != null && image!.isNotEmpty) 'image': image,",
      "      if (description != null && description!.isNotEmpty)",
      "        'description': description,",
      "      if (sortOrder != null) 'sortOrder': sortOrder,",
      "    };",
      "  }",
      "",
      "  /// Creates a copy with optional overrides.",
      "  Category copyWith({",
      "    String? id,",
      "    String? name,",
      "    String? image,",
      "    String? description,",
      "    int? sortOrder,",
      "  }) {",
      "    return Category(",
      "      id: id ?? this.id,",
      "      name: name ?? this.name,",
      "      image: image ?? this.image,",
      "      description: description ?? this.description,",
      "      sortOrder: sortOrder ?? this.sortOrder,",
      "    );",
      "  }",
      "",
      "  /// Equality override to help with provider dirty-state detection.",
      "  @override",
      "  bool operator ==(Object other) =>",
      "      identical(this, other) ||",
      "      other is Category &&",
      "          runtimeType == other.runtimeType &&",
      "          id == other.id &&",
      "          name == other.name &&",
      "          image == other.image &&",
      "          description == other.description;",
      "",
      "  @override",
      "  int get hashCode =>",
      "      id.hashCode ^ name.hashCode ^ image.hashCode ^ description.hashCode;",
      "",
      "  /// Used in import/export dialogs for JSON encoding",
      "  static String encodeJson(List<Map<String, dynamic>> categoryList) {",
      "    return JsonEncoder.withIndent('  ').convert(categoryList);",
      "  }",
      "",
      "  /// Batch validation utility for onboarding.",
      "  static List<String> findMissingReferences(",
      "    List<Category> categories,",
      "    List<String> referencedIdsOrNames,",
      "  ) {",
      "    return referencedIdsOrNames",
      "        .where((ref) => categories",
      "            .every((cat) => !cat.matchesId(ref) && !cat.matchesName(ref)))",
      "        .toList();",
      "  }",
      "",
      "  /// Returns true if this Category's id matches the given [id] (case-insensitive).",
      "  bool matchesId(String? otherId) =>",
      "      otherId != null && id.toLowerCase() == otherId.toLowerCase();",
      "",
      "  /// Returns true if this Category's name matches the given [name] (case-insensitive, trimmed).",
      "  bool matchesName(String? otherName) =>",
      "      otherName != null &&",
      "      name.trim().toLowerCase() == otherName.trim().toLowerCase();",
      "",
      "  /// Static utility to find a category by ID or (fallback) by name from a list.",
      "  static Category? resolveFromReference(",
      "    List<Category> categories, {",
      "    String? id,",
      "    String? name,",
      "  }) {",
      "    // Try by id",
      "    final byId = categories.firstWhereOrNull(",
      "      (cat) => cat.matchesId(id),",
      "    );",
      "    if (byId != null) return byId;",
      "",
      "// Try by name (for template onboarding fallbacks)",
      "    final byName = categories.firstWhereOrNull(",
      "      (cat) => cat.matchesName(name),",
      "    );",
      "    return byName;",
      "  }",
      "",
      "  /// Returns a warning string if this category is missing critical fields.",
      "  String? get schemaWarning {",
      "    if (id.isEmpty || name.isEmpty) {",
      "      return \"Category missing required id or name: id='$id', name='$name'\";",
      "    }",
      "    return null;",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 156,
      "file_size": 4978,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\models\\chat.dart",
    "content": [
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "",
      "class Chat {",
      "  final String id;",
      "  final String userId;",
      "  final String lastMessage;",
      "  final DateTime lastMessageAt;",
      "  final String status;",
      "  final String? userName; // Optionally store the user's name",
      "",
      "  Chat({",
      "    required this.id,",
      "    required this.userId,",
      "    required this.lastMessage,",
      "    required this.lastMessageAt,",
      "    required this.status,",
      "    this.userName,",
      "  });",
      "",
      "  factory Chat.fromFirestore(Map<String, dynamic> data, String id) {",
      "    return Chat(",
      "      id: id,",
      "      userId: data['userId'] ?? '',",
      "      lastMessage: data['lastMessage'] ?? '',",
      "      lastMessageAt: (data['lastMessageAt'] is Timestamp)",
      "          ? (data['lastMessageAt'] as Timestamp).toDate()",
      "          : DateTime.now(),",
      "      status: data['status'] ?? 'open',",
      "      userName:",
      "          data['userName'], // Optional, only if you store this in Firestore",
      "    );",
      "  }",
      "",
      "  Map<String, dynamic> toFirestore() {",
      "    return {",
      "      'userId': userId,",
      "      'lastMessage': lastMessage,",
      "      'lastMessageAt': Timestamp.fromDate(lastMessageAt),",
      "      'status': status,",
      "      if (userName != null) 'userName': userName,",
      "    };",
      "  }",
      "",
      "  /// Getter for userName (falls back to userId if not available)",
      "  String get userNameOrId => userName ?? userId;",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 46,
      "file_size": 1318,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\models\\customization.dart",
    "content": [
      "import 'dart:math';",
      "",
      "enum Portion { whole, left, right }",
      "",
      "class Customization {",
      "  final String id;",
      "  final String? ingredientId;",
      "  final String name;",
      "  final bool isGroup;",
      "  final double price;",
      "  final bool required;",
      "  final int? minChoices;",
      "  final int? maxChoices;",
      "  final int? maxFree;",
      "  final int? sortOrder;",
      "  final String? group;",
      "  final List<Customization>? options; // Nested options if group",
      "  final bool isDefault;",
      "  final bool outOfStock;",
      "  final Map<String, double>? upcharges; // Per-size upcharge",
      "  final double? extraUpcharge;",
      "  final double? doubleUpcharge;",
      "  final List<String>? dietaryTags;",
      "  final List<String>? allergens;",
      "  final bool allowExtra;",
      "  final bool allowSide;",
      "  final bool hidden;",
      "",
      "  // UI-state (not persisted)",
      "  final bool selected;",
      "  final Portion portion;",
      "  final int quantity;",
      "",
      "  Customization({",
      "    String? id,",
      "    this.ingredientId,",
      "    required this.name,",
      "    required this.isGroup,",
      "    this.price = 0.0,",
      "    this.required = false,",
      "    this.minChoices,",
      "    this.maxChoices,",
      "    this.maxFree,",
      "    this.sortOrder,",
      "    this.group,",
      "    this.options,",
      "    this.isDefault = false,",
      "    this.outOfStock = false,",
      "    this.upcharges,",
      "    this.extraUpcharge,",
      "    this.doubleUpcharge,",
      "    this.dietaryTags,",
      "    this.allergens,",
      "    this.allowExtra = false,",
      "    this.allowSide = false,",
      "    this.hidden = false,",
      "    this.selected = false,",
      "    this.portion = Portion.whole,",
      "    this.quantity = 1,",
      "  }) : id = id ?? _randomId();",
      "",
      "  Map<String, dynamic> toMap() => toFirestore();",
      "",
      "  factory Customization.fromMap(Map<String, dynamic> data) =>",
      "      Customization.fromFirestore(data);",
      "",
      "  factory Customization.fromFirestore(Map<String, dynamic> data) {",
      "    double parsedPrice = 0.0;",
      "    Map<String, double>? upcharges;",
      "    final priceField = data['price'];",
      "    if (priceField is num) {",
      "      parsedPrice = priceField.toDouble();",
      "    } else if (priceField is Map) {",
      "      upcharges = priceField.map<String, double>(",
      "          (k, v) => MapEntry(k.toString(), (v as num).toDouble()));",
      "      if (upcharges.isNotEmpty) parsedPrice = upcharges.values.first;",
      "    }",
      "",
      "    return Customization(",
      "      id: data['id'] ?? _randomId(),",
      "      ingredientId: data['ingredientId'],",
      "      name: data['name'] ?? '',",
      "      isGroup: data['isGroup'] ?? false,",
      "      price: parsedPrice,",
      "      required: data['required'] ?? false,",
      "      minChoices: data['minChoices'],",
      "      maxChoices: data['maxChoices'],",
      "      maxFree: data['maxFree'],",
      "      sortOrder: data['sortOrder'],",
      "      group: data['group'],",
      "      options: data['options'] != null",
      "          ? (data['options'] as List)",
      "              .map((o) =>",
      "                  Customization.fromFirestore(Map<String, dynamic>.from(o)))",
      "              .toList()",
      "          : null,",
      "      isDefault: data['isDefault'] ?? false,",
      "      outOfStock: data['outOfStock'] ?? false,",
      "      upcharges: upcharges ??",
      "          (data['upcharges'] != null",
      "              ? Map<String, double>.from(data['upcharges'])",
      "              : null),",
      "      extraUpcharge: (data['extraUpcharge'] as num?)?.toDouble(),",
      "      doubleUpcharge: (data['doubleUpcharge'] as num?)?.toDouble(),",
      "      dietaryTags: data['dietaryTags'] != null",
      "          ? List<String>.from(data['dietaryTags'])",
      "          : null,",
      "      allergens: data['allergens'] != null",
      "          ? List<String>.from(data['allergens'])",
      "          : null,",
      "      allowExtra: data['allowExtra'] ?? false,",
      "      allowSide: data['allowSide'] ?? false,",
      "      hidden: data['hidden'] ?? false,",
      "    );",
      "  }",
      "",
      "  Map<String, dynamic> toFirestore() {",
      "    final priceField =",
      "        (upcharges != null && upcharges!.isNotEmpty) ? upcharges : price;",
      "    return {",
      "      'id': id,",
      "      'ingredientId': ingredientId,",
      "      'name': name,",
      "      'isGroup': isGroup,",
      "      'price': priceField,",
      "      'required': required,",
      "      if (minChoices != null) 'minChoices': minChoices,",
      "      if (maxChoices != null) 'maxChoices': maxChoices,",
      "      if (maxFree != null) 'maxFree': maxFree,",
      "      if (sortOrder != null) 'sortOrder': sortOrder,",
      "      if (group != null) 'group': group,",
      "      if (options != null)",
      "        'options': options!.map((o) => o.toFirestore()).toList(),",
      "      'isDefault': isDefault,",
      "      'outOfStock': outOfStock,",
      "      if (upcharges != null && upcharges!.isNotEmpty) 'upcharges': upcharges,",
      "      if (extraUpcharge != null) 'extraUpcharge': extraUpcharge,",
      "      if (doubleUpcharge != null) 'doubleUpcharge': doubleUpcharge,",
      "      if (dietaryTags != null) 'dietaryTags': dietaryTags,",
      "      if (allergens != null) 'allergens': allergens,",
      "      'allowExtra': allowExtra,",
      "      'allowSide': allowSide,",
      "      'hidden': hidden,",
      "      // No UI-state fields are persisted",
      "    };",
      "  }",
      "}",
      "",
      "String _randomId([int len = 16]) {",
      "  const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';",
      "  final rand = Random.secure();",
      "  return List.generate(len, (index) => chars[rand.nextInt(chars.length)])",
      "      .join();",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 154,
      "file_size": 5008,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\models\\customization_group.dart",
    "content": [
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "import 'package:equatable/equatable.dart';",
      "import 'ingredient_reference.dart';",
      "",
      "/// Represents a logical group of customizable ingredients,",
      "/// such as \"Choose Your Sauce\", \"Toppings\", or \"Bread Options\".",
      "///",
      "/// A group contains:",
      "/// - A label (displayed to the customer)",
      "/// - A selectionLimit (e.g. choose up to 2 toppings)",
      "/// - A list of valid ingredient references (from IngredientMetadata)",
      "///",
      "/// CustomizationGroup is used inside MenuItem as a nested structure.",
      "class CustomizationGroup extends Equatable {",
      "  final String id;",
      "  final String label;",
      "  final int selectionLimit;",
      "  final List<IngredientReference> ingredients;",
      "",
      "  const CustomizationGroup({",
      "    required this.id,",
      "    required this.label,",
      "    required this.selectionLimit,",
      "    required this.ingredients,",
      "  });",
      "",
      "  CustomizationGroup copyWith({",
      "    String? id,",
      "    String? label,",
      "    int? selectionLimit,",
      "    List<IngredientReference>? ingredients,",
      "  }) {",
      "    return CustomizationGroup(",
      "      id: id ?? this.id,",
      "      label: label ?? this.label,",
      "      selectionLimit: selectionLimit ?? this.selectionLimit,",
      "      ingredients: ingredients ?? this.ingredients,",
      "    );",
      "  }",
      "",
      "  factory CustomizationGroup.fromMap(Map<String, dynamic> map) {",
      "    return CustomizationGroup(",
      "      id: map['id'] ?? '',",
      "      label: map['label'] ?? '',",
      "      selectionLimit: map['selectionLimit'] ?? 1,",
      "      ingredients: (map['ingredients'] as List?)",
      "              ?.where((e) => e != null)",
      "              .map((e) {",
      "            print(",
      "                '[DEBUG] Ingredient entry type: ${e.runtimeType} | value: $e');",
      "",
      "            if (e is IngredientReference) return e;",
      "            if (e is Map)",
      "              return IngredientReference.fromMap(Map<String, dynamic>.from(e));",
      "            if (e is String) {",
      "              // Defensive: convert string id to IngredientReference",
      "              return IngredientReference(",
      "                id: e,",
      "                name: e,",
      "                typeId: '',",
      "                isRemovable: true,",
      "              );",
      "            }",
      "            throw Exception(\"Invalid ingredient entry: $e\");",
      "          }).toList() ??",
      "          [],",
      "    );",
      "  }",
      "",
      "  Map<String, dynamic> toMap() {",
      "    return {",
      "      'id': id,",
      "      'label': label,",
      "      'selectionLimit': selectionLimit,",
      "      'ingredients': ingredients.map((e) => e.toMap()).toList(),",
      "    };",
      "  }",
      "",
      "  factory CustomizationGroup.fromFirestore(DocumentSnapshot doc) {",
      "    return CustomizationGroup.fromMap(doc.data() as Map<String, dynamic>);",
      "  }",
      "",
      "  Map<String, dynamic> toFirestore() => toMap();",
      "",
      "  @override",
      "  List<Object?> get props => [id, label, selectionLimit, ingredients];",
      "",
      "  bool get isValid => label.trim().isNotEmpty && ingredients.isNotEmpty;",
      "",
      "  @override",
      "  String toString() {",
      "    return 'CustomizationGroup(id: $id, label: $label, limit: $selectionLimit, ingredients: ${ingredients.length})';",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 94,
      "file_size": 2975,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\models\\dashboard_section.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "",
      "class DashboardSection {",
      "  final String key;",
      "  final String title;",
      "  final IconData icon;",
      "  final WidgetBuilder builder;",
      "  final int sidebarOrder;",
      "  final bool showInSidebar;",
      "",
      "  const DashboardSection({",
      "    required this.key,",
      "    required this.title,",
      "    required this.icon,",
      "    required this.builder,",
      "    required this.sidebarOrder,",
      "    this.showInSidebar = true,",
      "  });",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 19,
      "file_size": 433,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\models\\error_log.dart",
    "content": [
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "import 'package:flutter/material.dart';",
      "",
      "class ErrorLog {",
      "  final String id;",
      "  final String message;",
      "  final String severity;",
      "  final String source;",
      "  final String screen;",
      "  final String? stackTrace;",
      "  final Map<String, dynamic>? contextData;",
      "  final Map<String, dynamic>? deviceInfo;",
      "  final String? userId;",
      "  final String? errorType;",
      "  final String? assignedTo;",
      "  final bool resolved;",
      "  final bool archived;",
      "  final List<Map<String, dynamic>> comments;",
      "  final DateTime timestamp;",
      "  final DateTime? updatedAt;",
      "",
      "  ErrorLog({",
      "    required this.id,",
      "    required this.message,",
      "    required this.severity,",
      "    required this.source,",
      "    required this.screen,",
      "    this.stackTrace,",
      "    this.contextData,",
      "    this.deviceInfo,",
      "    this.userId,",
      "    this.errorType,",
      "    this.assignedTo,",
      "    this.resolved = false,",
      "    this.archived = false,",
      "    this.comments = const [],",
      "    required this.timestamp,",
      "    this.updatedAt,",
      "  });",
      "",
      "  /// For Firestore writes (do NOT include 'id' as field!)",
      "  Map<String, dynamic> toFirestore() {",
      "    return {",
      "      'message': message,",
      "      'severity': severity,",
      "      'source': source,",
      "      'screen': screen,",
      "      if (stackTrace != null) 'stackTrace': stackTrace,",
      "      if (contextData != null) 'contextData': contextData,",
      "      if (deviceInfo != null) 'deviceInfo': deviceInfo,",
      "      if (userId != null) 'userId': userId,",
      "      if (errorType != null) 'errorType': errorType,",
      "      if (assignedTo != null) 'assignedTo': assignedTo,",
      "      'resolved': resolved,",
      "      'archived': archived,",
      "      'comments': comments,",
      "      'timestamp': Timestamp.fromDate(timestamp),",
      "      if (updatedAt != null) 'updatedAt': Timestamp.fromDate(updatedAt!),",
      "    };",
      "  }",
      "",
      "  /// For table views, debug export, etc. (INCLUDES 'id')",
      "  Map<String, dynamic> toJson() {",
      "    return {",
      "      'id': id,",
      "      'message': message,",
      "      'severity': severity,",
      "      'source': source,",
      "      'screen': screen,",
      "      'stackTrace': stackTrace,",
      "      'contextData': contextData,",
      "      'deviceInfo': deviceInfo,",
      "      'userId': userId,",
      "      'errorType': errorType,",
      "      'assignedTo': assignedTo,",
      "      'resolved': resolved,",
      "      'archived': archived,",
      "      'comments': comments,",
      "      'timestamp': timestamp.toIso8601String(),",
      "      'updatedAt': updatedAt?.toIso8601String(),",
      "    };",
      "  }",
      "",
      "  factory ErrorLog.fromMap(Map<String, dynamic> data, String id) {",
      "    DateTime parseTimestamp(dynamic ts) {",
      "      if (ts == null) {",
      "        throw Exception(",
      "            '[ErrorLog] Missing required \"timestamp\" field in log: $id');",
      "      }",
      "      if (ts is Timestamp) return ts.toDate();",
      "      if (ts is DateTime) return ts;",
      "      if (ts is String) return DateTime.tryParse(ts) ?? DateTime.now();",
      "      throw Exception('[ErrorLog] Unrecognized timestamp format in log: $id');",
      "    }",
      "",
      "    List<Map<String, dynamic>> parseComments(dynamic val) {",
      "      if (val == null) return [];",
      "      if (val is List) {",
      "        return val",
      "            .where((e) => e is Map || e is Map<String, dynamic>)",
      "            .map((e) => Map<String, dynamic>.from(e))",
      "            .toList();",
      "      }",
      "      return [];",
      "    }",
      "",
      "    final dynamic ts = data['timestamp'] ?? data['createdAt'];",
      "    if (ts == null) {",
      "      debugPrint(",
      "          '⚠️ Skipping ErrorLog \"$id\" due to missing timestamp or createdAt');",
      "      throw Exception('Missing timestamp in ErrorLog \"$id\"');",
      "    }",
      "",
      "    final DateTime timestamp = parseTimestamp(ts);",
      "",
      "    return ErrorLog(",
      "      id: id,",
      "      message: data['message'] ?? '',",
      "      severity: data['severity'] ?? 'unknown',",
      "      source: data['source'] ?? '',",
      "      screen: data['screen'] ?? '',",
      "      stackTrace: data['stackTrace'],",
      "      contextData: (data['contextData'] as Map?)?.cast<String, dynamic>(),",
      "      deviceInfo: (data['deviceInfo'] as Map?)?.cast<String, dynamic>(),",
      "      userId: data['userId'],",
      "      errorType: data['errorType'],",
      "      assignedTo: data['assignedTo'],",
      "      resolved: data['resolved'] ?? false,",
      "      archived: data['archived'] ?? false,",
      "      comments: parseComments(data['comments']),",
      "      timestamp: timestamp,",
      "      updatedAt:",
      "          data['updatedAt'] != null ? parseTimestamp(data['updatedAt']) : null,",
      "    );",
      "  }",
      "",
      "  factory ErrorLog.fromFirestore(DocumentSnapshot doc) {",
      "    final data = doc.data() as Map<String, dynamic>;",
      "    return ErrorLog.fromMap(data, doc.id);",
      "  }",
      "",
      "  static ErrorLog? tryParse(DocumentSnapshot doc) {",
      "    final data = doc.data() as Map<String, dynamic>?;",
      "    if (data == null) return null;",
      "    try {",
      "      return ErrorLog.fromMap(data, doc.id);",
      "    } catch (e) {",
      "      return null;",
      "    }",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 151,
      "file_size": 4738,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\models\\feature_metadata.dart",
    "content": [
      "// File: lib/core/models/feature_metadata.dart",
      "",
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "import 'package:flutter/foundation.dart';",
      "import 'package:franchise_admin_portal/core/models/feature_module.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class FeatureState {",
      "  /// Map of feature modules keyed by feature ID",
      "  final Map<String, FeatureModule> modules;",
      "",
      "  /// Enables the Real-Time Operational Snapshot dashboard section",
      "  final bool liveSnapshotEnabled;",
      "",
      "  FeatureState({",
      "    required this.modules,",
      "    required this.liveSnapshotEnabled,",
      "  });",
      "",
      "  /// Factory for creating from a Map",
      "  factory FeatureState.fromMap(Map<String, dynamic> data) {",
      "    try {",
      "      final parsedModules = <String, FeatureModule>{};",
      "",
      "      for (final entry in data.entries) {",
      "        if (entry.value is Map<String, dynamic>) {",
      "          parsedModules[entry.key] = FeatureModule.fromMap(entry.value);",
      "        }",
      "      }",
      "",
      "      final liveSnapshotFlag = data['liveSnapshotEnabled'] ?? false;",
      "",
      "      debugPrint(",
      "        '[FeatureState] liveSnapshotEnabled loaded: $liveSnapshotFlag',",
      "      );",
      "",
      "      return FeatureState(",
      "        modules: parsedModules,",
      "        liveSnapshotEnabled: liveSnapshotFlag,",
      "      );",
      "    } catch (e, st) {",
      "      ErrorLogger.log(",
      "        message: 'Failed to parse FeatureState',",
      "        stack: st.toString(),",
      "        source: 'FeatureState.fromMap',",
      "        severity: 'error',",
      "        screen: 'feature_metadata.dart',",
      "        contextData: {'rawData': data},",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Converts to Map for Firestore or local storage",
      "  Map<String, dynamic> toMap() {",
      "    try {",
      "      return {",
      "        ...modules.map((key, module) => MapEntry(key, module.toMap())),",
      "        'liveSnapshotEnabled': liveSnapshotEnabled,",
      "      };",
      "    } catch (e, st) {",
      "      ErrorLogger.log(",
      "        message: 'Failed to convert FeatureState toMap',",
      "        stack: st.toString(),",
      "        source: 'FeatureState.toMap',",
      "        severity: 'error',",
      "        screen: 'feature_metadata.dart',",
      "        contextData: {",
      "          'moduleCount': modules.length,",
      "          'liveSnapshotEnabled': liveSnapshotEnabled,",
      "        },",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Factory for creating directly from Firestore snapshot",
      "  factory FeatureState.fromFirestore(DocumentSnapshot doc) {",
      "    try {",
      "      return FeatureState.fromMap(doc.data() as Map<String, dynamic>);",
      "    } catch (e, st) {",
      "      ErrorLogger.log(",
      "        message: 'Failed to parse FeatureState from Firestore',",
      "        stack: st.toString(),",
      "        source: 'FeatureState.fromFirestore',",
      "        severity: 'error',",
      "        screen: 'feature_metadata.dart',",
      "        contextData: {'docId': doc.id},",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Converts to Firestore format",
      "  Map<String, dynamic> toFirestore() => toMap();",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 96,
      "file_size": 2895,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\models\\feature_module.dart",
    "content": [
      "class FeatureModule {",
      "  final bool enabled;",
      "  final Map<String, bool> features;",
      "",
      "  FeatureModule({",
      "    required this.enabled,",
      "    required this.features,",
      "  });",
      "",
      "  factory FeatureModule.fromMap(Map<String, dynamic> map) {",
      "    return FeatureModule(",
      "      enabled: map['enabled'] == true,",
      "      features: Map<String, bool>.from(map['features'] ?? {}),",
      "    );",
      "  }",
      "",
      "  Map<String, dynamic> toMap() {",
      "    return {",
      "      'enabled': enabled,",
      "      'features': features,",
      "    };",
      "  }",
      "",
      "  FeatureModule copyWith({",
      "    bool? enabled,",
      "    Map<String, bool>? features,",
      "  }) {",
      "    return FeatureModule(",
      "      enabled: enabled ?? this.enabled,",
      "      features: features ?? Map<String, bool>.from(this.features),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 33,
      "file_size": 738,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\models\\feature_toggle.dart",
    "content": [],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 0,
      "file_size": 0,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\models\\feedback_entry.dart",
    "content": [
      "// lib/core/models/feedback.dart",
      "",
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "",
      "class FeedbackEntry {",
      "  final String id;",
      "  final int rating;",
      "  final String? comment;",
      "  final List<String> categories;",
      "  final DateTime timestamp;",
      "  final String userId;",
      "  final bool anonymous;",
      "  final String orderId;",
      "  final String subject;",
      "  final String message;",
      "  final String feedbackMode;",
      "  FeedbackEntry({",
      "    required this.id,",
      "    required this.rating,",
      "    this.comment,",
      "    required this.categories,",
      "    required this.timestamp,",
      "    required this.userId,",
      "    required this.anonymous,",
      "    required this.orderId,",
      "    this.subject = '',",
      "    this.message = '',",
      "    this.feedbackMode = 'orderExperience',",
      "  });",
      "",
      "  String get title => subject.isNotEmpty ? subject : 'Feedback';",
      "",
      "  factory FeedbackEntry.fromFirestore(Map<String, dynamic> data, String id) {",
      "    return FeedbackEntry(",
      "      id: id,",
      "      rating: data['rating'] ?? 0,",
      "      comment: data['comment'],",
      "      categories: (data['categories'] as List<dynamic>?)?.cast<String>() ?? [],",
      "      timestamp: (data['timestamp'] as Timestamp?)?.toDate() ?? DateTime.now(),",
      "      userId: data['userId'] ?? '',",
      "      anonymous: data['anonymous'] ?? false,",
      "      orderId: data['orderId'] ?? '',",
      "      subject: data['subject'] ?? '',",
      "      message: data['message'] ?? data['comment'] ?? '',",
      "      feedbackMode: data['feedbackMode'] ?? 'orderExperience',",
      "    );",
      "  }",
      "",
      "  Map<String, dynamic> toFirestore() {",
      "    return {",
      "      'rating': rating,",
      "      'comment': comment,",
      "      'categories': categories,",
      "      'timestamp': Timestamp.fromDate(timestamp),",
      "      'userId': userId,",
      "      'anonymous': anonymous,",
      "      'orderId': orderId,",
      "      'subject': subject,",
      "      'message': message,",
      "      'feedbackMode': feedbackMode,",
      "    };",
      "  }",
      "",
      "  FeedbackEntry copyWith({",
      "    String? id,",
      "    int? rating,",
      "    String? comment,",
      "    List<String>? categories,",
      "    DateTime? timestamp,",
      "    String? userId,",
      "    bool? anonymous,",
      "    String? orderId,",
      "    String? subject,",
      "    String? message,",
      "  }) {",
      "    return FeedbackEntry(",
      "      id: id ?? this.id,",
      "      rating: rating ?? this.rating,",
      "      comment: comment ?? this.comment,",
      "      categories: categories ?? this.categories,",
      "      timestamp: timestamp ?? this.timestamp,",
      "      userId: userId ?? this.userId,",
      "      anonymous: anonymous ?? this.anonymous,",
      "      orderId: orderId ?? this.orderId,",
      "      subject: subject ?? this.subject,",
      "      message: message ?? this.message,",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 89,
      "file_size": 2545,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\models\\franchisee_invitation.dart",
    "content": [
      "// File: lib/core/models/franchisee_invitation.dart",
      "",
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/config/branding_config.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "",
      "/// Model representing a pending or completed franchisee invitation.",
      "/// Includes methods for Firestore serialization/deserialization, robust error logging,",
      "/// and display helpers.",
      "class FranchiseeInvitation {",
      "  final String id;",
      "  final String email;",
      "  final String inviterUserId;",
      "  final String? franchiseName;",
      "  final String",
      "      status; // e.g. \"pending\", \"sent\", \"accepted\", \"revoked\", \"expired\"",
      "  final String? token;",
      "  final DateTime createdAt;",
      "  final DateTime? lastSentAt;",
      "  final String? role;",
      "",
      "  FranchiseeInvitation({",
      "    required this.id,",
      "    required this.email,",
      "    required this.inviterUserId,",
      "    this.franchiseName,",
      "    required this.status,",
      "    this.token,",
      "    this.role,",
      "    required this.createdAt,",
      "    this.lastSentAt,",
      "  });",
      "",
      "  /// For localization of status and info.",
      "  String localizedStatus(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[FranchiseeInvitation] loc is null! Localization not available for this context.');",
      "      // Fallback to default English or raw status",
      "      switch (status) {",
      "        case 'pending':",
      "          return 'Pending';",
      "        case 'sent':",
      "          return 'Sent';",
      "        case 'accepted':",
      "          return 'Accepted';",
      "        case 'revoked':",
      "          return 'Revoked';",
      "        case 'expired':",
      "          return 'Expired';",
      "        default:",
      "          return status;",
      "      }",
      "    }",
      "    switch (status) {",
      "      case 'pending':",
      "        return loc.inviteStatusPending ?? 'Pending';",
      "      case 'sent':",
      "        return loc.inviteStatusSent ?? 'Sent';",
      "      case 'accepted':",
      "        return loc.inviteStatusAccepted ?? 'Accepted';",
      "      case 'revoked':",
      "        return loc.inviteStatusRevoked ?? 'Revoked';",
      "      case 'expired':",
      "        return loc.inviteStatusExpired ?? 'Expired';",
      "      default:",
      "        return status;",
      "    }",
      "  }",
      "",
      "  /// Color mapping for status, uses config tokens.",
      "  Color statusColor(ColorScheme scheme) {",
      "    switch (status) {",
      "      case 'pending':",
      "        return scheme.primary;",
      "      case 'sent':",
      "        return scheme.secondary;",
      "      case 'accepted':",
      "        return Colors.green;",
      "      case 'revoked':",
      "        return scheme.error;",
      "      case 'expired':",
      "        return scheme.outline;",
      "      default:",
      "        return scheme.outlineVariant;",
      "    }",
      "  }",
      "",
      "  /// Firestore: from document snapshot",
      "  factory FranchiseeInvitation.fromDoc(DocumentSnapshot doc) {",
      "    final data = doc.data() as Map<String, dynamic>? ?? {};",
      "    try {",
      "      return FranchiseeInvitation(",
      "        id: doc.id,",
      "        email: data['email'] ?? '',",
      "        inviterUserId: data['inviterUserId'] ?? '',",
      "        franchiseName: data['franchiseName'],",
      "        status: data['status'] ?? 'pending',",
      "        token: data['token'],",
      "        role: data['role'],",
      "        createdAt:",
      "            (data['createdAt'] as Timestamp?)?.toDate() ?? DateTime.now(),",
      "        lastSentAt: (data['lastSentAt'] as Timestamp?)?.toDate(),",
      "      );",
      "    } catch (e, stack) {",
      "      ErrorLogger.log(",
      "        message: 'Failed to parse FranchiseeInvitation doc',",
      "        stack: stack.toString(),",
      "        severity: 'error',",
      "        source: 'FranchiseeInvitation.fromDoc',",
      "        screen: 'FranchiseeInvitation',",
      "        contextData: {'exception': e.toString(), 'docId': doc.id},",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Firestore: to map for saving",
      "  Map<String, dynamic> toMap() {",
      "    return {",
      "      'email': email,",
      "      'inviterUserId': inviterUserId,",
      "      if (franchiseName != null) 'franchiseName': franchiseName,",
      "      'status': status,",
      "      if (token != null) 'token': token,",
      "      if (role != null) 'role': role,",
      "      'createdAt': Timestamp.fromDate(createdAt),",
      "      if (lastSentAt != null) 'lastSentAt': Timestamp.fromDate(lastSentAt!),",
      "    };",
      "  }",
      "",
      "  /// Robustly create a Firestore doc for this invitation.",
      "  Future<void> saveToFirestore(FirestoreService firestoreService) async {",
      "    try {",
      "      await firestoreService.invitationCollection.doc(id).set(toMap());",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to save FranchiseeInvitation',",
      "        stack: stack.toString(),",
      "        severity: 'error',",
      "        source: 'FranchiseeInvitation.saveToFirestore',",
      "        screen: 'FranchiseeInvitation',",
      "        contextData: {",
      "          'exception': e.toString(),",
      "          'inviteId': id,",
      "          'email': email",
      "        },",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Static helper: create a new invitation and save, returns instance.",
      "  static Future<FranchiseeInvitation> createAndSave({",
      "    required String email,",
      "    required String inviterUserId,",
      "    String? franchiseName,",
      "    String? token,",
      "    required FirestoreService firestoreService,",
      "  }) async {",
      "    final id = firestoreService.invitationCollection.doc().id;",
      "    final invitation = FranchiseeInvitation(",
      "      id: id,",
      "      email: email,",
      "      inviterUserId: inviterUserId,",
      "      franchiseName: franchiseName,",
      "      status: 'pending',",
      "      token: token,",
      "      createdAt: DateTime.now(),",
      "      lastSentAt: null,",
      "    );",
      "    await invitation.saveToFirestore(firestoreService);",
      "    return invitation;",
      "  }",
      "",
      "  /// Developer-only: toString",
      "  @override",
      "  String toString() {",
      "    return 'FranchiseeInvitation(id: $id, email: $email, inviter: $inviterUserId, franchiseName: $franchiseName, status: $status, token: $token, createdAt: $createdAt, lastSentAt: $lastSentAt)';",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 186,
      "file_size": 6015,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\models\\franchise_info.dart",
    "content": [
      "class FranchiseInfo {",
      "  final String id;",
      "  final String name;",
      "  final String? logoUrl;",
      "  final String? status;",
      "  final String? ownerName;",
      "  final String? phone;",
      "  final String? businessEmail;",
      "  final String? restaurantType;",
      "",
      "  FranchiseInfo({",
      "    required this.id,",
      "    required this.name,",
      "    this.logoUrl,",
      "    this.status,",
      "    this.ownerName,",
      "    this.phone,",
      "    this.businessEmail,",
      "    this.restaurantType,",
      "  });",
      "",
      "  factory FranchiseInfo.fromMap(Map<String, dynamic> data, String id) {",
      "    return FranchiseInfo(",
      "      id: id,",
      "      name: data['name'] ?? 'Unnamed Franchise',",
      "      logoUrl: data['logoUrl'],",
      "      status: data['status'] ?? 'active',",
      "      ownerName: data['ownerName'],",
      "      phone: data['phone'],",
      "      businessEmail: data['businessEmail'],",
      "      restaurantType: data['restaurantType'] as String?,",
      "    );",
      "  }",
      "",
      "  Map<String, dynamic> toFirestore() {",
      "    return {",
      "      'name': name,",
      "      if (logoUrl != null) 'logoUrl': logoUrl,",
      "      if (status != null) 'status': status,",
      "      if (ownerName != null) 'ownerName': ownerName,",
      "      if (phone != null) 'phone': phone,",
      "      if (businessEmail != null) 'businessEmail': businessEmail,",
      "      if (restaurantType != null) 'restaurantType': restaurantType,",
      "    };",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 46,
      "file_size": 1277,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\models\\franchise_subscription_model.dart",
    "content": [
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "",
      "class FranchiseSubscription {",
      "  /// Firestore document ID",
      "  final String id;",
      "",
      "  /// Associated franchise ID",
      "  final String franchiseId;",
      "",
      "  /// Platform plan ID (linked to platform_plans collection)",
      "  final String platformPlanId;",
      "",
      "  /// Subscription status: 'active', 'paused', 'canceled', 'trialing', etc.",
      "  final String status;",
      "",
      "  /// Date the subscription started",
      "  final DateTime startDate;",
      "",
      "  /// Next billing cycle date",
      "  final DateTime nextBillingDate;",
      "",
      "  /// Whether the subscription is currently in trial mode",
      "  final bool isTrial;",
      "",
      "  /// Trial expiration (if applicable)",
      "  final DateTime? trialEndsAt;",
      "",
      "  /// Optional percentage discount applied",
      "  final int discountPercent;",
      "",
      "  /// Optional custom quote override",
      "  final String? customQuoteDetails;",
      "",
      "  /// ID of the last invoice (if applicable)",
      "  final String? lastInvoiceId;",
      "",
      "  /// Firestore creation timestamp",
      "  final DateTime? createdAt;",
      "",
      "  /// Firestore update timestamp",
      "  final DateTime? updatedAt;",
      "",
      "  /// e.g., 'monthly', 'yearly'",
      "  final String? billingInterval;",
      "",
      "  /// Billing cycle duration in days (e.g. 30, 365)",
      "  final int? billingCycleInDays;",
      "",
      "  /// Embedded snapshot of the plan at time of subscription",
      "  final Map<String, dynamic>? planSnapshot;",
      "",
      "  /// Price at time of subscription (snapshot)",
      "  final double priceAtSubscription;",
      "",
      "  /// Date of subscription (explicit timestamp)",
      "  final DateTime? subscribedAt;",
      "",
      "  /// Date of subscription cancellation",
      "  final bool cancelAtPeriodEnd;",
      "",
      "  /// Timestamp of last known activity (e.g., user login, menu edit)",
      "  final DateTime? lastActivity;",
      "",
      "  /// Whether subscription auto-renews",
      "  final bool autoRenew;",
      "",
      "  /// Whether any associated invoice is overdue",
      "  final bool hasOverdueInvoice;",
      "",
      "  /// Payment provider customer ID (e.g., Stripe customer ID)",
      "  final String? paymentProviderCustomerId;",
      "",
      "  /// Last 4 digits of card used (for display)",
      "  final String? cardLast4;",
      "",
      "  /// Card brand (e.g., Visa, MasterCard)",
      "  final String? cardBrand;",
      "",
      "  /// Payment method ID (e.g., Stripe PM ID)",
      "  final String? paymentMethodId;",
      "",
      "  /// Billing contact email used for this subscription",
      "  final String? billingEmail;",
      "",
      "  /// Status of last payment attempt (e.g., 'succeeded', 'failed')",
      "  final String? paymentStatus;",
      "",
      "  /// Most recent payment receipt URL (for user access)",
      "  final String? receiptUrl;",
      "",
      "  /// Payment Grace period",
      "  final DateTime? gracePeriodEndsAt;",
      "",
      "  /// Optional payment token ID used for merchant API (e.g. Stripe setup intent)",
      "  final String? paymentTokenId;",
      "",
      "  /// Last payment",
      "  final DateTime? lastPaymentAt;",
      "",
      "  const FranchiseSubscription({",
      "    required this.id,",
      "    required this.franchiseId,",
      "    required this.platformPlanId,",
      "    required this.status,",
      "    required this.startDate,",
      "    required this.nextBillingDate,",
      "    required this.isTrial,",
      "    this.trialEndsAt,",
      "    required this.discountPercent,",
      "    this.customQuoteDetails,",
      "    this.lastInvoiceId,",
      "    this.createdAt,",
      "    this.updatedAt,",
      "    final this.billingInterval,",
      "    final this.planSnapshot,",
      "    required this.priceAtSubscription,",
      "    this.subscribedAt,",
      "    required this.cancelAtPeriodEnd,",
      "    this.lastActivity,",
      "    this.autoRenew = true,",
      "    this.hasOverdueInvoice = false,",
      "    required this.billingCycleInDays,",
      "    this.paymentProviderCustomerId,",
      "    this.cardLast4,",
      "    this.cardBrand,",
      "    this.paymentMethodId,",
      "    this.billingEmail,",
      "    this.paymentStatus,",
      "    this.receiptUrl,",
      "    this.gracePeriodEndsAt,",
      "    this.paymentTokenId,",
      "    this.lastPaymentAt,",
      "  });",
      "",
      "  factory FranchiseSubscription.fromMap(String id, Map<String, dynamic> data) {",
      "    final snapshot = data['planSnapshot'] as Map<String, dynamic>? ?? {};",
      "",
      "    print(",
      "        '[FranchiseSubscriptionModel] fromMap: planId=${data['platformPlanId']}, price=${data['priceAtSubscription']}');",
      "",
      "    return FranchiseSubscription(",
      "      id: id,",
      "      franchiseId: data['franchiseId'] ?? '',",
      "      platformPlanId: data['platformPlanId'] ?? '',",
      "      status: data['status'] ?? 'inactive',",
      "      startDate: (data['startDate'] as Timestamp?)?.toDate() ?? DateTime.now(),",
      "      nextBillingDate:",
      "          (data['nextBillingDate'] as Timestamp?)?.toDate() ?? DateTime.now(),",
      "      billingCycleInDays: data['billingCycleInDays'] as int?,",
      "      isTrial: data['isTrial'] ?? false,",
      "      trialEndsAt: (data['trialEndsAt'] as Timestamp?)?.toDate(),",
      "      discountPercent: data['discountPercent'] ?? 0,",
      "      customQuoteDetails: data['customQuoteDetails'],",
      "      lastInvoiceId: data['lastInvoiceId'],",
      "      createdAt: (data['createdAt'] as Timestamp?)?.toDate(),",
      "      updatedAt: (data['updatedAt'] as Timestamp?)?.toDate(),",
      "      billingInterval: data['billingInterval'],",
      "      planSnapshot: {",
      "        'name': snapshot['name'],",
      "        'description': snapshot['description'],",
      "        'features': snapshot['features'] ?? [],",
      "        'currency': snapshot['currency'],",
      "        'price': snapshot['price'],",
      "        'billingInterval': snapshot['billingInterval'],",
      "        'isCustom': snapshot['isCustom'] ?? false,",
      "        'planVersion': snapshot['planVersion'] ?? 'v1',",
      "      },",
      "      priceAtSubscription:",
      "          (data['priceAtSubscription'] as num?)?.toDouble() ?? 0.0,",
      "      subscribedAt: (data['subscribedAt'] as Timestamp?)?.toDate(),",
      "      cancelAtPeriodEnd: data['cancelAtPeriodEnd'] ?? false,",
      "      lastActivity: (data['lastActivity'] as Timestamp?)?.toDate(),",
      "      autoRenew: data['autoRenew'] ?? true,",
      "      hasOverdueInvoice: data['hasOverdueInvoice'] ?? false,",
      "      paymentProviderCustomerId: data['paymentProviderCustomerId'],",
      "      cardLast4: data['cardLast4'],",
      "      cardBrand: data['cardBrand'],",
      "      paymentMethodId: data['paymentMethodId'],",
      "      billingEmail: data['billingEmail'],",
      "      paymentStatus: data['paymentStatus'],",
      "      receiptUrl: data['receiptUrl'],",
      "      gracePeriodEndsAt: (data['gracePeriodEndsAt'] as Timestamp?)?.toDate(),",
      "      paymentTokenId: data['paymentTokenId'],",
      "      lastPaymentAt: (data['lastPaymentAt'] as Timestamp?)?.toDate(),",
      "    );",
      "  }",
      "",
      "  factory FranchiseSubscription.fromFirestore(",
      "      QueryDocumentSnapshot<Map<String, dynamic>> doc) {",
      "    final data = doc.data();",
      "    final snapshot = data['planSnapshot'] as Map<String, dynamic>? ?? {};",
      "",
      "    return FranchiseSubscription(",
      "      id: doc.id,",
      "      franchiseId: data['franchiseId'] ?? '',",
      "      platformPlanId: data['platformPlanId'] ?? '',",
      "      status: data['status'] ?? 'active',",
      "      startDate: (data['startDate'] as Timestamp?)?.toDate() ?? DateTime.now(),",
      "      nextBillingDate:",
      "          (data['nextBillingDate'] as Timestamp?)?.toDate() ?? DateTime.now(),",
      "      billingCycleInDays: data['billingCycleInDays'] as int?,",
      "      isTrial: data['isTrial'] ?? false,",
      "      trialEndsAt: (data['trialEndsAt'] as Timestamp?)?.toDate(),",
      "      discountPercent: data['discountPercent'] ?? 0,",
      "      customQuoteDetails: data['customQuoteDetails'],",
      "      lastInvoiceId: data['lastInvoiceId'],",
      "      createdAt: (data['createdAt'] as Timestamp?)?.toDate(),",
      "      updatedAt: (data['updatedAt'] as Timestamp?)?.toDate(),",
      "      billingInterval: data['billingInterval'],",
      "      planSnapshot: {",
      "        'name': snapshot['name'],",
      "        'description': snapshot['description'],",
      "        'features': snapshot['features'] ?? [],",
      "        'currency': snapshot['currency'],",
      "        'price': snapshot['price'],",
      "        'billingInterval': snapshot['billingInterval'],",
      "        'isCustom': snapshot['isCustom'] ?? false,",
      "        'planVersion': snapshot['planVersion'] ?? 'v1',",
      "      },",
      "      priceAtSubscription:",
      "          (data['priceAtSubscription'] as num?)?.toDouble() ?? 0.0,",
      "      subscribedAt:",
      "          (data['subscribedAt'] as Timestamp?)?.toDate() ?? DateTime.now(),",
      "      cancelAtPeriodEnd: data['cancelAtPeriodEnd'] ?? false,",
      "      lastActivity: (data['lastActivity'] as Timestamp?)?.toDate(),",
      "      autoRenew: data['autoRenew'] ?? true,",
      "      hasOverdueInvoice: data['hasOverdueInvoice'] ?? false,",
      "      paymentProviderCustomerId: data['paymentProviderCustomerId'],",
      "      cardLast4: data['cardLast4'],",
      "      cardBrand: data['cardBrand'],",
      "      paymentMethodId: data['paymentMethodId'],",
      "      billingEmail: data['billingEmail'],",
      "      paymentStatus: data['paymentStatus'],",
      "      receiptUrl: data['receiptUrl'],",
      "      gracePeriodEndsAt: (data['gracePeriodEndsAt'] as Timestamp?)?.toDate(),",
      "      paymentTokenId: data['paymentTokenId'],",
      "      lastPaymentAt: (data['lastPaymentAt'] as Timestamp?)?.toDate(),",
      "    );",
      "  }",
      "",
      "  Map<String, dynamic> toFirestore() {",
      "    return {",
      "      'franchiseId': franchiseId,",
      "      'platformPlanId': platformPlanId,",
      "      'status': status,",
      "      'startDate': Timestamp.fromDate(startDate),",
      "      'nextBillingDate': Timestamp.fromDate(nextBillingDate),",
      "      'isTrial': isTrial,",
      "      'trialEndsAt':",
      "          trialEndsAt != null ? Timestamp.fromDate(trialEndsAt!) : null,",
      "      'discountPercent': discountPercent,",
      "      'customQuoteDetails': customQuoteDetails,",
      "      'lastInvoiceId': lastInvoiceId,",
      "      'createdAt': createdAt != null",
      "          ? Timestamp.fromDate(createdAt!)",
      "          : FieldValue.serverTimestamp(),",
      "      'updatedAt': FieldValue.serverTimestamp(),",
      "      'billingInterval': billingInterval,",
      "      'planSnapshot': planSnapshot,",
      "      'priceAtSubscription': priceAtSubscription,",
      "      'subscribedAt': subscribedAt != null",
      "          ? Timestamp.fromDate(subscribedAt!)",
      "          : FieldValue.serverTimestamp(),",
      "      'cancelAtPeriodEnd': cancelAtPeriodEnd,",
      "      'lastActivity':",
      "          lastActivity != null ? Timestamp.fromDate(lastActivity!) : null,",
      "      'autoRenew': autoRenew,",
      "      'cancelAtPeriodEnd': cancelAtPeriodEnd,",
      "      'hasOverdueInvoice': hasOverdueInvoice,",
      "      'billingCycleInDays': billingCycleInDays,",
      "      'paymentProviderCustomerId': paymentProviderCustomerId,",
      "      'cardLast4': cardLast4,",
      "      'cardBrand': cardBrand,",
      "      'paymentMethodId': paymentMethodId,",
      "      'billingEmail': billingEmail,",
      "      'paymentStatus': paymentStatus,",
      "      'receiptUrl': receiptUrl,",
      "      'gracePeriodEndsAt': gracePeriodEndsAt != null",
      "          ? Timestamp.fromDate(gracePeriodEndsAt!)",
      "          : null,",
      "      'paymentTokenId': paymentTokenId,",
      "      'lastPaymentAt':",
      "          lastPaymentAt != null ? Timestamp.fromDate(lastPaymentAt!) : null,",
      "    };",
      "  }",
      "",
      "  FranchiseSubscription copyWith({",
      "    String? franchiseId,",
      "    String? platformPlanId,",
      "    String? status,",
      "    DateTime? startDate,",
      "    DateTime? nextBillingDate,",
      "    bool? isTrial,",
      "    DateTime? trialEndsAt,",
      "    int? discountPercent,",
      "    String? customQuoteDetails,",
      "    String? lastInvoiceId,",
      "    DateTime? createdAt,",
      "    DateTime? updatedAt,",
      "    double? priceAtSubscription,",
      "    DateTime? subscribedAt,",
      "    bool? cancelAtPeriodEnd,",
      "    DateTime? lastActivity,",
      "    bool? autoRenew,",
      "    bool? hasOverdueInvoice,",
      "    int? billingCycleInDays,",
      "    String? paymentProviderCustomerId,",
      "    String? cardLast4,",
      "    String? cardBrand,",
      "    String? paymentMethodId,",
      "    String? billingEmail,",
      "    String? paymentStatus,",
      "    String? receiptUrl,",
      "    DateTime? gracePeriodEndsAt,",
      "    String? paymentTokenId,",
      "    DateTime? lastPaymentAt,",
      "  }) {",
      "    return FranchiseSubscription(",
      "      id: id,",
      "      franchiseId: franchiseId ?? this.franchiseId,",
      "      platformPlanId: platformPlanId ?? this.platformPlanId,",
      "      status: status ?? this.status,",
      "      startDate: startDate ?? this.startDate,",
      "      nextBillingDate: nextBillingDate ?? this.nextBillingDate,",
      "      isTrial: isTrial ?? this.isTrial,",
      "      trialEndsAt: trialEndsAt ?? this.trialEndsAt,",
      "      discountPercent: discountPercent ?? this.discountPercent,",
      "      customQuoteDetails: customQuoteDetails ?? this.customQuoteDetails,",
      "      lastInvoiceId: lastInvoiceId ?? this.lastInvoiceId,",
      "      createdAt: createdAt ?? this.createdAt,",
      "      updatedAt: updatedAt ?? this.updatedAt,",
      "      priceAtSubscription: priceAtSubscription ?? this.priceAtSubscription,",
      "      subscribedAt: subscribedAt ?? this.subscribedAt,",
      "      cancelAtPeriodEnd: cancelAtPeriodEnd ?? this.cancelAtPeriodEnd,",
      "      lastActivity: lastActivity ?? this.lastActivity,",
      "      autoRenew: autoRenew ?? this.autoRenew,",
      "      hasOverdueInvoice: hasOverdueInvoice ?? this.hasOverdueInvoice,",
      "      billingCycleInDays: billingCycleInDays ?? this.billingCycleInDays,",
      "      paymentProviderCustomerId:",
      "          paymentProviderCustomerId ?? this.paymentProviderCustomerId,",
      "      cardLast4: cardLast4 ?? this.cardLast4,",
      "      cardBrand: cardBrand ?? this.cardBrand,",
      "      paymentMethodId: paymentMethodId ?? this.paymentMethodId,",
      "      billingEmail: billingEmail ?? this.billingEmail,",
      "      paymentStatus: paymentStatus ?? this.paymentStatus,",
      "      receiptUrl: receiptUrl ?? this.receiptUrl,",
      "      gracePeriodEndsAt: gracePeriodEndsAt ?? this.gracePeriodEndsAt,",
      "      paymentTokenId: paymentTokenId ?? this.paymentTokenId,",
      "      lastPaymentAt: lastPaymentAt ?? this.lastPaymentAt,",
      "    );",
      "  }",
      "",
      "  bool get hasSavedPaymentToken =>",
      "      paymentTokenId != null && paymentTokenId!.isNotEmpty;",
      "",
      "  /// Returns a readable formatted summary of the current plan for display purposes.",
      "  String get displaySummary {",
      "    final priceString =",
      "        '\\$${priceFormatted ?? 'N/A'} / $billingIntervalFormatted';",
      "    return '$planName – $priceString';",
      "  }",
      "",
      "  /// Extracted snapshot plan name (if available)",
      "  String? get planName => platformPlanId;",
      "",
      "  /// Formats billing interval",
      "  String get billingIntervalFormatted {",
      "    switch (billingInterval?.toLowerCase()) {",
      "      case 'monthly':",
      "        return 'mo';",
      "      case 'yearly':",
      "        return 'yr';",
      "      default:",
      "        return billingInterval ?? 'N/A';",
      "    }",
      "  }",
      "",
      "  /// Returns the price at time of subscription (if available)",
      "  String? get priceFormatted {",
      "    final snapshot = planSnapshot;",
      "    if (snapshot != null && snapshot['price'] != null) {",
      "      return (snapshot['price'] as num).toStringAsFixed(2);",
      "    }",
      "    return null;",
      "  }",
      "",
      "  @override",
      "  bool operator ==(Object other) =>",
      "      identical(this, other) ||",
      "      other is FranchiseSubscription &&",
      "          runtimeType == other.runtimeType &&",
      "          id == other.id;",
      "",
      "  @override",
      "  int get hashCode => id.hashCode;",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 396,
      "file_size": 14411,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\models\\ingredient_metadata.dart",
    "content": [
      "// lib/core/models/ingredient_metadata.dart",
      "import 'package:collection/collection.dart';",
      "import 'package:flutter/foundation.dart';",
      "",
      "@immutable",
      "class IngredientMetadata {",
      "  /// Unique ingredient ID (e.g., \"cheese_mozzarella\")",
      "  final String id;",
      "",
      "  /// Display name (e.g., \"Mozzarella Cheese\")",
      "  final String name;",
      "",
      "  /// Category/group for ingredient (e.g., \"cheeses\", \"meats\", \"veggies\", etc.)",
      "  final String type;",
      "",
      "  /// List of allergen tags (e.g., [\"dairy\", \"gluten\"])",
      "  final List<String> allergens;",
      "",
      "  /// Can this ingredient be removed from default (\"included\") items?",
      "  final bool removable;",
      "",
      "  /// Optional size-based upcharge for adding ingredient as extra",
      "  /// Example: { \"Small\": 0.85, \"Large\": 1.95 }",
      "  final Map<String, double>? upcharge;",
      "",
      "  /// Can customer double/add extra portion of this ingredient?",
      "  final bool supportsExtra;",
      "",
      "  /// Can this ingredient be placed only on half (left/right/side) of an item?",
      "  final bool sidesAllowed;",
      "",
      "  /// Optional notes or description",
      "  final String? notes;",
      "",
      "  /// Inventory status: true if out of stock (for disabling in UI)",
      "  final bool outOfStock;",
      "",
      "  /// Optional image for UI display (future-proof)",
      "  final String? imageUrl;",
      "",
      "  /// Can the user select an amount (Light/Regular/Extra) for this ingredient?",
      "  final bool amountSelectable;",
      "",
      "  /// List of amount options (e.g., [\"Light\", \"Regular\", \"Extra\"])",
      "  final List<String>? amountOptions;",
      "",
      "  /// Ingredient type for onboarding",
      "  final String? typeId;",
      "",
      "  const IngredientMetadata({",
      "    required this.id,",
      "    required this.name,",
      "    this.typeId,",
      "    required this.type,",
      "    required this.allergens,",
      "    required this.removable,",
      "    this.upcharge,",
      "    required this.supportsExtra,",
      "    required this.sidesAllowed,",
      "    this.notes,",
      "    required this.outOfStock,",
      "    this.imageUrl,",
      "    required this.amountSelectable,",
      "    this.amountOptions,",
      "  });",
      "",
      "  /// Factory constructor for robust deserialization from Firestore or JSON",
      "  factory IngredientMetadata.fromMap(Map<String, dynamic> data) {",
      "    return IngredientMetadata(",
      "      id: data['id'] as String,",
      "      name: data['name'] as String,",
      "      typeId: data['typeId'] as String?,",
      "      type: data['type'] as String,",
      "      allergens: data['allergens'] is List",
      "          ? List<String>.from(data['allergens'])",
      "          : <String>[],",
      "      removable: data['removable'] is bool ? data['removable'] : true,",
      "      upcharge: data['upcharge'] != null && data['upcharge'] is Map",
      "          ? (data['upcharge'] as Map)",
      "              .map((k, v) => MapEntry(k.toString(), (v as num).toDouble()))",
      "          : null,",
      "      supportsExtra:",
      "          data['supportsExtra'] is bool ? data['supportsExtra'] : false,",
      "      sidesAllowed: data['sidesAllowed'] is bool ? data['sidesAllowed'] : false,",
      "      notes: data['notes'] is String ? data['notes'] : null,",
      "      outOfStock: data['outOfStock'] is bool ? data['outOfStock'] : false,",
      "      imageUrl: data['imageUrl'] is String ? data['imageUrl'] : null,",
      "      amountSelectable:",
      "          data['amountSelectable'] is bool ? data['amountSelectable'] : false,",
      "      amountOptions: data['amountOptions'] is List",
      "          ? List<String>.from(data['amountOptions'])",
      "          : null,",
      "    );",
      "  }",
      "",
      "  /// Serialization for uploading to Firestore/JSON",
      "  Map<String, dynamic> toMap() {",
      "    return {",
      "      'id': id,",
      "      'name': name,",
      "      if (typeId != null) 'typeId': typeId,",
      "      'type': type,",
      "      'allergens': allergens,",
      "      'removable': removable,",
      "      if (upcharge != null) 'upcharge': upcharge,",
      "      'supportsExtra': supportsExtra,",
      "      'sidesAllowed': sidesAllowed,",
      "      if (notes != null) 'notes': notes,",
      "      'outOfStock': outOfStock,",
      "      if (imageUrl != null) 'imageUrl': imageUrl,",
      "      'amountSelectable': amountSelectable,",
      "      if (amountOptions != null) 'amountOptions': amountOptions,",
      "    };",
      "  }",
      "",
      "  /// Return a copy with one or more fields changed",
      "  IngredientMetadata copyWith({",
      "    String? id,",
      "    String? name,",
      "    String? typeId,",
      "    String? type,",
      "    List<String>? allergens,",
      "    bool? removable,",
      "    Map<String, double>? upcharge,",
      "    bool? supportsExtra,",
      "    bool? sidesAllowed,",
      "    String? notes,",
      "    bool? outOfStock,",
      "    String? imageUrl,",
      "    bool? amountSelectable,",
      "    List<String>? amountOptions,",
      "  }) {",
      "    return IngredientMetadata(",
      "      id: id ?? this.id,",
      "      name: name ?? this.name,",
      "      typeId: typeId ?? this.typeId,",
      "      type: type ?? this.type,",
      "      allergens: allergens ?? List<String>.from(this.allergens),",
      "      removable: removable ?? this.removable,",
      "      upcharge: upcharge ?? this.upcharge,",
      "      supportsExtra: supportsExtra ?? this.supportsExtra,",
      "      sidesAllowed: sidesAllowed ?? this.sidesAllowed,",
      "      notes: notes ?? this.notes,",
      "      outOfStock: outOfStock ?? this.outOfStock,",
      "      imageUrl: imageUrl ?? this.imageUrl,",
      "      amountSelectable: amountSelectable ?? this.amountSelectable,",
      "      amountOptions: amountOptions ?? this.amountOptions,",
      "    );",
      "  }",
      "",
      "  /// Equality and hash code override for correct Set/List/map usage",
      "  @override",
      "  bool operator ==(Object other) =>",
      "      identical(this, other) ||",
      "      other is IngredientMetadata &&",
      "          runtimeType == other.runtimeType &&",
      "          id == other.id &&",
      "          name == other.name &&",
      "          typeId == other.typeId &&",
      "          type == other.type &&",
      "          listEquals(allergens, other.allergens) &&",
      "          removable == other.removable &&",
      "          mapEquals(upcharge, other.upcharge) &&",
      "          supportsExtra == other.supportsExtra &&",
      "          sidesAllowed == other.sidesAllowed &&",
      "          notes == other.notes &&",
      "          outOfStock == other.outOfStock &&",
      "          imageUrl == other.imageUrl &&",
      "          amountSelectable == other.amountSelectable &&",
      "          listEquals(amountOptions, other.amountOptions);",
      "",
      "  @override",
      "  int get hashCode =>",
      "      id.hashCode ^",
      "      name.hashCode ^",
      "      typeId.hashCode ^",
      "      type.hashCode ^",
      "      allergens.hashCode ^",
      "      removable.hashCode ^",
      "      upcharge.hashCode ^",
      "      supportsExtra.hashCode ^",
      "      sidesAllowed.hashCode ^",
      "      notes.hashCode ^",
      "      outOfStock.hashCode ^",
      "      imageUrl.hashCode ^",
      "      amountSelectable.hashCode ^",
      "      amountOptions.hashCode;",
      "",
      "  bool isValid() {",
      "    return name.trim().isNotEmpty && (typeId?.trim().isNotEmpty ?? false);",
      "  }",
      "",
      "  /// Checks if this ingredient matches the given ID (case-insensitive).",
      "  bool matchesId(String? otherId) =>",
      "      otherId != null && id.toLowerCase() == otherId.toLowerCase();",
      "",
      "  /// Checks if this ingredient matches the given name (case-insensitive, trimmed).",
      "  bool matchesName(String? otherName) =>",
      "      otherName != null &&",
      "      name.trim().toLowerCase() == otherName.trim().toLowerCase();",
      "",
      "  /// Checks if this ingredient matches the given typeId (case-insensitive, trimmed).",
      "  bool matchesTypeId(String? otherTypeId) =>",
      "      otherTypeId != null &&",
      "      (typeId?.trim().toLowerCase() ?? '') == otherTypeId.trim().toLowerCase();",
      "",
      "  /// Static utility: resolve an ingredient by id or name from a list.",
      "  static IngredientMetadata? resolveFromReference(List<IngredientMetadata> all,",
      "      {String? id, String? name}) {",
      "    // By id",
      "    final byId = all.firstWhereOrNull(",
      "      (ing) => ing.matchesId(id),",
      "    );",
      "    if (byId != null) return byId;",
      "",
      "    // By name",
      "    final byName = all.firstWhereOrNull(",
      "      (ing) => ing.matchesName(name),",
      "    );",
      "    return byName;",
      "  }",
      "",
      "  /// Warn if critical fields are missing.",
      "  String? get schemaWarning {",
      "    if (id.isEmpty || name.isEmpty || type.isEmpty) {",
      "      return \"IngredientMetadata missing required field: id='$id', name='$name', type='$type'\";",
      "    }",
      "    return null;",
      "  }",
      "",
      "  /// Batch utility: extract all IDs from a list.",
      "  static List<String> extractIds(List<IngredientMetadata> all) =>",
      "      all.map((e) => e.id).where((id) => id.isNotEmpty).toList();",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 234,
      "file_size": 7996,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\models\\ingredient_reference.dart",
    "content": [
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "import 'package:equatable/equatable.dart';",
      "",
      "/// Represents a lightweight reference to an ingredient used in menu items.",
      "///",
      "/// This is used to avoid duplicating full ingredient metadata inside each menu item,",
      "/// while still allowing menu-level control over display, placement, and upcharges.",
      "class IngredientReference extends Equatable {",
      "  final String id; // 🔐 Firestore document ID of the ingredient",
      "  final String name;",
      "  final String typeId; // 🔗 Must match an ingredientType defined in schema",
      "",
      "  /// Optional override values for UI rendering or pricing",
      "  final bool? doubled; // UI toggle for \"Double\" portion",
      "  final bool? isRemovable; // Whether customer can deselect this item",
      "  final double? upcharge; // Optional override if ingredient has price",
      "",
      "  /// [side] is only relevant for items with placement (left, right, both)",
      "  final String? side; // 'left', 'right', or 'both'",
      "",
      "  const IngredientReference({",
      "    required this.id,",
      "    required this.name,",
      "    required this.typeId,",
      "    this.doubled,",
      "    this.isRemovable,",
      "    this.upcharge,",
      "    this.side,",
      "  });",
      "",
      "  /// Deserialize from Firestore",
      "  factory IngredientReference.fromMap(Map<String, dynamic> data) {",
      "    // Support both admin export and runtime keys:",
      "    final id = data['id'] ?? data['ingredientId'] ?? '';",
      "    final name = data['name'] ?? '';",
      "    final typeId = data['typeId'] ?? data['type'] ?? '';",
      "    final isRemovable = data['isRemovable'] ?? data['removable'] ?? true;",
      "    double? upcharge;",
      "    final rawUpcharge = data['upcharge'] ?? data['price'];",
      "    if (rawUpcharge is num) {",
      "      upcharge = rawUpcharge.toDouble();",
      "    } else if (rawUpcharge is String) {",
      "      upcharge = double.tryParse(rawUpcharge);",
      "    } else if (rawUpcharge is Map) {",
      "      // If you want to pick a default size, for example \"Large\"",
      "      upcharge = (rawUpcharge['Large'] as num?)?.toDouble() ??",
      "          rawUpcharge.values",
      "              .cast<num?>()",
      "              .firstWhere((v) => v != null, orElse: () => null)",
      "              ?.toDouble();",
      "    } else {",
      "      upcharge = null;",
      "    }",
      "    final doubled = data['doubled'] as bool?;",
      "    final side = data['side'] as String?;",
      "",
      "    if (id == '' || name == '' || typeId == '') {",
      "      print(",
      "          '[IngredientReference.fromMap] WARNING: missing required fields! map=$data');",
      "    }",
      "",
      "    return IngredientReference(",
      "      id: id,",
      "      name: name,",
      "      typeId: typeId,",
      "      doubled: doubled,",
      "      isRemovable: isRemovable,",
      "      upcharge: upcharge,",
      "      side: side,",
      "    );",
      "  }",
      "",
      "  bool get isValid => id.isNotEmpty && name.isNotEmpty && typeId.isNotEmpty;",
      "",
      "  /// Serialize to Firestore",
      "  Map<String, dynamic> toMap() {",
      "    return {",
      "      'id': id,",
      "      'name': name,",
      "      'typeId': typeId,",
      "      if (doubled != null) 'doubled': doubled,",
      "      if (isRemovable != null) 'isRemovable': isRemovable,",
      "      if (upcharge != null) 'upcharge': upcharge,",
      "      if (side != null) 'side': side,",
      "    };",
      "  }",
      "",
      "  /// Required for form pre-fill & comparison",
      "  IngredientReference copyWith({",
      "    String? id,",
      "    String? name,",
      "    String? typeId,",
      "    bool? doubled,",
      "    bool? isRemovable,",
      "    double? upcharge,",
      "    String? side,",
      "  }) {",
      "    return IngredientReference(",
      "      id: id ?? this.id,",
      "      name: name ?? this.name,",
      "      typeId: typeId ?? this.typeId,",
      "      doubled: doubled ?? this.doubled,",
      "      isRemovable: isRemovable ?? this.isRemovable,",
      "      upcharge: upcharge ?? this.upcharge,",
      "      side: side ?? this.side,",
      "    );",
      "  }",
      "",
      "  @override",
      "  List<Object?> get props =>",
      "      [id, name, typeId, doubled, isRemovable, upcharge, side];",
      "",
      "  @override",
      "  String toString() => 'IngredientReference($name - $typeId)';",
      "",
      "  /// Checks if this ingredient reference matches an ID (case-insensitive).",
      "  bool matchesId(String? otherId) =>",
      "      otherId != null && id.toLowerCase() == otherId.toLowerCase();",
      "",
      "  /// Checks if this ingredient reference matches a name (case-insensitive, trimmed).",
      "  bool matchesName(String? otherName) =>",
      "      otherName != null &&",
      "      name.trim().toLowerCase() == otherName.trim().toLowerCase();",
      "",
      "  /// Checks if this reference matches a typeId (case-insensitive).",
      "  bool matchesTypeId(String? otherTypeId) =>",
      "      otherTypeId != null && typeId.toLowerCase() == otherTypeId.toLowerCase();",
      "",
      "  /// Checks if this reference matches the given label (case-insensitive, trimmed).",
      "  bool matchesLabel(String? label) =>",
      "      label != null && name.trim().toLowerCase() == label.trim().toLowerCase();",
      "",
      "  /// Batch utility: returns all referenced IDs from a list of IngredientReferences.",
      "  static List<String> extractIds(List<IngredientReference> refs) =>",
      "      refs.map((e) => e.id).where((id) => id.isNotEmpty).toList();",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 136,
      "file_size": 4832,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\models\\ingredient_type_model.dart",
    "content": [
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:collection/collection.dart';",
      "",
      "class IngredientType {",
      "  final String? id;",
      "  final String name;",
      "  final String? description;",
      "  final int? sortOrder;",
      "  final String? systemTag; // optional: e.g., 'cheese', 'sauce', etc.",
      "  final bool visibleInApp;",
      "  final Timestamp? createdAt;",
      "  final Timestamp? updatedAt;",
      "",
      "  IngredientType({",
      "    required this.id,",
      "    required this.name,",
      "    this.description,",
      "    this.sortOrder,",
      "    this.systemTag,",
      "    this.visibleInApp = true,",
      "    this.createdAt,",
      "    this.updatedAt,",
      "  });",
      "",
      "  /// Factory for Firestore document -> Dart object",
      "  factory IngredientType.fromFirestore(DocumentSnapshot doc) {",
      "    try {",
      "      final data = doc.data() as Map<String, dynamic>?;",
      "",
      "      if (data == null) {",
      "        throw StateError('Missing data for IngredientType: ${doc.id}');",
      "      }",
      "",
      "      return IngredientType(",
      "        id: doc.id,",
      "        name: data['name'] ?? '',",
      "        description: data['description'],",
      "        sortOrder: data['sortOrder'],",
      "        systemTag: data['systemTag'],",
      "        visibleInApp: data['visibleInApp'] ?? true,",
      "        createdAt: data['createdAt'],",
      "        updatedAt: data['updatedAt'],",
      "      );",
      "    } catch (e, stack) {",
      "      ErrorLogger.log(",
      "        message: 'Failed to parse IngredientType from Firestore',",
      "        source: 'ingredient_type_model.dart',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "        contextData: {",
      "          'docId': doc.id,",
      "          'collection': doc.reference.parent.path,",
      "          'errorType': e.runtimeType.toString(),",
      "          'rawData': doc.data().toString(),",
      "        },",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Converts object -> Firestore data map",
      "  Map<String, dynamic> toMap({bool includeTimestamps = false}) {",
      "    final map = <String, dynamic>{",
      "      'name': name,",
      "      'description': description,",
      "      'sortOrder': sortOrder,",
      "      'systemTag': systemTag,",
      "      'visibleInApp': visibleInApp,",
      "    };",
      "",
      "    if (includeTimestamps) {",
      "      map['updatedAt'] = FieldValue.serverTimestamp();",
      "      if (createdAt == null) {",
      "        map['createdAt'] = FieldValue.serverTimestamp();",
      "      }",
      "    }",
      "",
      "    return map;",
      "  }",
      "",
      "  IngredientType copyWith({",
      "    String? id,",
      "    String? name,",
      "    String? description,",
      "    int? sortOrder,",
      "    String? systemTag,",
      "    bool? visibleInApp,",
      "    Timestamp? createdAt,",
      "    Timestamp? updatedAt,",
      "  }) {",
      "    return IngredientType(",
      "      id: id ?? this.id,",
      "      name: name ?? this.name,",
      "      description: description ?? this.description,",
      "      sortOrder: sortOrder ?? this.sortOrder,",
      "      systemTag: systemTag ?? this.systemTag,",
      "      visibleInApp: visibleInApp ?? this.visibleInApp,",
      "      createdAt: createdAt ?? this.createdAt,",
      "      updatedAt: updatedAt ?? this.updatedAt,",
      "    );",
      "  }",
      "",
      "  static IngredientType fromMap(Map<String, dynamic> map, {String? id}) {",
      "    try {",
      "      return IngredientType(",
      "        id: id,",
      "        name: map['name'] ?? '',",
      "        description: map['description'],",
      "        sortOrder: map['sortOrder'],",
      "        systemTag: map['systemTag'],",
      "        visibleInApp: map['visibleInApp'] ?? true,",
      "        createdAt: map['createdAt'],",
      "        updatedAt: map['updatedAt'],",
      "      );",
      "    } catch (e, stack) {",
      "      ErrorLogger.log(",
      "        message: 'Failed to parse IngredientType from Map',",
      "        source: 'ingredient_type_model.dart',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "        contextData: {",
      "          'id': id,",
      "          'errorType': e.runtimeType.toString(),",
      "          'rawMap': map.toString(),",
      "        },",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  @override",
      "  String toString() {",
      "    return 'IngredientType(id: $id, name: $name, visibleInApp: $visibleInApp)';",
      "  }",
      "",
      "  @override",
      "  bool operator ==(Object other) =>",
      "      identical(this, other) ||",
      "      other is IngredientType &&",
      "          runtimeType == other.runtimeType &&",
      "          id == other.id &&",
      "          name == other.name;",
      "",
      "  @override",
      "  int get hashCode => id.hashCode ^ name.hashCode;",
      "",
      "  /// Checks if this type matches an ID (case-insensitive).",
      "  bool matchesId(String? otherId) =>",
      "      otherId != null &&",
      "      id != null &&",
      "      id!.toLowerCase() == otherId.toLowerCase();",
      "",
      "  /// Checks if this type matches a name (case-insensitive, trimmed).",
      "  bool matchesName(String? otherName) =>",
      "      otherName != null &&",
      "      name.trim().toLowerCase() == otherName.trim().toLowerCase();",
      "",
      "  /// Checks if this type matches a systemTag (case-insensitive).",
      "  bool matchesSystemTag(String? otherTag) =>",
      "      otherTag != null &&",
      "      systemTag != null &&",
      "      systemTag!.toLowerCase() == otherTag.toLowerCase();",
      "",
      "  /// Utility for schema mapping: resolve from ID, name, or systemTag.",
      "  static IngredientType? resolveFromReference(",
      "    List<IngredientType> types, {",
      "    String? id,",
      "    String? name,",
      "    String? systemTag,",
      "  }) {",
      "    final byId = types.firstWhereOrNull(",
      "      (t) => t.matchesId(id),",
      "    );",
      "    if (byId != null) return byId;",
      "",
      "    final byName = types.firstWhereOrNull(",
      "      (t) => t.matchesName(name),",
      "    );",
      "    if (byName != null) return byName;",
      "",
      "    final byTag = types.firstWhereOrNull(",
      "      (t) => t.matchesSystemTag(systemTag),",
      "    );",
      "    return byTag;",
      "  }",
      "",
      "  /// Warn if critical fields are missing for onboarding/template mapping.",
      "  String? get schemaWarning {",
      "    if (id == null || id!.isEmpty || name.isEmpty) {",
      "      return \"IngredientType missing required id or name: id='$id', name='$name'\";",
      "    }",
      "    return null;",
      "  }",
      "",
      "  /// Extracts all IDs from a list of IngredientTypes for mapping/validation.",
      "  static List<String> extractIds(List<IngredientType> types) => types",
      "      .where((t) => t.id != null && t.id!.isNotEmpty)",
      "      .map((t) => t.id!)",
      "      .toList();",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 201,
      "file_size": 5954,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\models\\inventory.dart",
    "content": [
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "",
      "class Inventory {",
      "  final String id;",
      "  final String name;",
      "  final String sku; // Stock Keeping Unit",
      "  final double stock; // The actual count in inventory",
      "  final double threshold; // Low-stock warning threshold",
      "  final String unitType; // e.g., \"lbs\", \"pieces\"",
      "  final DateTime lastUpdated;",
      "  final double quantity; // For legacy/alias compatibility—mirrors stock",
      "  final bool available; // True if in stock or as logic requires",
      "",
      "  Inventory({",
      "    required this.id,",
      "    required this.name,",
      "    required this.sku,",
      "    required this.stock,",
      "    required this.threshold,",
      "    required this.unitType,",
      "    required this.lastUpdated,",
      "    double? quantity, // Defaults to stock for compatibility",
      "    bool? available, // Defaults to (stock > 0)",
      "  })  : quantity = quantity ?? stock,",
      "        available = available ?? (stock > 0);",
      "",
      "  /// Factory constructor from Firestore data (map + doc ID)",
      "  factory Inventory.fromFirestore(Map<String, dynamic> data, String id) {",
      "    final stockVal = (data['stock'] ?? 0.0);",
      "    final double parsedStock =",
      "        stockVal is int ? stockVal.toDouble() : (stockVal as num).toDouble();",
      "",
      "    return Inventory(",
      "      id: id,",
      "      name: data['name'] ?? '',",
      "      sku: data['sku'] ?? '',",
      "      stock: parsedStock,",
      "      threshold: (data['threshold'] ?? 0.0).toDouble(),",
      "      unitType: data['unitType'] ?? '',",
      "      lastUpdated: (data['lastUpdated'] is Timestamp)",
      "          ? (data['lastUpdated'] as Timestamp).toDate()",
      "          : DateTime.now(),",
      "      quantity: (data['quantity'] ?? parsedStock).toDouble(),",
      "      available: data['available'] ?? (parsedStock > 0),",
      "    );",
      "  }",
      "",
      "  /// For Firestore updates/writes",
      "  Map<String, dynamic> toFirestore() {",
      "    return {",
      "      'name': name,",
      "      'sku': sku,",
      "      'stock': stock,",
      "      'threshold': threshold,",
      "      'unitType': unitType,",
      "      'lastUpdated': Timestamp.fromDate(lastUpdated),",
      "      'quantity': quantity,",
      "      'available': available,",
      "    };",
      "  }",
      "",
      "  /// For easy, immutable state updates",
      "  Inventory copyWith({",
      "    String? id,",
      "    String? name,",
      "    String? sku,",
      "    double? stock,",
      "    double? threshold,",
      "    String? unitType,",
      "    DateTime? lastUpdated,",
      "    double? quantity,",
      "    bool? available,",
      "  }) {",
      "    final double stockVal = stock ?? this.stock;",
      "    return Inventory(",
      "      id: id ?? this.id,",
      "      name: name ?? this.name,",
      "      sku: sku ?? this.sku,",
      "      stock: stockVal,",
      "      threshold: threshold ?? this.threshold,",
      "      unitType: unitType ?? this.unitType,",
      "      lastUpdated: lastUpdated ?? this.lastUpdated,",
      "      quantity: quantity ?? stockVal,",
      "      available: available ?? (stockVal > 0),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 87,
      "file_size": 2745,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\models\\invoice.dart",
    "content": [
      "// File: lib/core/models/invoice.dart",
      "",
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "import 'package:flutter/foundation.dart';",
      "import 'package:flutter/material.dart';",
      "import 'package:intl/intl.dart';",
      "",
      "/// ========================",
      "/// ENUMS",
      "/// ========================",
      "",
      "enum InvoiceStatus {",
      "  draft,",
      "  sent,",
      "  viewed,",
      "  open,",
      "  paid,",
      "  overdue,",
      "  refunded,",
      "  voided,",
      "  archived,",
      "  failed,",
      "}",
      "",
      "InvoiceStatus invoiceStatusFromString(String status) {",
      "  switch (status) {",
      "    case 'draft':",
      "      return InvoiceStatus.draft;",
      "    case 'sent':",
      "      return InvoiceStatus.sent;",
      "    case 'viewed':",
      "      return InvoiceStatus.viewed;",
      "    case 'open': // <--- add this case",
      "      return InvoiceStatus.open;",
      "    case 'paid':",
      "      return InvoiceStatus.paid;",
      "    case 'overdue':",
      "      return InvoiceStatus.overdue;",
      "    case 'refunded':",
      "      return InvoiceStatus.refunded;",
      "    case 'voided':",
      "      return InvoiceStatus.voided;",
      "    case 'archived':",
      "      return InvoiceStatus.archived;",
      "    case 'failed':",
      "      return InvoiceStatus.failed;",
      "    default:",
      "      return InvoiceStatus.draft;",
      "  }",
      "}",
      "",
      "String invoiceStatusToString(InvoiceStatus status) => describeEnum(status);",
      "",
      "/// ========================",
      "/// SUB-MODELS (Typed)",
      "/// ========================",
      "",
      "class InvoiceLineItem {",
      "  final String id;",
      "  final String description;",
      "  final double unitPrice;",
      "  final int quantity;",
      "  final double? tax; // for line-specific tax (optional)",
      "  final String? sku;",
      "  final String? notes;",
      "",
      "  InvoiceLineItem({",
      "    required this.id,",
      "    required this.description,",
      "    required this.unitPrice,",
      "    required this.quantity,",
      "    this.tax,",
      "    this.sku,",
      "    this.notes,",
      "  });",
      "",
      "  double get total => (unitPrice * quantity) + (tax ?? 0.0);",
      "",
      "  Map<String, dynamic> toMap() {",
      "    return {",
      "      'id': id,",
      "      'description': description,",
      "      'unitPrice': unitPrice,",
      "      'quantity': quantity,",
      "      'tax': tax,",
      "      'sku': sku,",
      "      'notes': notes,",
      "    };",
      "  }",
      "",
      "  factory InvoiceLineItem.fromMap(Map<String, dynamic> map) {",
      "    return InvoiceLineItem(",
      "      id: map['id'] ?? '',",
      "      description: map['description'] ?? '',",
      "      unitPrice: (map['unitPrice'] as num?)?.toDouble() ?? 0.0,",
      "      quantity: map['quantity'] ?? 1,",
      "      tax: (map['tax'] as num?)?.toDouble(),",
      "      sku: map['sku'],",
      "      notes: map['notes'],",
      "    );",
      "  }",
      "}",
      "",
      "class InvoiceAuditEvent {",
      "  final DateTime timestamp;",
      "  final String eventType; // e.g. 'created', 'sent', 'paid', etc.",
      "  final String userId;",
      "  final String? notes;",
      "",
      "  InvoiceAuditEvent({",
      "    required this.timestamp,",
      "    required this.eventType,",
      "    required this.userId,",
      "    this.notes,",
      "  });",
      "",
      "  Map<String, dynamic> toMap() {",
      "    return {",
      "      'timestamp': Timestamp.fromDate(timestamp),",
      "      'eventType': eventType,",
      "      'userId': userId,",
      "      'notes': notes,",
      "    };",
      "  }",
      "",
      "  factory InvoiceAuditEvent.fromMap(Map<String, dynamic> map) {",
      "    return InvoiceAuditEvent(",
      "      timestamp: (map['timestamp'] as Timestamp).toDate(),",
      "      eventType: map['eventType'] ?? '',",
      "      userId: map['userId'] ?? '',",
      "      notes: map['notes'],",
      "    );",
      "  }",
      "}",
      "",
      "class InvoiceSupportNote {",
      "  final DateTime createdAt;",
      "  final String userId;",
      "  final String content;",
      "",
      "  InvoiceSupportNote({",
      "    required this.createdAt,",
      "    required this.userId,",
      "    required this.content,",
      "  });",
      "",
      "  Map<String, dynamic> toMap() {",
      "    return {",
      "      'createdAt': Timestamp.fromDate(createdAt),",
      "      'userId': userId,",
      "      'content': content,",
      "    };",
      "  }",
      "",
      "  factory InvoiceSupportNote.fromMap(Map<String, dynamic> map) {",
      "    return InvoiceSupportNote(",
      "      createdAt: (map['createdAt'] as Timestamp).toDate(),",
      "      userId: map['userId'] ?? '',",
      "      content: map['content'] ?? '',",
      "    );",
      "  }",
      "}",
      "",
      "class InvoiceAttachment {",
      "  final String url;",
      "  final String fileName;",
      "  final DateTime uploadedAt;",
      "",
      "  InvoiceAttachment({",
      "    required this.url,",
      "    required this.fileName,",
      "    required this.uploadedAt,",
      "  });",
      "",
      "  Map<String, dynamic> toMap() {",
      "    return {",
      "      'url': url,",
      "      'fileName': fileName,",
      "      'uploadedAt': Timestamp.fromDate(uploadedAt),",
      "    };",
      "  }",
      "",
      "  factory InvoiceAttachment.fromMap(Map<String, dynamic> map) {",
      "    return InvoiceAttachment(",
      "      url: map['url'] ?? '',",
      "      fileName: map['fileName'] ?? '',",
      "      uploadedAt: (map['uploadedAt'] as Timestamp).toDate(),",
      "    );",
      "  }",
      "}",
      "",
      "/// ========================",
      "/// MAIN INVOICE MODEL",
      "/// ========================",
      "",
      "class Invoice {",
      "  final String id;",
      "  final String invoiceNumber;",
      "  final DocumentReference franchiseRef;",
      "  final DocumentReference locationRef;",
      "  final String? customerName;",
      "  final String? customerEmail;",
      "  final String? customerAddress;",
      "  final DateTime periodStart;",
      "  final DateTime periodEnd;",
      "  final DateTime? issuedAt;",
      "  final DateTime? dueAt;",
      "  final InvoiceStatus status;",
      "  final double subtotal;",
      "  final double tax;",
      "  final double total;",
      "  final String currency;",
      "  final String paymentMethod;",
      "  final DateTime? paidAt;",
      "  final String? paidBy;",
      "  final DateTime? refundedAt;",
      "  final DateTime? voidedAt;",
      "  final List<InvoiceLineItem> items;",
      "  final List<InvoiceAuditEvent> auditTrail;",
      "  final List<InvoiceAttachment> attachedFiles;",
      "  final List<InvoiceSupportNote> supportNotes;",
      "  final List<DateTime> overdueReminders;",
      "  final Map<String, dynamic> customFields;",
      "",
      "  /// SaaS: for multi-tax, payout, integrations",
      "  final Map<String, double>? taxBreakdown; // e.g. {'state': 1.50, 'city': 2.00}",
      "  final String? payoutId;",
      "  final String? accountingId;",
      "",
      "  Invoice({",
      "    required this.id,",
      "    required this.invoiceNumber,",
      "    required this.franchiseRef,",
      "    required this.locationRef,",
      "    this.customerName,",
      "    this.customerEmail,",
      "    this.customerAddress,",
      "    required this.periodStart,",
      "    required this.periodEnd,",
      "    this.issuedAt,",
      "    this.dueAt,",
      "    required this.status,",
      "    required this.subtotal,",
      "    required this.tax,",
      "    required this.total,",
      "    required this.currency,",
      "    required this.paymentMethod,",
      "    this.paidAt,",
      "    this.paidBy,",
      "    this.refundedAt,",
      "    this.voidedAt,",
      "    this.items = const [],",
      "    this.auditTrail = const [],",
      "    this.attachedFiles = const [],",
      "    this.supportNotes = const [],",
      "    this.overdueReminders = const [],",
      "    this.customFields = const {},",
      "    this.taxBreakdown,",
      "    this.payoutId,",
      "    this.accountingId,",
      "  });",
      "",
      "  /// ================",
      "  /// FROM/FIRESTORE",
      "  /// ================",
      "",
      "  factory Invoice.fromFirestore(Map<String, dynamic> data, String id) {",
      "    print(",
      "        '[Invoice] fromFirestore called for doc id: $id, data keys: ${data.keys}');",
      "    return Invoice(",
      "      id: id,",
      "      invoiceNumber: data['invoice_number'] ?? '',",
      "      franchiseRef: data['franchiseId'] as DocumentReference,",
      "      locationRef: data['locationId'] as DocumentReference,",
      "      customerName: data['customer_name'],",
      "      customerEmail: data['customer_email'],",
      "      customerAddress: data['customer_address'],",
      "      periodStart: (data['period_start'] as Timestamp).toDate(),",
      "      periodEnd: (data['period_end'] as Timestamp).toDate(),",
      "      issuedAt: (data['issued_at'] as Timestamp?)?.toDate(),",
      "      dueAt: (data['due_at'] as Timestamp?)?.toDate(),",
      "      status: invoiceStatusFromString(data['status'] ?? 'draft'),",
      "      subtotal: (data['subtotal'] as num?)?.toDouble() ?? 0.0,",
      "      tax: (data['tax'] as num?)?.toDouble() ?? 0.0,",
      "      total: (data['total'] as num?)?.toDouble() ?? 0.0,",
      "      currency: data['currency'] ?? '',",
      "      paymentMethod: data['payment_method'] ?? '',",
      "      paidAt: (data['paid_at'] as Timestamp?)?.toDate(),",
      "      paidBy: data['paid_by'],",
      "      refundedAt: (data['refunded_at'] as Timestamp?)?.toDate(),",
      "      voidedAt: (data['voided_at'] as Timestamp?)?.toDate(),",
      "      items: (data['items'] as List<dynamic>? ?? [])",
      "          .map((e) => InvoiceLineItem.fromMap(Map<String, dynamic>.from(e)))",
      "          .toList(),",
      "      auditTrail: (data['audit_trail'] as List<dynamic>? ?? [])",
      "          .map((e) => InvoiceAuditEvent.fromMap(Map<String, dynamic>.from(e)))",
      "          .toList(),",
      "      attachedFiles: (data['attached_files'] as List<dynamic>? ?? [])",
      "          .map((e) => InvoiceAttachment.fromMap(Map<String, dynamic>.from(e)))",
      "          .toList(),",
      "      supportNotes: (data['support_notes'] as List<dynamic>? ?? [])",
      "          .map((e) => InvoiceSupportNote.fromMap(Map<String, dynamic>.from(e)))",
      "          .toList(),",
      "      overdueReminders: (data['overdue_reminders'] as List<dynamic>? ?? [])",
      "          .map((e) => (e as Timestamp).toDate())",
      "          .toList(),",
      "      customFields: data['custom_fields'] ?? {},",
      "      taxBreakdown: data['tax_breakdown'] != null",
      "          ? Map<String, double>.from(data['tax_breakdown'])",
      "          : null,",
      "      payoutId: data['payout_id'],",
      "      accountingId: data['accounting_id'],",
      "    );",
      "  }",
      "",
      "  Map<String, dynamic> toFirestore() {",
      "    return {",
      "      'invoice_number': invoiceNumber,",
      "      'franchiseId': franchiseRef,",
      "      'locationId': locationRef,",
      "      'customer_name': customerName,",
      "      'customer_email': customerEmail,",
      "      'customer_address': customerAddress,",
      "      'period_start': Timestamp.fromDate(periodStart),",
      "      'period_end': Timestamp.fromDate(periodEnd),",
      "      'issued_at': issuedAt != null ? Timestamp.fromDate(issuedAt!) : null,",
      "      'due_at': dueAt != null ? Timestamp.fromDate(dueAt!) : null,",
      "      'status': invoiceStatusToString(status),",
      "      'subtotal': subtotal,",
      "      'tax': tax,",
      "      'total': total,",
      "      'currency': currency,",
      "      'payment_method': paymentMethod,",
      "      'paid_at': paidAt != null ? Timestamp.fromDate(paidAt!) : null,",
      "      'paid_by': paidBy,",
      "      'refunded_at':",
      "          refundedAt != null ? Timestamp.fromDate(refundedAt!) : null,",
      "      'voided_at': voidedAt != null ? Timestamp.fromDate(voidedAt!) : null,",
      "      'items': items.map((i) => i.toMap()).toList(),",
      "      'audit_trail': auditTrail.map((a) => a.toMap()).toList(),",
      "      'attached_files': attachedFiles.map((f) => f.toMap()).toList(),",
      "      'support_notes': supportNotes.map((n) => n.toMap()).toList(),",
      "      'overdue_reminders':",
      "          overdueReminders.map((d) => Timestamp.fromDate(d)).toList(),",
      "      'custom_fields': customFields,",
      "      'tax_breakdown': taxBreakdown,",
      "      'payout_id': payoutId,",
      "      'accounting_id': accountingId,",
      "    };",
      "  }",
      "",
      "  /// =================",
      "  /// COPY WITH",
      "  /// =================",
      "  Invoice copyWith({",
      "    String? id,",
      "    String? invoiceNumber,",
      "    DocumentReference? franchiseRef,",
      "    DocumentReference? locationRef,",
      "    String? customerName,",
      "    String? customerEmail,",
      "    String? customerAddress,",
      "    DateTime? periodStart,",
      "    DateTime? periodEnd,",
      "    DateTime? issuedAt,",
      "    DateTime? dueAt,",
      "    InvoiceStatus? status,",
      "    double? subtotal,",
      "    double? tax,",
      "    double? total,",
      "    String? currency,",
      "    String? paymentMethod,",
      "    DateTime? paidAt,",
      "    String? paidBy,",
      "    DateTime? refundedAt,",
      "    DateTime? voidedAt,",
      "    List<InvoiceLineItem>? items,",
      "    List<InvoiceAuditEvent>? auditTrail,",
      "    List<InvoiceAttachment>? attachedFiles,",
      "    List<InvoiceSupportNote>? supportNotes,",
      "    List<DateTime>? overdueReminders,",
      "    Map<String, dynamic>? customFields,",
      "    Map<String, double>? taxBreakdown,",
      "    String? payoutId,",
      "    String? accountingId,",
      "  }) {",
      "    return Invoice(",
      "      id: id ?? this.id,",
      "      invoiceNumber: invoiceNumber ?? this.invoiceNumber,",
      "      franchiseRef: franchiseRef ?? this.franchiseRef,",
      "      locationRef: locationRef ?? this.locationRef,",
      "      customerName: customerName ?? this.customerName,",
      "      customerEmail: customerEmail ?? this.customerEmail,",
      "      customerAddress: customerAddress ?? this.customerAddress,",
      "      periodStart: periodStart ?? this.periodStart,",
      "      periodEnd: periodEnd ?? this.periodEnd,",
      "      issuedAt: issuedAt ?? this.issuedAt,",
      "      dueAt: dueAt ?? this.dueAt,",
      "      status: status ?? this.status,",
      "      subtotal: subtotal ?? this.subtotal,",
      "      tax: tax ?? this.tax,",
      "      total: total ?? this.total,",
      "      currency: currency ?? this.currency,",
      "      paymentMethod: paymentMethod ?? this.paymentMethod,",
      "      paidAt: paidAt ?? this.paidAt,",
      "      paidBy: paidBy ?? this.paidBy,",
      "      refundedAt: refundedAt ?? this.refundedAt,",
      "      voidedAt: voidedAt ?? this.voidedAt,",
      "      items: items ?? this.items,",
      "      auditTrail: auditTrail ?? this.auditTrail,",
      "      attachedFiles: attachedFiles ?? this.attachedFiles,",
      "      supportNotes: supportNotes ?? this.supportNotes,",
      "      overdueReminders: overdueReminders ?? this.overdueReminders,",
      "      customFields: customFields ?? this.customFields,",
      "      taxBreakdown: taxBreakdown ?? this.taxBreakdown,",
      "      payoutId: payoutId ?? this.payoutId,",
      "      accountingId: accountingId ?? this.accountingId,",
      "    );",
      "  }",
      "",
      "  /// =========================",
      "  /// UI/LOGIC CONVENIENCE GETTERS",
      "  /// =========================",
      "",
      "  bool get isPaid => status == InvoiceStatus.paid;",
      "  bool get isOverdue =>",
      "      status == InvoiceStatus.overdue ||",
      "      (dueAt != null && DateTime.now().isAfter(dueAt!) && !isPaid);",
      "  bool get isDraft => status == InvoiceStatus.draft;",
      "  bool get isRefunded => status == InvoiceStatus.refunded;",
      "  bool get isVoided => status == InvoiceStatus.voided;",
      "  bool get isFailed => status == InvoiceStatus.failed;",
      "",
      "  double get totalTax {",
      "    if (taxBreakdown == null) return tax;",
      "    return taxBreakdown!.values",
      "        .where((v) => v != null)",
      "        .fold(0.0, (a, b) => a + (b ?? 0));",
      "  }",
      "",
      "  double get outstanding => total - (isPaid ? total : 0);",
      "",
      "  String statusLabel(BuildContext context) {",
      "    // TODO: Use AppLocalizations when available",
      "    switch (status) {",
      "      case InvoiceStatus.draft:",
      "        return 'Draft';",
      "      case InvoiceStatus.sent:",
      "        return 'Sent';",
      "      case InvoiceStatus.viewed:",
      "        return 'Viewed';",
      "      case InvoiceStatus.paid:",
      "        return 'Paid';",
      "      case InvoiceStatus.overdue:",
      "        return 'Overdue';",
      "      case InvoiceStatus.refunded:",
      "        return 'Refunded';",
      "      case InvoiceStatus.voided:",
      "        return 'Voided';",
      "      case InvoiceStatus.archived:",
      "        return 'Archived';",
      "      case InvoiceStatus.failed:",
      "        return 'Failed';",
      "      default:",
      "        return invoiceStatusToString(status);",
      "    }",
      "  }",
      "",
      "  String get formattedDueDate =>",
      "      dueAt != null ? DateFormat.yMMMd().format(dueAt!) : '';",
      "",
      "  String get formattedTotal =>",
      "      NumberFormat.simpleCurrency(name: currency).format(total);",
      "",
      "  // === Future Feature Placeholder ===",
      "  // You can add logic for CSV/Excel/PDF export serialization here.",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 477,
      "file_size": 14760,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\models\\menu_item.dart",
    "content": [
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "import 'nutrition_info.dart';",
      "import 'customization.dart';",
      "import 'package:franchise_admin_portal/core/models/size_template.dart';",
      "import 'dart:convert';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:flutter/material.dart';",
      "",
      "extension IterableFirstOrNull<T> on Iterable<T> {",
      "  T? get firstOrNull => isEmpty ? null : first;",
      "}",
      "",
      "/// Enum for supported crust/cook/cut types.",
      "enum CrustType { thin, regular, thick, glutenFree }",
      "",
      "enum CookType { regular, crispy, wellDone }",
      "",
      "enum CutStyle { square, pie }",
      "",
      "class MenuItem {",
      "  final String id;",
      "  final bool available;",
      "  final String category;",
      "  final String categoryId;",
      "  final String name;",
      "  final double price; // Default/base price (typically for 'Large')",
      "  final String description;",
      "  final String? notes;",
      "  final String? image;",
      "  final String taxCategory;",
      "  final bool availability;",
      "  final String? sku;",
      "  final List<String> dietaryTags;",
      "  final List<String> allergens;",
      "  final int? prepTime;",
      "  final NutritionInfo? nutrition;",
      "  final int? sortOrder;",
      "  final DateTime? lastModified;",
      "  final String? lastModifiedBy;",
      "  final bool archived;",
      "  final String? exportId;",
      "",
      "  // --- Dynamic pricing / multi-size ---",
      "  final List<SizeData>? sizes; // ['Small', 'Medium', 'Large']",
      "  final Map<String, double>? sizePrices; // {'Small': 10.99, 'Large': 13.99}",
      "",
      "  /// Per-size upcharges for additional toppings (e.g., { 'Large': 2.25, 'Small': 0.85 })",
      "  final Map<String, double>? additionalToppingPrices;",
      "",
      "  // --- Ingredient customization support ---",
      "  /// Ingredients included by default (e.g., pepperoni, cheese, etc.)",
      "  /// {ingredientId, name, type, removable}",
      "  final List<Map<String, dynamic>>? includedIngredients;",
      "",
      "  /// Ingredient customization groups (e.g., Meats, Veggies, Cheeses, Crust, etc.)",
      "  /// Each group: {label, ingredientIds}",
      "  final List<Map<String, dynamic>>? customizationGroups;",
      "",
      "  /// Optional add-ons (not included by default)",
      "  /// {ingredientId, name, type, removable, price?}",
      "  final List<Map<String, dynamic>>? optionalAddOns;",
      "",
      "  /// Full structured customizations (advanced, e.g., pizza builder)",
      "  final List<Customization> customizations;",
      "",
      "  /// Raw customizations from schema (may include `templateRef`)",
      "  final List<Map<String, dynamic>>? rawCustomizations;",
      "",
      "  // --- Firestore/admin integration fields ---",
      "  final List<String>? crustTypes; // ['Regular', 'Thin', ...]",
      "  final List<String>? cookTypes; // ['Regular', 'Crispy', ...]",
      "  final List<String>? cutStyles; // ['Pie', 'Square', ...]",
      "  final List<String>? sauceOptions; // (if relevant)",
      "  final List<String>? dressingOptions; // (if relevant)",
      "  final int? maxFreeToppings;",
      "  final int? maxFreeSauces;",
      "  final int? maxFreeDressings;",
      "  final int? maxToppings;",
      "  final DateTime? customizationsUpdatedAt;",
      "  final DateTime? createdAt;",
      "",
      "  // --- Combo/Bundle support ---",
      "  final String? comboId;",
      "  final List<String>? bundleItems;",
      "  final double? bundleDiscount;",
      "",
      "  // --- Dietary/Allergen UI tags ---",
      "  final List<String>? highlightTags;",
      "",
      "  // --- Admin feature flags ---",
      "  final bool? allowSpecialInstructions;",
      "  final bool? hideInMenu;",
      "",
      "  // --- NEW: Sauce/Dressing upcharge fields ---",
      "  final dynamic freeSauceCount; // int or Map<String, int>",
      "  final double? extraSauceUpcharge;",
      "  final dynamic freeDressingCount; // int or Map<String, int>",
      "  final double? extraDressingUpcharge;",
      "",
      "  // --- Wings customization fields ---",
      "  final List<String>? dippingSauceOptions; // For dipped/tossed wings",
      "  final Map<String, int>?",
      "      dippingSplits; // E.g., { '8pc': 2, '16pc': 2, '24pc': 2 }",
      "  final List<String>? sideDipSauceOptions; // For side dip cups (IDs)",
      "  final Map<String, int>? freeDipCupCount; // Free dip cups by size",
      "  final Map<String, double>? sideDipUpcharge; // Upcharge per dip cup by size",
      "",
      "  /// List of customization template IDs used to populate the menu item.",
      "  final List<String>? templateRefs;",
      "",
      "  Map<String, dynamic>? extraCharges;",
      "",
      "  Map<String, dynamic> toJson() {",
      "    return {",
      "      'id': id,",
      "      'name': name,",
      "      'category': category,",
      "      'categoryId': categoryId,",
      "      'price': price,",
      "      'available': availability,",
      "      'description': description,",
      "      'image': image,",
      "      'taxCategory': taxCategory,",
      "      'notes': notes,",
      "      'nutrition': nutrition?.toJson(),",
      "      'sizes': sizes?.map((s) => s.toMap()).toList(),",
      "      'sizePrices': sizePrices,",
      "      'includedIngredients': includedIngredients,",
      "      'optionalAddOns': optionalAddOns,",
      "      'customizations': customizations.map((c) => c.toFirestore()).toList(),",
      "      'rawCustomizations': rawCustomizations,",
      "      'maxFreeSauces': maxFreeSauces,",
      "      'extraSauceUpcharge': extraSauceUpcharge,",
      "      'extraCharges': extraCharges,",
      "      'customizationGroups': customizationGroups,",
      "    };",
      "  }",
      "",
      "  MenuItem({",
      "    required this.id,",
      "    required this.available,",
      "    required this.category,",
      "    required this.categoryId,",
      "    required this.name,",
      "    required this.price,",
      "    required this.description,",
      "    this.notes,",
      "    required this.customizationGroups,",
      "    this.image,",
      "    required this.taxCategory,",
      "    required this.availability,",
      "    this.sku,",
      "    List<String>? dietaryTags,",
      "    List<String>? allergens,",
      "    this.prepTime,",
      "    this.nutrition,",
      "    this.sortOrder,",
      "    this.lastModified,",
      "    this.lastModifiedBy,",
      "    this.archived = false,",
      "    this.exportId,",
      "    this.sizes,",
      "    this.sizePrices,",
      "    this.additionalToppingPrices,",
      "    this.includedIngredients,",
      "    this.optionalAddOns,",
      "    required this.customizations,",
      "    this.crustTypes,",
      "    this.cookTypes,",
      "    this.cutStyles,",
      "    this.sauceOptions,",
      "    this.dressingOptions,",
      "    this.maxFreeToppings,",
      "    this.maxFreeSauces,",
      "    this.maxFreeDressings,",
      "    this.maxToppings,",
      "    this.customizationsUpdatedAt,",
      "    this.createdAt,",
      "    this.comboId,",
      "    this.bundleItems,",
      "    this.bundleDiscount,",
      "    this.highlightTags,",
      "    this.allowSpecialInstructions,",
      "    this.hideInMenu,",
      "    // Sauce/Dressing fields",
      "    this.freeSauceCount,",
      "    this.extraSauceUpcharge,",
      "    this.freeDressingCount,",
      "    this.extraDressingUpcharge,",
      "    // WINGS fields",
      "    this.dippingSauceOptions,",
      "    this.dippingSplits,",
      "    this.sideDipSauceOptions,",
      "    this.freeDipCupCount,",
      "    this.sideDipUpcharge,",
      "    this.extraCharges,",
      "    // NEW: raw customizations",
      "    this.rawCustomizations,",
      "    this.templateRefs,",
      "  })  : dietaryTags = dietaryTags ?? [],",
      "        allergens = allergens ?? [];",
      "",
      "  // --- Firestore/JSON/Map Serialization ---",
      "",
      "  /// Convenience: returns true if this item is marked unavailable",
      "  bool get outOfStock => !availability;",
      "",
      "  /// Convenience: returns a non-null image string",
      "  String get imageUrl => image ?? '';",
      "",
      "  factory MenuItem.fromFirestore(Map<String, dynamic> data, String id) {",
      "    try {",
      "      double resolvedPrice = 0.0;",
      "      Map<String, double>? resolvedSizePrices;",
      "",
      "      Map<String, double>? parseStringDoubleMap(dynamic raw) {",
      "        try {",
      "          if (raw == null) return null;",
      "          if (raw is Map) {",
      "            return raw.map((k, v) => MapEntry(",
      "                k.toString(),",
      "                (v is num)",
      "                    ? v.toDouble()",
      "                    : double.tryParse(v.toString()) ?? 0));",
      "          }",
      "          if (raw is String) {",
      "            final parsed = jsonDecode(raw);",
      "            if (parsed is Map) {",
      "              return parsed.map((k, v) => MapEntry(",
      "                  k.toString(),",
      "                  (v is num)",
      "                      ? v.toDouble()",
      "                      : double.tryParse(v.toString()) ?? 0));",
      "            }",
      "          }",
      "        } catch (e, st) {",
      "          debugPrint('[MenuItem] Failed to parse string-double map: $e');",
      "          ErrorLogger.log(",
      "            message: 'Failed to parse string-double map',",
      "            stack: st.toString(),",
      "            source: 'MenuItem.fromFirestore',",
      "            screen: 'MenuItem',",
      "            contextData: {'raw': raw.toString()},",
      "          );",
      "        }",
      "        return null;",
      "      }",
      "",
      "      final priceField = data['price'];",
      "      if (priceField is num) {",
      "        resolvedPrice = priceField.toDouble();",
      "      } else if (priceField is Map) {",
      "        resolvedSizePrices = (priceField as Map).map(",
      "          (key, value) => MapEntry(key.toString(), (value as num).toDouble()),",
      "        );",
      "        resolvedPrice = resolvedSizePrices['Large'] ??",
      "            resolvedSizePrices['large'] ??",
      "            resolvedSizePrices.values.firstOrNull ??",
      "            0.0;",
      "      }",
      "",
      "      List<Customization> customizations = [];",
      "      if (data['customizations'] is List) {",
      "        try {",
      "          customizations = (data['customizations'] as List)",
      "              .map((e) =>",
      "                  Customization.fromFirestore(Map<String, dynamic>.from(e)))",
      "              .toList();",
      "        } catch (e, st) {",
      "          ErrorLogger.log(",
      "            message: 'Malformed customization entry',",
      "            stack: st.toString(),",
      "            source: 'MenuItem.fromFirestore',",
      "            screen: 'MenuItem',",
      "          );",
      "        }",
      "      }",
      "",
      "      final safeGroups = <Map<String, dynamic>>[];",
      "      for (final g in (data['customizationGroups'] as List?) ?? []) {",
      "        if (g is Map) {",
      "          safeGroups.add(Map<String, dynamic>.from(g));",
      "        } else {",
      "          debugPrint('[MenuItem] Skipped invalid customizationGroup: $g');",
      "          ErrorLogger.log(",
      "            message: 'Skipped malformed customizationGroup entry',",
      "            source: 'MenuItem.fromFirestore',",
      "            screen: 'MenuItem',",
      "            contextData: {'entry': g.toString()},",
      "          );",
      "        }",
      "      }",
      "",
      "      final safeAddOns = <Map<String, dynamic>>[];",
      "      for (final o in (data['optionalAddOns'] as List?) ?? []) {",
      "        if (o is Map) {",
      "          safeAddOns.add(Map<String, dynamic>.from(o));",
      "        } else {",
      "          debugPrint('[MenuItem] Skipped invalid optionalAddOn: $o');",
      "          ErrorLogger.log(",
      "            message: 'Skipped malformed optionalAddOn entry',",
      "            source: 'MenuItem.fromFirestore',",
      "            screen: 'MenuItem',",
      "            contextData: {'entry': o.toString()},",
      "          );",
      "        }",
      "      }",
      "",
      "      final safeIncluded = <Map<String, dynamic>>[];",
      "      for (final i in (data['includedIngredients'] as List?) ?? []) {",
      "        if (i is Map) {",
      "          safeIncluded.add(Map<String, dynamic>.from(i));",
      "        } else {",
      "          debugPrint('[MenuItem] Skipped invalid includedIngredient: $i');",
      "          ErrorLogger.log(",
      "            message: 'Skipped malformed includedIngredient entry',",
      "            source: 'MenuItem.fromFirestore',",
      "            screen: 'MenuItem',",
      "            contextData: {'entry': i.toString()},",
      "          );",
      "        }",
      "      }",
      "",
      "      return MenuItem(",
      "        id: id,",
      "        available: data['available'] ?? true,",
      "        category: data['category'] ?? '',",
      "        categoryId: data['categoryId'] ?? '',",
      "        name: data['name'] ?? '',",
      "        price: resolvedPrice,",
      "        description: data['description'] ?? '',",
      "        notes: data['notes'],",
      "        image: data['image'],",
      "        taxCategory: data['taxCategory'] ?? '',",
      "        availability: data['availability'] ?? data['available'] ?? true,",
      "        sku: data['sku'],",
      "        dietaryTags: List<String>.from(data['dietaryTags'] ?? []),",
      "        allergens: List<String>.from(data['allergens'] ?? []),",
      "        prepTime: data['prepTime'],",
      "        nutrition: data['nutrition'] != null",
      "            ? NutritionInfo.fromFirestore(",
      "                Map<String, dynamic>.from(data['nutrition']))",
      "            : null,",
      "        sortOrder: data['sortOrder'],",
      "        lastModified: (data['lastModified'] is Timestamp)",
      "            ? (data['lastModified'] as Timestamp).toDate()",
      "            : null,",
      "        lastModifiedBy: data['lastModifiedBy'],",
      "        archived: data['archived'] ?? false,",
      "        exportId: data['exportId'],",
      "        sizes: (() {",
      "          final sizesRaw = data['sizes'];",
      "          final pricesRaw = data['sizePrices'];",
      "          final toppingPricesRaw = data['additionalToppingPrices'];",
      "",
      "          if (sizesRaw is List && sizesRaw.isNotEmpty) {",
      "            // If list of maps, use as is (standard app save)",
      "            if (sizesRaw.first is Map) {",
      "              return sizesRaw",
      "                  .map((e) => SizeData.fromMap(Map<String, dynamic>.from(e)))",
      "                  .toList();",
      "            }",
      "            // If list of strings, pair with price maps",
      "            if (sizesRaw.first is String || sizesRaw.first is! Map) {",
      "              final sizeLabels = sizesRaw.map((e) => e.toString()).toList();",
      "",
      "              Map<String, double> priceMap = {};",
      "              if (pricesRaw is Map) {",
      "                priceMap = pricesRaw.map(",
      "                  (k, v) =>",
      "                      MapEntry(k.toString(), (v as num?)?.toDouble() ?? 0.0),",
      "                );",
      "              }",
      "",
      "              Map<String, double> toppingMap = {};",
      "              if (toppingPricesRaw is Map) {",
      "                toppingMap = toppingPricesRaw.map(",
      "                  (k, v) =>",
      "                      MapEntry(k.toString(), (v as num?)?.toDouble() ?? 0.0),",
      "                );",
      "              }",
      "",
      "              return sizeLabels",
      "                  .map((size) => SizeData(",
      "                        label: size,",
      "                        basePrice: priceMap[size] ?? 0.0,",
      "                        toppingPrice: toppingMap[size] ?? 0.0,",
      "                      ))",
      "                  .toList();",
      "            }",
      "          }",
      "          return <SizeData>[];",
      "        })(),",
      "        sizePrices: data['sizePrices'] != null",
      "            ? Map<String, double>.from((data['sizePrices'] as Map)",
      "                .map((key, value) => MapEntry(key, (value as num).toDouble())))",
      "            : resolvedSizePrices,",
      "        additionalToppingPrices:",
      "            parseStringDoubleMap(data['additionalToppingPrices']),",
      "        includedIngredients: safeIncluded.isEmpty ? null : safeIncluded,",
      "        customizationGroups: safeGroups.isEmpty ? null : safeGroups,",
      "        optionalAddOns: safeAddOns.isEmpty ? null : safeAddOns,",
      "        customizations: customizations,",
      "        crustTypes: data['crustTypes'] == null",
      "            ? null",
      "            : List<String>.from(data['crustTypes']),",
      "        cookTypes: data['cookTypes'] == null",
      "            ? null",
      "            : List<String>.from(data['cookTypes']),",
      "        cutStyles: data['cutStyles'] == null",
      "            ? null",
      "            : List<String>.from(data['cutStyles']),",
      "        sauceOptions: data['sauceOptions'] == null",
      "            ? null",
      "            : List<String>.from(data['sauceOptions']),",
      "        dressingOptions: data['dressingOptions'] == null",
      "            ? null",
      "            : List<String>.from(data['dressingOptions']),",
      "        maxFreeToppings: data['maxFreeToppings'],",
      "        maxFreeSauces: data['maxFreeSauces'],",
      "        maxFreeDressings: data['maxFreeDressings'],",
      "        maxToppings: data['maxToppings'],",
      "        customizationsUpdatedAt: data['customizationsUpdatedAt'] is Timestamp",
      "            ? (data['customizationsUpdatedAt'] as Timestamp).toDate()",
      "            : null,",
      "        createdAt: data['createdAt'] is Timestamp",
      "            ? (data['createdAt'] as Timestamp).toDate()",
      "            : null,",
      "        comboId: data['comboId'],",
      "        bundleItems: (data['bundleItems'] is List)",
      "            ? List<String>.from(data['bundleItems'])",
      "            : null,",
      "        bundleDiscount: (data['bundleDiscount'] as num?)?.toDouble(),",
      "        highlightTags: data['highlightTags'] == null",
      "            ? null",
      "            : List<String>.from(data['highlightTags']),",
      "        allowSpecialInstructions: data['allowSpecialInstructions'],",
      "        hideInMenu: data['hideInMenu'],",
      "        freeSauceCount: (data['freeSauceCount'] is Map)",
      "            ? Map.fromEntries(",
      "                (data['freeSauceCount'] as Map)",
      "                    .entries",
      "                    .where((e) => e.key != null && e.value != null)",
      "                    .map((e) {",
      "                  final parsed = int.tryParse(e.value.toString());",
      "                  return MapEntry(e.key.toString(), parsed ?? 0);",
      "                }),",
      "              )",
      "            : null,",
      "        extraSauceUpcharge: (data['extraSauceUpcharge'] as num?)?.toDouble(),",
      "        freeDressingCount: data['freeDressingCount'],",
      "        extraDressingUpcharge:",
      "            (data['extraDressingUpcharge'] as num?)?.toDouble(),",
      "        dippingSauceOptions: data['dippingSauceOptions'] == null",
      "            ? null",
      "            : List<String>.from(data['dippingSauceOptions']),",
      "        dippingSplits: (data['dippingSplits'] is Map)",
      "            ? Map.fromEntries(",
      "                (data['dippingSplits'] as Map)",
      "                    .entries",
      "                    .where((e) => e.key != null && e.value != null)",
      "                    .map((e) {",
      "                  final parsed = int.tryParse(e.value.toString());",
      "                  return MapEntry(e.key.toString(), parsed ?? 0);",
      "                }),",
      "              )",
      "            : null,",
      "        sideDipSauceOptions: data['sideDipSauceOptions'] == null",
      "            ? null",
      "            : List<String>.from(data['sideDipSauceOptions']),",
      "        freeDipCupCount: (data['freeDipCupCount'] is Map)",
      "            ? Map.fromEntries(",
      "                (data['freeDipCupCount'] as Map)",
      "                    .entries",
      "                    .where((e) => e.key != null && e.value != null)",
      "                    .map((e) {",
      "                  final parsed = int.tryParse(e.value.toString());",
      "                  return MapEntry(e.key.toString(), parsed ?? 0);",
      "                }),",
      "              )",
      "            : null,",
      "        sideDipUpcharge: (data['sideDipUpcharge'] is Map)",
      "            ? Map.fromEntries(",
      "                (data['sideDipUpcharge'] as Map)",
      "                    .entries",
      "                    .where((e) => e.key != null && e.value != null)",
      "                    .map((e) {",
      "                  final parsed = double.tryParse(e.value.toString());",
      "                  return MapEntry(e.key.toString(), parsed ?? 0.0);",
      "                }),",
      "              )",
      "            : null,",
      "        templateRefs:",
      "            (data['templateRefs'] as List?)?.map((e) => e.toString()).toList(),",
      "      );",
      "    } catch (e, st) {",
      "      ErrorLogger.log(",
      "        message: 'MenuItem.fromFirestore threw exception',",
      "        source: 'MenuItem.fromFirestore',",
      "        screen: 'menu_item_provider.dart',",
      "        severity: 'error',",
      "        stack: st.toString(),",
      "        contextData: {",
      "          'id': id,",
      "          'rawData': data.map((k, v) => MapEntry(",
      "              k, v is Timestamp ? v.toDate().toIso8601String() : v.toString())),",
      "          'error': e.toString(),",
      "        },",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  factory MenuItem.fromMap(Map<String, dynamic> data, [String? id]) {",
      "    try {",
      "      return MenuItem.fromFirestore(data, id ?? data['id'] ?? '');",
      "    } catch (e, stack) {",
      "      ErrorLogger.log(",
      "        message: 'MenuItem.fromMap failed',",
      "        source: 'MenuItem.fromMap',",
      "        screen: 'menu_item_provider.dart',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "        contextData: {",
      "          'id': id ?? data['id'] ?? '',",
      "          'rawData': data.map((k, v) => MapEntry(k, v.toString())),",
      "          'error': e.toString(),",
      "        },",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Creates a MenuItem for onboarding from a raw template map.",
      "  /// Ensures all model fields are present and ready for mapping/repair UI.",
      "  /// Fields not present in the template are set to '' (String), 0.0 (double), or null/empty for advanced fields.",
      "  /// Use this to create the initial onboarding state for a menu item from template.",
      "  factory MenuItem.fromTemplate(Map<String, dynamic> template,",
      "      {String? idOverride}) {",
      "    // Safely unwrap and initialize all model fields.",
      "    return MenuItem(",
      "      id: idOverride ?? template['id'] ?? '',",
      "      name: template['name'] ?? '',",
      "      description: template['description'] ?? '',",
      "      price: (template['price'] is num)",
      "          ? (template['price'] as num).toDouble()",
      "          : 0.0,",
      "      category: template['category'] ?? '',",
      "      categoryId: template['categoryId'] ?? '',",
      "      image: template['image'],",
      "      available: template['available'] ?? true,",
      "      availability: template['availability'] ?? template['available'] ?? true,",
      "      notes: template['notes'],",
      "      taxCategory: template['taxCategory'] ?? '',",
      "      sku: template['sku'],",
      "      dietaryTags: List<String>.from(template['dietaryTags'] ?? []),",
      "      allergens: List<String>.from(template['allergens'] ?? []),",
      "      prepTime: template['prepTime'],",
      "      nutrition: template['nutrition'] != null",
      "          ? NutritionInfo.fromFirestore(",
      "              Map<String, dynamic>.from(template['nutrition']))",
      "          : null,",
      "      sortOrder: template['sortOrder'],",
      "      lastModified: null,",
      "      lastModifiedBy: null,",
      "      archived: template['archived'] ?? false,",
      "      exportId: template['exportId'],",
      "      sizes: (template['sizes'] as List?)",
      "          ?.whereType<Map>()",
      "          .map((e) => SizeData.fromMap(Map<String, dynamic>.from(e)))",
      "          .toList(),",
      "      sizePrices: template['sizePrices'] != null",
      "          ? Map<String, double>.from((template['sizePrices'] as Map)",
      "              .map((key, value) => MapEntry(key, (value as num).toDouble())))",
      "          : null,",
      "      additionalToppingPrices: template['additionalToppingPrices'] != null",
      "          ? Map<String, double>.from((template['additionalToppingPrices']",
      "                  as Map)",
      "              .map((key, value) => MapEntry(key, (value as num).toDouble())))",
      "          : null,",
      "      includedIngredients: (template['includedIngredients'] as List?)",
      "          ?.whereType<Map>()",
      "          .map((e) => Map<String, dynamic>.from(e))",
      "          .toList(),",
      "      customizationGroups: (template['customizationGroups'] as List?)",
      "          ?.whereType<Map>()",
      "          .map((e) => Map<String, dynamic>.from(e))",
      "          .toList(),",
      "      optionalAddOns: (template['optionalAddOns'] as List?)",
      "          ?.whereType<Map>()",
      "          .map((e) => Map<String, dynamic>.from(e))",
      "          .toList(),",
      "      customizations: (template['customizations'] as List?)",
      "              ?.map((e) =>",
      "                  Customization.fromFirestore(Map<String, dynamic>.from(e)))",
      "              .toList() ??",
      "          [],",
      "      rawCustomizations: (template['rawCustomizations'] as List?)",
      "          ?.whereType<Map>()",
      "          .map((e) => Map<String, dynamic>.from(e))",
      "          .toList(),",
      "      crustTypes: template['crustTypes'] == null",
      "          ? null",
      "          : List<String>.from(template['crustTypes']),",
      "      cookTypes: template['cookTypes'] == null",
      "          ? null",
      "          : List<String>.from(template['cookTypes']),",
      "      cutStyles: template['cutStyles'] == null",
      "          ? null",
      "          : List<String>.from(template['cutStyles']),",
      "      sauceOptions: template['sauceOptions'] == null",
      "          ? null",
      "          : List<String>.from(template['sauceOptions']),",
      "      dressingOptions: template['dressingOptions'] == null",
      "          ? null",
      "          : List<String>.from(template['dressingOptions']),",
      "      maxFreeToppings: template['maxFreeToppings'],",
      "      maxFreeSauces: template['maxFreeSauces'],",
      "      maxFreeDressings: template['maxFreeDressings'],",
      "      maxToppings: template['maxToppings'],",
      "      customizationsUpdatedAt: null,",
      "      createdAt: null,",
      "      comboId: template['comboId'],",
      "      bundleItems: template['bundleItems'] == null",
      "          ? null",
      "          : List<String>.from(template['bundleItems']),",
      "      bundleDiscount: (template['bundleDiscount'] as num?)?.toDouble(),",
      "      highlightTags: template['highlightTags'] == null",
      "          ? null",
      "          : List<String>.from(template['highlightTags']),",
      "      allowSpecialInstructions: template['allowSpecialInstructions'],",
      "      hideInMenu: template['hideInMenu'],",
      "      freeSauceCount: template['freeSauceCount'],",
      "      extraSauceUpcharge: (template['extraSauceUpcharge'] as num?)?.toDouble(),",
      "      freeDressingCount: template['freeDressingCount'],",
      "      extraDressingUpcharge:",
      "          (template['extraDressingUpcharge'] as num?)?.toDouble(),",
      "      dippingSauceOptions: template['dippingSauceOptions'] == null",
      "          ? null",
      "          : List<String>.from(template['dippingSauceOptions']),",
      "      dippingSplits: template['dippingSplits'] == null",
      "          ? null",
      "          : Map<String, int>.from(template['dippingSplits']),",
      "      sideDipSauceOptions: template['sideDipSauceOptions'] == null",
      "          ? null",
      "          : List<String>.from(template['sideDipSauceOptions']),",
      "      freeDipCupCount: template['freeDipCupCount'] == null",
      "          ? null",
      "          : Map<String, int>.from(template['freeDipCupCount']),",
      "      sideDipUpcharge: template['sideDipUpcharge'] == null",
      "          ? null",
      "          : Map<String, double>.from(template['sideDipUpcharge']),",
      "      templateRefs: template['templateRefs'] == null",
      "          ? null",
      "          : List<String>.from(template['templateRefs']),",
      "      extraCharges: template['extraCharges'],",
      "    );",
      "  }",
      "",
      "  Map<String, dynamic> toFirestore() {",
      "    final priceField =",
      "        sizePrices != null && sizePrices!.isNotEmpty ? sizePrices : price;",
      "",
      "    final map = {",
      "      'category': category,",
      "      'categoryId': categoryId,",
      "      'name': name,",
      "      'price': priceField,",
      "      'description': description,",
      "      'notes': notes,",
      "      'image': image,",
      "      'taxCategory': taxCategory,",
      "      'available': availability,",
      "      'sku': sku,",
      "      'dietaryTags': dietaryTags,",
      "      'allergens': allergens,",
      "      'prepTime': prepTime,",
      "      'nutrition': nutrition?.toFirestore(),",
      "      'sortOrder': sortOrder,",
      "      'lastModified':",
      "          lastModified != null ? Timestamp.fromDate(lastModified!) : null,",
      "      'lastModifiedBy': lastModifiedBy,",
      "      'archived': archived,",
      "      'exportId': exportId,",
      "      //customization groups",
      "      if (sizes != null) 'sizes': sizes!.map((s) => s.toMap()).toList(),",
      "      if (sizePrices != null) 'sizePrices': sizePrices,",
      "      if (additionalToppingPrices != null)",
      "        'additionalToppingPrices': additionalToppingPrices,",
      "      if (includedIngredients != null)",
      "        'includedIngredients': includedIngredients,",
      "      if (customizationGroups != null)",
      "        'customizationGroups': customizationGroups,",
      "      if (optionalAddOns != null) 'optionalAddOns': optionalAddOns,",
      "      'customizations': customizations.map((c) => c.toFirestore()).toList(),",
      "      'customizationGroups': customizationGroups,",
      "      if (crustTypes != null) 'crustTypes': crustTypes,",
      "      if (cookTypes != null) 'cookTypes': cookTypes,",
      "      if (cutStyles != null) 'cutStyles': cutStyles,",
      "      if (sauceOptions != null) 'sauceOptions': sauceOptions,",
      "      if (dressingOptions != null) 'dressingOptions': dressingOptions,",
      "      if (maxFreeToppings != null) 'maxFreeToppings': maxFreeToppings,",
      "      if (maxFreeSauces != null) 'maxFreeSauces': maxFreeSauces,",
      "      if (maxFreeDressings != null) 'maxFreeDressings': maxFreeDressings,",
      "      if (maxToppings != null) 'maxToppings': maxToppings,",
      "      if (customizationsUpdatedAt != null)",
      "        'customizationsUpdatedAt': Timestamp.fromDate(customizationsUpdatedAt!),",
      "      if (createdAt != null) 'createdAt': Timestamp.fromDate(createdAt!),",
      "      if (comboId != null) 'comboId': comboId,",
      "      if (bundleItems != null) 'bundleItems': bundleItems,",
      "      if (bundleDiscount != null) 'bundleDiscount': bundleDiscount,",
      "      if (highlightTags != null) 'highlightTags': highlightTags,",
      "      if (templateRefs != null) 'templateRefs': templateRefs,",
      "      if (allowSpecialInstructions != null)",
      "        'allowSpecialInstructions': allowSpecialInstructions,",
      "      if (hideInMenu != null) 'hideInMenu': hideInMenu,",
      "      // Sauce/Dressing fields",
      "      if (freeSauceCount != null) 'freeSauceCount': freeSauceCount,",
      "      if (extraSauceUpcharge != null) 'extraSauceUpcharge': extraSauceUpcharge,",
      "      if (freeDressingCount != null) 'freeDressingCount': freeDressingCount,",
      "      if (extraDressingUpcharge != null)",
      "        'extraDressingUpcharge': extraDressingUpcharge,",
      "      // Wings fields",
      "      if (dippingSauceOptions != null)",
      "        'dippingSauceOptions': dippingSauceOptions,",
      "      if (dippingSplits != null) 'dippingSplits': dippingSplits,",
      "      if (sideDipSauceOptions != null)",
      "        'sideDipSauceOptions': sideDipSauceOptions,",
      "      if (freeDipCupCount != null) 'freeDipCupCount': freeDipCupCount,",
      "      if (sideDipUpcharge != null) 'sideDipUpcharge': sideDipUpcharge,",
      "    };",
      "    map.removeWhere((_, v) => v == null);",
      "    return map;",
      "  }",
      "",
      "  Map<String, dynamic> toMap() => toFirestore();",
      "",
      "  /// Utility: List of all included ingredient IDs (for quick lookup in UI)",
      "  List<String> get includedIngredientIds {",
      "    if (includedIngredients == null) return [];",
      "    return includedIngredients!",
      "        .map((e) => e['ingredientId'] ?? e['id'])",
      "        .whereType<String>()",
      "        .toList();",
      "  }",
      "",
      "  /// Utility: All available ingredient IDs from all customization groups",
      "  List<String> get allGroupIngredientIds {",
      "    if (customizationGroups == null) return [];",
      "    return customizationGroups!",
      "        .expand((group) =>",
      "            (group['ingredientIds'] as List<dynamic>).whereType<String>())",
      "        .toList();",
      "  }",
      "",
      "  /// Utility: Add-on ingredient IDs",
      "  List<String> get optionalAddOnIds {",
      "    if (optionalAddOns == null) return [];",
      "    return optionalAddOns!",
      "        .map((e) => e['ingredientId'] ?? e['id'])",
      "        .whereType<String>()",
      "        .toList();",
      "  }",
      "",
      "  // ==== UTILITY GETTERS for Upcharge Logic ====",
      "",
      "  /// Returns the free sauce count for the given size (if available).",
      "  int getFreeSauceCountForSize(String? size) {",
      "    if (freeSauceCount == null) return 0;",
      "    if (freeSauceCount is int) return freeSauceCount;",
      "    if (freeSauceCount is Map) {",
      "      if (size != null && (freeSauceCount as Map).containsKey(size)) {",
      "        return (freeSauceCount as Map)[size] as int;",
      "      }",
      "      final map = freeSauceCount as Map;",
      "      return map.values.cast<int>().first;",
      "    }",
      "    return 0;",
      "  }",
      "",
      "  double getExtraSauceUpcharge() => extraSauceUpcharge ?? 0.0;",
      "",
      "  int getFreeDressingCountForSize(String? size) {",
      "    if (freeDressingCount == null) return 0;",
      "    if (freeDressingCount is int) return freeDressingCount;",
      "    if (freeDressingCount is Map) {",
      "      if (size != null && (freeDressingCount as Map).containsKey(size)) {",
      "        return (freeDressingCount as Map)[size] as int;",
      "      }",
      "      final map = freeDressingCount as Map;",
      "      return map.values.cast<int>().first;",
      "    }",
      "    return 0;",
      "  }",
      "",
      "  double getExtraDressingUpcharge() => extraDressingUpcharge ?? 0.0;",
      "",
      "  // --- Wings-specific utility accessors ---",
      "",
      "  /// Number of splits allowed for dipped wings for this size.",
      "  int getDippingSplitsForSize(String? size) {",
      "    if (dippingSplits == null || size == null) return 1;",
      "    return dippingSplits![size] ?? 1;",
      "  }",
      "",
      "  /// List of allowed dipping sauce IDs for wings (dipped/tossed).",
      "  List<String> getDippingSauceOptions() => dippingSauceOptions ?? [];",
      "",
      "  /// List of allowed side dip cup options for this wings item.",
      "  List<String> getSideDipSauceOptions() => sideDipSauceOptions ?? [];",
      "",
      "  /// How many free side dip cups allowed per wings size.",
      "  int getFreeDipCupCountForSize(String? size) {",
      "    if (freeDipCupCount == null || size == null) return 0;",
      "    return freeDipCupCount![size] ?? 0;",
      "  }",
      "",
      "  /// The per-cup upcharge for side dips, by size.",
      "  double getSideDipUpchargeForSize(String? size) {",
      "    if (sideDipUpcharge == null || size == null) return 0.0;",
      "    return sideDipUpcharge![size] ?? 0.0;",
      "  }",
      "",
      "  MenuItem copyWith({",
      "    String? id,",
      "    bool? available,",
      "    String? category,",
      "    String? categoryId,",
      "    String? name,",
      "    double? price,",
      "    String? description,",
      "    String? notes,",
      "    String? image,",
      "    String? taxCategory,",
      "    bool? availability,",
      "    String? sku,",
      "    List<String>? dietaryTags,",
      "    List<String>? allergens,",
      "    int? prepTime,",
      "    NutritionInfo? nutrition,",
      "    int? sortOrder,",
      "    DateTime? lastModified,",
      "    String? lastModifiedBy,",
      "    bool? archived,",
      "    String? exportId,",
      "    List<SizeData>? sizes,",
      "    Map<String, double>? sizePrices,",
      "    Map<String, double>? additionalToppingPrices,",
      "    List<Map<String, dynamic>>? includedIngredients,",
      "    List<Map<String, dynamic>>? customizationGroups,",
      "    List<Map<String, dynamic>>? optionalAddOns,",
      "    List<Customization>? customizations,",
      "    List<String>? crustTypes,",
      "    List<String>? cookTypes,",
      "    List<String>? cutStyles,",
      "    List<String>? sauceOptions,",
      "    List<String>? dressingOptions,",
      "    int? maxFreeToppings,",
      "    int? maxFreeSauces,",
      "    int? maxFreeDressings,",
      "    int? maxToppings,",
      "    DateTime? customizationsUpdatedAt,",
      "    DateTime? createdAt,",
      "    String? comboId,",
      "    List<String>? bundleItems,",
      "    double? bundleDiscount,",
      "    List<String>? highlightTags,",
      "    List<String>? templateRefs,",
      "    bool? allowSpecialInstructions,",
      "    bool? hideInMenu,",
      "    // NEW fields",
      "    dynamic freeSauceCount,",
      "    double? extraSauceUpcharge,",
      "    dynamic freeDressingCount,",
      "    double? extraDressingUpcharge,",
      "    // Wings fields",
      "    List<String>? dippingSauceOptions,",
      "    Map<String, int>? dippingSplits,",
      "    List<String>? sideDipSauceOptions,",
      "    Map<String, int>? freeDipCupCount,",
      "    Map<String, double>? sideDipUpcharge,",
      "    // NEW: template refs",
      "  }) {",
      "    return MenuItem(",
      "      id: id ?? this.id,",
      "      available: available ?? this.available,",
      "      category: category ?? this.category,",
      "      categoryId: categoryId ?? this.categoryId,",
      "      name: name ?? this.name,",
      "      price: price ?? this.price,",
      "      description: description ?? this.description,",
      "      notes: notes ?? this.notes,",
      "      image: image ?? this.image,",
      "      taxCategory: taxCategory ?? this.taxCategory,",
      "      availability: availability ?? this.availability,",
      "      sku: sku ?? this.sku,",
      "      dietaryTags: dietaryTags ?? this.dietaryTags,",
      "      allergens: allergens ?? this.allergens,",
      "      prepTime: prepTime ?? this.prepTime,",
      "      nutrition: nutrition ?? this.nutrition,",
      "      sortOrder: sortOrder ?? this.sortOrder,",
      "      lastModified: lastModified ?? this.lastModified,",
      "      lastModifiedBy: lastModifiedBy ?? this.lastModifiedBy,",
      "      archived: archived ?? this.archived,",
      "      exportId: exportId ?? this.exportId,",
      "      sizes: sizes ?? this.sizes,",
      "      sizePrices: sizePrices ?? this.sizePrices,",
      "      additionalToppingPrices:",
      "          additionalToppingPrices ?? this.additionalToppingPrices,",
      "      includedIngredients: includedIngredients ?? this.includedIngredients,",
      "      customizationGroups: customizationGroups ?? this.customizationGroups,",
      "      optionalAddOns: optionalAddOns ?? this.optionalAddOns,",
      "      customizations: customizations ?? this.customizations,",
      "      crustTypes: crustTypes ?? this.crustTypes,",
      "      cookTypes: cookTypes ?? this.cookTypes,",
      "      cutStyles: cutStyles ?? this.cutStyles,",
      "      sauceOptions: sauceOptions ?? this.sauceOptions,",
      "      dressingOptions: dressingOptions ?? this.dressingOptions,",
      "      maxFreeToppings: maxFreeToppings ?? this.maxFreeToppings,",
      "      maxFreeSauces: maxFreeSauces ?? this.maxFreeSauces,",
      "      maxFreeDressings: maxFreeDressings ?? this.maxFreeDressings,",
      "      maxToppings: maxToppings ?? this.maxToppings,",
      "      customizationsUpdatedAt:",
      "          customizationsUpdatedAt ?? this.customizationsUpdatedAt,",
      "      createdAt: createdAt ?? this.createdAt,",
      "      comboId: comboId ?? this.comboId,",
      "      bundleItems: bundleItems ?? this.bundleItems,",
      "      bundleDiscount: bundleDiscount ?? this.bundleDiscount,",
      "      highlightTags: highlightTags ?? this.highlightTags,",
      "      allowSpecialInstructions:",
      "          allowSpecialInstructions ?? this.allowSpecialInstructions,",
      "      hideInMenu: hideInMenu ?? this.hideInMenu,",
      "      freeSauceCount: freeSauceCount ?? this.freeSauceCount,",
      "      extraSauceUpcharge: extraSauceUpcharge ?? this.extraSauceUpcharge,",
      "      freeDressingCount: freeDressingCount ?? this.freeDressingCount,",
      "      extraDressingUpcharge:",
      "          extraDressingUpcharge ?? this.extraDressingUpcharge,",
      "      // Wings",
      "      dippingSauceOptions: dippingSauceOptions ?? this.dippingSauceOptions,",
      "      dippingSplits: dippingSplits ?? this.dippingSplits,",
      "      sideDipSauceOptions: sideDipSauceOptions ?? this.sideDipSauceOptions,",
      "      freeDipCupCount: freeDipCupCount ?? this.freeDipCupCount,",
      "      sideDipUpcharge: sideDipUpcharge ?? this.sideDipUpcharge,",
      "      // NEW: template refs",
      "      templateRefs: templateRefs ?? this.templateRefs,",
      "    );",
      "  }",
      "",
      "  factory MenuItem.fromJson(Map<String, dynamic> data) =>",
      "      MenuItem.fromMap(data);",
      "",
      "  /// Checks if this menu item references a given categoryId (case-insensitive).",
      "  bool matchesCategoryId(String? otherCategoryId) =>",
      "      otherCategoryId != null &&",
      "      categoryId.toLowerCase() == otherCategoryId.toLowerCase();",
      "",
      "  /// Checks if this menu item references a given category name (case-insensitive, trimmed).",
      "  bool matchesCategoryName(String? otherName) =>",
      "      otherName != null &&",
      "      category.trim().toLowerCase() == otherName.trim().toLowerCase();",
      "",
      "  /// Returns a list of all ingredient IDs referenced by this item (included, add-ons, customization groups).",
      "  List<String> get allReferencedIngredientIds {",
      "    final ids = <String>{};",
      "    ids.addAll(includedIngredientIds);",
      "    ids.addAll(optionalAddOnIds);",
      "    ids.addAll(allGroupIngredientIds);",
      "    return ids.toList();",
      "  }",
      "",
      "  /// Returns all referenced ingredient type IDs, if present.",
      "  List<String> get allReferencedIngredientTypeIds {",
      "    // Checks includedIngredients and optionalAddOns for 'typeId'",
      "    final ids = <String>{};",
      "    if (includedIngredients != null) {",
      "      for (final e in includedIngredients!) {",
      "        if (e.containsKey('typeId') &&",
      "            e['typeId'] is String &&",
      "            (e['typeId'] as String).isNotEmpty) {",
      "          ids.add(e['typeId']);",
      "        }",
      "      }",
      "    }",
      "    if (optionalAddOns != null) {",
      "      for (final e in optionalAddOns!) {",
      "        if (e.containsKey('typeId') &&",
      "            e['typeId'] is String &&",
      "            (e['typeId'] as String).isNotEmpty) {",
      "          ids.add(e['typeId']);",
      "        }",
      "      }",
      "    }",
      "    return ids.toList();",
      "  }",
      "",
      "  /// Utility: Checks for missing references by comparing to schema lists.",
      "  /// Returns a map of schema element type to list of missing values.",
      "  Map<String, List<String>> findSchemaIssues({",
      "    required List<String> validCategoryIds,",
      "    required List<String> validIngredientIds,",
      "    required List<String> validIngredientTypeIds,",
      "  }) {",
      "    final issues = <String, List<String>>{};",
      "",
      "    // Category",
      "    if (!validCategoryIds.any((id) => matchesCategoryId(id))) {",
      "      issues['categoryId'] = [categoryId];",
      "    }",
      "",
      "    // Ingredients",
      "    final missingIngredients = allReferencedIngredientIds",
      "        .where((id) => !validIngredientIds.contains(id))",
      "        .toList();",
      "    if (missingIngredients.isNotEmpty) {",
      "      issues['ingredients'] = missingIngredients;",
      "    }",
      "",
      "    // Ingredient Types",
      "    final missingTypes = allReferencedIngredientTypeIds",
      "        .where((id) => !validIngredientTypeIds.contains(id))",
      "        .toList();",
      "    if (missingTypes.isNotEmpty) {",
      "      issues['ingredientTypes'] = missingTypes;",
      "    }",
      "",
      "    return issues;",
      "  }",
      "",
      "  /// Warn if critical fields are missing (for onboarding/mapping/debugging).",
      "  String? get schemaWarning {",
      "    if (id.isEmpty || name.isEmpty || categoryId.isEmpty) {",
      "      return \"MenuItem missing required id, name, or categoryId: id='$id', name='$name', categoryId='$categoryId'\";",
      "    }",
      "    return null;",
      "  }",
      "",
      "  /// Returns a list of all required or critical fields missing from onboarding/template import.",
      "  /// Used to block Save and drive the repair UI.",
      "  /// Update this list as your onboarding requirements evolve!",
      "  List<String> missingRequiredFields() {",
      "    final missing = <String>[];",
      "",
      "    // Core fields",
      "    if (name.isEmpty) missing.add('name');",
      "    if (description.isEmpty) missing.add('description');",
      "    if (categoryId.isEmpty) missing.add('categoryId');",
      "    if (category.isEmpty) missing.add('category');",
      "    if (image == null || image!.isEmpty) missing.add('image');",
      "    if (taxCategory.isEmpty) missing.add('taxCategory');",
      "    if (price == 0.0 && (sizePrices == null || sizePrices!.isEmpty))",
      "      missing.add('price');",
      "    if (availability != true && available != true) missing.add('available');",
      "",
      "    // Ingredient/Customization structure",
      "    if (includedIngredients == null || includedIngredients!.isEmpty)",
      "      missing.add('includedIngredients');",
      "    if (customizationGroups == null || customizationGroups!.isEmpty)",
      "      missing.add('customizationGroups');",
      "",
      "    // Add-ons (optional, but commonly required for certain categories)",
      "    // if (optionalAddOns == null || optionalAddOns!.isEmpty) missing.add('optionalAddOns');",
      "",
      "    // Sizing (for multi-size items)",
      "    if ((sizePrices != null && sizePrices!.isNotEmpty) &&",
      "        (sizes == null || sizes!.isEmpty)) missing.add('sizes');",
      "",
      "    // Customizations",
      "    if (customizations.isEmpty) missing.add('customizations');",
      "",
      "    // Advanced/Meta fields (optional—uncomment if needed for your workflow)",
      "    // if (sku == null || sku!.isEmpty) missing.add('sku');",
      "    // if (prepTime == null) missing.add('prepTime');",
      "    // if (nutrition == null) missing.add('nutrition');",
      "    // if (notes == null || notes!.isEmpty) missing.add('notes');",
      "",
      "    // Advanced upcharge fields (required for certain categories like pizza/wings)",
      "    // if (additionalToppingPrices == null) missing.add('additionalToppingPrices');",
      "    // if (freeSauceCount == null) missing.add('freeSauceCount');",
      "",
      "    // Required fields for your platform",
      "    // if (templateRefs == null || templateRefs!.isEmpty) missing.add('templateRefs');",
      "",
      "    // Add any other logic as needed for your onboarding flow",
      "",
      "    return missing;",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 1087,
      "file_size": 42352,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\models\\menu_item_schema_issue.dart",
    "content": [
      "// lib/core/models/menu_item_schema_issue.dart",
      "import 'package:collection/collection.dart';",
      "import 'package:flutter/foundation.dart';",
      "",
      "/// Enum representing the type of schema issue for a MenuItem.",
      "enum MenuItemSchemaIssueType {",
      "  category,",
      "  ingredient,",
      "  ingredientType,",
      "  missingField, // NEW: for core fields like name, price, etc.",
      "  // Expandable: add more types if needed, e.g. modifier, templateRef, etc.",
      "}",
      "",
      "/// Represents a missing or invalid reference found during schema validation.",
      "@immutable",
      "class MenuItemSchemaIssue {",
      "  /// The type of schema issue (e.g., category, ingredient, ingredientType).",
      "  final MenuItemSchemaIssueType type;",
      "",
      "  /// The missing or invalid value (e.g., a missing id or name).",
      "  final String missingReference;",
      "",
      "  /// Optionally, the human-readable label for the reference (for user clarity).",
      "  final String? label;",
      "",
      "  /// The menu item field/key where the issue was found (e.g., 'includedIngredients', 'categoryId').",
      "  final String field;",
      "",
      "  /// Optionally, the menu item ID this issue is attached to (for onboarding lists).",
      "  final String? menuItemId;",
      "",
      "  /// Optionally, context to further help in mapping (e.g., the group label, row number, etc.).",
      "  final String? context;",
      "",
      "  /// Severity (optional): warning, error, info, etc.",
      "  final String severity;",
      "",
      "  /// Optional: if this issue is resolved by the user (for UI state).",
      "  final bool resolved;",
      "",
      "  const MenuItemSchemaIssue({",
      "    required this.type,",
      "    required this.missingReference,",
      "    required this.field,",
      "    this.label,",
      "    this.menuItemId,",
      "    this.context,",
      "    this.severity = 'warning',",
      "    this.resolved = false,",
      "  });",
      "",
      "  /// Human-friendly display string for UI use.",
      "  String get displayMessage {",
      "    switch (type) {",
      "      case MenuItemSchemaIssueType.category:",
      "        return \"Category reference not found: '${label ?? missingReference}'\"",
      "            \"${context != null ? ' ($context)' : ''}\";",
      "      case MenuItemSchemaIssueType.ingredient:",
      "        return \"Ingredient reference not found: '${label ?? missingReference}'\"",
      "            \"${context != null ? ' ($context)' : ''}\";",
      "      case MenuItemSchemaIssueType.ingredientType:",
      "        return \"Ingredient type not found: '${label ?? missingReference}'\"",
      "            \"${context != null ? ' ($context)' : ''}\";",
      "      case MenuItemSchemaIssueType.missingField:",
      "        return \"Required field missing: ${label ?? field}\";",
      "      default:",
      "        return \"Unknown schema issue in '$field': '${label ?? missingReference}'\";",
      "    }",
      "  }",
      "",
      "  /// Clone with resolved state (for UI/repair workflows)",
      "  MenuItemSchemaIssue markResolved([bool isResolved = true]) =>",
      "      MenuItemSchemaIssue(",
      "        type: type,",
      "        missingReference: missingReference,",
      "        label: label,",
      "        field: field,",
      "        menuItemId: menuItemId,",
      "        context: context,",
      "        severity: severity,",
      "        resolved: isResolved,",
      "      );",
      "",
      "  /// Utility: Convert issue type enum to string for filtering/logging.",
      "  String get typeKey => describeEnum(type);",
      "",
      "  /// For equality/sets.",
      "  @override",
      "  bool operator ==(Object other) =>",
      "      identical(this, other) ||",
      "      other is MenuItemSchemaIssue &&",
      "          runtimeType == other.runtimeType &&",
      "          type == other.type &&",
      "          missingReference == other.missingReference &&",
      "          field == other.field &&",
      "          menuItemId == other.menuItemId &&",
      "          context == other.context;",
      "",
      "  @override",
      "  int get hashCode =>",
      "      type.hashCode ^",
      "      missingReference.hashCode ^",
      "      field.hashCode ^",
      "      menuItemId.hashCode ^",
      "      context.hashCode;",
      "",
      "  /// Factory for JSON or Map-based creation (optional, for API or export use)",
      "  factory MenuItemSchemaIssue.fromMap(Map<String, dynamic> map) {",
      "    return MenuItemSchemaIssue(",
      "      type: MenuItemSchemaIssueType.values.firstWhere(",
      "          (e) => describeEnum(e) == map['type'],",
      "          orElse: () => MenuItemSchemaIssueType.ingredient),",
      "      missingReference: map['missingReference'] as String,",
      "      label: map['label'] as String?,",
      "      field: map['field'] as String,",
      "      menuItemId: map['menuItemId'] as String?,",
      "      context: map['context'] as String?,",
      "      severity: map['severity'] as String? ?? 'warning',",
      "      resolved: map['resolved'] as bool? ?? false,",
      "    );",
      "  }",
      "",
      "  Map<String, dynamic> toMap() {",
      "    return {",
      "      'type': typeKey,",
      "      'missingReference': missingReference,",
      "      'label': label,",
      "      'field': field,",
      "      'menuItemId': menuItemId,",
      "      'context': context,",
      "      'severity': severity,",
      "      'resolved': resolved,",
      "    };",
      "  }",
      "",
      "  // ---",
      "  // NOTE: Expand this method as your onboarding grows (e.g., customizations, advanced upcharges, etc.)",
      "  // ---",
      "  /// Detects all missing references for the given menu item and current schema state.",
      "  static List<MenuItemSchemaIssue> detectAllIssues({",
      "    required dynamic menuItem,",
      "    required List categories,",
      "    required List ingredients,",
      "    required List ingredientTypes,",
      "  }) {",
      "    final List<MenuItemSchemaIssue> issues = [];",
      "",
      "    // --- CATEGORY CHECK ---",
      "    final categoryId = menuItem.categoryId;",
      "    if (categoryId != null &&",
      "        categories.where((c) => c.id == categoryId).isEmpty) {",
      "      issues.add(MenuItemSchemaIssue(",
      "        type: MenuItemSchemaIssueType.category,",
      "        missingReference: categoryId,",
      "        label: menuItem.category,",
      "        field: 'categoryId',",
      "        menuItemId: menuItem.id,",
      "        severity: 'error',",
      "      ));",
      "    }",
      "",
      "    // --- INCLUDED INGREDIENTS CHECK ---",
      "    final included = menuItem.includedIngredients ?? [];",
      "    for (final i in included) {",
      "      final id = i['id'] ?? i['ingredientId'];",
      "      if (id == null || ingredients.where((ing) => ing.id == id).isEmpty) {",
      "        issues.add(MenuItemSchemaIssue(",
      "          type: MenuItemSchemaIssueType.ingredient,",
      "          missingReference: id?.toString() ?? '',",
      "          label: i['name'],",
      "          field: 'includedIngredients',",
      "          menuItemId: menuItem.id,",
      "          context: i['type'] != null ? 'Type: ${i['type']}' : null,",
      "          severity: 'error',",
      "        ));",
      "      } else {",
      "        // Ingredient type check",
      "        final ingredient = ingredients.firstWhereOrNull((ing) => ing.id == id);",
      "        final typeId = i['typeId'] ?? i['type'];",
      "        if (ingredient != null &&",
      "            typeId != null &&",
      "            ingredientTypes.where((t) => t.id == typeId).isEmpty) {",
      "          issues.add(MenuItemSchemaIssue(",
      "            type: MenuItemSchemaIssueType.ingredientType,",
      "            missingReference: typeId,",
      "            label: i['name'],",
      "            field: 'includedIngredients',",
      "            menuItemId: menuItem.id,",
      "            context: 'Ingredient: ${i['name']}',",
      "            severity: 'warning',",
      "          ));",
      "        }",
      "      }",
      "    }",
      "",
      "    // --- OPTIONAL ADDONS CHECK ---",
      "    final optionalAddOns = menuItem.optionalAddOns ?? [];",
      "    for (final o in optionalAddOns) {",
      "      final id = o['id'] ?? o['ingredientId'];",
      "      if (id == null || ingredients.where((ing) => ing.id == id).isEmpty) {",
      "        issues.add(MenuItemSchemaIssue(",
      "          type: MenuItemSchemaIssueType.ingredient,",
      "          missingReference: id?.toString() ?? '',",
      "          label: o['name'],",
      "          field: 'optionalAddOns',",
      "          menuItemId: menuItem.id,",
      "          context: o['type'] != null ? 'Type: ${o['type']}' : null,",
      "          severity: 'error',",
      "        ));",
      "      } else {",
      "        // Ingredient type check",
      "        final ingredient = ingredients.firstWhereOrNull((ing) => ing.id == id);",
      "        final typeId = o['typeId'] ?? o['type'];",
      "        if (ingredient != null &&",
      "            typeId != null &&",
      "            ingredientTypes.where((t) => t.id == typeId).isEmpty) {",
      "          issues.add(MenuItemSchemaIssue(",
      "            type: MenuItemSchemaIssueType.ingredientType,",
      "            missingReference: typeId,",
      "            label: o['name'],",
      "            field: 'optionalAddOns',",
      "            menuItemId: menuItem.id,",
      "            context: 'Ingredient: ${o['name']}',",
      "            severity: 'warning',",
      "          ));",
      "        }",
      "      }",
      "    }",
      "",
      "    // --- CUSTOMIZATION GROUPS CHECK (by ingredientIds) ---",
      "    // --- CUSTOMIZATION GROUPS CHECK ---",
      "    // Support both: list of ingredientIds, and list of options (objects with ingredientId)",
      "    final customizationGroups = menuItem.customizationGroups ?? [];",
      "    for (final group in customizationGroups) {",
      "      final groupLabel = group['label'] ?? '';",
      "      // IngredientIds as List<String>",
      "      final ingredientIds = group['ingredientIds'] as List?;",
      "      if (ingredientIds != null) {",
      "        for (final gid in ingredientIds) {",
      "          if (ingredients.where((ing) => ing.id == gid).isEmpty) {",
      "            issues.add(MenuItemSchemaIssue(",
      "              type: MenuItemSchemaIssueType.ingredient,",
      "              missingReference: gid.toString(),",
      "              field: 'customizationGroups',",
      "              menuItemId: menuItem.id,",
      "              context: 'Group: $groupLabel',",
      "              severity: 'error',",
      "            ));",
      "          }",
      "        }",
      "      }",
      "      // NEW: Check options array (recommended modern structure)",
      "      final options = group['options'] as List?;",
      "      if (options != null) {",
      "        for (final opt in options) {",
      "          final ingId = opt['ingredientId'];",
      "          if (ingId == null ||",
      "              ingredients.where((ing) => ing.id == ingId).isEmpty) {",
      "            issues.add(MenuItemSchemaIssue(",
      "              type: MenuItemSchemaIssueType.ingredient,",
      "              missingReference: ingId?.toString() ?? '',",
      "              field: 'customizationGroups.options',",
      "              menuItemId: menuItem.id,",
      "              context: 'Group: $groupLabel',",
      "              severity: 'error',",
      "            ));",
      "          }",
      "          // Optional: Type checks for group options",
      "          final typeId = opt['typeId'] ?? opt['type'];",
      "          if (typeId != null &&",
      "              ingredientTypes.where((t) => t.id == typeId).isEmpty) {",
      "            issues.add(MenuItemSchemaIssue(",
      "              type: MenuItemSchemaIssueType.ingredientType,",
      "              missingReference: typeId,",
      "              field: 'customizationGroups.options',",
      "              menuItemId: menuItem.id,",
      "              context: 'Group: $groupLabel',",
      "              severity: 'warning',",
      "            ));",
      "          }",
      "        }",
      "      }",
      "    }",
      "",
      "    // --- CORE FIELD CHECKS (name, price, category, etc.) ---",
      "    if (menuItem.name == null || menuItem.name.isEmpty) {",
      "      issues.add(MenuItemSchemaIssue(",
      "        type: MenuItemSchemaIssueType.missingField,",
      "        missingReference: '',",
      "        label: 'Name',",
      "        field: 'name',",
      "        menuItemId: menuItem.id,",
      "        severity: 'error',",
      "      ));",
      "    }",
      "    if (menuItem.categoryId == null || menuItem.categoryId.isEmpty) {",
      "      issues.add(MenuItemSchemaIssue(",
      "        type: MenuItemSchemaIssueType.missingField,",
      "        missingReference: '',",
      "        label: 'Category',",
      "        field: 'categoryId',",
      "        menuItemId: menuItem.id,",
      "        severity: 'error',",
      "      ));",
      "    }",
      "    if (menuItem.price == null || menuItem.price == 0.0) {",
      "      issues.add(MenuItemSchemaIssue(",
      "        type: MenuItemSchemaIssueType.missingField,",
      "        missingReference: '',",
      "        label: 'Price',",
      "        field: 'price',",
      "        menuItemId: menuItem.id,",
      "        severity: 'error',",
      "      ));",
      "    }",
      "// Add more as needed (e.g., description, image, etc.)",
      "",
      "    // --- MORE CHECKS CAN GO HERE (future: templateRefs, etc.) ---",
      "",
      "    return issues;",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 322,
      "file_size": 11618,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\models\\menu_template_ref.dart",
    "content": [
      "class MenuTemplateRef {",
      "  final String id;",
      "  final String name;",
      "  // Add other fields as needed (e.g., preview, description)",
      "",
      "  MenuTemplateRef({required this.id, required this.name});",
      "",
      "  factory MenuTemplateRef.fromFirestore(Map<String, dynamic> data) {",
      "    return MenuTemplateRef(",
      "      id: data['id'] ?? '',",
      "      name: data['name'] ?? '',",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 14,
      "file_size": 370,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\models\\message.dart",
    "content": [
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "",
      "class Message {",
      "  final String id;",
      "  final String senderId;",
      "  final String content;",
      "  final DateTime timestamp;",
      "  final String status;",
      "",
      "  Message({",
      "    required this.id,",
      "    required this.senderId,",
      "    required this.content,",
      "    required this.timestamp,",
      "    required this.status,",
      "  });",
      "",
      "  /// Serialization for Firestore",
      "  Map<String, dynamic> toFirestore() => {",
      "        'senderId': senderId,",
      "        'content': content,",
      "        'timestamp': Timestamp.fromDate(timestamp),",
      "        'status': status,",
      "      };",
      "",
      "  /// Deserialization from Firestore (requires document ID)",
      "  static Message fromFirestore(Map<String, dynamic> data, String id) {",
      "    return Message(",
      "      id: id,",
      "      senderId: data['senderId'] ?? '',",
      "      content: data['content'] ?? '',",
      "      timestamp: (data['timestamp'] is Timestamp)",
      "          ? (data['timestamp'] as Timestamp).toDate()",
      "          : DateTime.now(),",
      "      status: data['status'] ?? '',",
      "    );",
      "  }",
      "",
      "  /// For local caching or general Dart usage (same as Firestore serialization)",
      "  Map<String, dynamic> toMap() => toFirestore();",
      "",
      "  /// Factory for deserialization if you have both the data map and ID",
      "  factory Message.fromMap(Map<String, dynamic> data, String id) =>",
      "      Message.fromFirestore(data, id);",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 45,
      "file_size": 1342,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\models\\model_utils.dart",
    "content": [
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "import '../models/customization.dart';",
      "import '../models/nutrition_info.dart';",
      "",
      "/// =======================",
      "/// ModelUtils",
      "/// =======================",
      "/// - Robust, defensive parsing and safe conversion for all models.",
      "/// - Use everywhere for (de)serialization of Firestore, SQLite, API, and user input.",
      "/// =======================",
      "",
      "// Safe list parser (with converter)",
      "List<T> safeList<T>(dynamic raw, T Function(dynamic) convert) {",
      "  if (raw is List) return raw.map<T>(convert).toList();",
      "  return <T>[];",
      "}",
      "",
      "// Safe CSV to List<String>",
      "List<String> splitCsv(dynamic csv) {",
      "  if (csv == null) return <String>[];",
      "  if (csv is String) {",
      "    return csv",
      "        .split(',')",
      "        .map((e) => e.trim())",
      "        .where((e) => e.isNotEmpty)",
      "        .toList();",
      "  }",
      "  if (csv is List) return csv.map((e) => e.toString()).toList();",
      "  return <String>[];",
      "}",
      "",
      "// Join List<String> to CSV",
      "String joinCsv(List<String> items) => items.join(',');",
      "",
      "// Defensive Map cast",
      "Map<String, dynamic> safeMap(dynamic data) {",
      "  if (data is Map<String, dynamic>) return data;",
      "  if (data is Map) return Map<String, dynamic>.from(data);",
      "  return <String, dynamic>{};",
      "}",
      "",
      "// Date/time conversion",
      "DateTime? safeDate(dynamic value) {",
      "  if (value == null) return null;",
      "  if (value is DateTime) return value;",
      "  if (value is int) return DateTime.fromMillisecondsSinceEpoch(value);",
      "  if (value is String) return DateTime.tryParse(value);",
      "  if (value is Timestamp) return value.toDate();",
      "  return null;",
      "}",
      "",
      "DateTime safeDateOrNow(dynamic value) => safeDate(value) ?? DateTime.now();",
      "",
      "// Numeric conversions",
      "double safeDouble(dynamic value, [double defaultValue = 0.0]) {",
      "  if (value is double) return value;",
      "  if (value is int) return value.toDouble();",
      "  if (value is String) return double.tryParse(value) ?? defaultValue;",
      "  return defaultValue;",
      "}",
      "",
      "int safeInt(dynamic value, [int defaultValue = 0]) {",
      "  if (value is int) return value;",
      "  if (value is double) return value.toInt();",
      "  if (value is String) return int.tryParse(value) ?? defaultValue;",
      "  return defaultValue;",
      "}",
      "",
      "// Bool conversion",
      "bool safeBool(dynamic value) {",
      "  if (value is bool) return value;",
      "  if (value is int) return value != 0;",
      "  if (value is String) return value.toLowerCase() == 'true';",
      "  return false;",
      "}",
      "",
      "// Price formatting",
      "String formatPrice(num price) => '\\$${price.toStringAsFixed(2)}';",
      "",
      "// Defensive image field",
      "String? safeImage(dynamic value) {",
      "  if (value == null) return null;",
      "  final s = value.toString().trim();",
      "  return s.isEmpty ? null : s;",
      "}",
      "",
      "// ==== CUSTOM MENU MODEL HELPERS ====",
      "",
      "// Defensive parse for List<Customization>",
      "List<Customization> parseCustomizations(dynamic raw) {",
      "  if (raw == null) return [];",
      "  if (raw is List) {",
      "    return raw.map((e) => Customization.fromFirestore(safeMap(e))).toList();",
      "  }",
      "  // New system: all customizations should be structured as List, not String/legacy!",
      "  return [];",
      "}",
      "",
      "// Defensive parse for NutritionInfo",
      "NutritionInfo? parseNutrition(dynamic raw) {",
      "  if (raw == null) return null;",
      "  return NutritionInfo.fromFirestore(safeMap(raw));",
      "}",
      "",
      "// ==== ADVANCED: Customization group flatten, deep search, included ingredient helpers ====",
      "",
      "// Flatten all selectable customizations from groups (used for \"included ingredients\")",
      "List<Customization> flattenCustomizations(List<Customization> groups) {",
      "  List<Customization> flat = [];",
      "  for (final group in groups) {",
      "    if (group.isGroup && group.options != null) {",
      "      flat.addAll(flattenCustomizations(group.options!));",
      "    } else if (!group.isGroup) {",
      "      flat.add(group);",
      "    }",
      "  }",
      "  return flat;",
      "}",
      "",
      "/// Find a Customization option by id",
      "Customization? findCustomizationById(List<Customization> groups, String id) {",
      "  for (final group in groups) {",
      "    if (group.id == id) return group;",
      "    if (group.options != null) {",
      "      final found = findCustomizationById(group.options!, id);",
      "      if (found != null) return found;",
      "    }",
      "  }",
      "  return null;",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 130,
      "file_size": 4074,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\models\\nutrition_info.dart",
    "content": [
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "",
      "/// Nutritional information for a menu item",
      "class NutritionInfo {",
      "  final int calories; // Total calories",
      "  final double fat; // Total fat (grams)",
      "  final double carbs; // Total carbohydrates (grams)",
      "  final double protein; // Total protein (grams)",
      "  final double? fiber; // Dietary fiber (grams, optional)",
      "  final double? sugar; // Sugar (grams, optional)",
      "  final double? sodium; // Sodium (mg, optional)",
      "  final double? cholesterol; // Cholesterol (mg, optional)",
      "  final String? servingSize; // e.g., \"1 slice (100g)\"",
      "  Map<String, dynamic> toJson() => toFirestore();",
      "",
      "  NutritionInfo({",
      "    this.calories = 0,",
      "    this.fat = 0.0,",
      "    this.carbs = 0.0,",
      "    this.protein = 0.0,",
      "    this.fiber,",
      "    this.sugar,",
      "    this.sodium,",
      "    this.cholesterol,",
      "    this.servingSize,",
      "  });",
      "",
      "  // From Firestore/Map",
      "  factory NutritionInfo.fromFirestore(Map<String, dynamic> data) {",
      "    return NutritionInfo(",
      "      calories: data['calories'] ?? 0,",
      "      fat: (data['fat'] ?? 0.0).toDouble(),",
      "      carbs: (data['carbs'] ?? 0.0).toDouble(),",
      "      protein: (data['protein'] ?? 0.0).toDouble(),",
      "      fiber: data['fiber'] != null ? (data['fiber'] as num).toDouble() : null,",
      "      sugar: data['sugar'] != null ? (data['sugar'] as num).toDouble() : null,",
      "      sodium:",
      "          data['sodium'] != null ? (data['sodium'] as num).toDouble() : null,",
      "      cholesterol: data['cholesterol'] != null",
      "          ? (data['cholesterol'] as num).toDouble()",
      "          : null,",
      "      servingSize: data['servingSize'],",
      "    );",
      "  }",
      "",
      "  // To Firestore (for saving)",
      "  Map<String, dynamic> toFirestore() {",
      "    return {",
      "      'calories': calories,",
      "      'fat': fat,",
      "      'carbs': carbs,",
      "      'protein': protein,",
      "      if (fiber != null) 'fiber': fiber,",
      "      if (sugar != null) 'sugar': sugar,",
      "      if (sodium != null) 'sodium': sodium,",
      "      if (cholesterol != null) 'cholesterol': cholesterol,",
      "      if (servingSize != null) 'servingSize': servingSize,",
      "    };",
      "  }",
      "",
      "  /// Alias for export/admin tools.",
      "  Map<String, dynamic> toMap() => toFirestore();",
      "",
      "  // For copyWith pattern (editing)",
      "  NutritionInfo copyWith({",
      "    int? calories,",
      "    double? fat,",
      "    double? carbs,",
      "    double? protein,",
      "    double? fiber,",
      "    double? sugar,",
      "    double? sodium,",
      "    double? cholesterol,",
      "    String? servingSize,",
      "  }) {",
      "    return NutritionInfo(",
      "      calories: calories ?? this.calories,",
      "      fat: fat ?? this.fat,",
      "      carbs: carbs ?? this.carbs,",
      "      protein: protein ?? this.protein,",
      "      fiber: fiber ?? this.fiber,",
      "      sugar: sugar ?? this.sugar,",
      "      sodium: sodium ?? this.sodium,",
      "      cholesterol: cholesterol ?? this.cholesterol,",
      "      servingSize: servingSize ?? this.servingSize,",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 88,
      "file_size": 2807,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\models\\onboarding_validation_issue.dart",
    "content": [
      "// File: lib/core/models/onboarding_validation_issue.dart",
      "",
      "import 'package:flutter/material.dart';",
      "",
      "/// Represents a single validation issue found during onboarding review.",
      "/// Used by all onboarding providers (ingredient types, ingredients, categories, menu items, etc.)",
      "/// and surfaced in the review/publish screen.",
      "class OnboardingValidationIssue {",
      "  /// The onboarding section or domain where this issue was found.",
      "  /// Example values: 'Features', 'Ingredient Types', 'Ingredients', 'Categories', 'Menu Items'",
      "  final String section;",
      "",
      "  /// The unique ID of the affected item, if applicable (ingredientId, typeId, categoryId, menuItemId, etc).",
      "  /// Empty if the issue is at the section or global level.",
      "  final String itemId;",
      "",
      "  /// Human-friendly display name for the affected item (e.g. 'Mozzarella Cheese', 'Deluxe Pizza').",
      "  /// Used for error details and UI highlighting.",
      "  final String itemDisplayName;",
      "",
      "  /// The criticality/severity of the issue:",
      "  /// 'critical' = blocks publish, 'warning' = advisory but not blocking, 'info' = for completeness.",
      "  final OnboardingIssueSeverity severity;",
      "",
      "  /// A unique error/warning code for analytics or programmatic handling (e.g., 'MISSING_TYPE', 'DUPLICATE_NAME').",
      "  final String code;",
      "",
      "  /// Human-readable, localized message explaining the problem.",
      "  /// Example: \"Ingredient 'Mozzarella Cheese' has no assigned type.\"",
      "  final String message;",
      "",
      "  /// Which field(s) are missing/invalid (e.g. 'type', 'sizePrices').",
      "  /// Used for auto-focus or deep linking in forms.",
      "  final List<String> affectedFields;",
      "",
      "  /// If true, this issue must be resolved before allowing publish.",
      "  final bool isBlocking;",
      "",
      "  /// The route or onboarding step key this issue is associated with (for navigation).",
      "  /// Example: '/onboarding/ingredients', '/onboarding/menu_items'",
      "  final String fixRoute;",
      "",
      "  /// (Optional) The index, list position, or deep reference to auto-scroll/highlight in the UI.",
      "  /// Example: row index, group name, or JSON path.",
      "  final String? itemLocator;",
      "",
      "  /// Localized tooltip or guidance for how to resolve the issue (can be empty).",
      "  final String? resolutionHint;",
      "",
      "  /// Optional quick-fix action label, e.g. 'Fix Now', 'Auto-Assign', 'Go to Step'.",
      "  final String? actionLabel;",
      "",
      "  /// Optional icon to represent the issue type (for UI/status table).",
      "  final IconData? icon;",
      "",
      "  /// Optional time the issue was detected (useful for audit trail/history).",
      "  final DateTime? detectedAt;",
      "",
      "  /// Optionally, extra context for debugging/logging (raw object, Firestore path, etc).",
      "  final Map<String, dynamic>? contextData;",
      "",
      "  /// (Optional) Whether the issue was auto-fixed or acknowledged (for warning/info issues).",
      "  final bool acknowledged;",
      "",
      "  // Constructor",
      "  const OnboardingValidationIssue({",
      "    required this.section,",
      "    required this.itemId,",
      "    required this.itemDisplayName,",
      "    required this.severity,",
      "    required this.code,",
      "    required this.message,",
      "    required this.affectedFields,",
      "    required this.isBlocking,",
      "    required this.fixRoute,",
      "    this.itemLocator,",
      "    this.resolutionHint,",
      "    this.actionLabel,",
      "    this.icon,",
      "    this.detectedAt,",
      "    this.contextData,",
      "    this.acknowledged = false,",
      "  });",
      "}",
      "",
      "/// Enum for strict typing of issue severity.",
      "/// All logic and UI should respect these tiers.",
      "enum OnboardingIssueSeverity {",
      "  critical, // blocks publish",
      "  warning, // shown, but doesn't block publish",
      "  info, // surfaced for user awareness only",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 92,
      "file_size": 3521,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\models\\order.dart",
    "content": [
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "import 'address.dart';",
      "",
      "class Order {",
      "  final String id;",
      "  final String userId;",
      "  final String storeId;",
      "  final List<OrderItem> items;",
      "  final double subtotal;",
      "  final double tax;",
      "  final double deliveryFee;",
      "  final double discount;",
      "  final double total;",
      "  final String deliveryType;",
      "  final String time;",
      "  final String status;",
      "  final DateTime timestamp;",
      "  final int estimatedTime;",
      "  final Map<String, dynamic> timestamps;",
      "  final Address? address;",
      "  final String? userName;",
      "  final String? refundStatus;",
      "  final Address? deliveryAddress;",
      "  final String? specialInstructions;",
      "",
      "  bool get isFeedbackEligible =>",
      "      status.toLowerCase() == 'completed' ||",
      "      status.toLowerCase() == 'placed' ||",
      "      status.toLowerCase() == 'delivered';",
      "",
      "  Order({",
      "    required this.id,",
      "    required this.userId,",
      "    required this.storeId,",
      "    required this.items,",
      "    required this.subtotal,",
      "    required this.tax,",
      "    required this.deliveryFee,",
      "    required this.discount,",
      "    required this.total,",
      "    required this.deliveryType,",
      "    required this.time,",
      "    required this.status,",
      "    required this.timestamp,",
      "    required this.estimatedTime,",
      "    required this.timestamps,",
      "    this.address,",
      "    this.userName,",
      "    this.refundStatus,",
      "    this.deliveryAddress,",
      "    this.specialInstructions,",
      "  });",
      "",
      "  factory Order.fromFirestore(Map<String, dynamic> data, String id) {",
      "    return Order(",
      "      id: id,",
      "      userId: data['userId'] ?? '',",
      "      items: (data['items'] as List<dynamic>?)",
      "              ?.map((item) => OrderItem.fromMap(item as Map<String, dynamic>))",
      "              .toList() ??",
      "          [],",
      "      subtotal: (data['subtotal'] as num?)?.toDouble() ?? 0.0,",
      "      tax: (data['tax'] as num?)?.toDouble() ?? 0.0,",
      "      deliveryFee: (data['deliveryFee'] as num?)?.toDouble() ?? 0.0,",
      "      discount: (data['discount'] as num?)?.toDouble() ?? 0.0,",
      "      total: (data['total'] as num?)?.toDouble() ?? 0.0,",
      "      deliveryType: data['deliveryType'] ?? '',",
      "      time: data['time'] ?? '',",
      "      status: data['status'] ?? '',",
      "      timestamp: data['timestamp'] is Timestamp",
      "          ? (data['timestamp'] as Timestamp).toDate()",
      "          : (data['timestamp'] as DateTime?) ?? DateTime.now(),",
      "      estimatedTime: data['estimatedTime'] as int? ?? 0,",
      "      timestamps: Map<String, dynamic>.from(data['timestamps'] as Map? ?? {}),",
      "      address: data['address'] != null",
      "          ? Address.fromMap(Map<String, dynamic>.from(data['address']))",
      "          : null,",
      "      userName: data['userName'],",
      "      refundStatus: data['refundStatus'],",
      "      deliveryAddress: data['deliveryAddress'] != null",
      "          ? Address.fromMap(Map<String, dynamic>.from(data['deliveryAddress']))",
      "          : null,",
      "      specialInstructions: data['specialInstructions'],",
      "      storeId: data['storeId'] ?? '',",
      "    );",
      "  }",
      "",
      "  Map<String, dynamic> toFirestore() {",
      "    return {",
      "      'userId': userId,",
      "      'storeId': storeId,",
      "      'items': items.map((item) => item.toMap()).toList(),",
      "      'subtotal': subtotal,",
      "      'tax': tax,",
      "      'deliveryFee': deliveryFee,",
      "      'discount': discount,",
      "      'total': total,",
      "      'deliveryType': deliveryType,",
      "      'time': time,",
      "      'status': status,",
      "      'timestamp': Timestamp.fromDate(timestamp),",
      "      'estimatedTime': estimatedTime,",
      "      'timestamps': timestamps,",
      "      'address': address?.toMap(),",
      "      'userName': userName,",
      "      'refundStatus': refundStatus,",
      "      'deliveryAddress': deliveryAddress?.toMap(),",
      "      'specialInstructions': specialInstructions,",
      "    };",
      "  }",
      "",
      "  Order copyWith({",
      "    String? id,",
      "    String? userId,",
      "    String? storeId,",
      "    List<OrderItem>? items,",
      "    double? subtotal,",
      "    double? tax,",
      "    double? deliveryFee,",
      "    double? discount,",
      "    double? total,",
      "    String? deliveryType,",
      "    String? time,",
      "    String? status,",
      "    DateTime? timestamp,",
      "    int? estimatedTime,",
      "    Map<String, dynamic>? timestamps,",
      "    Address? address,",
      "    String? userName,",
      "    String? refundStatus,",
      "    Address? deliveryAddress,",
      "    String? specialInstructions,",
      "  }) {",
      "    return Order(",
      "      id: id ?? this.id,",
      "      userId: userId ?? this.userId,",
      "      storeId: storeId ?? this.storeId,",
      "      items: items ?? this.items,",
      "      subtotal: subtotal ?? this.subtotal,",
      "      tax: tax ?? this.tax,",
      "      deliveryFee: deliveryFee ?? this.deliveryFee,",
      "      discount: discount ?? this.discount,",
      "      total: total ?? this.total,",
      "      deliveryType: deliveryType ?? this.deliveryType,",
      "      time: time ?? this.time,",
      "      status: status ?? this.status,",
      "      timestamp: timestamp ?? this.timestamp,",
      "      estimatedTime: estimatedTime ?? this.estimatedTime,",
      "      timestamps: timestamps ?? this.timestamps,",
      "      address: address ?? this.address,",
      "      userName: userName ?? this.userName,",
      "      refundStatus: refundStatus ?? this.refundStatus,",
      "      deliveryAddress: deliveryAddress ?? this.deliveryAddress,",
      "      specialInstructions: specialInstructions ?? this.specialInstructions,",
      "    );",
      "  }",
      "",
      "  String get userNameDisplay =>",
      "      userName ?? (address?.name?.isNotEmpty == true ? address!.name! : userId);",
      "",
      "  String get refundStatusDisplay => refundStatus ?? '';",
      "}",
      "",
      "class OrderItem {",
      "  final String menuItemId;",
      "  final String name;",
      "  final double price;",
      "  final int quantity;",
      "  final Map<String, dynamic> customizations;",
      "  final String? image;",
      "  final String? size;",
      "  final String? cartItemKey;",
      "  final double? deliveryFee;",
      "  final double? discount;",
      "  final String? deliveryType;",
      "  final String? time;",
      "  final DateTime? timestamp;",
      "  final int? estimatedTime;",
      "  final Address? deliveryAddress;",
      "  final String? specialInstructions;",
      "",
      "  OrderItem({",
      "    required this.menuItemId,",
      "    required this.name,",
      "    required this.price,",
      "    required this.quantity,",
      "    required this.customizations,",
      "    this.image,",
      "    this.size,",
      "    this.cartItemKey,",
      "    this.deliveryFee,",
      "    this.discount,",
      "    this.deliveryType,",
      "    this.time,",
      "    this.timestamp,",
      "    this.estimatedTime,",
      "    this.deliveryAddress,",
      "    this.specialInstructions,",
      "  });",
      "",
      "  factory OrderItem.fromMap(Map<String, dynamic> data) {",
      "    return OrderItem(",
      "      menuItemId: data['menuItemId'] ?? '',",
      "      name: data['name'] ?? '',",
      "      price: (data['price'] as num?)?.toDouble() ?? 0.0,",
      "      quantity: data['quantity'] ?? 1,",
      "      customizations: data['customizations'] != null",
      "          ? Map<String, dynamic>.from(data['customizations'])",
      "          : {},",
      "      image: data['image'],",
      "      size: data['size'],",
      "      cartItemKey: data['cartItemKey'],",
      "      deliveryFee: (data['deliveryFee'] as num?)?.toDouble(),",
      "      discount: (data['discount'] as num?)?.toDouble(),",
      "      deliveryType: data['deliveryType'],",
      "      time: data['time'],",
      "      timestamp: data['timestamp'] is Timestamp",
      "          ? (data['timestamp'] as Timestamp).toDate()",
      "          : data['timestamp'] as DateTime?,",
      "      estimatedTime: data['estimatedTime'],",
      "      deliveryAddress: data['deliveryAddress'] != null",
      "          ? Address.fromMap(Map<String, dynamic>.from(data['deliveryAddress']))",
      "          : null,",
      "      specialInstructions: data['specialInstructions'],",
      "    );",
      "  }",
      "",
      "  Map<String, dynamic> toMap() {",
      "    return {",
      "      'menuItemId': menuItemId,",
      "      'name': name,",
      "      'price': price,",
      "      'quantity': quantity,",
      "      'customizations': customizations,",
      "      if (image != null) 'image': image,",
      "      if (size != null) 'size': size,",
      "      if (cartItemKey != null) 'cartItemKey': cartItemKey,",
      "      if (deliveryFee != null) 'deliveryFee': deliveryFee,",
      "      if (discount != null) 'discount': discount,",
      "      if (deliveryType != null) 'deliveryType': deliveryType,",
      "      if (time != null) 'time': time,",
      "      if (timestamp != null) 'timestamp': Timestamp.fromDate(timestamp!),",
      "      if (estimatedTime != null) 'estimatedTime': estimatedTime,",
      "      if (deliveryAddress != null) 'deliveryAddress': deliveryAddress!.toMap(),",
      "      if (specialInstructions != null)",
      "        'specialInstructions': specialInstructions,",
      "    };",
      "  }",
      "",
      "  OrderItem copyWith({",
      "    String? menuItemId,",
      "    String? name,",
      "    double? price,",
      "    int? quantity,",
      "    Map<String, dynamic>? customizations,",
      "    String? image,",
      "    String? size,",
      "    String? cartItemKey,",
      "    double? deliveryFee,",
      "    double? discount,",
      "    String? deliveryType,",
      "    String? time,",
      "    DateTime? timestamp,",
      "    int? estimatedTime,",
      "    Address? deliveryAddress,",
      "    String? specialInstructions,",
      "  }) {",
      "    return OrderItem(",
      "      menuItemId: menuItemId ?? this.menuItemId,",
      "      name: name ?? this.name,",
      "      price: price ?? this.price,",
      "      quantity: quantity ?? this.quantity,",
      "      customizations: customizations ?? this.customizations,",
      "      image: image ?? this.image,",
      "      size: size ?? this.size,",
      "      cartItemKey: cartItemKey ?? this.cartItemKey,",
      "      deliveryFee: deliveryFee ?? this.deliveryFee,",
      "      discount: discount ?? this.discount,",
      "      deliveryType: deliveryType ?? this.deliveryType,",
      "      time: time ?? this.time,",
      "      timestamp: timestamp ?? this.timestamp,",
      "      estimatedTime: estimatedTime ?? this.estimatedTime,",
      "      deliveryAddress: deliveryAddress ?? this.deliveryAddress,",
      "      specialInstructions: specialInstructions ?? this.specialInstructions,",
      "    );",
      "  }",
      "",
      "  double get totalPrice => price * quantity;",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 289,
      "file_size": 9463,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\models\\payout.dart",
    "content": [
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "",
      "class Payout {",
      "  final String id;",
      "  final DocumentReference franchiseRef;",
      "  final DocumentReference locationRef;",
      "  final DocumentReference bankAccountRef;",
      "  final double amount;",
      "  final String currency;",
      "  final String status; // pending, sent, failed, on_hold",
      "  final String method;",
      "  final String? bankAccountLast4;",
      "  final String? notes;",
      "  final DateTime? scheduledAt;",
      "  final DateTime? sentAt;",
      "  final DateTime? failedAt;",
      "  final DateTime? confirmedAt;",
      "  final DateTime? createdAt;",
      "  final String? failureReason;",
      "  final String? errorCode;",
      "  final String? errorMessage;",
      "  final List<Map<String, dynamic>> attachments;",
      "  final List<Map<String, dynamic>> auditTrail;",
      "  final Map<String, dynamic> customFields;",
      "",
      "  Payout({",
      "    required this.id,",
      "    required this.franchiseRef,",
      "    required this.locationRef,",
      "    required this.bankAccountRef,",
      "    required this.amount,",
      "    required this.currency,",
      "    required this.status,",
      "    required this.method,",
      "    this.bankAccountLast4,",
      "    this.notes,",
      "    this.scheduledAt,",
      "    this.sentAt,",
      "    this.failedAt,",
      "    this.confirmedAt,",
      "    this.createdAt,",
      "    this.failureReason,",
      "    this.errorCode,",
      "    this.errorMessage,",
      "    this.attachments = const [],",
      "    this.auditTrail = const [],",
      "    this.customFields = const {},",
      "  });",
      "",
      "  factory Payout.fromFirestore(Map<String, dynamic> data, String id) {",
      "    return Payout(",
      "      id: id,",
      "      franchiseRef: data['franchiseId'] as DocumentReference,",
      "      locationRef: data['locationId'] as DocumentReference,",
      "      bankAccountRef: data['bank_account_id'] as DocumentReference,",
      "      amount: (data['amount'] as num?)?.toDouble() ?? 0.0,",
      "      currency: data['currency'] ?? '',",
      "      status: data['status'] ?? '',",
      "      method: data['method'] ?? '',",
      "      bankAccountLast4: data['bank_account_last4'],",
      "      notes: data['notes'],",
      "      scheduledAt: (data['scheduled_at'] as Timestamp?)?.toDate(),",
      "      sentAt: (data['sent_at'] as Timestamp?)?.toDate(),",
      "      failedAt: (data['failed_at'] as Timestamp?)?.toDate(),",
      "      confirmedAt: (data['confirmed_at'] as Timestamp?)?.toDate(),",
      "      createdAt: (data['created_at'] as Timestamp?)?.toDate(),",
      "      failureReason: data['failure_reason'] ?? data['error_message'],",
      "      errorCode: data['error_code'],",
      "      errorMessage: data['error_message'],",
      "      attachments: (data['attachments'] as List?)",
      "              ?.map((e) => Map<String, dynamic>.from(e as Map))",
      "              .toList() ??",
      "          const [],",
      "      auditTrail: (data['audit_trail'] as List?)",
      "              ?.map((e) => Map<String, dynamic>.from(e as Map))",
      "              .toList() ??",
      "          const [],",
      "      customFields: data['custom_fields'] ?? {},",
      "    );",
      "  }",
      "",
      "  Map<String, dynamic> toFirestore() {",
      "    return {",
      "      'franchiseId': franchiseRef,",
      "      'locationId': locationRef,",
      "      'bank_account_id': bankAccountRef,",
      "      'amount': amount,",
      "      'currency': currency,",
      "      'status': status,",
      "      'method': method,",
      "      'bank_account_last4': bankAccountLast4,",
      "      'notes': notes,",
      "      'scheduled_at':",
      "          scheduledAt != null ? Timestamp.fromDate(scheduledAt!) : null,",
      "      'sent_at': sentAt != null ? Timestamp.fromDate(sentAt!) : null,",
      "      'failed_at': failedAt != null ? Timestamp.fromDate(failedAt!) : null,",
      "      'confirmed_at':",
      "          confirmedAt != null ? Timestamp.fromDate(confirmedAt!) : null,",
      "      'created_at': createdAt != null ? Timestamp.fromDate(createdAt!) : null,",
      "      'failure_reason': failureReason,",
      "      'error_code': errorCode,",
      "      'error_message': errorMessage,",
      "      'attachments': attachments,",
      "      'audit_trail': auditTrail,",
      "      'custom_fields': customFields,",
      "    };",
      "  }",
      "",
      "  Payout copyWith({",
      "    String? id,",
      "    DocumentReference? franchiseRef,",
      "    DocumentReference? locationRef,",
      "    DocumentReference? bankAccountRef,",
      "    double? amount,",
      "    String? currency,",
      "    String? status,",
      "    String? method,",
      "    String? bankAccountLast4,",
      "    String? notes,",
      "    DateTime? scheduledAt,",
      "    DateTime? sentAt,",
      "    DateTime? failedAt,",
      "    DateTime? confirmedAt,",
      "    DateTime? createdAt,",
      "    String? failureReason,",
      "    String? errorCode,",
      "    String? errorMessage,",
      "    List<Map<String, dynamic>>? attachments,",
      "    List<Map<String, dynamic>>? auditTrail,",
      "    Map<String, dynamic>? customFields,",
      "  }) {",
      "    return Payout(",
      "      id: id ?? this.id,",
      "      franchiseRef: franchiseRef ?? this.franchiseRef,",
      "      locationRef: locationRef ?? this.locationRef,",
      "      bankAccountRef: bankAccountRef ?? this.bankAccountRef,",
      "      amount: amount ?? this.amount,",
      "      currency: currency ?? this.currency,",
      "      status: status ?? this.status,",
      "      method: method ?? this.method,",
      "      bankAccountLast4: bankAccountLast4 ?? this.bankAccountLast4,",
      "      notes: notes ?? this.notes,",
      "      scheduledAt: scheduledAt ?? this.scheduledAt,",
      "      sentAt: sentAt ?? this.sentAt,",
      "      failedAt: failedAt ?? this.failedAt,",
      "      confirmedAt: confirmedAt ?? this.confirmedAt,",
      "      createdAt: createdAt ?? this.createdAt,",
      "      failureReason: failureReason ?? this.failureReason,",
      "      errorCode: errorCode ?? this.errorCode,",
      "      errorMessage: errorMessage ?? this.errorMessage,",
      "      attachments: attachments ?? this.attachments,",
      "      auditTrail: auditTrail ?? this.auditTrail,",
      "      customFields: customFields ?? this.customFields,",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 156,
      "file_size": 5476,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\models\\payout_filter.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "",
      "/// A model representing filters and search for the payouts table.",
      "/// Integrates with FirestoreService's getPayoutsForFranchise().",
      "/// Suitable for use with Provider or other state management.",
      "class PayoutFilter {",
      "  /// Text entered into the general search box.",
      "  final String searchQuery;",
      "",
      "  /// Status filter: 'all', 'pending', 'sent', 'failed'",
      "  final String status;",
      "",
      "  /// Additional fields (future extensible: date range, method, amount, etc.)",
      "  // final DateTimeRange? dateRange;",
      "  // final String? payoutMethod;",
      "",
      "  const PayoutFilter({",
      "    this.searchQuery = '',",
      "    this.status = 'all',",
      "    // this.dateRange,",
      "    // this.payoutMethod,",
      "  });",
      "",
      "  /// Returns a copy with new values",
      "  PayoutFilter copyWith({",
      "    String? searchQuery,",
      "    String? status,",
      "    // DateTimeRange? dateRange,",
      "    // String? payoutMethod,",
      "  }) {",
      "    return PayoutFilter(",
      "      searchQuery: searchQuery ?? this.searchQuery,",
      "      status: status ?? this.status,",
      "      // dateRange: dateRange ?? this.dateRange,",
      "      // payoutMethod: payoutMethod ?? this.payoutMethod,",
      "    );",
      "  }",
      "",
      "  /// Converts to a Firestore query map for backend search",
      "  Map<String, dynamic> toQueryMap() {",
      "    final map = <String, dynamic>{};",
      "    if (status != 'all') map['status'] = status;",
      "    if (searchQuery.trim().isNotEmpty) map['search'] = searchQuery.trim();",
      "    // if (dateRange != null) {",
      "    //   map['startDate'] = dateRange!.start.toIso8601String();",
      "    //   map['endDate'] = dateRange!.end.toIso8601String();",
      "    // }",
      "    // if (payoutMethod != null) map['method'] = payoutMethod;",
      "    return map;",
      "  }",
      "",
      "  /// Returns the status label for UI (localized)",
      "  /// Returns the status label for UI (localized)",
      "  String statusLabel(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[PayoutFilter] loc is null! Localization not available for this context.');",
      "      // Fallback to status code itself or English string",
      "      switch (status) {",
      "        case 'pending':",
      "          return 'Pending';",
      "        case 'sent':",
      "          return 'Sent';",
      "        case 'failed':",
      "          return 'Failed';",
      "        case 'all':",
      "        default:",
      "          return 'All';",
      "      }",
      "    }",
      "    switch (status) {",
      "      case 'pending':",
      "        return loc.pending;",
      "      case 'sent':",
      "        return loc.sent;",
      "      case 'failed':",
      "        return loc.failed;",
      "      case 'all':",
      "      default:",
      "        return loc.all ?? 'All';",
      "    }",
      "  }",
      "",
      "  /// Returns the list of filter status dropdown items (localized)",
      "  static List<DropdownMenuItem<String>> statusDropdownItems(",
      "      BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[PayoutFilter] loc is null! Localization not available for this context.');",
      "      // Fallback to English",
      "      return [",
      "        DropdownMenuItem(value: 'all', child: Text('All')),",
      "        DropdownMenuItem(value: 'pending', child: Text('Pending')),",
      "        DropdownMenuItem(value: 'sent', child: Text('Sent')),",
      "        DropdownMenuItem(value: 'failed', child: Text('Failed')),",
      "      ];",
      "    }",
      "    return [",
      "      DropdownMenuItem(value: 'all', child: Text(loc.all ?? 'All')),",
      "      DropdownMenuItem(value: 'pending', child: Text(loc.pending)),",
      "      DropdownMenuItem(value: 'sent', child: Text(loc.sent)),",
      "      DropdownMenuItem(value: 'failed', child: Text(loc.failed)),",
      "    ];",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 108,
      "file_size": 3573,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\models\\platform_financial_kpis.dart",
    "content": [
      "// File: lib/core/models/platform_financial_kpis.dart",
      "",
      "import 'package:flutter/foundation.dart';",
      "",
      "/// Model representing platform-wide SaaS financial KPIs for the platform owner dashboard.",
      "/// Easily extendable for new metrics. Immutable for robust state management.",
      "@immutable",
      "class PlatformFinancialKpis {",
      "  /// Monthly Recurring Revenue (from current month's subscription invoices)",
      "  final double mrr;",
      "",
      "  /// Annual Recurring Revenue (MRR * 12)",
      "  final double arr;",
      "",
      "  /// Count of unique active franchises (franchises invoiced this month)",
      "  final int activeFranchises;",
      "",
      "  /// Total value of payouts issued platform-wide in last 30 days",
      "  final double recentPayouts;",
      "",
      "  // 💡 Future Feature Placeholders:",
      "  // final double churnRate;",
      "  // final double arpu;",
      "  // final int newFranchises;",
      "  // final double refunds;",
      "",
      "  const PlatformFinancialKpis({",
      "    required this.mrr,",
      "    required this.arr,",
      "    required this.activeFranchises,",
      "    required this.recentPayouts,",
      "    // this.churnRate = 0,",
      "    // this.arpu = 0,",
      "    // this.newFranchises = 0,",
      "    // this.refunds = 0,",
      "  });",
      "",
      "  /// JSON serialization (for testing, storage, cloud sync, etc.)",
      "  Map<String, dynamic> toJson() => {",
      "        'mrr': mrr,",
      "        'arr': arr,",
      "        'activeFranchises': activeFranchises,",
      "        'recentPayouts': recentPayouts,",
      "        // 'churnRate': churnRate,",
      "        // 'arpu': arpu,",
      "        // 'newFranchises': newFranchises,",
      "        // 'refunds': refunds,",
      "      };",
      "",
      "  /// Factory to create from Firestore or API data (if used directly)",
      "  factory PlatformFinancialKpis.fromJson(Map<String, dynamic> json) {",
      "    return PlatformFinancialKpis(",
      "      mrr: (json['mrr'] ?? 0).toDouble(),",
      "      arr: (json['arr'] ?? 0).toDouble(),",
      "      activeFranchises: (json['activeFranchises'] ?? 0) as int,",
      "      recentPayouts: (json['recentPayouts'] ?? 0).toDouble(),",
      "      // churnRate: (json['churnRate'] ?? 0).toDouble(),",
      "      // arpu: (json['arpu'] ?? 0).toDouble(),",
      "      // newFranchises: (json['newFranchises'] ?? 0) as int,",
      "      // refunds: (json['refunds'] ?? 0).toDouble(),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 63,
      "file_size": 2130,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\models\\platform_invoice.dart",
    "content": [
      "// lib/models/platform_invoice.dart",
      "",
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "/// A production-grade model representing an invoice issued by the platform",
      "/// to a franchisee (e.g. SaaS fees, royalties, services).",
      "class PlatformInvoice {",
      "  /// Document ID",
      "  final String id;",
      "",
      "  /// ID of the franchisee receiving the invoice",
      "  final String franchiseeId;",
      "",
      "  /// Optional: associated store (for franchisees with multiple locations)",
      "  final String? franchiseLocationId;",
      "",
      "  /// Human-readable invoice number",
      "  final String invoiceNumber;",
      "",
      "  /// Total amount due",
      "  final double amount;",
      "",
      "  /// ISO currency (e.g. 'USD')",
      "  final String currency;",
      "",
      "  /// Date the invoice was created",
      "  final DateTime createdAt;",
      "",
      "  /// Date the invoice is due",
      "  final DateTime dueDate;",
      "",
      "  /// Invoice status",
      "  /// 'unpaid', 'paid', 'overdue', 'partial'",
      "  final String status;",
      "",
      "  /// Optional list of payment IDs made toward this invoice",
      "  final List<String> paymentIds;",
      "",
      "  /// Optional metadata describing charges",
      "  final Map<String, dynamic>? lineItems;",
      "",
      "  /// Optional note for context (e.g. \"September Royalty Fee\")",
      "  final String? note;",
      "",
      "  /// Optional URL to downloadable PDF",
      "  final String? pdfUrl;",
      "",
      "  /// Origin tag",
      "  final String issuedBy; // 'platform'",
      "",
      "  /// If this invoice is for a specific billing plan",
      "  final String? planId;",
      "",
      "  /// Optional breakdown of taxes/fees",
      "  final Map<String, dynamic>? taxBreakdown;",
      "",
      "  /// Optional sandbox/test invoice flag",
      "  final bool isTest;",
      "",
      "  /// True if the invoice has been marked paid",
      "  bool get isPaid => status.toLowerCase() == 'paid';",
      "",
      "  /// True if the invoice is unpaid and past the due date",
      "  bool get isOverdue =>",
      "      status.toLowerCase() == 'unpaid' && dueDate.isBefore(DateTime.now());",
      "",
      "  /// True if invoice is partially paid",
      "  bool get isPartial => status.toLowerCase() == 'partial';",
      "",
      "  /// True if invoice is unpaid (not paid or partial)",
      "  bool get isUnpaid => status.toLowerCase() == 'unpaid';",
      "",
      "  /// Optional: Associated subscription (for recurring invoices)",
      "  final String? subscriptionId;",
      "",
      "  /// Timestamp when the invoice was paid (for audit / reconciliation)",
      "  final DateTime? paidAt;",
      "",
      "  /// Optional: External payment processor ID (e.g., Stripe invoice ID)",
      "  final String? externalInvoiceId;",
      "",
      "  /// Optional: External payment provider name (e.g., 'stripe')",
      "  final String? paymentProvider;",
      "",
      "  /// Optional: Method used (e.g. 'card', 'ach')",
      "  final String? paymentMethod;",
      "",
      "  /// Optional log of payment attempts with metadata",
      "  final List<Map<String, dynamic>>? paymentAttempts;",
      "",
      "  /// Last known status of payment attempt",
      "  final String? lastAttemptStatus;",
      "",
      "  /// Optional public receipt URL (if available from provider)",
      "  final String? receiptUrl;",
      "",
      "  PlatformInvoice({",
      "    required this.id,",
      "    required this.franchiseeId,",
      "    required this.invoiceNumber,",
      "    required this.amount,",
      "    required this.currency,",
      "    required this.createdAt,",
      "    required this.dueDate,",
      "    required this.status,",
      "    required this.issuedBy,",
      "    this.franchiseLocationId,",
      "    this.paymentIds = const [],",
      "    this.lineItems,",
      "    this.note,",
      "    this.pdfUrl,",
      "    this.planId,",
      "    this.taxBreakdown,",
      "    this.isTest = false,",
      "    this.subscriptionId,",
      "    this.paidAt,",
      "    this.externalInvoiceId,",
      "    this.paymentProvider,",
      "    this.paymentMethod,",
      "    this.paymentAttempts,",
      "    this.lastAttemptStatus,",
      "    this.receiptUrl,",
      "  });",
      "",
      "  /// Deserializes from Firestore document",
      "  factory PlatformInvoice.fromMap(String id, Map<String, dynamic> data) {",
      "    try {",
      "      return PlatformInvoice(",
      "        id: id,",
      "        franchiseeId: data['franchiseeId'] ?? '',",
      "        franchiseLocationId: data['franchiseLocationId'],",
      "        invoiceNumber: data['invoiceNumber'] ?? '',",
      "        amount: (data['amount'] ?? 0).toDouble(),",
      "        currency: data['currency'] ?? 'USD',",
      "        createdAt: (data['createdAt'] as Timestamp).toDate(),",
      "        dueDate: (data['dueDate'] as Timestamp).toDate(),",
      "        status: data['status'] ?? 'unpaid',",
      "        issuedBy: data['issuedBy'] ?? 'platform',",
      "        paymentIds: List<String>.from(data['paymentIds'] ?? []),",
      "        lineItems: data['lineItems'] != null",
      "            ? Map<String, dynamic>.from(data['lineItems'])",
      "            : null,",
      "        note: data['note'],",
      "        pdfUrl: data['pdfUrl'],",
      "        planId: data['planId'],",
      "        taxBreakdown: data['taxBreakdown'] != null",
      "            ? Map<String, dynamic>.from(data['taxBreakdown'])",
      "            : null,",
      "        isTest: data['isTest'] ?? false,",
      "        subscriptionId: data['subscriptionId'],",
      "        paidAt: (data['paidAt'] as Timestamp?)?.toDate(),",
      "        externalInvoiceId: data['externalInvoiceId'],",
      "        paymentProvider: data['paymentProvider'],",
      "        paymentMethod: data['paymentMethod'],",
      "        paymentAttempts: data['paymentAttempts'] != null",
      "            ? List<Map<String, dynamic>>.from(data['paymentAttempts'])",
      "            : null,",
      "        lastAttemptStatus: data['lastAttemptStatus'],",
      "        receiptUrl: data['receiptUrl'],",
      "      );",
      "    } catch (e, stack) {",
      "      ErrorLogger.log(",
      "        message: 'Failed to parse PlatformInvoice: $e',",
      "        stack: stack.toString(),",
      "        source: 'platform_invoice.fromMap',",
      "        screen: 'platform_invoice',",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Converts to Firestore map",
      "  Map<String, dynamic> toMap() {",
      "    return {",
      "      'franchiseeId': franchiseeId,",
      "      if (franchiseLocationId != null)",
      "        'franchiseLocationId': franchiseLocationId,",
      "      'invoiceNumber': invoiceNumber,",
      "      'amount': amount,",
      "      'currency': currency,",
      "      'createdAt': Timestamp.fromDate(createdAt),",
      "      'dueDate': Timestamp.fromDate(dueDate),",
      "      'status': status,",
      "      'issuedBy': issuedBy,",
      "      'paymentIds': paymentIds,",
      "      if (lineItems != null) 'lineItems': lineItems,",
      "      if (note != null) 'note': note,",
      "      if (pdfUrl != null) 'pdfUrl': pdfUrl,",
      "      if (planId != null) 'planId': planId,",
      "      if (taxBreakdown != null) 'taxBreakdown': taxBreakdown,",
      "      'isTest': isTest,",
      "      if (subscriptionId != null) 'subscriptionId': subscriptionId,",
      "      if (paidAt != null) 'paidAt': Timestamp.fromDate(paidAt!),",
      "      if (externalInvoiceId != null) 'externalInvoiceId': externalInvoiceId,",
      "      if (paymentProvider != null) 'paymentProvider': paymentProvider,",
      "      if (paymentMethod != null) 'paymentMethod': paymentMethod,",
      "      if (paymentAttempts != null) 'paymentAttempts': paymentAttempts,",
      "      if (lastAttemptStatus != null) 'lastAttemptStatus': lastAttemptStatus,",
      "      if (receiptUrl != null) 'receiptUrl': receiptUrl,",
      "    };",
      "  }",
      "",
      "  Map<String, dynamic> toWebhookPayload() {",
      "    return {",
      "      'invoiceId': id,",
      "      'franchiseeId': franchiseeId,",
      "      'amount': amount,",
      "      'currency': currency,",
      "      'status': status,",
      "      'dueDate': dueDate.toIso8601String(),",
      "      'createdAt': createdAt.toIso8601String(),",
      "      'receiptUrl': receiptUrl,",
      "      'paymentProvider': paymentProvider,",
      "      'externalInvoiceId': externalInvoiceId,",
      "      'subscriptionId': subscriptionId,",
      "      'invoiceNumber': invoiceNumber,",
      "      'paidAt': paidAt?.toIso8601String(),",
      "    };",
      "  }",
      "",
      "  /// Parses invoice data from a Stripe invoice webhook payload.",
      "  factory PlatformInvoice.fromStripeWebhook(",
      "    Map<String, dynamic> eventData,",
      "    String invoiceId,",
      "  ) {",
      "    final invoice = eventData['data']['object'];",
      "",
      "    return PlatformInvoice(",
      "      id: invoiceId,",
      "      franchiseeId: invoice['metadata']['franchiseeId'] ?? '',",
      "      invoiceNumber: invoice['number'] ?? invoiceId,",
      "      amount: (invoice['amount_due'] ?? 0) / 100, // Stripe uses cents",
      "      currency: invoice['currency']?.toUpperCase() ?? 'USD',",
      "      createdAt: DateTime.fromMillisecondsSinceEpoch(invoice['created'] * 1000),",
      "      dueDate: invoice['due_date'] != null",
      "          ? DateTime.fromMillisecondsSinceEpoch(invoice['due_date'] * 1000)",
      "          : DateTime.fromMillisecondsSinceEpoch(invoice['created'] * 1000)",
      "              .add(const Duration(days: 30)),",
      "      status: invoice['status'] ?? 'unpaid',",
      "      issuedBy: 'stripe',",
      "      paymentIds:",
      "          invoice['payment_intent'] != null ? [invoice['payment_intent']] : [],",
      "      lineItems: invoice['lines'] != null",
      "          ? {",
      "              'raw': invoice['lines'],",
      "            }",
      "          : null,",
      "      note: invoice['description'],",
      "      pdfUrl: invoice['invoice_pdf'],",
      "      receiptUrl:",
      "          invoice['hosted_invoice_url'], // This is Stripe’s receipt page",
      "      planId: invoice['metadata']['planId'],",
      "      externalInvoiceId: invoice['id'],",
      "      paymentProvider: 'stripe',",
      "      paymentMethod:",
      "          invoice['payment_settings']?['payment_method_types'] != null",
      "              ? invoice['payment_settings']['payment_method_types'].join(', ')",
      "              : null,",
      "      isTest: invoice['livemode'] == false,",
      "      subscriptionId: invoice['subscription'],",
      "      paidAt: invoice['status_transitions']?['paid_at'] != null",
      "          ? DateTime.fromMillisecondsSinceEpoch(",
      "              invoice['status_transitions']['paid_at'] * 1000)",
      "          : null,",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 268,
      "file_size": 9309,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\models\\platform_payment.dart",
    "content": [
      "// lib/models/platform_payment.dart",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "",
      "/// A full, production-ready model for a platform-level payment from a franchisee",
      "/// Supports one-time, split, scheduled, and recurring payments with metadata.",
      "class PlatformPayment {",
      "  /// Document ID",
      "  final String id;",
      "",
      "  /// ID of the franchisee making this payment",
      "  final String franchiseeId;",
      "",
      "  /// Optional: linked invoice",
      "  final String? invoiceId;",
      "",
      "  /// Optional: group ID for split/recurring payments",
      "  final String? paymentGroupId;",
      "",
      "  /// Type of payment behavior",
      "  final String type; // 'one_time' | 'split' | 'scheduled' | 'recurring'",
      "",
      "  /// Payment amount",
      "  final double amount;",
      "",
      "  /// ISO currency code (e.g. 'USD')",
      "  final String currency;",
      "",
      "  /// Method used for payment (e.g. PayPal, check)",
      "  final String paymentMethod;",
      "",
      "  /// Arbitrary details depending on method (e.g. masked card)",
      "  final Map<String, dynamic>? methodDetails;",
      "",
      "  /// When the payment record was created",
      "  final DateTime createdAt;",
      "",
      "  /// If scheduled, when it’s intended to occur",
      "  final DateTime? scheduledFor;",
      "",
      "  /// When the payment was actually processed",
      "  final DateTime? executedAt;",
      "",
      "  /// Optional recurrence rule (monthly, custom cron, etc.)",
      "  final String? recurringRule;",
      "",
      "  /// Current status of the payment",
      "  final String",
      "      status; // 'pending' | 'processing' | 'completed' | 'failed' | 'cancelled'",
      "",
      "  /// Retry attempts (e.g. for failed charges)",
      "  final int attempts;",
      "",
      "  /// Error or rejection code if applicable",
      "  final String? errorCode;",
      "",
      "  /// Optional note or memo",
      "  final String? note;",
      "",
      "  /// If verified manually or by processor",
      "  final String? confirmedBy;",
      "  final DateTime? verifiedAt;",
      "",
      "  /// System that originated the payment",
      "  final String",
      "      sourceSystem; // 'web' | 'mobile' | 'external_api' | 'admin_portal'",
      "",
      "  /// Optional: sandbox/test payment flag",
      "  final bool isTest;",
      "",
      "  /// Optional: processor reference",
      "  final String? externalTransactionId;",
      "",
      "  /// Optional: downloadable receipt link",
      "  final String? receiptUrl;",
      "",
      "  /// Optional: jurisdiction-based tax/fee breakdown",
      "  final Map<String, dynamic>? taxBreakdown;",
      "",
      "  /// Optional: Store within the franchise (if applicable)",
      "  final String? franchiseLocationId;",
      "",
      "  PlatformPayment({",
      "    required this.id,",
      "    required this.franchiseeId,",
      "    required this.type,",
      "    required this.amount,",
      "    required this.currency,",
      "    required this.paymentMethod,",
      "    required this.createdAt,",
      "    required this.status,",
      "    required this.attempts,",
      "    required this.sourceSystem,",
      "    this.invoiceId,",
      "    this.paymentGroupId,",
      "    this.methodDetails,",
      "    this.scheduledFor,",
      "    this.executedAt,",
      "    this.recurringRule,",
      "    this.errorCode,",
      "    this.note,",
      "    this.confirmedBy,",
      "    this.verifiedAt,",
      "    this.isTest = false,",
      "    this.externalTransactionId,",
      "    this.receiptUrl,",
      "    this.taxBreakdown,",
      "    this.franchiseLocationId,",
      "  });",
      "",
      "  /// Construct from Firestore doc",
      "  factory PlatformPayment.fromMap(String id, Map<String, dynamic> data) {",
      "    try {",
      "      return PlatformPayment(",
      "        id: id,",
      "        franchiseeId: data['franchiseeId'] ?? '',",
      "        invoiceId: data['invoiceId'],",
      "        paymentGroupId: data['paymentGroupId'],",
      "        type: data['type'] ?? 'one_time',",
      "        amount: (data['amount'] ?? 0).toDouble(),",
      "        currency: data['currency'] ?? 'USD',",
      "        paymentMethod: data['paymentMethod'] ?? 'unknown',",
      "        methodDetails: Map<String, dynamic>.from(data['methodDetails'] ?? {}),",
      "        createdAt: (data['createdAt'] as Timestamp).toDate(),",
      "        scheduledFor: (data['scheduledFor'] as Timestamp?)?.toDate(),",
      "        executedAt: (data['executedAt'] as Timestamp?)?.toDate(),",
      "        recurringRule: data['recurringRule'],",
      "        status: data['status'] ?? 'pending',",
      "        attempts: data['attempts'] ?? 0,",
      "        errorCode: data['errorCode'],",
      "        note: data['note'],",
      "        confirmedBy: data['confirmedBy'],",
      "        verifiedAt: (data['verifiedAt'] as Timestamp?)?.toDate(),",
      "        sourceSystem: data['sourceSystem'] ?? 'web',",
      "        isTest: data['isTest'] ?? false,",
      "        externalTransactionId: data['externalTransactionId'],",
      "        receiptUrl: data['receiptUrl'],",
      "        taxBreakdown: Map<String, dynamic>.from(data['taxBreakdown'] ?? {}),",
      "        franchiseLocationId: data['franchiseLocationId'],",
      "      );",
      "    } catch (e, stack) {",
      "      // Ensure your error_logger.dart supports log() with both error and stacktrace.",
      "      ErrorLogger.log(",
      "        message: 'Failed to parse PlatformPayment: $e',",
      "        stack: stack.toString(),",
      "        source: 'platform_payment.fromMap',",
      "        screen: 'platform_payment',",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Serialize for Firestore",
      "  Map<String, dynamic> toMap() {",
      "    return {",
      "      'franchiseeId': franchiseeId,",
      "      if (invoiceId != null) 'invoiceId': invoiceId,",
      "      if (paymentGroupId != null) 'paymentGroupId': paymentGroupId,",
      "      'type': type,",
      "      'amount': amount,",
      "      'currency': currency,",
      "      'paymentMethod': paymentMethod,",
      "      if (methodDetails != null) 'methodDetails': methodDetails,",
      "      'createdAt': Timestamp.fromDate(createdAt),",
      "      if (scheduledFor != null)",
      "        'scheduledFor': Timestamp.fromDate(scheduledFor!),",
      "      if (executedAt != null) 'executedAt': Timestamp.fromDate(executedAt!),",
      "      if (recurringRule != null) 'recurringRule': recurringRule,",
      "      'status': status,",
      "      'attempts': attempts,",
      "      if (errorCode != null) 'errorCode': errorCode,",
      "      if (note != null) 'note': note,",
      "      if (confirmedBy != null) 'confirmedBy': confirmedBy,",
      "      if (verifiedAt != null) 'verifiedAt': Timestamp.fromDate(verifiedAt!),",
      "      'sourceSystem': sourceSystem,",
      "      'isTest': isTest,",
      "      if (externalTransactionId != null)",
      "        'externalTransactionId': externalTransactionId,",
      "      if (receiptUrl != null) 'receiptUrl': receiptUrl,",
      "      if (taxBreakdown != null) 'taxBreakdown': taxBreakdown,",
      "      if (franchiseLocationId != null)",
      "        'franchiseLocationId': franchiseLocationId,",
      "    };",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 185,
      "file_size": 6246,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\models\\platform_plan_model.dart",
    "content": [
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "",
      "class PlatformPlan {",
      "  final String id;",
      "  final String name;",
      "  final String description;",
      "  final double price;",
      "  final String currency;",
      "  final String billingInterval; // e.g. 'monthly', 'annual'",
      "  final List<String> features;",
      "  final bool active;",
      "  final bool isCustom;",
      "  final DateTime? createdAt;",
      "  final DateTime? updatedAt;",
      "  final String? planVersion;",
      "",
      "  PlatformPlan({",
      "    required this.id,",
      "    required this.name,",
      "    required this.description,",
      "    required this.price,",
      "    required this.currency,",
      "    required this.billingInterval,",
      "    required this.features,",
      "    required this.active,",
      "    required this.isCustom,",
      "    this.createdAt,",
      "    this.updatedAt,",
      "    this.planVersion,",
      "  });",
      "",
      "  factory PlatformPlan.fromMap(String id, Map<String, dynamic> data) {",
      "    print('[DEBUG][PlatformPlan.fromMap] Raw data for $id: $data');",
      "    return PlatformPlan(",
      "      id: id,",
      "      name: data['name'] ?? '',",
      "      description: data['description'] ?? '',",
      "      price: (data['price'] ?? 0).toDouble(),",
      "      currency: data['currency'] ?? 'USD',",
      "      billingInterval: data['billingInterval'] ?? 'monthly',",
      "      features: (() {",
      "        if (data['includedFeatures'] is List) {",
      "          return List<String>.from(data['includedFeatures']);",
      "        } else if (data['features'] is List) {",
      "          return List<String>.from(data['features']);",
      "        } else {",
      "          return <String>[];",
      "        }",
      "      })(),",
      "      active: data['active'] ?? false,",
      "      isCustom: data['isCustom'] ?? false,",
      "      createdAt: (data['createdAt'] as Timestamp?)?.toDate(),",
      "      updatedAt: (data['updatedAt'] as Timestamp?)?.toDate(),",
      "      planVersion: data['planVersion'] ?? 'v1',",
      "    );",
      "  }",
      "",
      "  Map<String, dynamic> toFirestore() {",
      "    return {",
      "      'name': name,",
      "      'description': description,",
      "      'price': price,",
      "      'currency': currency,",
      "      'billingInterval': billingInterval,",
      "      'features': features,",
      "      'active': active,",
      "      'isCustom': isCustom,",
      "      'createdAt': createdAt ?? FieldValue.serverTimestamp(),",
      "      'updatedAt': FieldValue.serverTimestamp(),",
      "      'planVersion': planVersion ?? 'v1',",
      "    };",
      "  }",
      "",
      "  PlatformPlan copyWith({",
      "    String? name,",
      "    String? description,",
      "    double? price,",
      "    String? currency,",
      "    String? billingInterval,",
      "    List<String>? features,",
      "    bool? active,",
      "    bool? isCustom,",
      "    DateTime? createdAt,",
      "    DateTime? updatedAt,",
      "    String? planVersion,",
      "  }) {",
      "    return PlatformPlan(",
      "      id: id,",
      "      name: name ?? this.name,",
      "      description: description ?? this.description,",
      "      price: price ?? this.price,",
      "      currency: currency ?? this.currency,",
      "      billingInterval: billingInterval ?? this.billingInterval,",
      "      features: features ?? this.features,",
      "      active: active ?? this.active,",
      "      isCustom: isCustom ?? this.isCustom,",
      "      createdAt: createdAt ?? this.createdAt,",
      "      updatedAt: updatedAt ?? this.updatedAt,",
      "      planVersion: planVersion ?? this.planVersion,",
      "    );",
      "  }",
      "",
      "  factory PlatformPlan.fromFirestore(DocumentSnapshot doc) {",
      "    final data = doc.data() as Map<String, dynamic>;",
      "    return PlatformPlan.fromMap(doc.id, data);",
      "  }",
      "",
      "  /// ✅ Derived property: should not be stored",
      "  bool get requiresPayment => !isCustom && price > 0;",
      "",
      "  @override",
      "  bool operator ==(Object other) =>",
      "      identical(this, other) ||",
      "      other is PlatformPlan &&",
      "          runtimeType == other.runtimeType &&",
      "          id == other.id;",
      "",
      "  @override",
      "  int get hashCode => id.hashCode;",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 120,
      "file_size": 3616,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\models\\platform_revenue_overview.dart",
    "content": [
      "// File: lib/core/models/platform_revenue_overview.dart",
      "class PlatformRevenueOverview {",
      "  final double totalRevenueYtd;",
      "  final double subscriptionRevenue;",
      "  final double royaltyRevenue;",
      "  final double overdueAmount;",
      "",
      "  PlatformRevenueOverview({",
      "    required this.totalRevenueYtd,",
      "    required this.subscriptionRevenue,",
      "    required this.royaltyRevenue,",
      "    required this.overdueAmount,",
      "  });",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 14,
      "file_size": 409,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\models\\promo.dart",
    "content": [
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "",
      "class Promo {",
      "  final String id;",
      "  final String name; // Human-readable promo name",
      "  final String description; // Human-readable description",
      "  final String code; // Optional promo code string",
      "  final String type; // Discount type (e.g. 'percent', 'amount', etc)",
      "  final List<String> items; // List of item IDs or categories promo applies to",
      "  final double discount; // Discount value",
      "  final int maxUses;",
      "  final String maxUsesType;",
      "  final double minOrderValue;",
      "  final DateTime startDate;",
      "  final DateTime endDate;",
      "  final bool active;",
      "  final Segment? target;",
      "  final TimeRule? timeRules;",
      "",
      "  Promo({",
      "    required this.id,",
      "    required this.name,",
      "    required this.description,",
      "    required this.code,",
      "    required this.type,",
      "    required this.items,",
      "    required this.discount,",
      "    required this.maxUses,",
      "    required this.maxUsesType,",
      "    required this.minOrderValue,",
      "    required this.startDate,",
      "    required this.endDate,",
      "    required this.active,",
      "    this.target,",
      "    this.timeRules,",
      "  });",
      "",
      "  // Useful for export and admin logic",
      "  List<String> get applicableItems => items;",
      "",
      "  // Flat segment for export/compatibility",
      "  String? get segment => target?.segment;",
      "",
      "  // For export compatibility with codebases that expect these:",
      "  String get promoName => name;",
      "  String get promoDescription => description;",
      "  String get promoCode => code;",
      "",
      "  factory Promo.fromFirestore(Map<String, dynamic> data, String id) {",
      "    return Promo(",
      "      id: id,",
      "      name: data['name'] ?? '',",
      "      description: data['description'] ?? '',",
      "      code: data['code'] ?? '',",
      "      type: data['type'] ?? '',",
      "      items: (data['items'] as List<dynamic>?)?.cast<String>() ?? [],",
      "      discount: (data['discount'] ?? 0.0).toDouble(),",
      "      maxUses: data['maxUses'] ?? 0,",
      "      maxUsesType: data['maxUsesType'] ?? '',",
      "      minOrderValue: (data['minOrderValue'] ?? 0.0).toDouble(),",
      "      startDate: (data['startDate'] as Timestamp?)?.toDate() ?? DateTime.now(),",
      "      endDate: (data['endDate'] as Timestamp?)?.toDate() ?? DateTime.now(),",
      "      active: data['active'] ?? false,",
      "      target: data['target'] != null ? Segment.fromMap(data['target']) : null,",
      "      timeRules: data['timeRules'] != null",
      "          ? TimeRule.fromMap(data['timeRules'])",
      "          : null,",
      "    );",
      "  }",
      "",
      "  Map<String, dynamic> toFirestore() {",
      "    return {",
      "      'name': name,",
      "      'description': description,",
      "      'code': code,",
      "      'type': type,",
      "      'items': items,",
      "      'discount': discount,",
      "      'maxUses': maxUses,",
      "      'maxUsesType': maxUsesType,",
      "      'minOrderValue': minOrderValue,",
      "      'startDate': Timestamp.fromDate(startDate),",
      "      'endDate': Timestamp.fromDate(endDate),",
      "      'active': active,",
      "      'target': target?.toMap(),",
      "      'timeRules': timeRules?.toMap(),",
      "    };",
      "  }",
      "",
      "  Promo copyWith({",
      "    String? id,",
      "    String? name,",
      "    String? description,",
      "    String? code,",
      "    String? type,",
      "    List<String>? items,",
      "    double? discount,",
      "    int? maxUses,",
      "    String? maxUsesType,",
      "    double? minOrderValue,",
      "    DateTime? startDate,",
      "    DateTime? endDate,",
      "    bool? active,",
      "    Segment? target,",
      "    TimeRule? timeRules,",
      "  }) {",
      "    return Promo(",
      "      id: id ?? this.id,",
      "      name: name ?? this.name,",
      "      description: description ?? this.description,",
      "      code: code ?? this.code,",
      "      type: type ?? this.type,",
      "      items: items ?? List<String>.from(this.items),",
      "      discount: discount ?? this.discount,",
      "      maxUses: maxUses ?? this.maxUses,",
      "      maxUsesType: maxUsesType ?? this.maxUsesType,",
      "      minOrderValue: minOrderValue ?? this.minOrderValue,",
      "      startDate: startDate ?? this.startDate,",
      "      endDate: endDate ?? this.endDate,",
      "      active: active ?? this.active,",
      "      target: target ?? this.target,",
      "      timeRules: timeRules ?? this.timeRules,",
      "    );",
      "  }",
      "}",
      "",
      "class Segment {",
      "  final String segment;",
      "  final dynamic value;",
      "",
      "  Segment({required this.segment, required this.value});",
      "",
      "  factory Segment.fromMap(Map<String, dynamic> data) {",
      "    return Segment(",
      "      segment: data['segment'] ?? '',",
      "      value: data['value'],",
      "    );",
      "  }",
      "",
      "  Map<String, dynamic> toMap() {",
      "    return {",
      "      'segment': segment,",
      "      'value': value,",
      "    };",
      "  }",
      "}",
      "",
      "class TimeRule {",
      "  final String startTime;",
      "  final String endTime;",
      "  final double discount;",
      "",
      "  TimeRule({",
      "    required this.startTime,",
      "    required this.endTime,",
      "    required this.discount,",
      "  });",
      "",
      "  factory TimeRule.fromMap(Map<String, dynamic> data) {",
      "    return TimeRule(",
      "      startTime: data['startTime'] ?? '',",
      "      endTime: data['endTime'] ?? '',",
      "      discount: (data['discount'] ?? 0.0).toDouble(),",
      "    );",
      "  }",
      "",
      "  Map<String, dynamic> toMap() {",
      "    return {",
      "      'startTime': startTime,",
      "      'endTime': endTime,",
      "      'discount': discount,",
      "    };",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 174,
      "file_size": 4932,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\models\\report.dart",
    "content": [
      "// lib/core/models/report.dart",
      "",
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "",
      "class Report {",
      "  final String id;",
      "  final DocumentReference franchiseRef;",
      "  final String type; // financial, tax, performance, etc.",
      "  final DateTime? generatedAt;",
      "  final String? generatedBy;",
      "  final String fileUrl;",
      "  final Map<String, dynamic> meta;",
      "  final Map<String, dynamic> customFields;",
      "",
      "  Report({",
      "    required this.id,",
      "    required this.franchiseRef,",
      "    required this.type,",
      "    this.generatedAt,",
      "    this.generatedBy,",
      "    required this.fileUrl,",
      "    this.meta = const {},",
      "    this.customFields = const {},",
      "  });",
      "",
      "  factory Report.fromFirestore(Map<String, dynamic> data, String id) {",
      "    return Report(",
      "      id: id,",
      "      franchiseRef: data['franchiseId'] as DocumentReference,",
      "      type: data['type'] ?? '',",
      "      generatedAt: (data['generated_at'] as Timestamp?)?.toDate(),",
      "      generatedBy: data['generated_by'],",
      "      fileUrl: data['file_url'] ?? '',",
      "      meta: data['meta'] ?? {},",
      "      customFields: data['custom_fields'] ?? {},",
      "    );",
      "  }",
      "",
      "  Map<String, dynamic> toFirestore() {",
      "    return {",
      "      'franchiseId': franchiseRef,",
      "      'type': type,",
      "      'generated_at':",
      "          generatedAt != null ? Timestamp.fromDate(generatedAt!) : null,",
      "      'generated_by': generatedBy,",
      "      'file_url': fileUrl,",
      "      'meta': meta,",
      "      'custom_fields': customFields,",
      "    };",
      "  }",
      "",
      "  Report copyWith({",
      "    String? id,",
      "    DocumentReference? franchiseRef,",
      "    String? type,",
      "    DateTime? generatedAt,",
      "    String? generatedBy,",
      "    String? fileUrl,",
      "    Map<String, dynamic>? meta,",
      "    Map<String, dynamic>? customFields,",
      "  }) {",
      "    return Report(",
      "      id: id ?? this.id,",
      "      franchiseRef: franchiseRef ?? this.franchiseRef,",
      "      type: type ?? this.type,",
      "      generatedAt: generatedAt ?? this.generatedAt,",
      "      generatedBy: generatedBy ?? this.generatedBy,",
      "      fileUrl: fileUrl ?? this.fileUrl,",
      "      meta: meta ?? this.meta,",
      "      customFields: customFields ?? this.customFields,",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 73,
      "file_size": 2070,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\models\\restaurant_type.dart",
    "content": [
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "",
      "class RestaurantType {",
      "  final String id;",
      "  final String name;",
      "",
      "  RestaurantType({required this.id, required this.name});",
      "",
      "  factory RestaurantType.fromFirestore(DocumentSnapshot doc) {",
      "    final data = doc.data() as Map<String, dynamic>;",
      "    return RestaurantType(",
      "      id: doc.id,",
      "      name: data['name'] ?? '',",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 16,
      "file_size": 401,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\models\\size_template.dart",
    "content": [
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "",
      "class SizeTemplate {",
      "  final String id;",
      "  final String label;",
      "  final List<SizeData> sizes;",
      "",
      "  SizeTemplate({required this.id, required this.label, required this.sizes});",
      "",
      "  factory SizeTemplate.fromFirestore(DocumentSnapshot doc) {",
      "    final data = doc.data() as Map<String, dynamic>;",
      "    return SizeTemplate(",
      "      id: doc.id,",
      "      label: data['label'] ?? '',",
      "      sizes: (data['sizes'] as List<dynamic>)",
      "          .map((size) => SizeData.fromMap(size))",
      "          .toList(),",
      "    );",
      "  }",
      "}",
      "",
      "class SizeData {",
      "  final String label;",
      "  final double basePrice;",
      "  final double toppingPrice;",
      "",
      "  SizeData({",
      "    required this.label,",
      "    required this.basePrice,",
      "    required this.toppingPrice,",
      "  });",
      "",
      "  factory SizeData.fromMap(Map<String, dynamic> map) {",
      "    return SizeData(",
      "      label: map['label'],",
      "      basePrice: (map['basePrice'] ?? 0).toDouble(),",
      "      toppingPrice: (map['toppingPrice'] ?? 0).toDouble(),",
      "    );",
      "  }",
      "",
      "  Map<String, dynamic> toMap() {",
      "    return {",
      "      'label': label,",
      "      'basePrice': basePrice,",
      "      'toppingPrice': toppingPrice,",
      "    };",
      "  }",
      "",
      "  SizeData copy() {",
      "    return SizeData(",
      "      label: label,",
      "      basePrice: basePrice,",
      "      toppingPrice: toppingPrice,",
      "    );",
      "  }",
      "",
      "  SizeData copyWith({",
      "    String? label,",
      "    double? basePrice,",
      "    double? toppingPrice,",
      "  }) {",
      "    return SizeData(",
      "      label: label ?? this.label,",
      "      basePrice: basePrice ?? this.basePrice,",
      "      toppingPrice: toppingPrice ?? this.toppingPrice,",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 68,
      "file_size": 1592,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\models\\staff.dart",
    "content": [
      "class Staff {",
      "  final String id;",
      "  final String name;",
      "  final String email;",
      "  final String? phoneNumber;",
      "  final String role; // owner, manager, cashier",
      "  final String status; // active, inactive",
      "  final List<String> permissions;",
      "",
      "  Staff({",
      "    required this.id,",
      "    required this.name,",
      "    required this.email,",
      "    this.phoneNumber,",
      "    required this.role,",
      "    required this.status,",
      "    required this.permissions,",
      "  });",
      "",
      "  factory Staff.fromFirestore(Map<String, dynamic> data, String id) {",
      "    return Staff(",
      "      id: id,",
      "      name: data['name'] ?? '',",
      "      email: data['email'] ?? '',",
      "      phoneNumber: data['phoneNumber'],",
      "      role: data['role'] ?? 'cashier',",
      "      status: data['status'] ?? 'active',",
      "      permissions:",
      "          (data['permissions'] as List<dynamic>?)?.cast<String>() ?? [],",
      "    );",
      "  }",
      "",
      "  Map<String, dynamic> toFirestore() {",
      "    return {",
      "      'name': name,",
      "      'email': email,",
      "      'phoneNumber': phoneNumber,",
      "      'role': role,",
      "      'status': status,",
      "      'permissions': permissions,",
      "    };",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 43,
      "file_size": 1077,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\models\\user.dart",
    "content": [
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "import 'address.dart';",
      "",
      "class User {",
      "  static const String roleHqOwner = 'hq_owner';",
      "  static const String roleHqManager = 'hq_manager';",
      "  static const String roleOwner = 'owner';",
      "  static const String roleAdmin = 'admin';",
      "  static const String roleManager = 'manager';",
      "  static const String roleStaff = 'staff';",
      "  static const String roleCustomer = 'customer';",
      "  static const String roleDeveloper = 'developer';",
      "  static const String rolePlatformOwner = 'platform_owner';",
      "  static const String roleFranchisee = 'franchisee';",
      "  static const String roleStoreOwner = 'store_owner';",
      "",
      "  final bool? completeProfile;",
      "  final bool isActive;",
      "  final String id;",
      "  final String name;",
      "  final String email;",
      "  final String? phoneNumber;",
      "  final List<String> roles;",
      "  final List<Address> addresses;",
      "  final String language;",
      "  final String status;",
      "  final String? defaultFranchise;",
      "  final String? avatarUrl;",
      "  final List<String> franchiseIds;",
      "  final bool onboardingComplete;",
      "  final DateTime? updatedAt;",
      "",
      "  bool get isHqOwner => roles.contains(roleHqOwner);",
      "  bool get isHqManager => roles.contains(roleHqManager);",
      "  bool get isOwner => roles.contains(roleOwner);",
      "  bool get isAdmin => roles.contains(roleAdmin);",
      "  bool get isManager => roles.contains(roleManager);",
      "  bool get isStaff => roles.contains(roleStaff);",
      "  bool get isPlatformOwner => roles.contains(rolePlatformOwner);",
      "  bool get isFranchisee => roles.contains(roleFranchisee);",
      "  bool get isStoreOwner => roles.contains(roleStoreOwner);",
      "  bool get isCustomer =>",
      "      roles.contains(roleCustomer) ||",
      "      !(isHqOwner || isHqManager || isOwner || isAdmin || isManager || isStaff);",
      "  bool get isDeveloper => roles.contains(roleDeveloper);",
      "",
      "  User({",
      "    required this.id,",
      "    required this.name,",
      "    required this.email,",
      "    this.phoneNumber,",
      "    required this.roles,",
      "    List<Address>? addresses,",
      "    required this.language,",
      "    required this.status,",
      "    this.defaultFranchise,",
      "    this.avatarUrl,",
      "    this.isActive = true,",
      "    List<String>? franchiseIds,",
      "    this.completeProfile,",
      "    this.onboardingComplete = false,",
      "    this.updatedAt,",
      "  })  : addresses = addresses ?? [],",
      "        franchiseIds = franchiseIds ?? <String>[];",
      "",
      "  static User fromFirestore(Map<String, dynamic> data, String id) {",
      "    final rolesFromDb =",
      "        (data['roles'] as List<dynamic>?)?.map((e) => e.toString()).toList() ??",
      "            <String>[];",
      "    final franchiseIdsFromDb = (data['franchiseIds'] as List<dynamic>?)",
      "            ?.map((e) => e.toString())",
      "            .toList() ??",
      "        <String>[];",
      "    return User(",
      "      id: id,",
      "      name: data['name'] ?? '',",
      "      email: data['email'] ?? '',",
      "      phoneNumber: data['phoneNumber'] ?? data['phone'] ?? '',",
      "      roles: rolesFromDb,",
      "      addresses: (data['addresses'] as List<dynamic>?)",
      "              ?.map((e) => Address.fromMap(Map<String, dynamic>.from(e)))",
      "              .toList() ??",
      "          [],",
      "      language: data['language'] ?? 'en',",
      "      status: data['status'] ?? 'active',",
      "      defaultFranchise: data['defaultFranchise'],",
      "      avatarUrl: data['avatarUrl'],",
      "      isActive: data['isActive'] ?? true,",
      "      franchiseIds: franchiseIdsFromDb,",
      "      completeProfile: data['completeProfile'],",
      "      onboardingComplete: data['onboardingStatus'] == 'complete',",
      "      updatedAt: (data['updatedAt'] as Timestamp?)?.toDate(),",
      "    );",
      "  }",
      "",
      "  Map<String, dynamic> toFirestore() {",
      "    return {",
      "      'name': name,",
      "      'email': email,",
      "      'phoneNumber': phoneNumber ?? '',",
      "      'roles': roles,",
      "      'addresses': addresses.map((e) => e.toMap()).toList(),",
      "      'language': language,",
      "      'status': status,",
      "      'defaultFranchise': defaultFranchise,",
      "      'avatarUrl': avatarUrl,",
      "      'isActive': isActive,",
      "      'franchiseIds': franchiseIds,",
      "      'completeProfile': completeProfile,",
      "      'onboardingStatus': onboardingComplete ? 'complete' : 'incomplete',",
      "      if (updatedAt != null) 'updatedAt': Timestamp.fromDate(updatedAt!),",
      "    };",
      "  }",
      "",
      "  User copyWith({",
      "    String? name,",
      "    String? email,",
      "    String? phoneNumber,",
      "    List<String>? roles,",
      "    List<Address>? addresses,",
      "    String? language,",
      "    String? status,",
      "    String? defaultFranchise,",
      "    String? avatarUrl,",
      "    bool? isActive,",
      "    List<String>? franchiseIds,",
      "    bool? completeProfile,",
      "    bool? onboardingComplete,",
      "  }) {",
      "    return User(",
      "      id: id,",
      "      name: name ?? this.name,",
      "      email: email ?? this.email,",
      "      phoneNumber: phoneNumber ?? this.phoneNumber,",
      "      roles: roles ?? this.roles,",
      "      addresses: addresses ?? this.addresses,",
      "      language: language ?? this.language,",
      "      status: status ?? this.status,",
      "      defaultFranchise: defaultFranchise ?? this.defaultFranchise,",
      "      avatarUrl: avatarUrl ?? this.avatarUrl,",
      "      isActive: isActive ?? this.isActive,",
      "      franchiseIds: franchiseIds ?? this.franchiseIds,",
      "      completeProfile: completeProfile ?? this.completeProfile,",
      "      onboardingComplete: onboardingComplete ?? this.onboardingComplete,",
      "    );",
      "  }",
      "",
      "  bool get isFranchiseRequired =>",
      "      !(isPlatformOwner || isDeveloper || isHqOwner);",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 150,
      "file_size": 5243,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\models\\enriched\\enriched_franchise_subscription.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/core/models/franchise_subscription_model.dart';",
      "import 'package:franchise_admin_portal/core/models/franchise_info.dart';",
      "import 'package:franchise_admin_portal/core/models/platform_invoice.dart';",
      "import 'package:franchise_admin_portal/core/models/user.dart' as app_user;",
      "",
      "/// Combines a franchise subscription with enriched franchise and billing data.",
      "class EnrichedFranchiseSubscription {",
      "  /// Raw franchise subscription object.",
      "  final FranchiseSubscription subscription;",
      "",
      "  /// Franchise details (display name, logo, etc.)",
      "  final FranchiseInfo? franchise;",
      "",
      "  /// Optional latest invoice issued to this franchise.",
      "  final PlatformInvoice? latestInvoice;",
      "",
      "  /// Extracted metadata",
      "  String get franchiseId => subscription.franchiseId;",
      "  String get subscriptionStatus => subscription.status;",
      "  String get planId => subscription.platformPlanId;",
      "  DateTime get nextBilling => subscription.nextBillingDate;",
      "",
      "  /// Optional: Displayable price summary string.",
      "  String get priceLabel {",
      "    final formatted = subscription.priceFormatted ?? '--';",
      "    final interval = subscription.billingIntervalFormatted;",
      "    return '\\$$formatted / $interval';",
      "  }",
      "",
      "  /// Optional custom note",
      "  String? get notes => subscription.customQuoteDetails;",
      "",
      "  /// Optional visual branding",
      "  String? get logoUrl => franchise?.logoUrl;",
      "  String get franchiseName => franchise?.name ?? 'Unnamed Franchise';",
      "",
      "  /// Used for sorting",
      "  DateTime get sortTimestamp =>",
      "      subscription.subscribedAt ?? subscription.startDate;",
      "",
      "  /// Optional future insights field placeholder",
      "  final Map<String, dynamic>? futureInsights;",
      "",
      "  /// Associated franchise owner (if available)",
      "  final app_user.User? owner;",
      "",
      "  EnrichedFranchiseSubscription({",
      "    required this.subscription,",
      "    required this.franchise,",
      "    this.latestInvoice,",
      "    this.futureInsights,",
      "    this.owner,",
      "  });",
      "",
      "  /// Helper for creating a stub entry if something fails to load.",
      "  factory EnrichedFranchiseSubscription.stub(FranchiseSubscription sub) {",
      "    return EnrichedFranchiseSubscription(",
      "      subscription: sub,",
      "      franchise: null,",
      "      owner: null,",
      "    );",
      "  }",
      "",
      "  /// Allows basic filtering e.g., by status or name.",
      "  bool matches(String query) {",
      "    final lower = query.toLowerCase();",
      "    return franchiseName.toLowerCase().contains(lower) ||",
      "        subscription.status.toLowerCase().contains(lower);",
      "  }",
      "",
      "  String get ownerName => (owner?.name?.trim().isNotEmpty ?? false)",
      "      ? owner!.name",
      "      : franchise?.ownerName ?? '—';",
      "  String get contactEmail => owner?.email ?? franchise?.businessEmail ?? '—';",
      "  String get phoneNumber => owner?.phoneNumber ?? franchise?.phone ?? '—';",
      "  String? get userId => owner?.id;",
      "",
      "  /// Returns true if the most recent invoice is unpaid and past due",
      "  bool get isPaymentOverdue {",
      "    final invoice = latestInvoice;",
      "    return invoice?.isOverdue ?? false;",
      "  }",
      "",
      "  bool get isInvoicePaid => latestInvoice?.isPaid ?? false;",
      "",
      "  bool get isInvoicePartial => latestInvoice?.isPartial ?? false;",
      "",
      "  bool get isInvoiceUnpaid => latestInvoice?.isUnpaid ?? false;",
      "",
      "  bool get isInvoiceOverdue => latestInvoice?.isOverdue ?? false;",
      "",
      "  /// Timestamp of the last known activity (login or menu update)",
      "  DateTime? get lastActivity {",
      "    // Prefer user update timestamp",
      "    return owner?.updatedAt ?? subscription.updatedAt;",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 98,
      "file_size": 3472,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\providers\\admin_user_provider.dart",
    "content": [
      "import 'dart:async';",
      "",
      "import 'package:flutter/foundation.dart';",
      "import 'package:firebase_auth/firebase_auth.dart' as fb_auth;",
      "import 'package:franchise_admin_portal/core/models/user.dart' as admin_user;",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/models/franchise_info.dart';",
      "",
      "class AdminUserProvider extends ChangeNotifier {",
      "  admin_user.User? _user;",
      "  admin_user.User? get user => _user;",
      "",
      "  set user(admin_user.User? value) {",
      "    _user = value;",
      "    notifyListeners();",
      "  }",
      "",
      "  bool get isHqOwner => user?.isHqOwner == true;",
      "  bool get isHqManager => user?.isHqManager == true;",
      "  bool get isOwner => user?.isOwner == true;",
      "  bool get isManager => user?.isManager == true;",
      "  bool get isAdmin => user?.isAdmin == true;",
      "  bool get isStaff => user?.isStaff == true;",
      "  bool get isCustomer => user?.isCustomer == true;",
      "  bool get isDeveloper => user?.isDeveloper == true;",
      "",
      "  bool get isHqUser => isHqOwner || isHqManager;",
      "  bool get isFranchiseUser => isOwner || isManager;",
      "",
      "  StreamSubscription? _sub;",
      "  bool _loading = false;",
      "  bool get loading => _loading;",
      "",
      "  Object? _lastError;",
      "  Object? get lastError => _lastError;",
      "",
      "  void listenToAdminUser(",
      "    FirestoreService firestoreService,",
      "    String? uid,",
      "    FranchiseProvider franchiseProvider,",
      "  ) {",
      "    _sub?.cancel();",
      "    _loading = true;",
      "    _lastError = null;",
      "    notifyListeners();",
      "",
      "    if (uid == null) {",
      "      _user = null;",
      "      _loading = false;",
      "      franchiseProvider.clearFranchiseContext(); // Ensure state is reset",
      "      notifyListeners();",
      "      return;",
      "    }",
      "",
      "    _sub = firestoreService.userStream(uid).listen(",
      "      (userDoc) async {",
      "        _user = userDoc;",
      "",
      "        // ✅ Inject the user into FranchiseProvider so it can compute viewableFranchises",
      "        franchiseProvider.setAdminUser(_user);",
      "",
      "        // ✅ Fetch allowed franchises immediately after user loads",
      "        try {",
      "          List<FranchiseInfo> fList;",
      "",
      "          if (_user?.isPlatformOwner == true || _user?.isDeveloper == true) {",
      "            fList = await firestoreService.getAllFranchises(); // 🧠 must exist",
      "          } else {",
      "            fList = await firestoreService",
      "                .getFranchisesByIds(_user?.franchiseIds ?? []);",
      "          }",
      "",
      "          franchiseProvider.setAllFranchises(fList);",
      "          print(",
      "              '[AdminUserProvider] Loaded ${fList.length} franchises for user.');",
      "        } catch (e, st) {",
      "          print('[AdminUserProvider] Failed to fetch franchise list: $e\\n$st');",
      "        }",
      "",
      "        _loading = false;",
      "        notifyListeners();",
      "      },",
      "      onError: (error) {",
      "        _lastError = error;",
      "        _loading = false;",
      "        notifyListeners();",
      "      },",
      "    );",
      "  }",
      "",
      "  void clear() {",
      "    _sub?.cancel();",
      "    _user = null;",
      "    _loading = false;",
      "    _lastError = null;",
      "    notifyListeners();",
      "  }",
      "",
      "  @override",
      "  void dispose() {",
      "    _sub?.cancel();",
      "    super.dispose();",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 105,
      "file_size": 3108,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\providers\\category_provider.dart",
    "content": [
      "// lib/core/providers/category_provider.dart",
      "import 'package:franchise_admin_portal/core/models/onboarding_validation_issue.dart';",
      "import 'package:flutter/material.dart';",
      "import 'package:collection/collection.dart';",
      "import 'package:franchise_admin_portal/core/models/category.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class CategoryProvider extends ChangeNotifier {",
      "  final FirestoreService firestore;",
      "  String franchiseId;",
      "",
      "  List<Category> _original = [];",
      "  List<Category> _current = [];",
      "  final Set<String> _selectedCategoryIds = {};",
      "",
      "  bool _loading = true;",
      "  bool _groupByVisible = false;",
      "",
      "  // Tracks whether we've completed at least one successful Firestore load.",
      "  bool _hasLoaded = false;",
      "  bool get isLoaded => _hasLoaded;",
      "",
      "  CategoryProvider({",
      "    required this.firestore,",
      "    required this.franchiseId,",
      "  });",
      "",
      "  List<Category> get categories => List.unmodifiable(_categories);",
      "  bool get isLoading => _loading;",
      "  bool get isDirty =>",
      "      !const DeepCollectionEquality().equals(_original, _current);",
      "  bool get groupByVisible => _groupByVisible;",
      "",
      "  Set<String> get selectedCategoryIds => _selectedCategoryIds;",
      "",
      "  /// Schema issue sidebar",
      "  final List<Category> _stagedCategories = [];",
      "  int get stagedCategoryCount => _stagedCategories.length;",
      "",
      "  /// End",
      "",
      "  String? _loadedFranchiseId;",
      "  final List<Category> _categories = [];",
      "",
      "  set groupByVisible(bool val) {",
      "    _groupByVisible = val;",
      "    notifyListeners();",
      "  }",
      "",
      "  Future<void> createCategory(Category newCategory) async {",
      "    final colRef = firestore.db",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection('categories');",
      "    await colRef.doc(newCategory.id).set(newCategory.toFirestore());",
      "    addOrUpdateCategory(newCategory);",
      "  }",
      "",
      "  /// Adds or updates multiple new categories (for repair/add-new)",
      "  void addOrUpdateCategories(List<Category> newCategories) {",
      "    for (final cat in newCategories) {",
      "      addOrUpdateCategory(cat);",
      "    }",
      "    notifyListeners();",
      "  }",
      "",
      "  /// Returns all category IDs missing from the current provider (for repair UI)",
      "  List<String> missingCategoryIds(List<String> ids) {",
      "    final currentIds = allCategoryIds.toSet();",
      "    return ids.where((id) => !currentIds.contains(id)).toList();",
      "  }",
      "",
      "  /// Reload categories from Firestore (useful after mapping or create-new in repair UI)",
      "  Future<void> reload(String franchiseId,",
      "      {bool forceReloadFromFirestore = false}) async {",
      "    print('[CategoryProvider - reLoad] Incoming franchiseId=\"$franchiseId\"');",
      "    if (franchiseId.isEmpty || franchiseId == 'unknown') {",
      "      print(",
      "          '[CategoryProvider][RELOAD] ⚠️ Called with blank/unknown franchiseId! Skipping reload.');",
      "      await ErrorLogger.log(",
      "        message:",
      "            'CategoryProvider: reload called with blank/unknown franchiseId',",
      "        stack: '',",
      "        source: 'category_provider.dart',",
      "        screen: 'category_provider.dart',",
      "        severity: 'warning',",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      return;",
      "    }",
      "",
      "    if (forceReloadFromFirestore) {",
      "      print(",
      "          '[CategoryProvider][RELOAD] 🔄 Forcing reload from Firestore for franchise \"$franchiseId\"...');",
      "      _hasLoaded = false;",
      "    } else {",
      "      print(",
      "          '[CategoryProvider][RELOAD] ♻️ Reloading categories for franchise \"$franchiseId\"...');",
      "    }",
      "",
      "    await loadCategories(franchiseId,",
      "        forceReloadFromFirestore: forceReloadFromFirestore);",
      "  }",
      "",
      "  Future<void> loadCategories(",
      "    String franchiseId, {",
      "    bool forceReloadFromFirestore = false,",
      "  }) async {",
      "    print('[CategoryProvider][LOAD] Incoming franchiseId=\"$franchiseId\"');",
      "",
      "    // 🔹 If caller passed blank/unknown, try to use the last loaded franchise ID",
      "    if (franchiseId.isEmpty || franchiseId == 'unknown') {",
      "      if (_loadedFranchiseId != null && _loadedFranchiseId!.isNotEmpty) {",
      "        print(",
      "          '[CategoryProvider][LOAD] ℹ️ Using cached franchiseId=\"$_loadedFranchiseId\" since incoming was blank/unknown.',",
      "        );",
      "        franchiseId = _loadedFranchiseId!;",
      "      }",
      "    }",
      "",
      "    // 🔹 Still invalid? bail and log",
      "    if (franchiseId.isEmpty || franchiseId == 'unknown') {",
      "      print('[CategoryProvider][LOAD] ⚠️ No valid franchiseId. Skipping load.');",
      "      await ErrorLogger.log(",
      "        message: 'CategoryProvider: load called with blank/unknown franchiseId',",
      "        stack: '',",
      "        source: 'category_provider.dart',",
      "        screen: 'category_provider.dart',",
      "        severity: 'warning',",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      return;",
      "    }",
      "",
      "    // 🔹 Skip if already loaded for this franchise and no force reload",
      "    if (_hasLoaded &&",
      "        _loadedFranchiseId == franchiseId &&",
      "        !forceReloadFromFirestore) {",
      "      print(",
      "        '[CategoryProvider][LOAD] ✅ Already loaded for \"$franchiseId\". Skipping fetch.',",
      "      );",
      "      return;",
      "    }",
      "",
      "    try {",
      "      print(",
      "        '[CategoryProvider][LOAD] 📡 Fetching categories for franchise \"$franchiseId\"...',",
      "      );",
      "      final fetched = await firestore.fetchCategories(franchiseId);",
      "",
      "      print('[CategoryProvider][LOAD] ✅ Fetched ${fetched.length} categories.');",
      "      for (final category in fetched) {",
      "        print('    • id=\"${category.id}\", name=\"${category.name}\"');",
      "      }",
      "",
      "      _categories",
      "        ..clear()",
      "        ..addAll(fetched);",
      "",
      "      _hasLoaded = true;",
      "      _loadedFranchiseId = franchiseId;",
      "",
      "      notifyListeners();",
      "    } catch (e, stack) {",
      "      print('[CategoryProvider][LOAD][ERROR] ❌ Failed to load categories: $e');",
      "      await ErrorLogger.log(",
      "        message: 'category_load_error',",
      "        stack: stack.toString(),",
      "        source: 'category_provider.dart',",
      "        screen: 'category_provider.dart',",
      "        severity: 'error',",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Uniform loader used by the review screen.",
      "  /// If [forceReloadFromFirestore] is false and data is warm, this is a no-op.",
      "  Future<void> load(",
      "      {bool forceReloadFromFirestore = false,",
      "      String? franchiseIdOverride}) async {",
      "    if (franchiseIdOverride != null &&",
      "        franchiseIdOverride.isNotEmpty &&",
      "        franchiseIdOverride != franchiseId) {",
      "      franchiseId = franchiseIdOverride;",
      "    }",
      "    print('[CategoryProvider - load] Incoming franchiseId=\"$franchiseId\"');",
      "    if (franchiseId.isEmpty || franchiseId == 'unknown') {",
      "      debugPrint(",
      "          '[CategoryProvider][load] ⚠️ Skipping load: empty/unknown franchiseId.');",
      "      return;",
      "    }",
      "",
      "    if (_hasLoaded && !forceReloadFromFirestore) {",
      "      debugPrint(",
      "          '[CategoryProvider][load] 🔁 Using warm cache (categories=${_current.length}).');",
      "      return;",
      "    }",
      "",
      "    await loadCategories(franchiseId,",
      "        forceReloadFromFirestore: forceReloadFromFirestore);",
      "  }",
      "",
      "  Future<void> saveCategories() async {",
      "    try {",
      "      await firestore.saveAllCategories(franchiseId, _current);",
      "      _original = List.from(_current);",
      "      notifyListeners();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to save categories',",
      "        stack: stack.toString(),",
      "        source: 'CategoryProvider',",
      "        screen: 'onboarding_categories_screen',",
      "        severity: 'error',",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  void addOrUpdateCategory(Category category) {",
      "    final index = _current.indexWhere((c) => c.id == category.id);",
      "    if (index != -1) {",
      "      _current[index] = category;",
      "    } else {",
      "      _current.add(category);",
      "    }",
      "    notifyListeners();",
      "  }",
      "",
      "  Future<void> deleteCategory(String categoryId) async {",
      "    try {",
      "      await firestore.deleteCategory(",
      "          franchiseId: franchiseId, categoryId: categoryId);",
      "      await loadCategories(franchiseId,",
      "          forceReloadFromFirestore:",
      "              true); // ⬅️ Forces Firestore re-fetch, like ingredients",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'category_deletion_failed',",
      "        stack: stack.toString(),",
      "        source: 'CategoryProvider',",
      "        screen: 'onboarding_categories_screen',",
      "        severity: 'error',",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "          'categoryId': categoryId,",
      "        },",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  Future<void> bulkDeleteCategoriesFromFirestore(List<String> ids) async {",
      "    try {",
      "      final batch = firestore.db.batch();",
      "      final colRef = firestore.db",
      "          .collection('franchises')",
      "          .doc(franchiseId)",
      "          .collection('categories');",
      "",
      "      for (final id in ids) {",
      "        batch.delete(colRef.doc(id));",
      "      }",
      "",
      "      await batch.commit();",
      "",
      "      await loadCategories(franchiseId, forceReloadFromFirestore: true);",
      "      // 🔁 reload after deletion",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'bulk_delete_categories_failed',",
      "        stack: stack.toString(),",
      "        source: 'CategoryProvider',",
      "        screen: 'onboarding_categories_screen',",
      "        severity: 'error',",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "          'deletedCount': ids.length,",
      "        },",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  void reorderCategories(int oldIndex, int newIndex) {",
      "    if (oldIndex < newIndex) newIndex -= 1;",
      "    final item = _current.removeAt(oldIndex);",
      "    _current.insert(newIndex, item);",
      "    _applySortOrder();",
      "    notifyListeners();",
      "  }",
      "",
      "  void _applySortOrder() {",
      "    for (int i = 0; i < _current.length; i++) {",
      "      _current[i] = _current[i].copyWith(sortOrder: i);",
      "    }",
      "  }",
      "",
      "  void toggleSelection(String categoryId) {",
      "    if (_selectedCategoryIds.contains(categoryId)) {",
      "      _selectedCategoryIds.remove(categoryId);",
      "    } else {",
      "      _selectedCategoryIds.add(categoryId);",
      "    }",
      "    notifyListeners();",
      "  }",
      "",
      "  void clearSelection() {",
      "    _selectedCategoryIds.clear();",
      "    notifyListeners();",
      "  }",
      "",
      "  void deleteSelected() {",
      "    _current.removeWhere((c) => _selectedCategoryIds.contains(c.id));",
      "    _selectedCategoryIds.clear();",
      "    notifyListeners();",
      "  }",
      "",
      "  void revertChanges() {",
      "    _current = List.from(_original);",
      "    _selectedCategoryIds.clear();",
      "    notifyListeners();",
      "  }",
      "",
      "  void updateFranchiseId(String newId) {",
      "    if (newId != franchiseId && newId.isNotEmpty) {",
      "      franchiseId = newId;",
      "      // Defer to next frame to avoid build cycle errors",
      "      WidgetsBinding.instance.addPostFrameCallback((_) {",
      "        loadCategories(franchiseId, forceReloadFromFirestore: true);",
      "      });",
      "    }",
      "  }",
      "",
      "  Future<void> bulkImportCategories(List<Category> imported) async {",
      "    _current = List.from(imported);",
      "    _applySortOrder();",
      "    notifyListeners();",
      "  }",
      "",
      "  String exportAsJson() {",
      "    final encoded = _current.map((c) => c.toFirestore()).toList();",
      "    return Category.encodeJson(encoded);",
      "  }",
      "",
      "  Category? getCategoryById(String id) {",
      "    return _current.firstWhereOrNull((c) => c.id == id);",
      "  }",
      "",
      "  Future<void> loadTemplate(String templateId) async {",
      "    try {",
      "      final snapshot = await firestore.db",
      "          .collection('onboarding_templates')",
      "          .doc(templateId)",
      "          .collection('categories')",
      "          .get();",
      "",
      "      final imported = snapshot.docs.map((doc) {",
      "        final data = doc.data();",
      "        final id = doc.id;",
      "        return Category.fromFirestore(data, id);",
      "      }).toList();",
      "",
      "      _current = imported;",
      "      _applySortOrder();",
      "      notifyListeners();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'category_template_load_failed',",
      "        stack: stack.toString(),",
      "        source: 'CategoryProvider',",
      "        screen: 'onboarding_categories_screen',",
      "        severity: 'error',",
      "        contextData: {",
      "          'templateId': templateId,",
      "          'franchiseId': franchiseId,",
      "        },",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Returns a map of all category IDs to names.",
      "  Map<String, String> get categoryIdToName =>",
      "      Map.fromEntries(categories.map((c) => MapEntry(c.id, c.name)));",
      "",
      "  /// Returns a list of all available category IDs.",
      "  List<String> get allCategoryIds => categories.map((c) => c.id).toList();",
      "",
      "  /// Returns a list of all available category names.",
      "  List<String> get allCategoryNames => categories.map((c) => c.name).toList();",
      "",
      "  /// Find a category by name (case-insensitive, trimmed).",
      "  Category? getByName(String name) {",
      "    return categories.firstWhereOrNull(",
      "        (c) => c.name.trim().toLowerCase() == name.trim().toLowerCase());",
      "  }",
      "",
      "  /// Find a category by ID (case-insensitive).",
      "  Category? getByIdCaseInsensitive(String id) {",
      "    return categories",
      "        .firstWhereOrNull((c) => c.id.toLowerCase() == id.toLowerCase());",
      "  }",
      "",
      "  /// schema issue sidebar methods to add, discard and stage categories",
      "  void stageCategory(Category category) {",
      "    final alreadyStaged = _stagedCategories.any((c) => c.id == category.id);",
      "    final alreadyInCurrent = _current.any((c) => c.id == category.id);",
      "",
      "    debugPrint('[CategoryProvider] stageCategory called: '",
      "        'id=${category.id}, name=${category.name}, '",
      "        'alreadyStaged=$alreadyStaged, alreadyInCurrent=$alreadyInCurrent');",
      "",
      "    if (alreadyStaged || alreadyInCurrent) {",
      "      debugPrint('[CategoryProvider] Not staging: already exists.');",
      "      return;",
      "    }",
      "",
      "    _stagedCategories.add(category);",
      "    _current.add(category);",
      "",
      "    debugPrint('[CategoryProvider] Staged new category: '",
      "        'id=${category.id}, name=${category.name}. '",
      "        'StagedCategories=${_stagedCategories.length}, Current=${_current.length}');",
      "    notifyListeners();",
      "  }",
      "",
      "  Future<void> saveStagedCategories() async {",
      "    try {",
      "      final colRef = firestore.db",
      "          .collection('franchises')",
      "          .doc(franchiseId)",
      "          .collection('categories');",
      "",
      "      final batch = firestore.db.batch();",
      "",
      "      for (final category in _stagedCategories) {",
      "        batch.set(colRef.doc(category.id), category.toFirestore());",
      "      }",
      "      print(",
      "          '[CategoryProvider] Persisting ${_stagedCategories.length} categories');",
      "",
      "      await batch.commit();",
      "      _original = List.from(_current);",
      "      _stagedCategories.clear();",
      "      notifyListeners();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'category_stage_save_failed',",
      "        stack: stack.toString(),",
      "        source: 'CategoryProvider',",
      "        screen: 'onboarding_categories_screen',",
      "        severity: 'error',",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  void discardStagedCategories() {",
      "    for (final cat in _stagedCategories) {",
      "      _current.removeWhere((c) => c.id == cat.id);",
      "    }",
      "    _stagedCategories.clear();",
      "    print('[ProviderName] Discarded staged items: '",
      "        'count=${_stagedCategories.length} before clearing');",
      "",
      "    notifyListeners();",
      "  }",
      "",
      "  bool get hasStagedCategoryChanges => _stagedCategories.isNotEmpty;",
      "  List<Category> get stagedCategories => List.unmodifiable(_stagedCategories);",
      "",
      "  /// Attempts to stage a new category if it doesn't already exist in Firestore or staged memory.",
      "  /// Returns true if the category was staged, false if it already exists.",
      "  bool stageIfNew({required String id, required String name}) {",
      "    final alreadyExists = _current.any((c) => c.id == id) ||",
      "        _stagedCategories.any((c) => c.id == id);",
      "",
      "    if (!alreadyExists) {",
      "      final newCat = Category(",
      "        id: id,",
      "        name: name,",
      "        sortOrder: _current.length,",
      "      );",
      "      stageCategory(newCat);",
      "      debugPrint('[CategoryProvider] stageIfNew -> Staged new category: '",
      "          'id=${newCat.id}, name=${newCat.name}');",
      "      return true;",
      "    }",
      "",
      "    debugPrint('[CategoryProvider] Category already exists: $id');",
      "    return false;",
      "  }",
      "",
      "  Future<List<OnboardingValidationIssue>> validate({",
      "    List<String>? referencedCategoryIds, // For checking unused/in-use",
      "  }) async {",
      "    final issues = <OnboardingValidationIssue>[];",
      "    try {",
      "      final categoryNames = <String>{};",
      "      for (final cat in _current) {",
      "        // Uniqueness",
      "        if (!categoryNames.add(cat.name.trim().toLowerCase())) {",
      "          issues.add(OnboardingValidationIssue(",
      "            section: 'Categories',",
      "            itemId: cat.id,",
      "            itemDisplayName: cat.name,",
      "            severity: OnboardingIssueSeverity.critical,",
      "            code: 'DUPLICATE_CATEGORY_NAME',",
      "            message: \"Duplicate category name: '${cat.name}'.\",",
      "            affectedFields: ['name'],",
      "            isBlocking: true,",
      "            fixRoute: '/onboarding/categories',",
      "            itemLocator: cat.id,",
      "            resolutionHint: \"All category names must be unique.\",",
      "            actionLabel: \"Fix Now\",",
      "            icon: Icons.label_important,",
      "            detectedAt: DateTime.now(),",
      "            contextData: {",
      "              'category': cat.toFirestore(),",
      "            },",
      "          ));",
      "        }",
      "      }",
      "      // Required: at least one category",
      "      if (_current.isEmpty) {",
      "        issues.add(OnboardingValidationIssue(",
      "          section: 'Categories',",
      "          itemId: '',",
      "          itemDisplayName: '',",
      "          severity: OnboardingIssueSeverity.critical,",
      "          code: 'NO_CATEGORIES_DEFINED',",
      "          message: \"At least one menu category must be defined.\",",
      "          affectedFields: ['categories'],",
      "          isBlocking: true,",
      "          fixRoute: '/onboarding/categories',",
      "          resolutionHint: \"Add at least one category.\",",
      "          actionLabel: \"Add Category\",",
      "          icon: Icons.add_box_outlined,",
      "          detectedAt: DateTime.now(),",
      "        ));",
      "      }",
      "",
      "      // (Optional) Unused category warning",
      "      if (referencedCategoryIds != null) {",
      "        for (final cat in _current) {",
      "          if (!referencedCategoryIds.contains(cat.id)) {",
      "            issues.add(OnboardingValidationIssue(",
      "              section: 'Categories',",
      "              itemId: cat.id,",
      "              itemDisplayName: cat.name,",
      "              severity: OnboardingIssueSeverity.warning,",
      "              code: 'UNUSED_CATEGORY',",
      "              message: \"Category '${cat.name}' is not used by any menu item.\",",
      "              affectedFields: [],",
      "              isBlocking: false,",
      "              fixRoute: '/onboarding/categories',",
      "              itemLocator: cat.id,",
      "              resolutionHint: \"Consider removing unused categories.\",",
      "              actionLabel: \"Review\",",
      "              icon: Icons.info_outline,",
      "              detectedAt: DateTime.now(),",
      "            ));",
      "          }",
      "        }",
      "      }",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'category_validate_failed',",
      "        stack: stack.toString(),",
      "        source: 'CategoryProvider.validate',",
      "        severity: 'error',",
      "        contextData: {},",
      "      );",
      "    }",
      "    return issues;",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 583,
      "file_size": 19196,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\providers\\franchisee_invitation_provider.dart",
    "content": [
      "// File: lib/core/providers/franchisee_invitation_provider.dart",
      "",
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/core/models/franchisee_invitation.dart';",
      "import 'package:franchise_admin_portal/widgets/financials/franchisee_invitation_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:cloud_functions/cloud_functions.dart';",
      "",
      "/// Provider for Franchisee Invitations. Owns invitation state, exposes",
      "/// all major actions (invite, cancel, delete, refresh, etc.).",
      "/// UI may use this as a ChangeNotifierProvider.",
      "class FranchiseeInvitationProvider with ChangeNotifier {",
      "  final FranchiseeInvitationService service;",
      "",
      "  List<FranchiseeInvitation> _invitations = [];",
      "  bool _loading = false;",
      "  String? _lastError;",
      "",
      "  List<FranchiseeInvitation> get invitations => _invitations;",
      "  bool get loading => _loading;",
      "  String? get lastError => _lastError;",
      "",
      "  // Optionally filter (status, inviter, etc.) for future extension",
      "  String? _filterStatus;",
      "",
      "  // Stream subscription handle for live updates",
      "  Stream<List<FranchiseeInvitation>>? _subscription;",
      "  VoidCallback? _cancelSubscription;",
      "",
      "  FranchiseeInvitationProvider({required this.service});",
      "",
      "  // === State Management ===",
      "",
      "  /// Start listening to all invitations (for real-time UI updates).",
      "  void subscribeInvitations({String? status, String? inviterUserId}) {",
      "    _filterStatus = status;",
      "    _cancelSubscription?.call(); // Cancel any existing sub",
      "    _subscription = service.invitationsStream(",
      "      status: status,",
      "      inviterUserId: inviterUserId,",
      "    );",
      "    final sub = _subscription!.listen((list) {",
      "      _invitations = list;",
      "      notifyListeners();",
      "    }, onError: (e, stack) async {",
      "      _lastError = e.toString();",
      "      await ErrorLogger.log(",
      "        message: 'Subscription error in FranchiseeInvitationProvider',",
      "        stack: stack.toString(),",
      "        source: 'FranchiseeInvitationProvider.subscribeInvitations',",
      "        screen: 'FranchiseeInvitation',",
      "        contextData: {'exception': e.toString()},",
      "      );",
      "      notifyListeners();",
      "    });",
      "    _cancelSubscription = () => sub.cancel();",
      "  }",
      "",
      "  /// Stop listening to invitations (cleanup)",
      "  void unsubscribeInvitations() {",
      "    _cancelSubscription?.call();",
      "    _subscription = null;",
      "    _cancelSubscription = null;",
      "  }",
      "",
      "  /// One-time fetch (not streamed)",
      "  Future<void> fetchInvitations(",
      "      {String? status, String? inviterUserId, String? email}) async {",
      "    _loading = true;",
      "    _lastError = null;",
      "    notifyListeners();",
      "    try {",
      "      _invitations = await service.fetchInvitations(",
      "        status: status ?? _filterStatus,",
      "        inviterUserId: inviterUserId,",
      "        email: email,",
      "      );",
      "    } catch (e) {",
      "      _lastError = e.toString();",
      "    }",
      "    _loading = false;",
      "    notifyListeners();",
      "  }",
      "",
      "  /// Fetch invitation by Firestore doc ID (for dialog/detail screens)",
      "  Future<FranchiseeInvitation?> fetchInvitationById(String id) async {",
      "    try {",
      "      return await service.fetchInvitationById(id);",
      "    } catch (e) {",
      "      _lastError = e.toString();",
      "      notifyListeners();",
      "      return null;",
      "    }",
      "  }",
      "",
      "  // === Invitation Actions ===",
      "  bool sending = false;",
      "  Future<void> sendInvitation({",
      "    required String email,",
      "    required String franchiseName,",
      "    required String role,",
      "    String? notes,",
      "  }) async {",
      "    sending = true;",
      "    notifyListeners();",
      "",
      "    final HttpsCallable inviteFn =",
      "        FirebaseFunctions.instance.httpsCallable('inviteAndSetRole');",
      "",
      "    try {",
      "      final result = await inviteFn.call({",
      "        'email': email,",
      "        'franchiseName': franchiseName,",
      "        'role': role,",
      "        if (notes != null) 'notes': notes,",
      "        // Optionally provide a default password for new users if your function requires",
      "        // 'password': 'SetRandomlyOrGenerateOnUI',",
      "      });",
      "",
      "      // Refresh invitation list",
      "      await fetchInvitations();",
      "      // You can also handle success (e.g. store result if needed)",
      "    } on FirebaseFunctionsException catch (e, stack) {",
      "      // Optionally: handle different error codes/types",
      "      // Use your error logger",
      "      await ErrorLogger.log(",
      "        message: 'Failed to send invitation',",
      "        stack: stack.toString(),",
      "        severity: 'error',",
      "        source: 'FranchiseeInvitationProvider.sendInvitation',",
      "        screen: 'PlatformOwnerDashboardScreen',",
      "        contextData: {",
      "          'exception': e.toString(),",
      "          'email': email,",
      "          'franchiseName': franchiseName,",
      "          'role': role,",
      "        },",
      "      );",
      "      rethrow;",
      "    } finally {",
      "      sending = false;",
      "      notifyListeners();",
      "    }",
      "  }",
      "",
      "  /// Send a new invite (calls cloud function)",
      "  Future<bool> inviteFranchisee({",
      "    required String email,",
      "    required String role,",
      "    required String inviterUserId,",
      "    String? franchiseName,",
      "    String? password,",
      "    Map<String, dynamic>? extraData,",
      "  }) async {",
      "    _loading = true;",
      "    _lastError = null;",
      "    notifyListeners();",
      "    try {",
      "      await service.inviteFranchisee(",
      "        email: email,",
      "        role: role,",
      "        inviterUserId: inviterUserId,",
      "        franchiseName: franchiseName,",
      "        password: password,",
      "        extraData: extraData,",
      "      );",
      "      _loading = false;",
      "      await fetchInvitations(); // Refresh",
      "      return true;",
      "    } catch (e, stack) {",
      "      _lastError = e.toString();",
      "      await ErrorLogger.log(",
      "        message: 'Failed to invite franchisee',",
      "        stack: stack.toString(),",
      "        source: 'FranchiseeInvitationProvider.inviteFranchisee',",
      "        screen: 'FranchiseeInvitation',",
      "        contextData: {",
      "          'email': email,",
      "          'role': role,",
      "          'exception': e.toString(),",
      "        },",
      "      );",
      "      _loading = false;",
      "      notifyListeners();",
      "      return false;",
      "    }",
      "  }",
      "",
      "  /// Update invitation meta (admin-only)",
      "  Future<bool> updateInvitation(String id, Map<String, dynamic> data) async {",
      "    _loading = true;",
      "    _lastError = null;",
      "    notifyListeners();",
      "    try {",
      "      await service.updateInvitation(id, data);",
      "      await fetchInvitations(); // Refresh",
      "      _loading = false;",
      "      return true;",
      "    } catch (e, stack) {",
      "      _lastError = e.toString();",
      "      await ErrorLogger.log(",
      "        message: 'Failed to update invitation',",
      "        stack: stack.toString(),",
      "        source: 'FranchiseeInvitationProvider.updateInvitation',",
      "        screen: 'FranchiseeInvitation',",
      "        contextData: {'id': id, 'data': data, 'exception': e.toString()},",
      "      );",
      "      _loading = false;",
      "      notifyListeners();",
      "      return false;",
      "    }",
      "  }",
      "",
      "  /// Cancel/revoke an invitation (soft-cancel)",
      "  Future<bool> cancelInvitation(String id, {String? revokedByUserId}) async {",
      "    _loading = true;",
      "    _lastError = null;",
      "    notifyListeners();",
      "    try {",
      "      await service.cancelInvitation(id, revokedByUserId: revokedByUserId);",
      "      await fetchInvitations(); // Refresh",
      "      _loading = false;",
      "      return true;",
      "    } catch (e, stack) {",
      "      _lastError = e.toString();",
      "      await ErrorLogger.log(",
      "        message: 'Failed to cancel invitation',",
      "        stack: stack.toString(),",
      "        source: 'FranchiseeInvitationProvider.cancelInvitation',",
      "        screen: 'FranchiseeInvitation',",
      "        contextData: {'id': id, 'exception': e.toString()},",
      "      );",
      "      _loading = false;",
      "      notifyListeners();",
      "      return false;",
      "    }",
      "  }",
      "",
      "  /// Delete invitation (hard delete)",
      "  Future<bool> deleteInvitation(String id) async {",
      "    _loading = true;",
      "    _lastError = null;",
      "    notifyListeners();",
      "    try {",
      "      await service.deleteInvitation(id);",
      "      await fetchInvitations(); // Refresh",
      "      _loading = false;",
      "      return true;",
      "    } catch (e, stack) {",
      "      _lastError = e.toString();",
      "      await ErrorLogger.log(",
      "        message: 'Failed to delete invitation',",
      "        stack: stack.toString(),",
      "        source: 'FranchiseeInvitationProvider.deleteInvitation',",
      "        screen: 'FranchiseeInvitation',",
      "        contextData: {'id': id, 'exception': e.toString()},",
      "      );",
      "      _loading = false;",
      "      notifyListeners();",
      "      return false;",
      "    }",
      "  }",
      "",
      "  /// Expire invitation (for auto-expiry or admin)",
      "  Future<bool> expireInvitation(String id) async {",
      "    _loading = true;",
      "    _lastError = null;",
      "    notifyListeners();",
      "    try {",
      "      await service.expireInvitation(id);",
      "      await fetchInvitations();",
      "      _loading = false;",
      "      return true;",
      "    } catch (e, stack) {",
      "      _lastError = e.toString();",
      "      await ErrorLogger.log(",
      "        message: 'Failed to expire invitation',",
      "        stack: stack.toString(),",
      "        source: 'FranchiseeInvitationProvider.expireInvitation',",
      "        screen: 'FranchiseeInvitation',",
      "        contextData: {'id': id, 'exception': e.toString()},",
      "      );",
      "      _loading = false;",
      "      notifyListeners();",
      "      return false;",
      "    }",
      "  }",
      "",
      "  /// Mark as re-sent (meta only; actual email/cloud function should be called separately)",
      "  Future<bool> markInvitationResent(String id) async {",
      "    _loading = true;",
      "    _lastError = null;",
      "    notifyListeners();",
      "    try {",
      "      await service.markInvitationResent(id);",
      "      await fetchInvitations();",
      "      _loading = false;",
      "      return true;",
      "    } catch (e, stack) {",
      "      _lastError = e.toString();",
      "      await ErrorLogger.log(",
      "        message: 'Failed to mark invitation as re-sent',",
      "        stack: stack.toString(),",
      "        source: 'FranchiseeInvitationProvider.markInvitationResent',",
      "        screen: 'FranchiseeInvitation',",
      "        contextData: {'id': id, 'exception': e.toString()},",
      "      );",
      "      _loading = false;",
      "      notifyListeners();",
      "      return false;",
      "    }",
      "  }",
      "",
      "  // === Developer-only Debug Utilities ===",
      "  @visibleForTesting",
      "  Future<void> devClearInvitations() async {",
      "    // For testing only! Use with care.",
      "    for (final invite in _invitations) {",
      "      await deleteInvitation(invite.id);",
      "    }",
      "    await fetchInvitations();",
      "  }",
      "",
      "  // === Future Feature Placeholders ===",
      "  /// Bulk invite (planned feature)",
      "  Future<void> bulkInviteFranchisees(",
      "      List<Map<String, dynamic>> inviteDataList) async {",
      "    throw UnimplementedError('Bulk invite is not implemented yet.');",
      "  }",
      "",
      "  /// Export invitations (planned feature)",
      "  Future<void> exportInvitations() async {",
      "    throw UnimplementedError('Export invitations is not implemented yet.');",
      "  }",
      "",
      "  @override",
      "  void dispose() {",
      "    unsubscribeInvitations();",
      "    super.dispose();",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 341,
      "file_size": 10603,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\providers\\franchise_feature_provider.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/core/models/feature_metadata.dart'",
      "    show FeatureState;",
      "import 'package:franchise_admin_portal/core/models/feature_module.dart';",
      "import 'package:franchise_admin_portal/core/services/franchise_feature_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/core/models/onboarding_validation_issue.dart';",
      "",
      "class FranchiseFeatureProvider with ChangeNotifier {",
      "  final FranchiseFeatureService _service;",
      "  String _franchiseId;",
      "  String get currentFranchiseId => _franchiseId;",
      "",
      "  FranchiseFeatureProvider({",
      "    required FranchiseFeatureService service,",
      "    required String franchiseId,",
      "  })  : _service = service,",
      "        _franchiseId = franchiseId;",
      "",
      "  /// ✅ Features granted by the subscription",
      "  final Set<String> _availableFeatures = {};",
      "",
      "  /// ✅ Structured metadata (what the user has opted to enable)",
      "  FeatureState _featureMetadata = FeatureState(",
      "    modules: {},",
      "    liveSnapshotEnabled: false,",
      "  );",
      "",
      "  /// ⏳ Initialization state",
      "  bool _isInitialized = false;",
      "",
      "  bool get isInitialized => _isInitialized;",
      "",
      "  Set<String> get allGrantedFeatures => _availableFeatures;",
      "",
      "  FeatureState get featureMetadata => _featureMetadata;",
      "",
      "  bool _liveSnapshotEnabled = false;",
      "  bool get liveSnapshotEnabled => _liveSnapshotEnabled;",
      "",
      "  Future<void> loadLiveSnapshotFlag(String franchiseId) async {",
      "    try {",
      "      _liveSnapshotEnabled = await _service.isLiveSnapshotEnabled(franchiseId);",
      "      debugPrint(",
      "          '[FranchiseFeatureProvider] liveSnapshotEnabled set to $_liveSnapshotEnabled');",
      "      notifyListeners();",
      "    } catch (e, st) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to load liveSnapshotEnabled flag',",
      "        stack: st.toString(),",
      "        source: 'FranchiseFeatureProvider.loadLiveSnapshotFlag',",
      "        severity: 'error',",
      "        screen: 'franchise_feature_provider.dart',",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "    }",
      "  }",
      "",
      "  void setLiveSnapshotEnabled(bool value) {",
      "    if (_featureMetadata.liveSnapshotEnabled == value) return;",
      "",
      "    debugPrint('[FranchiseFeatureProvider] liveSnapshotEnabled changing from '",
      "        '${_featureMetadata.liveSnapshotEnabled} → $value');",
      "",
      "    // Update local state",
      "    _featureMetadata = FeatureState(",
      "      modules: _featureMetadata.modules,",
      "      liveSnapshotEnabled: value,",
      "    );",
      "    _liveSnapshotEnabled = value;",
      "    notifyListeners();",
      "",
      "    // Persist to Firestore instantly",
      "    _service",
      "        .updateLiveSnapshotFlag(_franchiseId, value)",
      "        .catchError((e, st) async {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to persist liveSnapshotEnabled change',",
      "        stack: st.toString(),",
      "        source: 'FranchiseFeatureProvider.setLiveSnapshotEnabled',",
      "        severity: 'error',",
      "        screen: 'franchise_feature_provider.dart',",
      "        contextData: {",
      "          'franchiseId': _franchiseId,",
      "          'attemptedValue': value,",
      "        },",
      "      );",
      "    });",
      "",
      "    // Log to ErrorLogger for audit trail",
      "    ErrorLogger.log(",
      "      message: 'liveSnapshotEnabled flag updated locally and persisted',",
      "      source: 'FranchiseFeatureProvider.setLiveSnapshotEnabled',",
      "      severity: 'info',",
      "      screen: 'franchise_feature_provider.dart',",
      "      contextData: {",
      "        'franchiseId': _franchiseId,",
      "        'newValue': value,",
      "      },",
      "    );",
      "  }",
      "",
      "  /// Loads both subscription and Firestore feature metadata",
      "  Future<void> initialize() async {",
      "    final granted =",
      "        await _service.getGrantedFeaturesFromSubscription(_franchiseId);",
      "    final metadata = await _service.getFeatureMetadata(_franchiseId);",
      "    debugPrint(",
      "        '[FeatureProvider] initialize() called for franchiseId: $_franchiseId');",
      "    debugPrint('[FeatureProvider] granted: $granted');",
      "    debugPrint('[FeatureProvider] metadata keys: ${metadata?.modules.keys}');",
      "    _availableFeatures",
      "      ..clear()",
      "      ..addAll(granted);",
      "",
      "    // Inject default disabled modules if missing",
      "    final updated = <String, FeatureModule>{};",
      "    for (final entry in (metadata?.modules ?? {}).entries) {",
      "      updated[entry.key] = entry.value;",
      "    }",
      "",
      "    for (final granted in _availableFeatures) {",
      "      updated.putIfAbsent(",
      "        granted,",
      "        () => FeatureModule(enabled: false, features: {}),",
      "      );",
      "    }",
      "",
      "    _featureMetadata = FeatureState(",
      "      modules: updated,",
      "      liveSnapshotEnabled:",
      "          metadata?.liveSnapshotEnabled ?? _featureMetadata.liveSnapshotEnabled,",
      "    );",
      "    _liveSnapshotEnabled = _featureMetadata.liveSnapshotEnabled;",
      "",
      "    _isInitialized = true;",
      "    notifyListeners();",
      "  }",
      "",
      "  // -------------------------",
      "  // 🔍 Feature Checks",
      "  // -------------------------",
      "",
      "  bool hasFeature(String key) => _availableFeatures.contains(key);",
      "",
      "  /// True if the module is granted by plan and enabled",
      "  bool isModuleEnabled(String moduleKey) {",
      "    if (!hasFeature(moduleKey)) return false;",
      "    return _featureMetadata.modules[moduleKey]?.enabled ?? false;",
      "  }",
      "",
      "  /// True if the subfeature is granted and explicitly enabled",
      "  bool isSubfeatureEnabled(String moduleKey, String featureKey) {",
      "    if (!isModuleEnabled(moduleKey)) return false;",
      "    return _featureMetadata.modules[moduleKey]?.features[featureKey] ?? false;",
      "  }",
      "",
      "  /// Exposed safely for UI",
      "  FeatureModule? getModule(String moduleKey) {",
      "    return _featureMetadata.modules[moduleKey];",
      "  }",
      "",
      "  /// Indicates if module is unavailable due to plan tier",
      "  bool isModuleLocked(String moduleKey) => !hasFeature(moduleKey);",
      "",
      "  /// Indicates if subfeature is plan-granted but not enabled yet",
      "  bool isSubfeatureAvailableButDisabled(String moduleKey, String featureKey) {",
      "    return hasFeature(moduleKey) &&",
      "        (_featureMetadata.modules[moduleKey]?.features[featureKey] == false);",
      "  }",
      "",
      "  // -------------------------",
      "  // 🛠️ Runtime Updaters",
      "  // -------------------------",
      "",
      "  void setModuleEnabled(String moduleKey, bool enabled) {",
      "    final existing = _featureMetadata.modules[moduleKey];",
      "    _featureMetadata.modules[moduleKey] =",
      "        (existing ?? FeatureModule(enabled: false, features: {}))",
      "            .copyWith(enabled: enabled);",
      "    notifyListeners();",
      "  }",
      "",
      "  void toggleSubfeature(String moduleKey, String featureKey, bool enabled) {",
      "    debugPrint('[FeatureProvider] Toggling $moduleKey.$featureKey -> $enabled');",
      "",
      "    if (featureKey == 'enabled') {",
      "      setModuleEnabled(moduleKey, enabled);",
      "      return;",
      "    }",
      "",
      "    final existing = _featureMetadata.modules[moduleKey];",
      "    if (existing != null) {",
      "      existing.features[featureKey] = enabled;",
      "    } else {",
      "      _featureMetadata.modules[moduleKey] =",
      "          FeatureModule(enabled: true, features: {featureKey: enabled});",
      "    }",
      "    notifyListeners();",
      "  }",
      "",
      "  void setFeatureMetadata(FeatureState metadata) {",
      "    _featureMetadata = FeatureState(",
      "      modules: metadata.modules,",
      "      liveSnapshotEnabled:",
      "          metadata.liveSnapshotEnabled ?? _featureMetadata.liveSnapshotEnabled,",
      "    );",
      "    _liveSnapshotEnabled = _featureMetadata.liveSnapshotEnabled;",
      "    debugPrint('[FranchiseFeatureProvider] setFeatureMetadata: '",
      "        'liveSnapshotEnabled=${_featureMetadata.liveSnapshotEnabled}');",
      "    notifyListeners();",
      "  }",
      "",
      "  void clearAll() {",
      "    _featureMetadata = FeatureState(",
      "      modules: {},",
      "      liveSnapshotEnabled: false,",
      "    );",
      "    _liveSnapshotEnabled = false;",
      "    debugPrint(",
      "        '[FranchiseFeatureProvider] clearAll() → liveSnapshotEnabled=false');",
      "    _availableFeatures.clear();",
      "    _isInitialized = false;",
      "    notifyListeners();",
      "  }",
      "",
      "  void setFranchiseId(String newId) {",
      "    if (newId.isNotEmpty && newId != _franchiseId) {",
      "      debugPrint('[FeatureProvider] setFranchiseId: $newId');",
      "      _franchiseId = newId;",
      "      _isInitialized = false;",
      "",
      "      Future.microtask(",
      "          () => initialize()); // ✅ Now re-fetches with correct franchiseId",
      "    }",
      "  }",
      "",
      "  /// Optional: persist to Firestore",
      "  /// Attempts to save the feature metadata to Firestore.",
      "  /// Returns true if the save succeeded (i.e., validated and persisted).",
      "  Future<bool> persistToFirestore() async {",
      "    return await _service.saveFeatureMetadata(",
      "      franchiseId: _franchiseId,",
      "      metadata: _featureMetadata,",
      "    );",
      "  }",
      "",
      "  /// Returns all subfeatures (with enabled state) for a given module.",
      "  Map<String, bool> getSubfeatures(String moduleKey) {",
      "    return _featureMetadata.modules[moduleKey]?.features ?? {};",
      "  }",
      "",
      "  /// getter for enabled modules",
      "  List<String> get enabledModuleKeys => _featureMetadata.modules.entries",
      "      .where((e) => e.value.enabled)",
      "      .map((e) => e.key)",
      "      .toList();",
      "",
      "  /// validate() method checking for enabled modules",
      "  Future<List<OnboardingValidationIssue>> validate() async {",
      "    final issues = <OnboardingValidationIssue>[];",
      "    try {",
      "      // Require Menu Management to be enabled",
      "      if (!enabledModuleKeys.contains('menu_management')) {",
      "        issues.add(OnboardingValidationIssue(",
      "          section: 'Features',",
      "          itemId: '',",
      "          itemDisplayName: '',",
      "          severity: OnboardingIssueSeverity.critical,",
      "          code: 'MISSING_MENU_MANAGEMENT_FEATURE',",
      "          message:",
      "              \"Menu Management feature must be enabled to continue onboarding.\",",
      "          affectedFields: ['menu_management'],",
      "          isBlocking: true,",
      "          fixRoute: '/onboarding/feature_setup',",
      "          resolutionHint: \"Enable the Menu Management feature.\",",
      "          actionLabel: \"Fix Now\",",
      "          icon: Icons.build_outlined,",
      "          detectedAt: DateTime.now(),",
      "          contextData: {",
      "            'enabledFeatures': enabledModuleKeys,",
      "          },",
      "        ));",
      "      }",
      "      // ...add more enabled-feature checks as needed",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'franchise_feature_validate_failed',",
      "        stack: stack.toString(),",
      "        source: 'FranchiseFeatureProvider.validate',",
      "        severity: 'error',",
      "        contextData: {},",
      "      );",
      "    }",
      "    return issues;",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 297,
      "file_size": 10212,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\providers\\franchise_gate.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'franchise_selector.dart';",
      "import 'franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/models/user.dart' as admin_user;",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "",
      "class FranchiseGate extends StatelessWidget {",
      "  final Widget child;",
      "  const FranchiseGate({required this.child, super.key});",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final franchiseProvider = Provider.of<FranchiseProvider>(context);",
      "    final user = Provider.of<AdminUserProvider>(context).user;",
      "",
      "    if (user == null) {",
      "      print('[FranchiseGate] ⏳ Admin user not yet available.');",
      "      return const Scaffold(",
      "        body: Center(child: CircularProgressIndicator()),",
      "      );",
      "    }",
      "",
      "    final roles = user.roles;",
      "    final isFranchiseOptionalRole = roles.contains('platform_owner') ||",
      "        roles.contains('developer') ||",
      "        roles.contains('hq_owner');",
      "",
      "    print('[FranchiseGate] build() for ${child.runtimeType}');",
      "    print('[FranchiseGate] Roles: $roles');",
      "    print(",
      "        '[FranchiseGate] Franchise selected: ${franchiseProvider.isFranchiseSelected}');",
      "    print(",
      "        '[FranchiseGate] FranchiseProvider loading: ${franchiseProvider.loading}');",
      "",
      "    if (franchiseProvider.loading) {",
      "      return const Scaffold(",
      "        body: Center(child: CircularProgressIndicator()),",
      "      );",
      "    }",
      "",
      "    if (!franchiseProvider.isFranchiseSelected && !isFranchiseOptionalRole) {",
      "      return Scaffold(",
      "        body: FranchiseSelector(",
      "          onSelected: (id) => franchiseProvider.setFranchiseId(id),",
      "        ),",
      "      );",
      "    }",
      "",
      "    return child;",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 52,
      "file_size": 1739,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\providers\\franchise_info_provider.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "",
      "import 'package:franchise_admin_portal/core/models/franchise_info.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "",
      "class FranchiseInfoProvider extends ChangeNotifier {",
      "  final FirestoreService firestore;",
      "  final FranchiseProvider franchiseProvider;",
      "",
      "  FranchiseInfoProvider({",
      "    required this.firestore,",
      "    required this.franchiseProvider,",
      "  });",
      "",
      "  FranchiseInfo? _franchise;",
      "  bool _loading = false;",
      "",
      "  FranchiseInfo? get franchise => _franchise;",
      "  bool get loading => _loading;",
      "",
      "  /// Call this whenever the franchiseId changes.",
      "  Future<void> loadFranchiseInfo() async {",
      "    final fid = franchiseProvider.franchiseId;",
      "",
      "    if (fid == null || fid.isEmpty || fid == 'unknown') {",
      "      debugPrint(",
      "          '[FranchiseInfoProvider] Skipping load — invalid franchiseId: \"$fid\"');",
      "",
      "      if (_franchise != null) {",
      "        _franchise = null;",
      "        notifyListeners();",
      "      }",
      "      return;",
      "    }",
      "",
      "    if (_franchise?.id == fid) {",
      "      // Already loaded — skip",
      "      return;",
      "    }",
      "",
      "    _loading = true;",
      "    notifyListeners();",
      "",
      "    try {",
      "      debugPrint('[FranchiseInfoProvider] Loading franchise info for id=$fid');",
      "      final info = await firestore.getFranchiseInfo(fid);",
      "      _franchise = info;",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'FranchiseInfoProvider failed to load franchise: $e',",
      "        stack: stack.toString(),",
      "        source: 'FranchiseInfoProvider',",
      "        screen: 'global',",
      "        severity: 'error',",
      "        contextData: {'franchiseId': fid},",
      "      );",
      "      _franchise = null;",
      "    } finally {",
      "      _loading = false;",
      "      notifyListeners();",
      "    }",
      "  }",
      "",
      "  /// Reload franchise info (useful after sidebar repair/add-new flows)",
      "  Future<void> reload() async {",
      "    await loadFranchiseInfo();",
      "  }",
      "",
      "  void clear() {",
      "    _franchise = null;",
      "    _loading = false;",
      "    notifyListeners();",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 77,
      "file_size": 2187,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\providers\\franchise_provider.dart",
    "content": [
      "import 'package:flutter/foundation.dart';",
      "import 'package:shared_preferences/shared_preferences.dart';",
      "import 'package:franchise_admin_portal/core/models/user.dart' as admin_user;",
      "import 'package:franchise_admin_portal/core/models/franchise_info.dart';",
      "",
      "class FranchiseProvider extends ChangeNotifier {",
      "  VoidCallback? onFranchiseChanged;",
      "  String _franchiseId = 'unknown';",
      "  bool _loading = true;",
      "  admin_user.User? _adminUser;",
      "",
      "  String get franchiseId {",
      "    print('[FranchiseProvider] franchiseId getter: $_franchiseId');",
      "    return _franchiseId.isEmpty ? 'unknown' : _franchiseId;",
      "  }",
      "",
      "  bool get loading => _loading;",
      "  bool get isFranchiseSelected =>",
      "      _franchiseId != 'unknown' && _franchiseId.isNotEmpty;",
      "  admin_user.User? get adminUser => _adminUser;",
      "  bool get isDeveloper => _adminUser?.isDeveloper ?? false;",
      "",
      "  bool get hasValidFranchise =>",
      "      _franchiseId.isNotEmpty && _franchiseId != 'unknown';",
      "",
      "  FranchiseProvider() {",
      "    _loadFranchiseId();",
      "  }",
      "",
      "  /// Set the logged-in admin user context",
      "  void setAdminUser(admin_user.User? user) {",
      "    _adminUser = user;",
      "    notifyListeners();",
      "  }",
      "",
      "  /// Load franchiseId from local storage (used at boot or cold start)",
      "  Future<void> _loadFranchiseId() async {",
      "    _loading = true;",
      "    notifyListeners();",
      "    final prefs = await SharedPreferences.getInstance();",
      "    final id = prefs.getString('selectedFranchiseId');",
      "    if (id != null && id.isNotEmpty) {",
      "      _franchiseId = id;",
      "    } else {",
      "      _franchiseId = 'unknown';",
      "    }",
      "    _loading = false;",
      "    notifyListeners();",
      "  }",
      "",
      "  /// Lock access unless explicitly allowed or user is developer",
      "  Future<void> setFranchiseId(String id) async {",
      "    print(",
      "        '[FranchiseProvider] setFranchiseId called: new id=\"$id\" (was \"$_franchiseId\")');",
      "    if (id.isEmpty) return;",
      "    if (_franchiseId != id) {",
      "      _franchiseId = id;",
      "      notifyListeners();",
      "      if (onFranchiseChanged != null) onFranchiseChanged!();",
      "      final prefs = await SharedPreferences.getInstance();",
      "      await prefs.setString('selectedFranchiseId', id);",
      "    }",
      "  }",
      "",
      "  /// Use this at login to override franchiseId based on defaultFranchise",
      "  Future<void> setInitialFranchiseId(String id) async {",
      "    print('[FranchiseProvider] setInitialFranchiseId called: id=\"$id\"');",
      "",
      "    if (_franchiseId == id) {",
      "      print(",
      "          '[FranchiseProvider] setInitialFranchiseId: No change (already \"$id\"), skipping update.');",
      "      return;",
      "    }",
      "",
      "    _franchiseId = id;",
      "",
      "    final prefs = await SharedPreferences.getInstance();",
      "    final existing = prefs.getString('selectedFranchiseId');",
      "",
      "    if (existing != id) {",
      "      await prefs.setString('selectedFranchiseId', id);",
      "      print(",
      "          '[FranchiseProvider] setInitialFranchiseId: Saved to SharedPreferences: \"$id\"');",
      "    } else {",
      "      print(",
      "          '[FranchiseProvider] setInitialFranchiseId: Already persisted, skipping write.');",
      "    }",
      "",
      "    notifyListeners();",
      "    print(",
      "        '[FranchiseProvider] setInitialFranchiseId: Notified listeners. Current franchiseId=\"$id\"');",
      "  }",
      "",
      "  Future<void> clear() async {",
      "    print(",
      "        '[FranchiseProvider] clear() called: franchiseId and adminUser set to null/unknown');",
      "",
      "    _franchiseId = 'unknown';",
      "    _adminUser = null;",
      "    notifyListeners();",
      "    final prefs = await SharedPreferences.getInstance();",
      "    await prefs.remove('selectedFranchiseId');",
      "  }",
      "",
      "  List<FranchiseInfo> _allFranchises = [];",
      "",
      "  // Public getter for the franchise picker",
      "  List<FranchiseInfo> get allFranchises => List.unmodifiable(_allFranchises);",
      "",
      "  // Optionally, expose a way to set them (you might fetch from Firestore/API)",
      "  void setAllFranchises(List<FranchiseInfo> franchises) {",
      "    _allFranchises = franchises;",
      "    notifyListeners();",
      "  }",
      "",
      "  Future<void> initializeWithUser(admin_user.User user) async {",
      "    _adminUser = user;",
      "    final prefs = await SharedPreferences.getInstance();",
      "",
      "    // ✅ If _franchiseId already initialized, don't override",
      "    if (_franchiseId != null &&",
      "        _franchiseId != 'unknown' &&",
      "        _franchiseId!.isNotEmpty) {",
      "      print(",
      "          '[FranchiseProvider] initializeWithUser: Skipped — already set to $_franchiseId');",
      "      _loading = false;",
      "      notifyListeners();",
      "      return;",
      "    }",
      "",
      "    final storedId = prefs.getString('selectedFranchiseId');",
      "    if (storedId != null && storedId.isNotEmpty) {",
      "      _franchiseId = storedId;",
      "      print(",
      "          '[FranchiseProvider] initializeWithUser: Loaded from SharedPreferences: $_franchiseId');",
      "    } else if (user.defaultFranchise != null &&",
      "        user.defaultFranchise!.isNotEmpty) {",
      "      _franchiseId = user.defaultFranchise!;",
      "      await prefs.setString('selectedFranchiseId', _franchiseId);",
      "      print(",
      "          '[FranchiseProvider] initializeWithUser: Set from user.defaultFranchise: $_franchiseId');",
      "    } else {",
      "      _franchiseId = 'unknown';",
      "      print(",
      "          '[FranchiseProvider] initializeWithUser: No valid source, defaulting to \"unknown\"');",
      "    }",
      "",
      "    _loading = false;",
      "    notifyListeners();",
      "",
      "    print(",
      "        '[FranchiseProvider] Initialized franchiseId=$_franchiseId for user=${user.email}');",
      "    print(",
      "        '[FranchiseProvider] Final state: franchiseId=$_franchiseId, user roles=${user.roles}');",
      "  }",
      "",
      "  /// Filtered viewable franchises based on current user access",
      "  List<FranchiseInfo> get viewableFranchises {",
      "    if (_adminUser == null) return [];",
      "",
      "    // Platform Owner and Developer can see all",
      "    if (_adminUser!.isPlatformOwner || _adminUser!.isDeveloper) {",
      "      return _allFranchises;",
      "    }",
      "",
      "    // Everyone else is filtered to their allowed franchise IDs",
      "    final allowedIds = _adminUser!.franchiseIds;",
      "    return _allFranchises.where((f) => allowedIds.contains(f.id)).toList();",
      "  }",
      "",
      "  void clearFranchiseContext() {",
      "    _franchiseId = '';",
      "    _allFranchises = [];",
      "    _adminUser = null;",
      "    notifyListeners();",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 177,
      "file_size": 5995,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\providers\\franchise_selector.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "",
      "/// FranchiseSelector is a widget that displays all available franchises",
      "/// and allows the user to pick one. On selection, it calls [onSelected].",
      "class FranchiseSelector extends StatefulWidget {",
      "  final void Function(String franchiseId) onSelected;",
      "",
      "  const FranchiseSelector({required this.onSelected, super.key});",
      "",
      "  @override",
      "  State<FranchiseSelector> createState() => _FranchiseSelectorState();",
      "}",
      "",
      "class _FranchiseSelectorState extends State<FranchiseSelector> {",
      "  late Future<List<_FranchiseInfo>> _franchisesFuture;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _franchisesFuture = _fetchFranchises();",
      "  }",
      "",
      "  Future<List<_FranchiseInfo>> _fetchFranchises() async {",
      "    final snapshot =",
      "        await FirebaseFirestore.instance.collection('franchises').get();",
      "    return snapshot.docs.map((doc) {",
      "      // You can expand _FranchiseInfo as needed",
      "      return _FranchiseInfo(",
      "        id: doc.id,",
      "        name: doc.data()['displayName'] ?? doc.id,",
      "        logoUrl: doc.data()['logoUrl'],",
      "      );",
      "    }).toList();",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Scaffold(",
      "      appBar: AppBar(",
      "        title: const Text('Select Franchise'),",
      "        centerTitle: true,",
      "      ),",
      "      body: FutureBuilder<List<_FranchiseInfo>>(",
      "        future: _franchisesFuture,",
      "        builder: (context, snapshot) {",
      "          if (snapshot.connectionState == ConnectionState.waiting) {",
      "            return const Center(child: CircularProgressIndicator());",
      "          }",
      "          if (snapshot.hasError) {",
      "            return Center(",
      "              child: Padding(",
      "                padding: const EdgeInsets.all(24.0),",
      "                child: Column(",
      "                  mainAxisSize: MainAxisSize.min,",
      "                  children: [",
      "                    const Icon(Icons.error_outline,",
      "                        size: 48, color: Colors.redAccent),",
      "                    const SizedBox(height: 16),",
      "                    Text(",
      "                      'Failed to load franchises.\\n${snapshot.error}',",
      "                      textAlign: TextAlign.center,",
      "                    ),",
      "                    const SizedBox(height: 24),",
      "                    ElevatedButton.icon(",
      "                      icon: const Icon(Icons.refresh),",
      "                      label: const Text('Retry'),",
      "                      onPressed: () {",
      "                        setState(() {",
      "                          _franchisesFuture = _fetchFranchises();",
      "                        });",
      "                      },",
      "                    ),",
      "                  ],",
      "                ),",
      "              ),",
      "            );",
      "          }",
      "          final franchises = snapshot.data ?? [];",
      "          if (franchises.isEmpty) {",
      "            return const Center(",
      "              child: Text('No franchises available. Please contact support.'),",
      "            );",
      "          }",
      "",
      "// Insert 'All Franchises' at the top of the list.",
      "          final allFranchisesOption = _FranchiseInfo(",
      "            id: 'all',",
      "            name: 'All Franchises',",
      "            logoUrl: null,",
      "          );",
      "",
      "          final displayList = [allFranchisesOption, ...franchises];",
      "",
      "          return ListView.separated(",
      "            padding: const EdgeInsets.symmetric(vertical: 28, horizontal: 16),",
      "            itemCount: displayList.length,",
      "            separatorBuilder: (_, __) => const Divider(),",
      "            itemBuilder: (context, idx) {",
      "              final f = displayList[idx];",
      "              return ListTile(",
      "                leading: f.logoUrl != null",
      "                    ? CircleAvatar(backgroundImage: NetworkImage(f.logoUrl!))",
      "                    : idx == 0",
      "                        ? const CircleAvatar(child: Icon(Icons.all_inclusive))",
      "                        : const CircleAvatar(child: Icon(Icons.storefront)),",
      "                title: Text(f.name),",
      "                subtitle: Text(f.id),",
      "                onTap: () => widget.onSelected(f.id),",
      "                trailing: const Icon(Icons.chevron_right),",
      "                shape: RoundedRectangleBorder(",
      "                  borderRadius: BorderRadius.circular(12),",
      "                ),",
      "              );",
      "            },",
      "          );",
      "        },",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "/// Internal helper class for franchise display.",
      "/// You can expand this for more data fields as needed.",
      "class _FranchiseInfo {",
      "  final String id;",
      "  final String name;",
      "  final String? logoUrl;",
      "  _FranchiseInfo({required this.id, required this.name, this.logoUrl});",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 130,
      "file_size": 4597,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\providers\\franchise_subscription_provider.dart",
    "content": [
      "import 'dart:async';",
      "import 'package:flutter/foundation.dart';",
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/core/models/franchise_subscription_model.dart';",
      "import 'package:franchise_admin_portal/core/models/platform_plan_model.dart';",
      "import 'package:franchise_admin_portal/core/services/franchise_subscription_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class FranchiseSubscriptionNotifier extends ChangeNotifier {",
      "  final FranchiseSubscriptionService _service;",
      "  String _franchiseId;",
      "",
      "  FranchiseSubscription? _currentSubscription;",
      "  FranchiseSubscription? get currentSubscription => _currentSubscription;",
      "",
      "  PlatformPlan? _activePlatformPlan;",
      "  PlatformPlan? get activePlatformPlan => _activePlatformPlan;",
      "",
      "  bool _hasLoaded = false;",
      "  bool get hasLoaded => _hasLoaded;",
      "",
      "  String get franchiseId => _franchiseId;",
      "",
      "  StreamSubscription<FranchiseSubscription?>? _subscriptionStream;",
      "",
      "  // Guards",
      "  bool _planResolved = false;",
      "  bool _resolvingPlan = false;",
      "",
      "  // Role handling",
      "  List<String> _userRoles = [];",
      "  void setUserRoles(List<String> roles) {",
      "    _userRoles = roles;",
      "  }",
      "",
      "  FranchiseSubscriptionNotifier({",
      "    required FranchiseSubscriptionService service,",
      "    required String franchiseId,",
      "  })  : _service = service,",
      "        _franchiseId = franchiseId {",
      "    if (_shouldTrackSubscription(franchiseId)) {",
      "      _initSubscription(franchiseId);",
      "    }",
      "  }",
      "",
      "  bool _shouldTrackSubscription(String franchiseId) {",
      "    return franchiseId.isNotEmpty &&",
      "        franchiseId != 'unknown' &&",
      "        !_userRoles.contains('platform_owner') &&",
      "        !_userRoles.contains('developer');",
      "  }",
      "",
      "  void _initSubscription(String franchiseId) {",
      "    _subscriptionStream?.cancel();",
      "",
      "    if (!_shouldTrackSubscription(franchiseId)) {",
      "      if (kDebugMode) {",
      "        debugPrint(",
      "            '[FranchiseSubscriptionNotifier] ⛔ Subscription tracking skipped for roles: $_userRoles');",
      "      }",
      "      return;",
      "    }",
      "",
      "    if (kDebugMode) {",
      "      debugPrint(",
      "          '[FranchiseSubscriptionNotifier] 📡 Listening to franchiseId: $franchiseId');",
      "    }",
      "",
      "    _subscriptionStream =",
      "        _service.watchCurrentSubscription(franchiseId).listen((sub) async {",
      "      if (kDebugMode) {",
      "        debugPrint(",
      "            '[FranchiseSubscriptionNotifier] 📥 Stream emitted subscription: ${sub?.platformPlanId}');",
      "      }",
      "",
      "      if (sub == null) {",
      "        if (kDebugMode) {",
      "          debugPrint(",
      "              '[FranchiseSubscriptionNotifier] ⚠️ Stream returned null. Attempting fallback via getCurrentSubscription().');",
      "        }",
      "",
      "        try {",
      "          final fallback = await _service.getCurrentSubscription(franchiseId);",
      "          _currentSubscription = fallback;",
      "          _hasLoaded = true;",
      "          notifyListeners();",
      "          if (kDebugMode) {",
      "            debugPrint(",
      "                '[FranchiseSubscriptionNotifier] ✅ Fallback subscription loaded.');",
      "          }",
      "          if (!_planResolved) {",
      "            await resolveActivePlan();",
      "          }",
      "        } catch (e, stack) {",
      "          await ErrorLogger.log(",
      "            message: 'Fallback getCurrentSubscription failed: $e',",
      "            stack: stack.toString(),",
      "            source: 'FranchiseSubscriptionNotifier',",
      "            screen: 'subscription_logic',",
      "            severity: 'error',",
      "            contextData: {'franchiseId': franchiseId},",
      "          );",
      "        }",
      "      } else {",
      "        _currentSubscription = sub;",
      "        _hasLoaded = true;",
      "        notifyListeners();",
      "        if (kDebugMode) {",
      "          debugPrint(",
      "              '[FranchiseSubscriptionNotifier] ✅ Subscription received and listeners notified.');",
      "        }",
      "        if (!_planResolved) {",
      "          await resolveActivePlan();",
      "        }",
      "      }",
      "    });",
      "  }",
      "",
      "  Future<void> resolveActivePlan() async {",
      "    if (_planResolved || _resolvingPlan) return;",
      "",
      "    if (_userRoles.contains('platform_owner') ||",
      "        _userRoles.contains('developer')) {",
      "      if (kDebugMode) {",
      "        debugPrint(",
      "            '[FranchiseSubscriptionNotifier] ⛔ resolveActivePlan skipped for roles: $_userRoles');",
      "      }",
      "      return;",
      "    }",
      "",
      "    final planId = _currentSubscription?.platformPlanId;",
      "    if (planId == null || planId.isEmpty) return;",
      "",
      "    _resolvingPlan = true;",
      "",
      "    try {",
      "      final plan = await _service.getPlatformPlanById(planId);",
      "      _activePlatformPlan = plan;",
      "      _planResolved = true;",
      "      notifyListeners();",
      "      if (kDebugMode) {",
      "        debugPrint(",
      "            '[FranchiseSubscriptionNotifier] ✅ Resolved active plan: ${plan?.name}');",
      "      }",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to fetch active platform plan: $e',",
      "        stack: stack.toString(),",
      "        source: 'FranchiseSubscriptionNotifier',",
      "        screen: 'resolveActivePlan',",
      "        severity: 'warning',",
      "        contextData: {'planId': planId},",
      "      );",
      "    } finally {",
      "      _resolvingPlan = false;",
      "    }",
      "  }",
      "",
      "  void updateFranchiseId(String newId) {",
      "    if (newId.isEmpty || newId == _franchiseId) return;",
      "",
      "    if (kDebugMode) {",
      "      debugPrint(",
      "          '[FranchiseSubscriptionNotifier] 🔁 Updating franchiseId to: $newId');",
      "    }",
      "",
      "    _franchiseId = newId;",
      "    _hasLoaded = false;",
      "    _planResolved = false;",
      "    _resolvingPlan = false;",
      "",
      "    if (_shouldTrackSubscription(newId)) {",
      "      _initSubscription(newId);",
      "    } else {",
      "      if (kDebugMode) {",
      "        debugPrint(",
      "            '[FranchiseSubscriptionNotifier] Skipped initSubscription for $newId due to role or id constraints.');",
      "      }",
      "    }",
      "  }",
      "",
      "  // === Subscription Status Flags ===",
      "  bool get isTrialExpired {",
      "    final expiry = _currentSubscription?.trialEndsAt;",
      "    return expiry != null && DateTime.now().isAfter(expiry);",
      "  }",
      "",
      "  bool get isOverdue {",
      "    final status = _currentSubscription?.status.toLowerCase();",
      "    return status == 'overdue' || status == 'past_due' || status == 'unpaid';",
      "  }",
      "",
      "  bool get isActivePlanCustom {",
      "    return _activePlatformPlan?.isCustom ?? false;",
      "  }",
      "",
      "  @override",
      "  void dispose() {",
      "    _subscriptionStream?.cancel();",
      "    super.dispose();",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 202,
      "file_size": 6246,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\providers\\ingredient_metadata_provider.dart",
    "content": [
      "import 'package:flutter/foundation.dart';",
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/core/models/ingredient_metadata.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:collection/collection.dart';",
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "import 'package:franchise_admin_portal/core/models/onboarding_validation_issue.dart';",
      "",
      "class IngredientMetadataProvider extends ChangeNotifier {",
      "  final FirestoreService _firestore;",
      "  final String franchiseId;",
      "",
      "  List<IngredientMetadata> _original = [];",
      "  List<IngredientMetadata> _current = [];",
      "  final List<IngredientMetadata> _stagedIngredients = [];",
      "  final List<IngredientMetadata> _ingredients = [];",
      "  bool _hasLoaded = false;",
      "  String? _loadedFranchiseId;",
      "  bool get hasStagedChanges => _stagedIngredients.isNotEmpty;",
      "  final Set<String> _selectedIngredientIds = {};",
      "",
      "  Set<String> get selectedIngredientIds =>",
      "      Set.unmodifiable(_selectedIngredientIds);",
      "",
      "  // --- New state for sorting and grouping ---",
      "  String _sortKey = 'name'; // 'name', 'type', 'notes', etc.",
      "  bool _ascending = true;",
      "  String? _groupByKey = 'type'; // 'type', 'typeId', or null for no grouping",
      "",
      "  final Map<String, GlobalKey> itemGlobalKeys = {};",
      "  final Map<String, GlobalKey> fieldGlobalKeys = {};",
      "  IngredientMetadataProvider({",
      "    required FirestoreService firestoreService,",
      "    required this.franchiseId,",
      "  }) : _firestore = firestoreService;",
      "",
      "  bool get isDirty => !listEquals(_original, _current);",
      "  List<IngredientMetadata> get ingredients {",
      "    print('[Provider] get ingredients: ${_current.length}');",
      "    return _current;",
      "  }",
      "",
      "  // ✅ Used by widgets like MultiIngredientSelector to check loading state",
      "  bool get isInitialized => _hasLoaded;",
      "",
      "  /// getter for staged ingredients count",
      "  int get stagedIngredientCount => _stagedIngredients.length;",
      "  List<IngredientMetadata> get stagedIngredients =>",
      "      List.unmodifiable(_stagedIngredients);",
      "",
      "  // ✅ Exposes all current ingredients as read-only",
      "  List<IngredientMetadata> get allIngredients => List.unmodifiable([",
      "        ..._current,",
      "        ..._stagedIngredients,",
      "      ]);",
      "",
      "  String get sortKey => _sortKey;",
      "  bool get ascending => _ascending;",
      "  String? get groupByKey => _groupByKey;",
      "",
      "  set sortKey(String key) {",
      "    if (key != _sortKey) {",
      "      _sortKey = key;",
      "      notifyListeners();",
      "    }",
      "  }",
      "",
      "  set ascending(bool asc) {",
      "    if (asc != _ascending) {",
      "      _ascending = asc;",
      "      notifyListeners();",
      "    }",
      "  }",
      "",
      "  set groupByKey(String? key) {",
      "    if (key != _groupByKey) {",
      "      _groupByKey = key;",
      "      notifyListeners();",
      "    }",
      "  }",
      "",
      "  Future<void> createIngredient(IngredientMetadata newIngredient) async {",
      "    // Defensive: Block blank or unknown franchise IDs",
      "    if (franchiseId.isEmpty || franchiseId == 'unknown') {",
      "      print(",
      "          '[IngredientMetadataProvider] Called with blank/unknown franchiseId!');",
      "      await ErrorLogger.log(",
      "        message:",
      "            'IngredientMetadataProvider: called with blank/unknown franchiseId',",
      "        stack: '',",
      "        source: 'ingredient_metadata_provider.dart',",
      "        screen: 'ingredient_metadata_provider.dart',",
      "        severity: 'warning',",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      return;",
      "    }",
      "    final colRef = _firestore.db",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection('ingredient_metadata');",
      "    await colRef.doc(newIngredient.id).set(newIngredient.toMap());",
      "    updateIngredient(newIngredient);",
      "  }",
      "",
      "  /// Adds multiple new ingredients (e.g. after mapping or create-new from sidebar)",
      "  void addIngredients(List<IngredientMetadata> newItems) {",
      "    for (final item in newItems) {",
      "      updateIngredient(item);",
      "    }",
      "    notifyListeners();",
      "  }",
      "",
      "  /// Adds a list of validated/imported ingredients to the current working set.",
      "  /// Will update if ID exists, add if new.",
      "  void addImportedIngredients(List<IngredientMetadata> imported) {",
      "    int skippedTypeId = 0;",
      "    int skippedType = 0;",
      "    final valid = <IngredientMetadata>[];",
      "    for (final item in imported) {",
      "      if (item.typeId == null || item.typeId!.isEmpty) {",
      "        print(",
      "            '[Provider][addImportedIngredients] SKIP: id=${item.id}, name=\"${item.name}\" - NULL/EMPTY typeId');",
      "        skippedTypeId++;",
      "        continue;",
      "      }",
      "      if (item.type == null || item.type!.isEmpty) {",
      "        print(",
      "            '[Provider][addImportedIngredients] SKIP: id=${item.id}, name=\"${item.name}\" - NULL/EMPTY type');",
      "        skippedType++;",
      "        continue;",
      "      }",
      "      print(",
      "          '[Provider][addImportedIngredients] ADD: id=${item.id}, name=\"${item.name}\", typeId=\"${item.typeId}\", type=\"${item.type}\"');",
      "      valid.add(item);",
      "      updateIngredient(item);",
      "    }",
      "    if (skippedTypeId > 0 || skippedType > 0) {",
      "      print(",
      "          '[Provider][addImportedIngredients] --- SUMMARY: ${skippedTypeId + skippedType} SKIPPED (typeId: $skippedTypeId, type: $skippedType), ${valid.length} ADDED ---');",
      "    }",
      "    notifyListeners();",
      "  }",
      "",
      "  /// Returns all ingredient IDs missing from the current provider (for repair UI)",
      "  List<String> missingIngredientIds(List<String> ids) {",
      "    final currentIds = allIngredientIds.toSet();",
      "    return ids.where((id) => !currentIds.contains(id)).toList();",
      "  }",
      "",
      "  /// Reloads ingredients from Firestore (useful after repair or add-new)",
      "  Future<void> reload() async {",
      "    // Defensive: Block blank or unknown franchise IDs",
      "    if (franchiseId.isEmpty || franchiseId == 'unknown') {",
      "      print(",
      "          '[IngredientMetadataProvider] Called with blank/unknown franchiseId!');",
      "      await ErrorLogger.log(",
      "        message:",
      "            'IngredientMetadataProvider: called with blank/unknown franchiseId',",
      "        stack: '',",
      "        source: 'ingredient_metadata_provider.dart',",
      "        screen: 'ingredient_metadata_provider.dart',",
      "        severity: 'warning',",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      return;",
      "    }",
      "    await load();",
      "  }",
      "",
      "  /// Loads ingredient metadata from Firestore and sets as original",
      "  Future<void> load({bool forceReloadFromFirestore = false}) async {",
      "    print(",
      "        '\\n[IngredientMetadataProvider.load] 🚀 Starting ingredient metadata load...');",
      "    print('   ➤ franchiseId = \"$franchiseId\"');",
      "    print('   ➤ _loadedFranchiseId = \"${_loadedFranchiseId ?? 'null'}\"');",
      "    print(",
      "        '   ➤ _hasLoaded = $_hasLoaded, _current.length = ${_current.length}');",
      "    print('   ➤ forceReloadFromFirestore = $forceReloadFromFirestore');",
      "",
      "    // 1️⃣ Defensive: Block blank or 'unknown' franchise IDs",
      "    if (franchiseId.isEmpty || franchiseId == 'unknown') {",
      "      print(",
      "          '[IngredientMetadataProvider.load] ⚠️ Called with blank/unknown franchiseId! Skipping load.');",
      "      await ErrorLogger.log(",
      "        message:",
      "            'IngredientMetadataProvider: called with blank/unknown franchiseId',",
      "        stack: '',",
      "        source: 'ingredient_metadata_provider.dart',",
      "        screen: 'ingredient_metadata_provider.dart',",
      "        severity: 'warning',",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      return;",
      "    }",
      "",
      "    // 2️⃣ Skip reload if already loaded for same franchise (unless forced)",
      "    if (!forceReloadFromFirestore &&",
      "        _hasLoaded &&",
      "        _loadedFranchiseId == franchiseId) {",
      "      print(",
      "          '[IngredientMetadataProvider.load] ⏩ Data already loaded for this franchise. Skipping fetch.');",
      "      return;",
      "    }",
      "",
      "    try {",
      "      // 3️⃣ Clear stale in-memory data",
      "      if (_current.isNotEmpty ||",
      "          _original.isNotEmpty ||",
      "          itemGlobalKeys.isNotEmpty) {",
      "        print(",
      "            '[IngredientMetadataProvider.load] 🧹 Clearing stale in-memory ingredient data...');",
      "        _current.clear();",
      "        _original.clear();",
      "        itemGlobalKeys.clear();",
      "        print(",
      "            '[IngredientMetadataProvider.load]    Cleared _current, _original, and itemGlobalKeys.');",
      "      }",
      "",
      "      // 4️⃣ Fetch from Firestore",
      "      print(",
      "          '[IngredientMetadataProvider.load] 📡 Fetching ingredient metadata from Firestore...');",
      "      final fetched = await _firestore.fetchIngredientMetadata(franchiseId);",
      "",
      "      print(",
      "          '[IngredientMetadataProvider.load] ✅ Fetch complete: ${fetched.length} items returned.');",
      "      if (fetched.isEmpty) {",
      "        print(",
      "            '[IngredientMetadataProvider.load] ⚠️ No ingredient docs found for this franchise.');",
      "      } else {",
      "        for (final ing in fetched) {",
      "          print(",
      "              '    • id=\"${ing.id}\", name=\"${ing.name}\", typeId=\"${ing.typeId}\"');",
      "        }",
      "      }",
      "",
      "      // 5️⃣ Replace in-memory data",
      "      _original = List<IngredientMetadata>.from(fetched);",
      "      _current = List<IngredientMetadata>.from(fetched);",
      "      _hasLoaded = true;",
      "      _loadedFranchiseId = franchiseId;",
      "",
      "      // 6️⃣ Refresh keys",
      "      for (final ing in _current) {",
      "        itemGlobalKeys[ing.id] = GlobalKey();",
      "      }",
      "      print(",
      "          '[IngredientMetadataProvider.load] 🔑 Global keys set for ${itemGlobalKeys.length} items.');",
      "",
      "      // 7️⃣ Notify listeners",
      "      notifyListeners();",
      "      print('[IngredientMetadataProvider.load] 🎯 Load complete. UI notified.');",
      "    } catch (e, stack) {",
      "      print(",
      "          '[IngredientMetadataProvider.load][ERROR] ❌ Failed to load ingredient metadata: $e');",
      "      await ErrorLogger.log(",
      "        message: 'ingredient_metadata_load_error',",
      "        stack: stack.toString(),",
      "        source: 'IngredientMetadataProvider',",
      "        screen: 'ingredient_metadata_provider.dart',",
      "        severity: 'error',",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      rethrow;",
      "    }",
      "",
      "    print('[IngredientMetadataProvider.load] 🏁 Finished.\\n');",
      "  }",
      "",
      "  Future<void> loadTemplate(String templateId) async {",
      "    // Defensive: Block blank or unknown franchise IDs",
      "    if (franchiseId.isEmpty || franchiseId == 'unknown') {",
      "      print(",
      "          '[IngredientMetadataProvider] Called with blank/unknown franchiseId!');",
      "      await ErrorLogger.log(",
      "        message:",
      "            'IngredientMetadataProvider: called with blank/unknown franchiseId',",
      "        stack: '',",
      "        source: 'ingredient_metadata_provider.dart',",
      "        screen: 'ingredient_metadata_provider.dart',",
      "        severity: 'warning',",
      "        contextData: {'franchiseId': franchiseId, 'templateId': templateId},",
      "      );",
      "      return;",
      "    }",
      "    try {",
      "      final snapshot = await _firestore.db",
      "          .collection('onboarding_templates')",
      "          .doc(templateId)",
      "          .collection('ingredient_metadata')",
      "          .get();",
      "",
      "      final newItems = snapshot.docs",
      "          .map((doc) => IngredientMetadata.fromMap(doc.data()))",
      "          .toList();",
      "",
      "      for (final item in newItems) {",
      "        updateIngredient(item); // Adds to _current, marks dirty",
      "      }",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'template_load_error',",
      "        stack: stack.toString(),",
      "        source: 'IngredientMetadataProvider',",
      "        screen: 'ingredient_metadata_provider.dart',",
      "        severity: 'error',",
      "        contextData: {'templateId': templateId, 'franchiseId': franchiseId},",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  // -- Sorting method --",
      "  List<IngredientMetadata> get sortedIngredients {",
      "    List<IngredientMetadata> sorted = List.from(_current);",
      "    sorted.sort((a, b) {",
      "      final aVal = _getSortValue(a, _sortKey);",
      "      final bVal = _getSortValue(b, _sortKey);",
      "      return _ascending ? aVal.compareTo(bVal) : bVal.compareTo(aVal);",
      "    });",
      "    return sorted;",
      "  }",
      "",
      "  String _getSortValue(IngredientMetadata item, String key) {",
      "    switch (key) {",
      "      case 'name':",
      "        return item.name.toLowerCase();",
      "      case 'type':",
      "        return (item.type ?? '').toLowerCase();",
      "      case 'notes':",
      "        return (item.notes ?? '').toLowerCase();",
      "      default:",
      "        return '';",
      "    }",
      "  }",
      "",
      "  // -- Grouping method --",
      "  Map<String, List<IngredientMetadata>> get groupedIngredients {",
      "    if (_groupByKey == null) {",
      "      return {'All': sortedIngredients};",
      "    }",
      "",
      "    final groups = <String, List<IngredientMetadata>>{};",
      "    for (final item in sortedIngredients) {",
      "      String groupKey;",
      "      if (_groupByKey == 'type') {",
      "        if (item.type == null || item.type!.isEmpty) {",
      "          print(",
      "              '[Provider][groupedIngredients] item with id=${item.id} has missing or empty type!');",
      "          groupKey = 'Unknown';",
      "        } else {",
      "          groupKey = item.type!;",
      "        }",
      "      } else if (_groupByKey == 'typeId') {",
      "        if (item.typeId == null || item.typeId!.isEmpty) {",
      "          print(",
      "              '[Provider][groupedIngredients] item with id=${item.id} has missing or empty typeId!');",
      "          groupKey = 'Unknown';",
      "        } else {",
      "          groupKey = item.typeId!;",
      "        }",
      "      } else {",
      "        groupKey = 'Unknown';",
      "      }",
      "      groups.putIfAbsent(groupKey, () => []).add(item);",
      "    }",
      "    return groups;",
      "  }",
      "",
      "  /// Inject a full list of ingredients (e.g. from template)",
      "  void setIngredients(List<IngredientMetadata> items) {",
      "    _current = List.from(items);",
      "    notifyListeners();",
      "  }",
      "",
      "  /// Add or update a single ingredient",
      "  void updateIngredient(IngredientMetadata newData) {",
      "    if (newData.typeId == null || newData.typeId!.isEmpty) {",
      "      print(",
      "          '[Provider][updateIngredient] SKIP: id=${newData.id}, name=\"${newData.name}\" - NULL/EMPTY typeId!');",
      "      return;",
      "    }",
      "    if (newData.type == null || newData.type!.isEmpty) {",
      "      print(",
      "          '[Provider][updateIngredient] SKIP: id=${newData.id}, name=\"${newData.name}\" - NULL/EMPTY type!');",
      "      return;",
      "    }",
      "    print(",
      "        '[Provider][updateIngredient] ADD/UPDATE: id=${newData.id}, name=\"${newData.name}\", typeId=\"${newData.typeId}\", type=\"${newData.type}\"');",
      "    final index = _current.indexWhere((e) => e.id == newData.id);",
      "    if (index != -1) {",
      "      _current[index] = newData;",
      "      print('[Provider][updateIngredient] Updated ingredient: ${newData.id}');",
      "    } else {",
      "      _current.add(newData);",
      "      print('[Provider][updateIngredient] Added ingredient: ${newData.id}');",
      "    }",
      "    print(",
      "        '[Provider][updateIngredient] isDirty after update: $isDirty, _current: ${_current.length}, _original: ${_original.length}');",
      "    notifyListeners();",
      "  }",
      "",
      "  /// Delete by ID",
      "  void deleteIngredient(String id) {",
      "    _current.removeWhere((e) => e.id == id);",
      "    notifyListeners();",
      "  }",
      "",
      "  /// Get by ID (for editing)",
      "  IngredientMetadata? getIngredientById(String id) {",
      "    return _current.firstWhereOrNull((e) => e.id == id);",
      "  }",
      "",
      "  /// Push all current data to Firestore (overwrites existing)",
      "  Future<void> saveChanges() async {",
      "    // Defensive: Block blank or unknown franchise IDs",
      "    if (franchiseId.isEmpty || franchiseId == 'unknown') {",
      "      print(",
      "          '[IngredientMetadataProvider] Called with blank/unknown franchiseId!');",
      "      await ErrorLogger.log(",
      "        message:",
      "            'IngredientMetadataProvider: called with blank/unknown franchiseId',",
      "        stack: '',",
      "        source: 'ingredient_metadata_provider.dart',",
      "        screen: 'ingredient_metadata_provider.dart',",
      "        severity: 'warning',",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      return;",
      "    }",
      "    try {",
      "      final batch = _firestore.db.batch();",
      "      final colRef = _firestore.db",
      "          .collection('franchises')",
      "          .doc(franchiseId)",
      "          .collection('ingredient_metadata');",
      "",
      "      for (final item in _current) {",
      "        batch.set(colRef.doc(item.id), item.toMap());",
      "      }",
      "",
      "      await batch.commit();",
      "      _original = List.from(_current);",
      "      notifyListeners();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'ingredient_metadata_save_failed',",
      "        stack: stack.toString(),",
      "        source: 'IngredientMetadataProvider',",
      "        screen: 'ingredient_metadata_provider.dart',",
      "        severity: 'error',",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  Future<void> saveAllChanges(String franchiseId) async {",
      "    // Defensive: Block blank or unknown franchise IDs",
      "    if (franchiseId.isEmpty || franchiseId == 'unknown') {",
      "      print(",
      "          '[IngredientMetadataProvider] Called with blank/unknown franchiseId!');",
      "      await ErrorLogger.log(",
      "        message:",
      "            'IngredientMetadataProvider: called with blank/unknown franchiseId',",
      "        stack: '',",
      "        source: 'ingredient_metadata_provider.dart',",
      "        screen: 'onboarding_ingredients_screen',",
      "        severity: 'warning',",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      return;",
      "    }",
      "    final batch = FirebaseFirestore.instance.batch();",
      "    final collectionRef = FirebaseFirestore.instance",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection('ingredient_metadata');",
      "",
      "    try {",
      "      for (final entry in _current) {",
      "        if (!entry.isValid()) {",
      "          throw Exception('Invalid ingredient: ${entry.name}');",
      "        }",
      "        final docRef = collectionRef.doc(entry.id);",
      "        batch.set(docRef, entry.toMap());",
      "      }",
      "",
      "      await batch.commit();",
      "      // After saving, reload from Firestore to reset _original and _current",
      "      await load(); // <<--- Add this line!",
      "      notifyListeners();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'ingredient_metadata_save_failed',",
      "        stack: stack.toString(),",
      "        source: 'ingredient_metadata_provider.dart',",
      "        screen: 'onboarding_ingredients_screen',",
      "        severity: 'error',",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "          'ingredientCount': _current.length,",
      "          'error': e.toString(),",
      "        },",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// BULK DELETE METHODS",
      "  /// Toggle selection state for an ingredient by ID",
      "  void toggleSelection(String id) {",
      "    try {",
      "      if (_selectedIngredientIds.contains(id)) {",
      "        _selectedIngredientIds.remove(id);",
      "      } else {",
      "        _selectedIngredientIds.add(id);",
      "      }",
      "      notifyListeners();",
      "    } catch (e, stack) {",
      "      ErrorLogger.log(",
      "        message: 'toggleSelection failed',",
      "        source: 'IngredientMetadataProvider',",
      "        screen: 'ingredient_metadata_provider.dart',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "        contextData: {'id': id},",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Clear all selected ingredient IDs",
      "  void clearSelection() {",
      "    try {",
      "      _selectedIngredientIds.clear();",
      "      notifyListeners();",
      "    } catch (e, stack) {",
      "      ErrorLogger.log(",
      "        message: 'clearSelection failed',",
      "        source: 'IngredientMetadataProvider',",
      "        screen: 'ingredient_metadata_provider.dart',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Select all loaded ingredients",
      "  void selectAll() {",
      "    try {",
      "      _selectedIngredientIds.clear();",
      "      _selectedIngredientIds.addAll(_current.map((e) => e.id));",
      "      notifyListeners();",
      "    } catch (e, stack) {",
      "      ErrorLogger.log(",
      "        message: 'selectAll failed',",
      "        source: 'IngredientMetadataProvider',",
      "        screen: 'ingredient_metadata_provider.dart',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Bulk delete all selected ingredients locally (does NOT commit to Firestore)",
      "  void deleteSelected() {",
      "    try {",
      "      _current.removeWhere(",
      "          (ingredient) => _selectedIngredientIds.contains(ingredient.id));",
      "      _selectedIngredientIds.clear();",
      "      notifyListeners();",
      "    } catch (e, stack) {",
      "      ErrorLogger.log(",
      "        message: 'deleteSelected failed',",
      "        source: 'IngredientMetadataProvider',",
      "        screen: 'ingredient_metadata_provider.dart',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Bulk delete all selected ingredients and commit the changes to Firestore",
      "  Future<void> bulkDeleteIngredients(List<String> ids) async {",
      "    // Defensive: Block blank or unknown franchise IDs",
      "    if (franchiseId.isEmpty || franchiseId == 'unknown') {",
      "      print(",
      "          '[IngredientMetadataProvider] Called with blank/unknown franchiseId!');",
      "      await ErrorLogger.log(",
      "        message:",
      "            'IngredientMetadataProvider: called with blank/unknown franchiseId',",
      "        stack: '',",
      "        source: 'ingredient_metadata_provider.dart',",
      "        screen: 'ingredient_metadata_provider.dart',",
      "        severity: 'warning',",
      "        contextData: {'franchiseId': franchiseId, 'ids': ids},",
      "      );",
      "      return;",
      "    }",
      "    try {",
      "      _current.removeWhere((ingredient) => ids.contains(ingredient.id));",
      "      _selectedIngredientIds.removeAll(ids);",
      "      notifyListeners();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'bulk_delete_ingredients_failed',",
      "        stack: stack.toString(),",
      "        source: 'IngredientMetadataProvider',",
      "        screen: 'ingredient_metadata_provider.dart',",
      "        severity: 'error',",
      "        contextData: {'ids': ids, 'franchiseId': franchiseId},",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  Future<void> bulkDeleteIngredientsFromFirestore(List<String> ids) async {",
      "    // Defensive: Block blank or unknown franchise IDs",
      "    if (franchiseId.isEmpty || franchiseId == 'unknown') {",
      "      print(",
      "          '[IngredientMetadataProvider] Called with blank/unknown franchiseId!');",
      "      await ErrorLogger.log(",
      "        message:",
      "            'IngredientMetadataProvider: called with blank/unknown franchiseId',",
      "        stack: '',",
      "        source: 'ingredient_metadata_provider.dart',",
      "        screen: 'ingredient_metadata_provider.dart',",
      "        severity: 'warning',",
      "        contextData: {'franchiseId': franchiseId, 'ids': ids},",
      "      );",
      "      return;",
      "    }",
      "    try {",
      "      final batch = _firestore.db.batch();",
      "      final colRef = _firestore.db",
      "          .collection('franchises')",
      "          .doc(franchiseId)",
      "          .collection('ingredient_metadata');",
      "",
      "      for (final id in ids) {",
      "        batch.delete(colRef.doc(id));",
      "      }",
      "",
      "      await batch.commit();",
      "",
      "      // After deletion, reload the ingredients",
      "      await load();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'bulk_delete_ingredients_failed',",
      "        stack: stack.toString(),",
      "        source: 'IngredientMetadataProvider',",
      "        screen: 'ingredient_metadata_provider.dart',",
      "        severity: 'error',",
      "        contextData: {'deletedCount': ids.length, 'franchiseId': franchiseId},",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Replace the entire current ingredient metadata list locally (does NOT write to Firestore).",
      "  /// Marks provider as dirty to enable SaveChangesBanner.",
      "  Future<void> bulkReplaceIngredientMetadata(",
      "    String franchiseId,",
      "    List<IngredientMetadata> newItems,",
      "  ) async {",
      "    // Defensive: Block blank or unknown franchise IDs",
      "    if (franchiseId.isEmpty || franchiseId == 'unknown') {",
      "      print(",
      "          '[IngredientMetadataProvider] Called with blank/unknown franchiseId!');",
      "      await ErrorLogger.log(",
      "        message:",
      "            'IngredientMetadataProvider: called with blank/unknown franchiseId',",
      "        stack: '',",
      "        source: 'ingredient_metadata_provider.dart',",
      "        screen: 'ingredient_metadata_provider.dart',",
      "        severity: 'warning',",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      return;",
      "    }",
      "    print(",
      "        '[Provider] bulkReplaceIngredientMetadata (hashCode: ${this.hashCode})');",
      "    print(",
      "        '[Provider] bulkReplaceIngredientMetadata: replacing with ${newItems.length} items');",
      "    int skippedTypeId = 0;",
      "    int skippedType = 0;",
      "    final filtered = <IngredientMetadata>[];",
      "    for (final item in newItems) {",
      "      if (item.typeId == null || item.typeId!.isEmpty) {",
      "        print(",
      "            '[Provider][bulkReplaceIngredientMetadata] SKIP: id=${item.id}, name=\"${item.name}\" - NULL/EMPTY typeId');",
      "        skippedTypeId++;",
      "        continue;",
      "      }",
      "      if (item.type == null || item.type!.isEmpty) {",
      "        print(",
      "            '[Provider][bulkReplaceIngredientMetadata] SKIP: id=${item.id}, name=\"${item.name}\" - NULL/EMPTY type');",
      "        skippedType++;",
      "        continue;",
      "      }",
      "      print(",
      "          '[Provider][bulkReplaceIngredientMetadata] ADD: id=${item.id}, name=\"${item.name}\", typeId=\"${item.typeId}\", type=\"${item.type}\"');",
      "      filtered.add(item);",
      "    }",
      "    if (skippedTypeId > 0 || skippedType > 0) {",
      "      print(",
      "          '[Provider][bulkReplaceIngredientMetadata] --- SUMMARY: ${skippedTypeId + skippedType} SKIPPED (typeId: $skippedTypeId, type: $skippedType), ${filtered.length} ADDED ---');",
      "    }",
      "    _current = List.from(filtered);",
      "    notifyListeners();",
      "  }",
      "",
      "  /// Revert to original snapshot",
      "  void revertChanges() {",
      "    _current = List.from(_original);",
      "    notifyListeners();",
      "  }",
      "",
      "  /// Returns a map of all ingredient IDs to names.",
      "  Map<String, String> get ingredientIdToName => Map.fromEntries(",
      "      [..._current, ..._stagedIngredients].map((i) => MapEntry(i.id, i.name)));",
      "",
      "  /// Returns a list of all available ingredient IDs.",
      "  List<String> get allIngredientIds =>",
      "      [..._current, ..._stagedIngredients].map((i) => i.id).toSet().toList();",
      "",
      "  /// Returns a list of all available ingredient names.",
      "  List<String> get allIngredientNames =>",
      "      ingredients.map((i) => i.name).toList();",
      "",
      "  /// Find an ingredient by name (case-insensitive, trimmed).",
      "  IngredientMetadata? getByName(String name) {",
      "    return ingredients.firstWhereOrNull(",
      "        (i) => i.name.trim().toLowerCase() == name.trim().toLowerCase());",
      "  }",
      "",
      "  /// Find an ingredient by ID (case-insensitive).",
      "  IngredientMetadata? getByIdCaseInsensitive(String id) {",
      "    return ingredients",
      "        .firstWhereOrNull((i) => i.id.toLowerCase() == id.toLowerCase());",
      "  }",
      "",
      "  /// Find all unique typeIds in the current ingredient set.",
      "  List<String> get allIngredientTypeIds {",
      "    final ids = <String>{};",
      "    for (final i in ingredients) {",
      "      if (i.typeId != null && i.typeId!.isNotEmpty) {",
      "        ids.add(i.typeId!);",
      "      }",
      "    }",
      "    return ids.toList();",
      "  }",
      "",
      "  /// Method to stage a new ingredient for schema issue sidebar to be added",
      "  void stageIngredient(IngredientMetadata ingredient) {",
      "    if (ingredient.typeId == null || ingredient.typeId!.isEmpty) {",
      "      print(",
      "          '[IngredientMetadataProvider][stageIngredient] SKIP: Ingredient ${ingredient.id} (${ingredient.name}) has null or empty typeId!');",
      "      return;",
      "    }",
      "    if (ingredient.type == null || ingredient.type!.isEmpty) {",
      "      print(",
      "          '[IngredientMetadataProvider][stageIngredient] SKIP: Ingredient ${ingredient.id} (${ingredient.name}) has null or empty type!');",
      "      return;",
      "    }",
      "",
      "    final alreadyStaged = _stagedIngredients.any((e) => e.id == ingredient.id);",
      "    final alreadyInIngredients = _ingredients.any((e) => e.id == ingredient.id);",
      "    final alreadyInCurrent = _current.any((e) => e.id == ingredient.id);",
      "",
      "    debugPrint('[IngredientMetadataProvider] stageIngredient called: '",
      "        'id=${ingredient.id}, name=${ingredient.name}, '",
      "        'alreadyStaged=$alreadyStaged, alreadyInIngredients=$alreadyInIngredients, alreadyInCurrent=$alreadyInCurrent');",
      "",
      "    if (alreadyStaged || alreadyInIngredients || alreadyInCurrent) {",
      "      debugPrint('[IngredientMetadataProvider] Not staging: already exists.');",
      "      return;",
      "    }",
      "",
      "    _stagedIngredients.add(ingredient);",
      "    _ingredients.add(ingredient);",
      "    _current.add(ingredient); // Ensures presence for dropdown/save",
      "",
      "    ingredientIdToName[ingredient.id] = ingredient.name;",
      "",
      "    debugPrint('[IngredientMetadataProvider] Staged new ingredient: '",
      "        'id=${ingredient.id}, name=${ingredient.name}. '",
      "        'StagedIngredients=${_stagedIngredients.length}, '",
      "        'Ingredients=${_ingredients.length}, Current=${_current.length}');",
      "    notifyListeners();",
      "  }",
      "",
      "  /// Method to commit staged ingredients (invoked in onboarding save logic):",
      "  Future<void> saveStagedIngredients() async {",
      "    // Defensive: Block blank or unknown franchise IDs",
      "    if (franchiseId.isEmpty || franchiseId == 'unknown') {",
      "      print(",
      "          '[IngredientMetadataProvider] Called with blank/unknown franchiseId!');",
      "      await ErrorLogger.log(",
      "        message:",
      "            'IngredientMetadataProvider: called with blank/unknown franchiseId',",
      "        stack: '',",
      "        source: 'ingredient_metadata_provider.dart',",
      "        screen: 'ingredient_metadata_provider.dart',",
      "        severity: 'warning',",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      return;",
      "    }",
      "    if (_stagedIngredients.isEmpty) return;",
      "",
      "    try {",
      "      final batch = _firestore.db.batch();",
      "      final colRef = _firestore.db",
      "          .collection('franchises')",
      "          .doc(franchiseId)",
      "          .collection('ingredient_metadata');",
      "",
      "      for (final ingredient in _stagedIngredients) {",
      "        batch.set(colRef.doc(ingredient.id), ingredient.toMap());",
      "      }",
      "      print(",
      "          '[IngredientMetadataProvider] Persisting ${_stagedIngredients.length} ingredients');",
      "",
      "      await batch.commit();",
      "      _ingredients.addAll(_stagedIngredients);",
      "      _stagedIngredients.clear();",
      "      notifyListeners();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'ingredient_metadata_batch_save_failed',",
      "        stack: stack.toString(),",
      "        source: 'IngredientMetadataProvider',",
      "        screen: 'ingredient_metadata_provider.dart',",
      "        severity: 'error',",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "          'stagedCount': _stagedIngredients.length,",
      "          'stagedIds': _stagedIngredients.map((e) => e.id).toList(),",
      "        },",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Optional method to revert staged ingredients:",
      "  void discardStagedIngredients() {",
      "    if (_stagedIngredients.isNotEmpty) {",
      "      _stagedIngredients.clear();",
      "      print('[ProviderName] Discarded staged items: '",
      "          'count=${_stagedIngredients.length} before clearing');",
      "",
      "      notifyListeners();",
      "    }",
      "  }",
      "",
      "  /// Returns the full Ingredient by ID from staged or loaded ingredients.",
      "  IngredientMetadata? getById(String id) {",
      "    return _stagedIngredients.firstWhereOrNull((e) => e.id == id) ??",
      "        _ingredients.firstWhereOrNull((e) => e.id == id);",
      "  }",
      "",
      "  /// Adds the ingredient to staging if it's not already present.",
      "  bool stageIfNew({required String id, required String name}) {",
      "    final alreadyExists = _ingredients.any((e) => e.id == id) ||",
      "        _stagedIngredients.any((e) => e.id == id);",
      "",
      "    if (!alreadyExists) {",
      "      final newIngredient = IngredientMetadata(",
      "        id: id,",
      "        name: name,",
      "        type: '', // default blank, since no type available",
      "        allergens: [],",
      "        removable: true,",
      "        supportsExtra: false,",
      "        sidesAllowed: false,",
      "        outOfStock: false,",
      "        amountSelectable: false,",
      "      );",
      "      _stagedIngredients.add(newIngredient);",
      "      notifyListeners();",
      "      debugPrint('[IngredientMetadataProvider] Staged new ingredient: '",
      "          'id=${newIngredient.id}, name=${newIngredient.name}, '",
      "          'typeId=${newIngredient.typeId}, type=${newIngredient.type}');",
      "",
      "      return true;",
      "    }",
      "    return false;",
      "  }",
      "",
      "  Future<List<OnboardingValidationIssue>> validate({",
      "    List<String>? validTypeIds,",
      "    List<String>? referencedIngredientIds,",
      "  }) async {",
      "    print('\\n[IngredientMetadataProvider.validate] 🔍 Starting validation...');",
      "    print('   ➤ validTypeIds length = ${validTypeIds?.length ?? 0}');",
      "    print(",
      "        '   ➤ referencedIngredientIds length = ${referencedIngredientIds?.length ?? 0}');",
      "    print('   ➤ Current in-memory ingredient count = ${_current.length}');",
      "",
      "    final issues = <OnboardingValidationIssue>[];",
      "",
      "    try {",
      "      final ingredientNames = <String>{};",
      "      for (final ing in _current) {",
      "        print(",
      "            '   [CHECK] Ingredient: id=\"${ing.id}\", name=\"${ing.name}\", typeId=\"${ing.typeId}\"');",
      "",
      "        // 🔹 Duplicate name check",
      "        final normalizedName = ing.name.trim().toLowerCase();",
      "        if (!ingredientNames.add(normalizedName)) {",
      "          print('    ❌ Duplicate name found: \"${ing.name}\"');",
      "          issues.add(OnboardingValidationIssue(",
      "            section: 'Ingredients',",
      "            itemId: ing.id,",
      "            itemDisplayName: ing.name,",
      "            severity: OnboardingIssueSeverity.critical,",
      "            code: 'DUPLICATE_INGREDIENT_NAME',",
      "            message: \"Duplicate ingredient name: '${ing.name}'.\",",
      "            affectedFields: ['name'],",
      "            isBlocking: true,",
      "            fixRoute: '/onboarding/ingredients',",
      "            itemLocator: ing.id,",
      "            resolutionHint: \"Make all ingredient names unique.\",",
      "            actionLabel: \"Fix Now\",",
      "            icon: Icons.label_important,",
      "            detectedAt: DateTime.now(),",
      "            contextData: {'ingredient': ing.toMap()},",
      "          ));",
      "        }",
      "",
      "        // 🔹 Missing/invalid type check",
      "        if ((ing.typeId?.isEmpty ?? true) ||",
      "            (validTypeIds != null && !validTypeIds.contains(ing.typeId))) {",
      "          print(",
      "              '    ❌ Missing or invalid type for ingredient: \"${ing.name}\" (typeId=\"${ing.typeId}\")');",
      "          issues.add(OnboardingValidationIssue(",
      "            section: 'Ingredients',",
      "            itemId: ing.id,",
      "            itemDisplayName: ing.name,",
      "            severity: OnboardingIssueSeverity.critical,",
      "            code: 'MISSING_INGREDIENT_TYPE',",
      "            message: \"Ingredient '${ing.name}' has no valid type assigned.\",",
      "            affectedFields: ['typeId'],",
      "            isBlocking: true,",
      "            fixRoute: '/onboarding/ingredients',",
      "            itemLocator: ing.id,",
      "            resolutionHint: \"Assign a valid type to this ingredient.\",",
      "            actionLabel: \"Fix Now\",",
      "            icon: Icons.link_off,",
      "            detectedAt: DateTime.now(),",
      "            contextData: {'ingredient': ing.toMap()},",
      "          ));",
      "        }",
      "      }",
      "",
      "      // 🔹 Orphan ingredient warning",
      "      if (referencedIngredientIds != null) {",
      "        for (final ing in _current) {",
      "          if (!referencedIngredientIds.contains(ing.id)) {",
      "            print('    ⚠️ Unused ingredient: \"${ing.name}\"');",
      "            issues.add(OnboardingValidationIssue(",
      "              section: 'Ingredients',",
      "              itemId: ing.id,",
      "              itemDisplayName: ing.name,",
      "              severity: OnboardingIssueSeverity.warning,",
      "              code: 'UNUSED_INGREDIENT',",
      "              message: \"Ingredient '${ing.name}' is not used by any menu item.\",",
      "              affectedFields: [],",
      "              isBlocking: false,",
      "              fixRoute: '/onboarding/ingredients',",
      "              itemLocator: ing.id,",
      "              resolutionHint: \"Consider removing unused ingredients.\",",
      "              actionLabel: \"Review\",",
      "              icon: Icons.info_outline,",
      "              detectedAt: DateTime.now(),",
      "            ));",
      "          }",
      "        }",
      "      }",
      "",
      "      // 🔹 At least one ingredient required",
      "      if (_current.isEmpty) {",
      "        print('    ❌ No ingredients defined.');",
      "        issues.add(OnboardingValidationIssue(",
      "          section: 'Ingredients',",
      "          itemId: '',",
      "          itemDisplayName: '',",
      "          severity: OnboardingIssueSeverity.critical,",
      "          code: 'NO_INGREDIENTS_DEFINED',",
      "          message: \"At least one ingredient must be defined.\",",
      "          affectedFields: ['ingredients'],",
      "          isBlocking: true,",
      "          fixRoute: '/onboarding/ingredients',",
      "          resolutionHint: \"Add at least one ingredient.\",",
      "          actionLabel: \"Add Ingredient\",",
      "          icon: Icons.add_box_outlined,",
      "          detectedAt: DateTime.now(),",
      "        ));",
      "      }",
      "    } catch (e, stack) {",
      "      print('[IngredientMetadataProvider.validate][ERROR] ❌ $e');",
      "      await ErrorLogger.log(",
      "        message: 'ingredient_metadata_validate_failed',",
      "        stack: stack.toString(),",
      "        source: 'IngredientMetadataProvider.validate',",
      "        severity: 'error',",
      "        contextData: {},",
      "      );",
      "    }",
      "",
      "    print(",
      "        '[IngredientMetadataProvider.validate] 🏁 Finished with ${issues.length} issues.\\n');",
      "    return issues;",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 1022,
      "file_size": 36916,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\providers\\ingredient_type_provider.dart",
    "content": [
      "import 'package:flutter/foundation.dart';",
      "import 'package:franchise_admin_portal/core/models/ingredient_type_model.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "import 'package:collection/collection.dart';",
      "import 'dart:convert';",
      "import 'package:franchise_admin_portal/core/models/ingredient_metadata.dart';",
      "import 'package:franchise_admin_portal/core/models/onboarding_validation_issue.dart';",
      "import 'package:flutter/material.dart';",
      "",
      "class IngredientTypeProvider with ChangeNotifier {",
      "  final FirestoreService _firestoreService = FirestoreService();",
      "  String franchiseId = '';",
      "  String? _loadedFranchiseId;",
      "  bool _loading = false;",
      "  String? _error;",
      "",
      "  List<IngredientType> get ingredientTypes => _ingredientTypes;",
      "  bool get loading => _loading;",
      "  String? get error => _error;",
      "  List<IngredientType> _ingredientTypes = [];",
      "",
      "  /// Ingredient type staging for schema issue sidebar",
      "  final List<IngredientType> _stagedTypes = [];",
      "  List<IngredientType> get stagedTypes => List.unmodifiable(_stagedTypes);",
      "",
      "  // NEW: Staged for delete (IDs only)",
      "  final Set<String> _stagedForDelete = {};",
      "",
      "  Set<String> get stagedForDelete => Set.unmodifiable(_stagedForDelete);",
      "",
      "  // Tracks whether this provider has ever completed an initial load.",
      "  bool _hasLoaded = false;",
      "  bool get isLoaded => _hasLoaded;",
      "",
      "  /// Uniform loader used by the review screen to avoid stale data.",
      "  /// - If [forceReloadFromFirestore] is true, always hits Firestore.",
      "  /// - Otherwise, it no-ops after the first successful load.",
      "  Future<void> load(",
      "      {bool forceReloadFromFirestore = false,",
      "      String? franchiseIdOverride}) async {",
      "    final id = (franchiseIdOverride ?? franchiseId);",
      "    if (id.isEmpty || id == 'unknown') {",
      "      debugPrint(",
      "          '[IngredientTypeProvider][load] ⚠️ Skipping load: empty/unknown franchiseId.');",
      "      return;",
      "    }",
      "",
      "    if (_hasLoaded && !forceReloadFromFirestore) {",
      "      debugPrint(",
      "          '[IngredientTypeProvider][load] 🔁 Using warm cache (types=${_ingredientTypes.length}).');",
      "      return;",
      "    }",
      "",
      "    debugPrint(",
      "        '[IngredientTypeProvider][load] 📡 Fetching ingredient types for franchise \"$id\"...');",
      "    await loadIngredientTypes(id); // ← uses your existing method",
      "    _hasLoaded = true;",
      "    debugPrint(",
      "        '[IngredientTypeProvider][load] ✅ Loaded (types=${_ingredientTypes.length}).');",
      "  }",
      "",
      "  /// Load all ingredient types for the given franchise",
      "  Future<void> loadIngredientTypes(String franchiseId,",
      "      {bool forceReloadFromFirestore = false}) async {",
      "    // Defensive: Block blank or unknown franchise IDs",
      "    if (franchiseId.isEmpty || franchiseId == 'unknown') {",
      "      print(",
      "          '[IngredientTypeProvider][LOAD] ⚠️ Called with blank/unknown franchiseId! Skipping load.');",
      "      await ErrorLogger.log(",
      "        message:",
      "            'IngredientTypeProvider: load called with blank/unknown franchiseId',",
      "        stack: '',",
      "        source: 'ingredient_type_provider.dart',",
      "        screen: 'ingredient_type_provider.dart',",
      "        severity: 'warning',",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      return;",
      "    }",
      "",
      "    // Skip load if already loaded and not forcing refresh",
      "    if (_hasLoaded &&",
      "        _loadedFranchiseId == franchiseId &&",
      "        !forceReloadFromFirestore) {",
      "      print(",
      "          '[IngredientTypeProvider][LOAD] ✅ Already loaded for \"$franchiseId\". Skipping fetch.');",
      "      return;",
      "    }",
      "",
      "    try {",
      "      print(",
      "          '[IngredientTypeProvider][LOAD] 📡 Fetching ingredient types for franchise \"$franchiseId\"...');",
      "      final fetched = await FirestoreService.getIngredientTypes(franchiseId);",
      "",
      "      print(",
      "          '[IngredientTypeProvider][LOAD] ✅ Fetched ${fetched.length} ingredient types.');",
      "      for (final type in fetched) {",
      "        print('    • id=\"${type.id}\", name=\"${type.name}\"');",
      "      }",
      "",
      "      _ingredientTypes",
      "        ..clear()",
      "        ..addAll(fetched);",
      "",
      "      _hasLoaded = true;",
      "      _loadedFranchiseId = franchiseId;",
      "",
      "      notifyListeners();",
      "    } catch (e, stack) {",
      "      print(",
      "          '[IngredientTypeProvider][LOAD][ERROR] ❌ Failed to load ingredient types: $e');",
      "      await ErrorLogger.log(",
      "        message: 'ingredient_type_load_error',",
      "        stack: stack.toString(),",
      "        source: 'ingredient_type_provider.dart',",
      "        screen: 'ingredient_type_provider.dart',",
      "        severity: 'error',",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Reload ingredient types from Firestore (used after sidebar repair/add-new)",
      "  Future<void> reload(String franchiseId,",
      "      {bool forceReloadFromFirestore = false}) async {",
      "    // Defensive: Block blank or unknown franchise IDs",
      "    if (franchiseId.isEmpty || franchiseId == 'unknown') {",
      "      print(",
      "          '[IngredientTypeProvider][RELOAD] ⚠️ Called with blank/unknown franchiseId! Skipping reload.');",
      "      await ErrorLogger.log(",
      "        message:",
      "            'IngredientTypeProvider: reload called with blank/unknown franchiseId',",
      "        stack: '',",
      "        source: 'ingredient_type_provider.dart',",
      "        screen: 'ingredient_type_provider.dart',",
      "        severity: 'warning',",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      return;",
      "    }",
      "",
      "    if (forceReloadFromFirestore) {",
      "      print(",
      "          '[IngredientTypeProvider][RELOAD] 🔄 Forcing reload from Firestore for franchise \"$franchiseId\"...');",
      "      _hasLoaded = false; // ensure load runs fresh",
      "    } else {",
      "      print(",
      "          '[IngredientTypeProvider][RELOAD] ♻️ Reloading ingredient types for franchise \"$franchiseId\"...');",
      "    }",
      "",
      "    await loadIngredientTypes(franchiseId,",
      "        forceReloadFromFirestore: forceReloadFromFirestore);",
      "  }",
      "",
      "  /// Returns all type IDs missing from the current provider (for repair UI)",
      "  List<String> missingTypeIds(List<String> ids) {",
      "    final currentIds = allTypeIds.toSet();",
      "    return ids.where((id) => !currentIds.contains(id)).toList();",
      "  }",
      "",
      "  /// Adds or updates multiple ingredient types (for repair/add-new flows)",
      "  void addOrUpdateTypes(List<IngredientType> newTypes) {",
      "    for (final t in newTypes) {",
      "      final idx = _ingredientTypes.indexWhere((e) => e.id == t.id);",
      "      if (idx != -1) {",
      "        _ingredientTypes[idx] = t;",
      "      } else {",
      "        _ingredientTypes.add(t);",
      "      }",
      "    }",
      "    notifyListeners();",
      "  }",
      "",
      "  Future<void> createType(String franchiseId, IngredientType type) async {",
      "    // Defensive: Block blank or unknown franchise IDs",
      "    if (franchiseId.isEmpty || franchiseId == 'unknown') {",
      "      print(",
      "          '[IngredientTypeProvider] createType called with blank/unknown franchiseId!');",
      "      await ErrorLogger.log(",
      "        message:",
      "            'IngredientTypeProvider: createType called with blank/unknown franchiseId',",
      "        stack: '',",
      "        source: 'ingredient_type_provider.dart',",
      "        screen: 'ingredient_type_provider.dart',",
      "        severity: 'warning',",
      "        contextData: {'franchiseId': franchiseId, 'typeName': type.name},",
      "      );",
      "      return;",
      "    }",
      "    try {",
      "      final colRef = _firestoreService.db",
      "          .collection('franchises')",
      "          .doc(franchiseId)",
      "          .collection('ingredient_types');",
      "      await colRef.doc(type.id).set(type.toMap(includeTimestamps: true));",
      "      await loadIngredientTypes(franchiseId);",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to create ingredient type',",
      "        stack: stack.toString(),",
      "        source: 'ingredient_type_provider.dart',",
      "        screen: 'ingredient_type_provider.dart',",
      "        severity: 'error',",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "          'typeName': type.name,",
      "          'errorType': e.runtimeType.toString(),",
      "        },",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Reorders ingredient types and persists updated sortOrder to Firestore",
      "  /// Reorders ingredient types and updates their sortOrder in Firestore",
      "  Future<void> reorderIngredientTypes(",
      "    String franchiseId,",
      "    List<IngredientType> newOrder,",
      "  ) async {",
      "    // Defensive: Block blank or unknown franchise IDs",
      "    if (franchiseId.isEmpty || franchiseId == 'unknown') {",
      "      print(",
      "          '[IngredientTypeProvider] reorderIngredientTypes called with blank/unknown franchiseId!');",
      "      await ErrorLogger.log(",
      "        message:",
      "            'IngredientTypeProvider: reorder called with blank/unknown franchiseId',",
      "        stack: '',",
      "        source: 'ingredient_type_provider.dart',",
      "        screen: 'ingredient_type_management_screen',",
      "        severity: 'warning',",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      return;",
      "    }",
      "    try {",
      "      final updates = newOrder.asMap().entries.map((entry) {",
      "        return {",
      "          'id': entry.value.id,",
      "          'sortOrder': entry.key,",
      "        };",
      "      }).toList();",
      "",
      "      await _firestoreService.updateIngredientTypeSortOrders(",
      "        franchiseId: franchiseId,",
      "        sortedUpdates: updates,",
      "      );",
      "",
      "      // Reload local state after update",
      "      await loadIngredientTypes(franchiseId);",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to reorder ingredient types',",
      "        source: 'ingredient_type_provider.dart',",
      "        screen: 'ingredient_type_management_screen',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "          'newOrderIds': newOrder.map((e) => e.id).toList(),",
      "        },",
      "      );",
      "    }",
      "  }",
      "",
      "  /// Get a specific type by ID",
      "  /// Find an ingredient type by ID (searches both staged and loaded)",
      "  IngredientType? getById(String id) {",
      "    return _stagedTypes.firstWhereOrNull((t) => t.id == id) ??",
      "        _ingredientTypes.firstWhereOrNull((t) => t.id == id);",
      "  }",
      "",
      "  /// Add a new ingredient type to Firestore and local list",
      "  Future<void> addIngredientType(",
      "      String franchiseId, IngredientType type) async {",
      "    // Defensive: Block blank or unknown franchise IDs",
      "    if (franchiseId.isEmpty || franchiseId == 'unknown') {",
      "      print('[IngredientTypeProvider] Called with blank/unknown franchiseId!');",
      "      await ErrorLogger.log(",
      "        message:",
      "            'IngredientTypeProvider: called with blank/unknown franchiseId',",
      "        stack: '',",
      "        source: 'ingredient_type_provider.dart',",
      "        screen: 'ingredient_type_provider.dart',",
      "        severity: 'warning',",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      return;",
      "    }",
      "    try {",
      "      await FirebaseFirestore.instance",
      "          .collection('franchises')",
      "          .doc(franchiseId)",
      "          .collection('ingredient_types')",
      "          .add(type.toMap(includeTimestamps: true));",
      "      await loadIngredientTypes(franchiseId);",
      "    } catch (e, stack) {",
      "      ErrorLogger.log(",
      "        message: 'Failed to add ingredient type',",
      "        source: 'ingredient_type_provider.dart',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "          'typeName': type.name,",
      "          'errorType': e.runtimeType.toString(),",
      "        },",
      "      );",
      "    }",
      "  }",
      "",
      "  /// Update an existing ingredient type",
      "  /// Update specific fields of an existing ingredient type",
      "  Future<void> updateIngredientType(",
      "    String franchiseId,",
      "    String typeId,",
      "    Map<String, dynamic> updatedFields,",
      "  ) async {",
      "    // Defensive: Block blank or unknown franchise IDs",
      "    if (franchiseId.isEmpty || franchiseId == 'unknown') {",
      "      print(",
      "          '[IngredientTypeProvider] updateIngredientType called with blank/unknown franchiseId!');",
      "      await ErrorLogger.log(",
      "        message:",
      "            'IngredientTypeProvider: update called with blank/unknown franchiseId',",
      "        stack: '',",
      "        source: 'ingredient_type_provider.dart',",
      "        screen: 'ingredient_type_provider.dart',",
      "        severity: 'warning',",
      "        contextData: {'franchiseId': franchiseId, 'typeId': typeId},",
      "      );",
      "      return;",
      "    }",
      "    try {",
      "      await FirebaseFirestore.instance",
      "          .collection('franchises')",
      "          .doc(franchiseId)",
      "          .collection('ingredient_types')",
      "          .doc(typeId)",
      "          .update({",
      "        ...updatedFields,",
      "        'updatedAt': FieldValue.serverTimestamp(),",
      "      });",
      "",
      "      await loadIngredientTypes(franchiseId);",
      "    } catch (e, stack) {",
      "      ErrorLogger.log(",
      "        message: 'Failed to update ingredient type (partial)',",
      "        source: 'ingredient_type_provider.dart',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "          'typeId': typeId,",
      "          'updatedFields': updatedFields.keys.toList(),",
      "          'errorType': e.runtimeType.toString(),",
      "        },",
      "      );",
      "    }",
      "  }",
      "",
      "  Future<void> deleteIngredientType(String franchiseId, String typeId) async {",
      "    // Defensive: Block blank or unknown franchise IDs",
      "    if (franchiseId.isEmpty || franchiseId == 'unknown') {",
      "      print(",
      "          '[IngredientTypeProvider] deleteIngredientType called with blank/unknown franchiseId!');",
      "      await ErrorLogger.log(",
      "        message:",
      "            'IngredientTypeProvider: delete called with blank/unknown franchiseId',",
      "        stack: '',",
      "        source: 'ingredient_type_provider.dart',",
      "        screen: 'ingredient_type_provider.dart',",
      "        severity: 'warning',",
      "        contextData: {'franchiseId': franchiseId, 'typeId': typeId},",
      "      );",
      "      return;",
      "    }",
      "    try {",
      "      await FirebaseFirestore.instance",
      "          .collection('franchises')",
      "          .doc(franchiseId)",
      "          .collection('ingredient_types')",
      "          .doc(typeId)",
      "          .delete();",
      "      _ingredientTypes.removeWhere((t) => t.id == typeId);",
      "      notifyListeners();",
      "    } catch (e, stack) {",
      "      ErrorLogger.log(",
      "        message: 'Failed to delete ingredient type',",
      "        source: 'ingredient_type_provider.dart',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "          'typeId': typeId,",
      "          'errorType': e.runtimeType.toString(),",
      "        },",
      "      );",
      "    }",
      "  }",
      "",
      "  /// Check if the ingredient type is currently referenced by any ingredient_metadata",
      "  Future<bool> isIngredientTypeInUse({",
      "    required String franchiseId,",
      "    required String typeId,",
      "  }) async {",
      "    // Defensive: Block blank or unknown franchise IDs",
      "    if (franchiseId.isEmpty || franchiseId == 'unknown') {",
      "      print(",
      "          '[IngredientTypeProvider] isIngredientTypeInUse called with blank/unknown franchiseId!');",
      "      await ErrorLogger.log(",
      "        message:",
      "            'IngredientTypeProvider: isInUse called with blank/unknown franchiseId',",
      "        stack: '',",
      "        source: 'ingredient_type_provider.dart',",
      "        screen: 'ingredient_type_provider.dart',",
      "        severity: 'warning',",
      "        contextData: {'franchiseId': franchiseId, 'typeId': typeId},",
      "      );",
      "      return true; // Defensive: treat as \"in use\"",
      "    }",
      "    try {",
      "      final querySnapshot = await FirebaseFirestore.instance",
      "          .collection('franchises')",
      "          .doc(franchiseId)",
      "          .collection('ingredient_metadata')",
      "          .where('typeId', isEqualTo: typeId)",
      "          .limit(1)",
      "          .get();",
      "",
      "      return querySnapshot.docs.isNotEmpty;",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to check ingredient type usage',",
      "        source: 'ingredient_type_provider.dart',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "          'typeId': typeId,",
      "          'errorType': e.runtimeType.toString(),",
      "        },",
      "      );",
      "      return true; // Defensive: assume in-use if error",
      "    }",
      "  }",
      "",
      "  Future<String> exportTypesAsJson(String franchiseId) async {",
      "    // Defensive: Block blank or unknown franchise IDs",
      "    if (franchiseId.isEmpty || franchiseId == 'unknown') {",
      "      print(",
      "          '[IngredientTypeProvider] exportTypesAsJson called with blank/unknown franchiseId!');",
      "      await ErrorLogger.log(",
      "        message:",
      "            'IngredientTypeProvider: exportTypesAsJson called with blank/unknown franchiseId',",
      "        stack: '',",
      "        source: 'IngredientTypeProvider',",
      "        screen: 'ingredient_type_management_screen',",
      "        severity: 'warning',",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      return '[]';",
      "    }",
      "    try {",
      "      final exportable = types.map((type) => type.toMap()).toList();",
      "      return const JsonEncoder.withIndent('  ').convert(exportable);",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to export ingredient types as JSON',",
      "        source: 'IngredientTypeProvider',",
      "        screen: 'ingredient_type_management_screen',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "          'typesLength': types.length,",
      "        },",
      "      );",
      "      return '[]';",
      "    }",
      "  }",
      "",
      "  Future<void> bulkReplaceIngredientTypes(",
      "    String franchiseId,",
      "    List<IngredientType> newTypes,",
      "  ) async {",
      "    // Defensive: Block blank or unknown franchise IDs",
      "    if (franchiseId.isEmpty || franchiseId == 'unknown') {",
      "      print(",
      "          '[IngredientTypeProvider] bulkReplaceIngredientTypes called with blank/unknown franchiseId!');",
      "      await ErrorLogger.log(",
      "        message:",
      "            'IngredientTypeProvider: bulkReplace called with blank/unknown franchiseId',",
      "        stack: '',",
      "        source: 'ingredient_type_provider.dart',",
      "        screen: 'ingredient_type_json_import_export_dialog.dart',",
      "        severity: 'warning',",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      return;",
      "    }",
      "    try {",
      "      final batch = _firestoreService.db.batch();",
      "      final collectionRef = _firestoreService.db",
      "          .collection('franchises')",
      "          .doc(franchiseId)",
      "          .collection('ingredient_types');",
      "",
      "      // 1. Delete existing types",
      "      final existingSnapshot = await collectionRef.get();",
      "      for (final doc in existingSnapshot.docs) {",
      "        batch.delete(doc.reference);",
      "      }",
      "",
      "      // 2. Add new types",
      "      for (int i = 0; i < newTypes.length; i++) {",
      "        final type = newTypes[i];",
      "        final docRef = collectionRef.doc();",
      "        batch.set(docRef, {",
      "          ...type.toMap(includeTimestamps: true),",
      "          'sortOrder': i,",
      "        });",
      "      }",
      "",
      "      await batch.commit();",
      "      await loadIngredientTypes(franchiseId);",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed bulk replace of ingredient types',",
      "        stack: stack.toString(),",
      "        severity: 'error',",
      "        source: 'ingredient_type_provider.dart',",
      "        screen: 'ingredient_type_json_import_export_dialog.dart',",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "          'newTypeCount': newTypes.length,",
      "        },",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  Future<void> loadTemplateIngredients(",
      "    String templateId,",
      "    String franchiseId,",
      "  ) async {",
      "    // Defensive: Block blank or unknown franchise IDs",
      "    if (franchiseId.isEmpty || franchiseId == 'unknown') {",
      "      print(",
      "          '[IngredientTypeProvider] loadTemplateIngredients called with blank/unknown franchiseId!');",
      "      await ErrorLogger.log(",
      "        message:",
      "            'IngredientTypeProvider: loadTemplateIngredients called with blank/unknown franchiseId',",
      "        stack: '',",
      "        source: 'IngredientTypeProvider',",
      "        screen: 'ingredient_metadata_template_picker_dialog',",
      "        severity: 'warning',",
      "        contextData: {'franchiseId': franchiseId, 'templateId': templateId},",
      "      );",
      "      return;",
      "    }",
      "    try {",
      "      final firestoreService = FirestoreService();",
      "",
      "      // 🔹 Load ingredient_metadata from template",
      "      final List<IngredientMetadata> ingredients =",
      "          await firestoreService.getIngredientMetadataTemplate(templateId);",
      "",
      "      final batch = firestoreService.db.batch();",
      "      final destRef = firestoreService.db",
      "          .collection('franchises')",
      "          .doc(franchiseId)",
      "          .collection('ingredient_metadata');",
      "",
      "      for (final ingredient in ingredients) {",
      "        final docRef = destRef.doc(ingredient.id);",
      "        batch.set(docRef, ingredient.toMap());",
      "      }",
      "",
      "      await batch.commit();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'template_ingredient_metadata_import_failed',",
      "        source: 'IngredientTypeProvider',",
      "        stack: stack.toString(),",
      "        severity: 'error',",
      "        screen: 'ingredient_metadata_template_picker_dialog',",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "          'templateId': templateId,",
      "        },",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  // Aliased methods for UI usage compatibility",
      "  Future<void> loadTypes(String franchiseId) =>",
      "      loadIngredientTypes(franchiseId);",
      "  List<IngredientType> get types => _ingredientTypes;",
      "",
      "  Future<void> addType(String franchiseId, IngredientType type) =>",
      "      addIngredientType(franchiseId, type);",
      "",
      "  Future<void> updateType(String franchiseId, IngredientType type) =>",
      "      updateIngredientType(",
      "          franchiseId, type.id!, type.toMap(includeTimestamps: true));",
      "",
      "  Future<void> deleteType(String franchiseId, String typeId) =>",
      "      deleteIngredientType(franchiseId, typeId);",
      "",
      "  /// Returns a map of all type IDs to names.",
      "  Map<String, String> get typeIdToName => Map.fromEntries(",
      "      types.where((t) => t.id != null).map((t) => MapEntry(t.id!, t.name)));",
      "",
      "  /// Returns a list of all available type IDs.",
      "  List<String> get allTypeIds => types",
      "      .where((t) => t.id != null && t.id!.isNotEmpty)",
      "      .map((t) => t.id!)",
      "      .toList();",
      "",
      "  /// Returns a list of all available type names.",
      "  List<String> get allTypeNames => types.map((t) => t.name).toList();",
      "",
      "  /// Find a type by name (case-insensitive, trimmed).",
      "  IngredientType? getByName(String name) {",
      "    return types.firstWhereOrNull(",
      "        (t) => t.name.trim().toLowerCase() == name.trim().toLowerCase());",
      "  }",
      "",
      "  /// Find a type by systemTag (case-insensitive).",
      "  IngredientType? getBySystemTag(String tag) {",
      "    return types.firstWhereOrNull((t) =>",
      "        t.systemTag != null && t.systemTag!.toLowerCase() == tag.toLowerCase());",
      "  }",
      "",
      "  /// Methods for ingredient type in schema issue sidebar",
      "  void stageIngredientType(IngredientType type) {",
      "    final alreadyStaged = _stagedTypes.any((t) => t.id == type.id);",
      "    final alreadyLoaded = _ingredientTypes.any((t) => t.id == type.id);",
      "",
      "    debugPrint('[IngredientTypeProvider] stageIngredientType called: '",
      "        'id=${type.id}, name=${type.name}, '",
      "        'alreadyStaged=$alreadyStaged, alreadyLoaded=$alreadyLoaded');",
      "",
      "    if (alreadyStaged || alreadyLoaded) {",
      "      debugPrint('[IngredientTypeProvider] Not staging: already exists.');",
      "      return;",
      "    }",
      "",
      "    _stagedTypes.add(type);",
      "    _ingredientTypes.add(type); // Ensure visible in all lists/dropdowns",
      "",
      "    debugPrint('[IngredientTypeProvider] Staged new ingredient type: '",
      "        'id=${type.id}, name=${type.name}. '",
      "        'StagedTypes=${_stagedTypes.length}, IngredientTypes=${_ingredientTypes.length}');",
      "    notifyListeners();",
      "  }",
      "",
      "  Future<void> saveStagedIngredientTypes() async {",
      "    // Defensive: Block blank or unknown franchise IDs",
      "    if (franchiseId.isEmpty || franchiseId == 'unknown') {",
      "      print(",
      "          '[IngredientTypeProvider] saveStagedIngredientTypes called with blank/unknown franchiseId!');",
      "      await ErrorLogger.log(",
      "        message:",
      "            'IngredientTypeProvider: saveStagedIngredientTypes called with blank/unknown franchiseId',",
      "        stack: '',",
      "        source: 'IngredientTypeProvider',",
      "        screen: 'ingredient_type_provider.dart',",
      "        severity: 'warning',",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      return;",
      "    }",
      "    final collectionRef = _firestoreService.db",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection('ingredient_types');",
      "",
      "    try {",
      "      final batch = _firestoreService.db.batch();",
      "",
      "      for (final type in _stagedTypes) {",
      "        batch.set(",
      "          collectionRef.doc(type.id),",
      "          type.toMap(includeTimestamps: true),",
      "        );",
      "      }",
      "      print('[IngredientTypeProvider] Persisting ${_stagedTypes.length} types');",
      "",
      "      await batch.commit();",
      "      _stagedTypes.clear();",
      "      await loadIngredientTypes(franchiseId);",
      "      notifyListeners();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'ingredient_type_save_failed',",
      "        stack: stack.toString(),",
      "        source: 'IngredientTypeProvider',",
      "        screen: 'ingredient_type_provider.dart',",
      "        severity: 'error',",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  void discardStagedIngredientTypes() {",
      "    _stagedTypes.clear();",
      "    print('[ProviderName] Discarded staged items: '",
      "        'count=${_stagedTypes.length} before clearing');",
      "    notifyListeners();",
      "  }",
      "",
      "  bool get hasStagedTypeChanges => _stagedTypes.isNotEmpty;",
      "",
      "  /// Adds the ingredient type to staging if it's not already present.",
      "  /// Adds the ingredient type to staging if it's not already staged or in the main list",
      "  bool stageIfNew({required String id, required String name}) {",
      "    final alreadyExists = _ingredientTypes.any((t) => t.id == id) ||",
      "        _stagedTypes.any((t) => t.id == id); // ✅ use _stagedTypes",
      "",
      "    if (!alreadyExists) {",
      "      final staged = IngredientType(",
      "        id: id,",
      "        name: name,",
      "        visibleInApp: true,",
      "      );",
      "      _stagedTypes.add(staged); // ✅ use _stagedTypes",
      "      notifyListeners();",
      "      debugPrint('[IngredientTypeProvider] Staged new type: '",
      "          'id=${staged.id}, name=${staged.name}');",
      "      return true;",
      "    }",
      "    return false;",
      "  }",
      "",
      "  // Add/remove single or bulk",
      "  void stageTypeForDelete(String id) {",
      "    _stagedForDelete.add(id);",
      "    notifyListeners();",
      "  }",
      "",
      "  void unstageTypeForDelete(String id) {",
      "    _stagedForDelete.remove(id);",
      "    notifyListeners();",
      "  }",
      "",
      "  void clearStagedDeletes() {",
      "    _stagedForDelete.clear();",
      "    notifyListeners();",
      "  }",
      "",
      "  bool get hasStagedDeletes => _stagedForDelete.isNotEmpty;",
      "",
      "  // Commit staged deletes to Firestore",
      "  Future<void> commitStagedDeletes(String franchiseId) async {",
      "    // Defensive: Block blank or unknown franchise IDs",
      "    if (franchiseId.isEmpty || franchiseId == 'unknown') {",
      "      print(",
      "          '[IngredientTypeProvider] commitStagedDeletes called with blank/unknown franchiseId!');",
      "      await ErrorLogger.log(",
      "        message:",
      "            'IngredientTypeProvider: commitStagedDeletes called with blank/unknown franchiseId',",
      "        stack: '',",
      "        source: 'ingredient_type_provider.dart',",
      "        screen: 'ingredient_type_provider.dart',",
      "        severity: 'warning',",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "          'ids': _stagedForDelete.toList()",
      "        },",
      "      );",
      "      return;",
      "    }",
      "    try {",
      "      final batch = _firestoreService.db.batch();",
      "      for (final id in _stagedForDelete) {",
      "        final docRef = _firestoreService.db",
      "            .collection('franchises')",
      "            .doc(franchiseId)",
      "            .collection('ingredient_types')",
      "            .doc(id);",
      "        batch.delete(docRef);",
      "      }",
      "      await batch.commit();",
      "      _stagedForDelete.clear();",
      "      await loadIngredientTypes(franchiseId);",
      "      notifyListeners();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to commit staged ingredient type deletions',",
      "        source: 'ingredient_type_provider.dart',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "          'ids': _stagedForDelete.toList(),",
      "        },",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  Future<List<OnboardingValidationIssue>> validate({",
      "    List<String>?",
      "        referencedTypeIds, // Optionally pass in-use type IDs for orphan checks",
      "  }) async {",
      "    final issues = <OnboardingValidationIssue>[];",
      "    try {",
      "      final typeNames = <String>{};",
      "      for (final type in _ingredientTypes) {",
      "        // Uniqueness check",
      "        if (!typeNames.add(type.name.trim().toLowerCase())) {",
      "          issues.add(OnboardingValidationIssue(",
      "            section: 'Ingredient Types',",
      "            itemId: type.id ?? '',",
      "            itemDisplayName: type.name,",
      "            severity: OnboardingIssueSeverity.critical,",
      "            code: 'DUPLICATE_TYPE_NAME',",
      "            message:",
      "                \"Duplicate ingredient type name: '${type.name}'. Names must be unique.\",",
      "            affectedFields: ['name'],",
      "            isBlocking: true,",
      "            fixRoute: '/onboarding/ingredient-types',",
      "            itemLocator: type.id,",
      "            resolutionHint: \"Change the type name to be unique.\",",
      "            actionLabel: \"Fix Now\",",
      "            icon: Icons.label_important,",
      "            detectedAt: DateTime.now(),",
      "            contextData: {",
      "              'type': type.toMap(),",
      "            },",
      "          ));",
      "        }",
      "      }",
      "",
      "      // Required at least one type",
      "      if (_ingredientTypes.isEmpty) {",
      "        issues.add(OnboardingValidationIssue(",
      "          section: 'Ingredient Types',",
      "          itemId: '',",
      "          itemDisplayName: '',",
      "          severity: OnboardingIssueSeverity.critical,",
      "          code: 'NO_INGREDIENT_TYPES',",
      "          message: \"At least one ingredient type must be defined.\",",
      "          affectedFields: ['ingredient_types'],",
      "          isBlocking: true,",
      "          fixRoute: '/onboarding/ingredient-types',",
      "          resolutionHint: \"Add an ingredient type before proceeding.\",",
      "          actionLabel: \"Add Type\",",
      "          icon: Icons.add_box_outlined,",
      "          detectedAt: DateTime.now(),",
      "        ));",
      "      }",
      "",
      "      // (Optional) Orphan check: find types not referenced by any ingredient if referencedTypeIds provided",
      "      if (referencedTypeIds != null) {",
      "        for (final type in _ingredientTypes) {",
      "          if (!referencedTypeIds.contains(type.id)) {",
      "            issues.add(OnboardingValidationIssue(",
      "              section: 'Ingredient Types',",
      "              itemId: type.id ?? '',",
      "              itemDisplayName: type.name,",
      "              severity: OnboardingIssueSeverity.warning,",
      "              code: 'UNUSED_TYPE',",
      "              message: \"Type '${type.name}' is not used by any ingredient.\",",
      "              affectedFields: [],",
      "              isBlocking: false,",
      "              fixRoute: '/onboarding/ingredient-types',",
      "              itemLocator: type.id,",
      "              resolutionHint: \"Consider removing unused types.\",",
      "              actionLabel: \"Review\",",
      "              icon: Icons.info_outline,",
      "              detectedAt: DateTime.now(),",
      "            ));",
      "          }",
      "        }",
      "      }",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'ingredient_type_validate_failed',",
      "        stack: stack.toString(),",
      "        source: 'IngredientTypeProvider.validate',",
      "        severity: 'error',",
      "        contextData: {},",
      "      );",
      "    }",
      "    return issues;",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 894,
      "file_size": 31660,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\providers\\menu_item_provider.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter/foundation.dart';",
      "import 'package:franchise_admin_portal/core/models/menu_item.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/core/models/menu_template_ref.dart';",
      "import 'package:franchise_admin_portal/core/models/size_template.dart';",
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "import 'package:firebase_auth/firebase_auth.dart' as fb_auth;",
      "import 'package:franchise_admin_portal/core/providers/franchise_info_provider.dart';",
      "import 'package:collection/collection.dart';",
      "import 'package:franchise_admin_portal/core/providers/category_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/ingredient_metadata_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/ingredient_type_provider.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/models/onboarding_validation_issue.dart';",
      "",
      "class MenuItemProvider extends ChangeNotifier {",
      "  final FirestoreService _firestoreService;",
      "  List<MenuTemplateRef> _templateRefs = [];",
      "  bool _templateRefsLoading = false;",
      "  String? _templateRefsError;",
      "  FranchiseInfoProvider _franchiseInfoProvider;",
      "",
      "  late IngredientMetadataProvider _ingredientProvider;",
      "  late CategoryProvider _categoryProvider;",
      "  late IngredientTypeProvider _typeProvider;",
      "",
      "  // 🔢 Size Templates",
      "  List<SizeTemplate> _sizeTemplates = [];",
      "  String? _selectedSizeTemplateId;",
      "",
      "  List<SizeTemplate> get sizeTemplates => _sizeTemplates;",
      "  String? get selectedSizeTemplateId => _selectedSizeTemplateId;",
      "",
      "  set franchiseInfoProvider(FranchiseInfoProvider value) {",
      "    final oldType = _franchiseInfoProvider.franchise?.restaurantType;",
      "    final newType = value.franchise?.restaurantType;",
      "    _franchiseInfoProvider = value;",
      "    if (newType != null && newType.isNotEmpty && newType != oldType) {",
      "      loadTemplateRefs();",
      "    }",
      "  }",
      "",
      "  void injectDependencies({",
      "    required IngredientMetadataProvider ingredientProvider,",
      "    required CategoryProvider categoryProvider,",
      "    required IngredientTypeProvider typeProvider,",
      "  }) {",
      "    _ingredientProvider = ingredientProvider;",
      "    _categoryProvider = categoryProvider;",
      "    _typeProvider = typeProvider;",
      "  }",
      "",
      "  void setSelectedSizeTemplateId(String? id) {",
      "    _selectedSizeTemplateId = id;",
      "    notifyListeners();",
      "  }",
      "",
      "  Future<void> loadSizeTemplates(String restaurantType) async {",
      "    try {",
      "      _sizeTemplates =",
      "          await _firestoreService.getSizeTemplatesForTemplate(restaurantType);",
      "      notifyListeners();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to load size templates',",
      "        source: 'MenuItemProvider',",
      "        screen: 'menu_item_provider',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "      );",
      "    }",
      "  }",
      "",
      "  List<MenuItem> _original = [];",
      "  List<MenuItem> _working = [];",
      "",
      "  bool _isLoading = false;",
      "  String? _franchiseId;",
      "",
      "  // Tracks whether we've completed at least one successful Firestore load.",
      "  bool _hasLoaded = false;",
      "  String? _loadedFranchiseId;",
      "",
      "  bool get isLoaded => _hasLoaded;",
      "",
      "  List<MenuTemplateRef> get templateRefs => _templateRefs;",
      "  bool get templateRefsLoading => _templateRefsLoading;",
      "  String? get templateRefsError => _templateRefsError;",
      "",
      "  MenuItemProvider({",
      "    required FirestoreService firestoreService,",
      "    required FranchiseInfoProvider franchiseInfoProvider,",
      "  })  : _firestoreService = firestoreService,",
      "        _franchiseInfoProvider = franchiseInfoProvider;",
      "",
      "  List<MenuItem> get menuItems => _working;",
      "  bool get isLoading => _isLoading;",
      "",
      "  bool get isDirty {",
      "    if (_original.length != _working.length) return true;",
      "    for (int i = 0; i < _original.length; i++) {",
      "      if (_original[i].toMap().toString() != _working[i].toMap().toString()) {",
      "        return true;",
      "      }",
      "    }",
      "    return false;",
      "  }",
      "",
      "  /// Uniform loader used by the review screen.",
      "  /// - Provide [franchiseIdOverride] if this provider hasn't been told its franchise yet.",
      "  /// - If [forceReloadFromFirestore] is false and data is warm, this is a no-op.",
      "  Future<void> load(",
      "      {bool forceReloadFromFirestore = false,",
      "      String? franchiseIdOverride}) async {",
      "    if (franchiseIdOverride != null && franchiseIdOverride.isNotEmpty) {",
      "      _franchiseId = franchiseIdOverride;",
      "    }",
      "",
      "    final id = _franchiseId;",
      "    if (id == null || id.isEmpty || id == 'unknown') {",
      "      debugPrint(",
      "          '[MenuItemProvider][load] ⚠️ Skipping load: missing/unknown franchiseId.');",
      "      return;",
      "    }",
      "",
      "    if (_hasLoaded && !forceReloadFromFirestore) {",
      "      debugPrint(",
      "          '[MenuItemProvider][load] 🔁 Using warm cache (items=${_working.length}).');",
      "      return;",
      "    }",
      "",
      "    debugPrint(",
      "        '[MenuItemProvider][load] 📡 Fetching menu items for franchise \"$id\"...');",
      "    await loadMenuItems(id); // ← uses your existing method",
      "    _hasLoaded = true;",
      "    debugPrint('[MenuItemProvider][load] ✅ Loaded (items=${_working.length}).');",
      "  }",
      "",
      "  Future<void> reload(String franchiseId,",
      "      {bool forceReloadFromFirestore = false}) async {",
      "    if (franchiseId.isEmpty || franchiseId == 'unknown') {",
      "      print(",
      "          '[MenuItemProvider][RELOAD] ⚠️ Called with blank/unknown franchiseId! Skipping reload.');",
      "      await ErrorLogger.log(",
      "        message:",
      "            'MenuItemProvider: reload called with blank/unknown franchiseId',",
      "        stack: '',",
      "        source: 'menu_item_provider.dart',",
      "        screen: 'menu_item_provider.dart',",
      "        severity: 'warning',",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      return;",
      "    }",
      "",
      "    if (forceReloadFromFirestore) {",
      "      print(",
      "          '[MenuItemProvider][RELOAD] 🔄 Forcing reload from Firestore for franchise \"$franchiseId\"...');",
      "      _hasLoaded = false;",
      "    } else {",
      "      print(",
      "          '[MenuItemProvider][RELOAD] ♻️ Reloading menu items for franchise \"$franchiseId\"...');",
      "    }",
      "",
      "    await loadMenuItems(franchiseId,",
      "        forceReloadFromFirestore: forceReloadFromFirestore);",
      "  }",
      "",
      "  Future<void> loadMenuItems(",
      "    String franchiseId, {",
      "    bool forceReloadFromFirestore = false,",
      "  }) async {",
      "    print(",
      "        '\\n[MenuItemProvider][LOAD] 🚀 Starting menu item load for franchiseId=\"$franchiseId\"');",
      "    print(",
      "        '   ➤ _loadedFranchiseId = \"${_loadedFranchiseId ?? 'null'}\", _hasLoaded = $_hasLoaded');",
      "    print('   ➤ forceReloadFromFirestore = $forceReloadFromFirestore');",
      "",
      "    // Defensive: Block blank/unknown franchise IDs",
      "    if (franchiseId.isEmpty || franchiseId == 'unknown') {",
      "      print(",
      "          '[MenuItemProvider][LOAD] ⚠️ Called with blank/unknown franchiseId! Skipping load.');",
      "      await ErrorLogger.log(",
      "        message: 'MenuItemProvider: load called with blank/unknown franchiseId',",
      "        stack: '',",
      "        source: 'menu_item_provider.dart',",
      "        screen: 'menu_item_provider.dart',",
      "        severity: 'warning',",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      return;",
      "    }",
      "",
      "    // Skip reload if already loaded for same franchise (unless forced)",
      "    if (!forceReloadFromFirestore &&",
      "        _hasLoaded &&",
      "        _loadedFranchiseId == franchiseId) {",
      "      print(",
      "          '[MenuItemProvider][LOAD] ⏩ Already loaded for this franchise. Skipping fetch.');",
      "      return;",
      "    }",
      "",
      "    try {",
      "      print(",
      "          '[MenuItemProvider][LOAD] 📡 Fetching menu items from Firestore...');",
      "      final fetched = await _firestoreService.fetchMenuItems(franchiseId);",
      "",
      "      print('[MenuItemProvider][LOAD] ✅ Fetched ${fetched.length} menu items.');",
      "      for (final item in fetched) {",
      "        print('    • id=\"${item.id}\", name=\"${item.name}\"');",
      "      }",
      "",
      "      // Replace in-memory collections",
      "      _working",
      "        ..clear()",
      "        ..addAll(fetched);",
      "",
      "      _original = _working.map((e) => e.copyWith()).toList();",
      "",
      "      _hasLoaded = true;",
      "      _loadedFranchiseId = franchiseId;",
      "",
      "      notifyListeners();",
      "      print('[MenuItemProvider][LOAD] 🎯 Load complete. UI notified.');",
      "    } catch (e, stack) {",
      "      print('[MenuItemProvider][LOAD][ERROR] ❌ Failed to load menu items: $e');",
      "      await ErrorLogger.log(",
      "        message: 'menu_item_load_error',",
      "        stack: stack.toString(),",
      "        source: 'menu_item_provider.dart',",
      "        screen: 'menu_item_provider.dart',",
      "        severity: 'error',",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      rethrow;",
      "    }",
      "",
      "    print('[MenuItemProvider][LOAD] 🏁 Finished.\\n');",
      "  }",
      "",
      "  void addOrUpdateMenuItem(MenuItem item) {",
      "    print('[DEBUG] addOrUpdateMenuItem called with id=${item.id}');",
      "    final index = _working.indexWhere((i) => i.id == item.id);",
      "    if (index == -1) {",
      "      _working.add(item);",
      "    } else {",
      "      _working[index] = item;",
      "    }",
      "    notifyListeners(); // ✅ Needed for UI to react to dirty state",
      "  }",
      "",
      "  void deleteMenuItem(String id) {",
      "    _working.removeWhere((item) => item.id == id);",
      "    notifyListeners();",
      "  }",
      "",
      "  Future<void> persistChanges() async {",
      "    print('[DEBUG] persistChanges called');",
      "    if (_franchiseId == null || !isDirty) {",
      "      print(",
      "          '[DEBUG] Aborting persistChanges: isDirty=$isDirty, franchiseId=$_franchiseId');",
      "      return;",
      "    }",
      "",
      "    if (_ingredientProvider == null ||",
      "        _categoryProvider == null ||",
      "        _typeProvider == null) {",
      "      throw StateError('Dependencies not injected into MenuItemProvider.');",
      "    }",
      "",
      "    try {",
      "      // --- 1. Save staged ingredient types FIRST ---",
      "      if (_typeProvider.hasStagedTypeChanges) {",
      "        try {",
      "          print('[DEBUG] Saving staged ingredient types...');",
      "          print('[DEBUG] Staged Ingredient Types to save: '",
      "              '${_typeProvider.stagedTypes.map((t) => t.id).toList()}');",
      "          await _typeProvider.saveStagedIngredientTypes();",
      "          print('[DEBUG] Staged ingredient types saved');",
      "        } catch (e, stack) {",
      "          await ErrorLogger.log(",
      "            message: 'Failed to save staged ingredient types',",
      "            source: 'MenuItemProvider',",
      "            screen: 'menu_item_provider.dart',",
      "            severity: 'error',",
      "            stack: stack.toString(),",
      "            contextData: {'franchiseId': _franchiseId},",
      "          );",
      "          rethrow; // 🚨 BLOCK SAVE if fail!",
      "        }",
      "      }",
      "",
      "      // --- 2. Save staged ingredients SECOND ---",
      "      if (_ingredientProvider.hasStagedChanges) {",
      "        try {",
      "          print('[DEBUG] Saving staged ingredients...');",
      "          print('[DEBUG] Staged Ingredients to save: '",
      "              '${_ingredientProvider.stagedIngredients.map((e) => e.id).toList()}');",
      "          await _ingredientProvider.saveStagedIngredients();",
      "          print('[DEBUG] Staged ingredients saved');",
      "        } catch (e, stack) {",
      "          await ErrorLogger.log(",
      "            message: 'Failed to save staged ingredients',",
      "            source: 'MenuItemProvider',",
      "            screen: 'menu_item_provider.dart',",
      "            severity: 'error',",
      "            stack: stack.toString(),",
      "            contextData: {'franchiseId': _franchiseId},",
      "          );",
      "          rethrow; // 🚨 BLOCK SAVE if fail!",
      "        }",
      "      }",
      "",
      "      // --- 3. Save staged categories THIRD ---",
      "      if (_categoryProvider.hasStagedCategoryChanges) {",
      "        try {",
      "          print('[DEBUG] Saving staged categories...');",
      "          print('[DEBUG] Staged Categories to save: '",
      "              '${_categoryProvider.stagedCategories.map((c) => c.id).toList()}');",
      "          await _categoryProvider.saveStagedCategories();",
      "          print('[DEBUG] Staged categories saved');",
      "        } catch (e, stack) {",
      "          await ErrorLogger.log(",
      "            message: 'Failed to save staged categories',",
      "            source: 'MenuItemProvider',",
      "            screen: 'menu_item_provider.dart',",
      "            severity: 'error',",
      "            stack: stack.toString(),",
      "            contextData: {'franchiseId': _franchiseId},",
      "          );",
      "          rethrow; // 🚨 BLOCK SAVE if fail!",
      "        }",
      "      }",
      "",
      "      // --- 4. Save menu items LAST ---",
      "      print('[DEBUG] Saving ${_working.length} menu items...');",
      "      await _firestoreService.saveMenuItems(_franchiseId!, _working);",
      "      print('[DEBUG] Menu items saved');",
      "",
      "      // --- 5. Clear staged memory (regardless of error) ---",
      "      _ingredientProvider.discardStagedIngredients();",
      "      _categoryProvider.discardStagedCategories();",
      "      _typeProvider.discardStagedIngredientTypes();",
      "      print('[DEBUG] All staged data discarded');",
      "",
      "      // --- 6. Mark menu items clean ---",
      "      _original = _working.map((e) => e.copyWith()).toList();",
      "      notifyListeners();",
      "      print('[DEBUG] Save complete, isDirty=$isDirty');",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to persist menu item changes',",
      "        source: 'MenuItemProvider',",
      "        screen: 'menu_item_provider.dart',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "        contextData: {'franchiseId': _franchiseId},",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  void revertChanges() {",
      "    _working = _original.map((e) => e.copyWith()).toList();",
      "    notifyListeners();",
      "  }",
      "",
      "  Future<void> reorderMenuItems(List<MenuItem> reordered) async {",
      "    if (_franchiseId == null) return;",
      "",
      "    try {",
      "      await _firestoreService.reorderMenuItems(_franchiseId!, reordered);",
      "      _working = reordered;",
      "      notifyListeners();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to reorder menu items',",
      "        source: 'MenuItemProvider',",
      "        screen: 'menu_item_provider',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "        contextData: {'franchiseId': _franchiseId},",
      "      );",
      "    }",
      "  }",
      "",
      "  Future<void> loadTemplateRefs() async {",
      "    _templateRefsLoading = true;",
      "    _templateRefsError = null;",
      "    notifyListeners();",
      "",
      "    try {",
      "      final franchise = _franchiseInfoProvider.franchise;",
      "      if (franchise == null ||",
      "          franchise.restaurantType == null ||",
      "          franchise.restaurantType!.isEmpty) {",
      "        throw Exception('Missing restaurant type during template load');",
      "      }",
      "",
      "      _templateRefs = await _firestoreService.fetchMenuTemplateRefs(",
      "        restaurantType: franchise.restaurantType!,",
      "      );",
      "    } catch (e, stack) {",
      "      _templateRefsError = e.toString();",
      "      await ErrorLogger.log(",
      "        message: 'Failed to load menu template refs',",
      "        source: 'MenuItemProvider',",
      "        screen: 'menu_item_provider',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "      );",
      "    } finally {",
      "      _templateRefsLoading = false;",
      "      notifyListeners();",
      "    }",
      "  }",
      "",
      "  Future<MenuItem?> fetchMenuItemTemplateById({",
      "    required String restaurantType,",
      "    required String templateId,",
      "  }) async {",
      "    try {",
      "      final docSnapshot = await FirebaseFirestore.instance",
      "          .collection('onboarding_templates')",
      "          .doc(restaurantType)",
      "          .collection('menu_items')",
      "          .doc(templateId)",
      "          .get();",
      "",
      "      if (!docSnapshot.exists) {",
      "        await ErrorLogger.log(",
      "          message: 'Menu item template not found',",
      "          source: 'MenuItemProvider.fetchMenuItemTemplateById',",
      "          screen: 'menu_item_editor_sheet.dart',",
      "          severity: 'warning',",
      "          contextData: {",
      "            'restaurantType': restaurantType,",
      "            'templateId': templateId,",
      "          },",
      "        );",
      "        return null;",
      "      }",
      "",
      "      final data = docSnapshot.data();",
      "      if (data == null) {",
      "        await ErrorLogger.log(",
      "          message: 'Empty menu item template document',",
      "          source: 'MenuItemProvider.fetchMenuItemTemplateById',",
      "          screen: 'menu_item_editor_sheet.dart',",
      "          severity: 'error',",
      "          contextData: {",
      "            'restaurantType': restaurantType,",
      "            'templateId': templateId,",
      "          },",
      "        );",
      "        return null;",
      "      }",
      "",
      "      try {",
      "        return MenuItem.fromFirestore(data, docSnapshot.id);",
      "      } catch (e, stack) {",
      "        await ErrorLogger.log(",
      "          message: 'MenuItem.fromFirestore threw during template fetch',",
      "          stack: stack.toString(),",
      "          source: 'MenuItemProvider.fetchMenuItemTemplateById',",
      "          screen: 'menu_item_editor_sheet.dart',",
      "          severity: 'error',",
      "          contextData: {",
      "            'restaurantType': restaurantType,",
      "            'templateId': templateId,",
      "            'rawData': data.map((k, v) => MapEntry(k, _safeStringify(v))),",
      "            'error': e.toString(),",
      "            'env': kReleaseMode ? 'production' : 'development',",
      "          },",
      "        );",
      "        return null;",
      "      }",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Unhandled exception during menu item template fetch',",
      "        stack: stack.toString(),",
      "        source: 'MenuItemProvider.fetchMenuItemTemplateById',",
      "        screen: 'menu_item_editor_sheet.dart',",
      "        severity: 'error',",
      "        contextData: {",
      "          'restaurantType': restaurantType,",
      "          'templateId': templateId,",
      "          'error': e.toString(),",
      "        },",
      "      );",
      "      return null;",
      "    }",
      "  }",
      "",
      "  MenuItem applyTemplateToNewItem(MenuItem template) {",
      "    return template.copyWith(",
      "      id: '',",
      "      templateRefs: [template.id],",
      "      archived: false,",
      "      available: true,",
      "      sortOrder: _working.length,",
      "    );",
      "  }",
      "",
      "  /// Returns a list of missing required fields for a given MenuItem (used by onboarding/repair UI)",
      "  List<String> getMissingRequiredFields(MenuItem item) {",
      "    final missing = <String>[];",
      "    if (item.name.isEmpty) missing.add('name');",
      "    if (item.description.isEmpty) missing.add('description');",
      "    if (item.categoryId.isEmpty) missing.add('categoryId');",
      "    if (item.category.isEmpty) missing.add('category');",
      "    if (item.price == 0.0 &&",
      "        (item.sizePrices == null || item.sizePrices!.isEmpty))",
      "      missing.add('price');",
      "    if (item.includedIngredients == null || item.includedIngredients!.isEmpty)",
      "      missing.add('includedIngredients');",
      "    if (item.customizationGroups == null || item.customizationGroups!.isEmpty)",
      "      missing.add('customizationGroups');",
      "    if (item.sizes != null &&",
      "        item.sizes!.isNotEmpty &&",
      "        (item.sizePrices == null || item.sizePrices!.isEmpty))",
      "      missing.add('sizePrices');",
      "    // Add more as your onboarding requires",
      "    return missing;",
      "  }",
      "",
      "  Future<MenuItem> repairMenuItemReferences(MenuItem item,",
      "      {required Map<String, String> ingredientIdMap,",
      "      required Map<String, String> categoryIdMap}) async {",
      "    // Implement logic to map/repair all invalid IDs based on mappings from UI",
      "    // Return the fixed MenuItem",
      "    // (Useful for bulk import/fixes, not required for single-item UI)",
      "    return item;",
      "  }",
      "",
      "  void updateWorkingMenuItem(MenuItem item) {",
      "    final idx = _working.indexWhere((m) => m.id == item.id);",
      "    if (idx != -1) {",
      "      _working[idx] = item;",
      "      notifyListeners();",
      "    }",
      "  }",
      "",
      "  String _safeStringify(dynamic v) {",
      "    if (v is Timestamp) return v.toDate().toIso8601String();",
      "    if (v is Map)",
      "      return v.map((k, val) => MapEntry(k, _safeStringify(val))).toString();",
      "    if (v is List) return v.map(_safeStringify).toList().toString();",
      "    return v.toString();",
      "  }",
      "",
      "  /// Returns all menu item IDs for mapping/repair UI.",
      "  List<String> get allMenuItemIds => menuItems.map((m) => m.id).toList();",
      "",
      "  /// Find a menu item by name (case-insensitive, trimmed).",
      "  MenuItem? getByName(String name) {",
      "    return menuItems.firstWhereOrNull(",
      "        (m) => m.name.trim().toLowerCase() == name.trim().toLowerCase());",
      "  }",
      "",
      "  /// Find a menu item by ID (case-insensitive).",
      "  MenuItem? getByIdCaseInsensitive(String id) {",
      "    return menuItems",
      "        .firstWhereOrNull((m) => m.id.toLowerCase() == id.toLowerCase());",
      "  }",
      "",
      "  Future<void> logRepairAction({",
      "    required String menuItemId,",
      "    required String field,",
      "    required String oldValue,",
      "    required String newValue,",
      "    required String user,",
      "  }) async {",
      "    await ErrorLogger.log(",
      "      message: 'MenuItem repair',",
      "      source: 'MenuItemProvider',",
      "      screen: 'onboarding/repair',",
      "      severity: 'info',",
      "      contextData: {",
      "        'menuItemId': menuItemId,",
      "        'field': field,",
      "        'oldValue': oldValue,",
      "        'newValue': newValue,",
      "        'user': user,",
      "      },",
      "    );",
      "  }",
      "",
      "  Future<void> refreshAllProviders({",
      "    required CategoryProvider categoryProvider,",
      "    required IngredientMetadataProvider ingredientProvider,",
      "    required IngredientTypeProvider ingredientTypeProvider,",
      "    String? franchiseId,",
      "  }) async {",
      "    final fid =",
      "        franchiseId ?? _franchiseId ?? _franchiseInfoProvider.franchise?.id;",
      "    if (fid == null || fid.isEmpty) return;",
      "",
      "    await Future.wait([",
      "      _franchiseInfoProvider.reload(),",
      "      categoryProvider.reload(fid),",
      "      ingredientProvider.reload(),",
      "      ingredientTypeProvider.reload(fid),",
      "    ]);",
      "    notifyListeners();",
      "  }",
      "",
      "  /// Returns all unique category IDs referenced by current menu items.",
      "  List<String> get allReferencedCategoryIds {",
      "    final ids = <String>{};",
      "    for (final item in menuItems) {",
      "      ids.add(item.categoryId);",
      "    }",
      "    return ids.toList();",
      "  }",
      "",
      "  /// Returns all unique ingredient IDs referenced by all menu items.",
      "  List<String> get allReferencedIngredientIds {",
      "    final ids = <String>{};",
      "    for (final item in menuItems) {",
      "      ids.addAll(item.allReferencedIngredientIds);",
      "    }",
      "    return ids.toList();",
      "  }",
      "",
      "  /// Returns all unique ingredient type IDs referenced by all menu items.",
      "  List<String> get allReferencedIngredientTypeIds {",
      "    final ids = <String>{};",
      "    for (final item in menuItems) {",
      "      ids.addAll(item.allReferencedIngredientTypeIds);",
      "    }",
      "    return ids.toList();",
      "  }",
      "",
      "  Future<void> deleteFromFirestore(String id) async {",
      "    if (_franchiseId == null) return;",
      "",
      "    try {",
      "      await _firestoreService.deleteMenuItem(_franchiseId!, id);",
      "      deleteMenuItem(id);",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to delete menu item from Firestore',",
      "        source: 'MenuItemProvider',",
      "        screen: 'menu_item_provider',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "        contextData: {'franchiseId': _franchiseId, 'menuItemId': id},",
      "      );",
      "    }",
      "  }",
      "",
      "  Future<List<OnboardingValidationIssue>> validate({",
      "    required List<String> validCategoryIds,",
      "    required List<String> validIngredientIds,",
      "    required List<String> validTypeIds,",
      "  }) async {",
      "    final issues = <OnboardingValidationIssue>[];",
      "    try {",
      "      final menuItemNames = <String>{};",
      "      for (final item in _working) {",
      "        // Name uniqueness",
      "        if (!menuItemNames.add(item.name.trim().toLowerCase())) {",
      "          issues.add(OnboardingValidationIssue(",
      "            section: 'Menu Items',",
      "            itemId: item.id,",
      "            itemDisplayName: item.name,",
      "            severity: OnboardingIssueSeverity.critical,",
      "            code: 'DUPLICATE_MENU_ITEM_NAME',",
      "            message: \"Duplicate menu item name: '${item.name}'.\",",
      "            affectedFields: ['name'],",
      "            isBlocking: true,",
      "            fixRoute: '/onboarding/menu_items',",
      "            itemLocator: item.id,",
      "            resolutionHint: \"Menu item names must be unique.\",",
      "            actionLabel: \"Fix Now\",",
      "            icon: Icons.label_important,",
      "            detectedAt: DateTime.now(),",
      "            contextData: {",
      "              'menu_item': item.toMap(),",
      "            },",
      "          ));",
      "        }",
      "        // Category reference valid",
      "        if (!validCategoryIds.contains(item.categoryId)) {",
      "          issues.add(OnboardingValidationIssue(",
      "            section: 'Menu Items',",
      "            itemId: item.id,",
      "            itemDisplayName: item.name,",
      "            severity: OnboardingIssueSeverity.critical,",
      "            code: 'INVALID_CATEGORY_REFERENCE',",
      "            message:",
      "                \"Menu item '${item.name}' references a missing or invalid category.\",",
      "            affectedFields: ['categoryId'],",
      "            isBlocking: true,",
      "            fixRoute: '/onboarding/menu_items',",
      "            itemLocator: item.id,",
      "            resolutionHint: \"Assign a valid category.\",",
      "            actionLabel: \"Fix Now\",",
      "            icon: Icons.link_off,",
      "            detectedAt: DateTime.now(),",
      "          ));",
      "        }",
      "        // Ingredient references valid",
      "        for (final includedIng in item.includedIngredients ?? []) {",
      "          if (!validIngredientIds.contains(includedIng.ingredientId)) {",
      "            issues.add(OnboardingValidationIssue(",
      "              section: 'Menu Items',",
      "              itemId: item.id,",
      "              itemDisplayName: item.name,",
      "              severity: OnboardingIssueSeverity.critical,",
      "              code: 'INVALID_INGREDIENT_REFERENCE',",
      "              message:",
      "                  \"Menu item '${item.name}' references a missing ingredient.\",",
      "              affectedFields: ['includedIngredients'],",
      "              isBlocking: true,",
      "              fixRoute: '/onboarding/menu_items',",
      "              itemLocator: item.id,",
      "              resolutionHint: \"Replace or remove invalid ingredient reference.\",",
      "              actionLabel: \"Fix Now\",",
      "              icon: Icons.link_off,",
      "              detectedAt: DateTime.now(),",
      "              contextData: {",
      "                'missingIngredientId': includedIng.ingredientId,",
      "              },",
      "            ));",
      "          }",
      "          // Optional: Check included ingredient's type is valid",
      "          if (includedIng.typeId != null &&",
      "              !validTypeIds.contains(includedIng.typeId)) {",
      "            issues.add(OnboardingValidationIssue(",
      "              section: 'Menu Items',",
      "              itemId: item.id,",
      "              itemDisplayName: item.name,",
      "              severity: OnboardingIssueSeverity.critical,",
      "              code: 'INVALID_TYPE_REFERENCE',",
      "              message:",
      "                  \"Menu item '${item.name}' includes an ingredient with an invalid type.\",",
      "              affectedFields: ['includedIngredients.typeId'],",
      "              isBlocking: true,",
      "              fixRoute: '/onboarding/menu_items',",
      "              itemLocator: item.id,",
      "              resolutionHint: \"Assign a valid type.\",",
      "              actionLabel: \"Fix Now\",",
      "              icon: Icons.link_off,",
      "              detectedAt: DateTime.now(),",
      "              contextData: {",
      "                'includedIngredient': includedIng.toMap(),",
      "              },",
      "            ));",
      "          }",
      "        }",
      "        // Required fields check (e.g., price, sizePrices, etc)",
      "        // Check for each menu item required field as per your schema",
      "        if (item.price == null) {",
      "          issues.add(OnboardingValidationIssue(",
      "            section: 'Menu Items',",
      "            itemId: item.id,",
      "            itemDisplayName: item.name,",
      "            severity: OnboardingIssueSeverity.critical,",
      "            code: 'MISSING_REQUIRED_FIELD',",
      "            message:",
      "                \"Menu item '${item.name}' is missing required field: price.\",",
      "            affectedFields: ['price'],",
      "            isBlocking: true,",
      "            fixRoute: '/onboarding/menu_items',",
      "            itemLocator: item.id,",
      "            resolutionHint: \"Enter a valid price.\",",
      "            actionLabel: \"Fix Now\",",
      "            icon: Icons.price_change,",
      "            detectedAt: DateTime.now(),",
      "          ));",
      "        }",
      "        // ... Repeat for other schema-required fields (sizePrices, available, image, etc)",
      "      }",
      "      if (_working.isEmpty) {",
      "        issues.add(OnboardingValidationIssue(",
      "          section: 'Menu Items',",
      "          itemId: '',",
      "          itemDisplayName: '',",
      "          severity: OnboardingIssueSeverity.critical,",
      "          code: 'NO_MENU_ITEMS_DEFINED',",
      "          message: \"At least one menu item must be defined.\",",
      "          affectedFields: ['menu_items'],",
      "          isBlocking: true,",
      "          fixRoute: '/onboarding/menu_items',",
      "          resolutionHint: \"Add at least one menu item.\",",
      "          actionLabel: \"Add Item\",",
      "          icon: Icons.add_box_outlined,",
      "          detectedAt: DateTime.now(),",
      "        ));",
      "      }",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'menu_item_validate_failed',",
      "        stack: stack.toString(),",
      "        source: 'MenuItemProvider.validate',",
      "        severity: 'error',",
      "        contextData: {},",
      "      );",
      "    }",
      "    return issues;",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 806,
      "file_size": 28807,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\providers\\onboarding_progress_provider.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class OnboardingProgressProvider extends ChangeNotifier {",
      "  final FirestoreService firestore;",
      "  final String franchiseId;",
      "",
      "  Map<String, bool> _stepStatus = {};",
      "  bool _loading = true;",
      "",
      "  OnboardingProgressProvider({",
      "    required this.firestore,",
      "    required this.franchiseId,",
      "  }) {",
      "    _loadProgress();",
      "  }",
      "",
      "  Map<String, bool> get stepStatus => _stepStatus;",
      "  bool get loading => _loading;",
      "",
      "  bool isStepComplete(String stepKey) => _stepStatus[stepKey] == true;",
      "",
      "  Future<void> _loadProgress() async {",
      "    print(",
      "        '[DEBUG][OnboardingProgressProvider] Loading for franchiseId: \"$franchiseId\"');",
      "    if (franchiseId.isEmpty) {",
      "      print(",
      "          '[ERROR][OnboardingProgressProvider] FranchiseId is empty! Skipping progress load.');",
      "      await ErrorLogger.log(",
      "        message: 'Failed to load onboarding progress for empty franchiseId',",
      "        stack: '',",
      "        source: 'OnboardingProgressProvider',",
      "        screen: 'onboarding_menu_screen',",
      "        severity: 'error',",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      _stepStatus = {};",
      "      _loading = false;",
      "      notifyListeners();",
      "      return;",
      "    }",
      "    try {",
      "      _loading = true;",
      "      notifyListeners();",
      "",
      "      final data = await firestore.getOnboardingProgress(franchiseId);",
      "      final defaultSteps = [",
      "        'ingredientTypes',",
      "        'ingredients',",
      "        'categories',",
      "        'menuItems',",
      "        'review',",
      "      ];",
      "",
      "      _stepStatus = {",
      "        for (final step in defaultSteps)",
      "          step: data != null && data[step] == true",
      "      };",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to load onboarding progress',",
      "        stack: stack.toString(),",
      "        source: 'OnboardingProgressProvider',",
      "        screen: 'onboarding_menu_screen',",
      "        severity: 'warning',",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "    } finally {",
      "      _loading = false;",
      "      notifyListeners();",
      "    }",
      "  }",
      "",
      "  Future<void> markStepComplete(String stepKey) async {",
      "    if (franchiseId.isEmpty) {",
      "      print(",
      "          '[ERROR][OnboardingProgressProvider] Cannot mark step complete: franchiseId is empty!');",
      "      await ErrorLogger.log(",
      "        message:",
      "            'Failed to mark onboarding step \"$stepKey\" complete: franchiseId is empty',",
      "        stack: '',",
      "        source: 'OnboardingProgressProvider',",
      "        screen: 'onboarding_menu_screen',",
      "        severity: 'error',",
      "        contextData: {'franchiseId': franchiseId, 'stepKey': stepKey},",
      "      );",
      "      return;",
      "    }",
      "    try {",
      "      await firestore.updateOnboardingStep(",
      "        franchiseId: franchiseId,",
      "        stepKey: stepKey,",
      "        completed: true,",
      "      );",
      "      _stepStatus[stepKey] = true;",
      "      notifyListeners();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to mark onboarding step \"$stepKey\" complete',",
      "        stack: stack.toString(),",
      "        source: 'OnboardingProgressProvider',",
      "        screen: 'onboarding_menu_screen',",
      "        severity: 'error',",
      "        contextData: {'franchiseId': franchiseId, 'stepKey': stepKey},",
      "      );",
      "    }",
      "  }",
      "",
      "  Future<void> markStepIncomplete(String stepKey) async {",
      "    if (franchiseId.isEmpty) {",
      "      print(",
      "          '[ERROR][OnboardingProgressProvider] Cannot mark step incomplete: franchiseId is empty!');",
      "      await ErrorLogger.log(",
      "        message:",
      "            'Failed to mark onboarding step \"$stepKey\" incomplete: franchiseId is empty',",
      "        stack: '',",
      "        source: 'OnboardingProgressProvider',",
      "        screen: 'onboarding_menu_screen',",
      "        severity: 'error',",
      "        contextData: {'franchiseId': franchiseId, 'stepKey': stepKey},",
      "      );",
      "      return;",
      "    }",
      "    try {",
      "      await firestore.updateOnboardingStep(",
      "        franchiseId: franchiseId,",
      "        stepKey: stepKey,",
      "        completed: false,",
      "      );",
      "      _stepStatus[stepKey] = false;",
      "      notifyListeners();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to mark onboarding step \"$stepKey\" incomplete',",
      "        stack: stack.toString(),",
      "        source: 'OnboardingProgressProvider',",
      "        screen: 'onboarding_menu_screen',",
      "        severity: 'error',",
      "        contextData: {'franchiseId': franchiseId, 'stepKey': stepKey},",
      "      );",
      "    }",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 144,
      "file_size": 4557,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\providers\\onboarding_review_provider.dart",
    "content": [
      "// File: lib/core/providers/onboarding_review_provider.dart",
      "",
      "import 'dart:convert';",
      "import 'package:collection/collection.dart';",
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/core/models/onboarding_validation_issue.dart';",
      "import 'package:franchise_admin_portal/core/providers/ingredient_type_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/ingredient_metadata_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/category_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/menu_item_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_feature_provider.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/services/audit_log_service.dart';",
      "",
      "/// OnboardingReviewProvider: Aggregates and enforces all onboarding state and menu integrity",
      "///",
      "/// - Collates issues from each onboarding provider",
      "/// - Cross-checks all references (ingredients, types, categories) for consistency",
      "/// - Surfaces every critical and warning issue for review/publish",
      "/// - Controls publish/export/refresh",
      "class OnboardingReviewProvider extends ChangeNotifier {",
      "  // References to all onboarding providers; these must be set by the screen/parent.",
      "  final FranchiseFeatureProvider franchiseFeatureProvider;",
      "  final IngredientTypeProvider ingredientTypeProvider;",
      "  final IngredientMetadataProvider ingredientMetadataProvider;",
      "  final CategoryProvider categoryProvider;",
      "  final MenuItemProvider menuItemProvider;",
      "",
      "  final FirestoreService firestoreService; // For publishing",
      "  final AuditLogService auditLogService; //audit log",
      "  // Holds the current issue list, updated via [validateAll]",
      "  Map<String, List<OnboardingValidationIssue>> _issuesBySection = {};",
      "",
      "  // Optional: timestamp of last full validation",
      "  DateTime? lastValidatedAt;",
      "",
      "  // Last exportable snapshot of onboarding data, for backup/download",
      "  Map<String, dynamic> _lastExportSnapshot = {};",
      "",
      "  OnboardingReviewProvider({",
      "    required this.franchiseFeatureProvider,",
      "    required this.ingredientTypeProvider,",
      "    required this.ingredientMetadataProvider,",
      "    required this.categoryProvider,",
      "    required this.menuItemProvider,",
      "    required this.firestoreService,",
      "    required this.auditLogService,",
      "  });",
      "",
      "  /// Get all issues grouped by section (Features, Ingredient Types, Ingredients, Categories, Menu Items)",
      "  Map<String, List<OnboardingValidationIssue>> get allIssuesBySection =>",
      "      _issuesBySection;",
      "",
      "  /// Get flattened issue list for UI (useful for summary/counts)",
      "  List<OnboardingValidationIssue> get allIssuesFlat =>",
      "      _issuesBySection.values.expand((x) => x).toList();",
      "",
      "  /// True if no critical issues exist (menu is safe to publish)",
      "  bool get isPublishable => allIssuesFlat",
      "      .where(",
      "          (i) => i.isBlocking && i.severity == OnboardingIssueSeverity.critical)",
      "      .isEmpty;",
      "",
      "  /// Validates the entire onboarding state, collecting issues from each provider and cross-checking references.",
      "  /// Updates [_issuesBySection] and exportable snapshot. Notifies listeners on completion.",
      "  /// No placeholder logic; all validations are active.",
      "  Future<void> validateAll() async {",
      "    try {",
      "      _issuesBySection = {",
      "        'Features': [],",
      "        'Ingredient Types': [],",
      "        'Ingredients': [],",
      "        'Categories': [],",
      "        'Menu Items': [],",
      "      };",
      "      final Map<String, List<OnboardingValidationIssue>> issues = {};",
      "",
      "      // --- 1. Franchise Features ---",
      "      final featuresIssues = await franchiseFeatureProvider.validate();",
      "      issues['Features'] = featuresIssues;",
      "",
      "      // --- 2. Ingredient Types ---",
      "      final typeIssues = await ingredientTypeProvider.validate(",
      "        referencedTypeIds: ingredientMetadataProvider.ingredients",
      "            .map((e) => e.typeId ?? '')",
      "            .toSet()",
      "            .toList(),",
      "      );",
      "      issues['Ingredient Types'] = typeIssues;",
      "",
      "      // --- 3. Ingredients ---",
      "      final ingredientIssues = await ingredientMetadataProvider.validate(",
      "        validTypeIds: ingredientTypeProvider.ingredientTypes",
      "            .map((e) => e.id ?? '')",
      "            .toSet()",
      "            .toList(),",
      "        referencedIngredientIds: _allReferencedIngredientIdsFromMenu(),",
      "      );",
      "      issues['Ingredients'] = ingredientIssues;",
      "",
      "      // --- 4. Categories ---",
      "      final categoryIssues = await categoryProvider.validate(",
      "        referencedCategoryIds: menuItemProvider.menuItems",
      "            .map((e) => e.categoryId)",
      "            .whereType<String>()",
      "            .toSet()",
      "            .toList(),",
      "      );",
      "      issues['Categories'] = categoryIssues;",
      "",
      "      // --- 5. Menu Items (deep, cross-model) ---",
      "      final menuItemIssues = await menuItemProvider.validate(",
      "        validCategoryIds: categoryProvider.categories",
      "            .map((e) => e.id)",
      "            .whereType<String>()",
      "            .toSet()",
      "            .toList(),",
      "        validIngredientIds: ingredientMetadataProvider.ingredients",
      "            .map((e) => e.id)",
      "            .whereType<String>()",
      "            .toSet()",
      "            .toList(),",
      "        validTypeIds: ingredientTypeProvider.ingredientTypes",
      "            .map((e) => e.id)",
      "            .whereType<String>()",
      "            .toSet()",
      "            .toList(),",
      "      );",
      "      issues['Menu Items'] = menuItemIssues;",
      "",
      "      // --- 6. Cross-step checks not covered by providers ---",
      "      // Cross-reference checks for each menu item",
      "      for (final menuItem in menuItemProvider.menuItems) {",
      "        // 6.1: Validate all included ingredients exist and reference valid types",
      "        for (final included in menuItem.includedIngredients ?? []) {",
      "          final includedIngredientId =",
      "              included['ingredientId'] ?? included['id'];",
      "          final ingredient =",
      "              ingredientMetadataProvider.ingredients.firstWhereOrNull(",
      "            (e) => e.id == includedIngredientId,",
      "          );",
      "          if (ingredient == null) {",
      "            issues['Menu Items'] ??= [];",
      "            issues['Menu Items']!.add(OnboardingValidationIssue(",
      "              section: 'Menu Items',",
      "              itemId: menuItem.id,",
      "              itemDisplayName: menuItem.name,",
      "              severity: OnboardingIssueSeverity.critical,",
      "              code: 'REFERENCES_MISSING_INGREDIENT',",
      "              message:",
      "                  \"Menu item '${menuItem.name}' includes missing ingredient (ID: '$includedIngredientId').\",",
      "              affectedFields: ['includedIngredients'],",
      "              isBlocking: true,",
      "              fixRoute: '/onboarding/menu_items',",
      "              itemLocator: menuItem.id,",
      "              resolutionHint:",
      "                  \"Remove or replace the missing ingredient reference.\",",
      "              actionLabel: \"Fix Now\",",
      "              icon: Icons.link_off,",
      "              detectedAt: DateTime.now(),",
      "              contextData: {'missingIngredientId': includedIngredientId},",
      "            ));",
      "          } else {",
      "            // Ingredient exists, but its type must also be valid",
      "            if (ingredient.typeId == null ||",
      "                ingredient.typeId!.isEmpty ||",
      "                !ingredientTypeProvider.ingredientTypes",
      "                    .any((t) => t.id == ingredient.typeId)) {",
      "              issues['Menu Items'] ??= [];",
      "              issues['Menu Items']!.add(OnboardingValidationIssue(",
      "                section: 'Menu Items',",
      "                itemId: menuItem.id,",
      "                itemDisplayName: menuItem.name,",
      "                severity: OnboardingIssueSeverity.critical,",
      "                code: 'INGREDIENT_MISSING_TYPE',",
      "                message:",
      "                    \"Included ingredient '${ingredient.name}' in '${menuItem.name}' has no valid type assigned.\",",
      "                affectedFields: ['includedIngredients.typeId'],",
      "                isBlocking: true,",
      "                fixRoute: '/onboarding/menu_items',",
      "                itemLocator: menuItem.id,",
      "                resolutionHint:",
      "                    \"Assign a valid type to ingredient '${ingredient.name}'.\",",
      "                actionLabel: \"Fix Now\",",
      "                icon: Icons.link_off,",
      "                detectedAt: DateTime.now(),",
      "                contextData: {",
      "                  'ingredientId': ingredient.id,",
      "                  'menuItemId': menuItem.id",
      "                },",
      "              ));",
      "            }",
      "          }",
      "        }",
      "        // 6.2: Validate menu item category exists",
      "        if (menuItem.categoryId.isEmpty ||",
      "            !categoryProvider.categories",
      "                .any((c) => c.id == menuItem.categoryId)) {",
      "          issues['Menu Items'] ??= [];",
      "          issues['Menu Items']!.add(OnboardingValidationIssue(",
      "            section: 'Menu Items',",
      "            itemId: menuItem.id,",
      "            itemDisplayName: menuItem.name,",
      "            severity: OnboardingIssueSeverity.critical,",
      "            code: 'MISSING_CATEGORY_FOR_MENU_ITEM',",
      "            message:",
      "                \"Menu item '${menuItem.name}' references a missing category.\",",
      "            affectedFields: ['categoryId'],",
      "            isBlocking: true,",
      "            fixRoute: '/onboarding/menu_items',",
      "            itemLocator: menuItem.id,",
      "            resolutionHint: \"Select a valid category for this menu item.\",",
      "            actionLabel: \"Fix Now\",",
      "            icon: Icons.category_outlined,",
      "            detectedAt: DateTime.now(),",
      "          ));",
      "        }",
      "        // 6.3: Enforce all required fields per menu schema",
      "        if (menuItem.name.trim().isEmpty) {",
      "          issues['Menu Items'] ??= [];",
      "          issues['Menu Items']!.add(OnboardingValidationIssue(",
      "            section: 'Menu Items',",
      "            itemId: menuItem.id,",
      "            itemDisplayName: menuItem.name,",
      "            severity: OnboardingIssueSeverity.critical,",
      "            code: 'MISSING_MENU_ITEM_NAME',",
      "            message: \"Menu item is missing a name.\",",
      "            affectedFields: ['name'],",
      "            isBlocking: true,",
      "            fixRoute: '/onboarding/menu_items',",
      "            itemLocator: menuItem.id,",
      "            resolutionHint: \"Enter a name for this menu item.\",",
      "            actionLabel: \"Fix Now\",",
      "            icon: Icons.short_text,",
      "            detectedAt: DateTime.now(),",
      "          ));",
      "        }",
      "        // 6.4: Check for at least one price",
      "        if ((menuItem.price == 0.0 || menuItem.price == null) &&",
      "            (menuItem.sizePrices == null || menuItem.sizePrices!.isEmpty)) {",
      "          issues['Menu Items'] ??= [];",
      "          issues['Menu Items']!.add(OnboardingValidationIssue(",
      "            section: 'Menu Items',",
      "            itemId: menuItem.id,",
      "            itemDisplayName: menuItem.name,",
      "            severity: OnboardingIssueSeverity.critical,",
      "            code: 'MISSING_MENU_ITEM_PRICE',",
      "            message: \"Menu item '${menuItem.name}' has no price set.\",",
      "            affectedFields: ['price', 'sizePrices'],",
      "            isBlocking: true,",
      "            fixRoute: '/onboarding/menu_items',",
      "            itemLocator: menuItem.id,",
      "            resolutionHint: \"Enter a price or size prices for this menu item.\",",
      "            actionLabel: \"Fix Now\",",
      "            icon: Icons.attach_money,",
      "            detectedAt: DateTime.now(),",
      "          ));",
      "        }",
      "        // 6.5: Image warning",
      "        if (menuItem.imageUrl.isEmpty) {",
      "          issues['Menu Items'] ??= [];",
      "          issues['Menu Items']!.add(OnboardingValidationIssue(",
      "            section: 'Menu Items',",
      "            itemId: menuItem.id,",
      "            itemDisplayName: menuItem.name,",
      "            severity: OnboardingIssueSeverity.warning,",
      "            code: 'MISSING_MENU_ITEM_IMAGE',",
      "            message: \"Menu item '${menuItem.name}' does not have an image.\",",
      "            affectedFields: ['imageUrl'],",
      "            isBlocking: false,",
      "            fixRoute: '/onboarding/menu_items',",
      "            itemLocator: menuItem.id,",
      "            resolutionHint: \"Add a photo to improve the menu.\",",
      "            actionLabel: \"Review\",",
      "            icon: Icons.image_not_supported,",
      "            detectedAt: DateTime.now(),",
      "          ));",
      "        }",
      "      }",
      "",
      "      // --- Save state ---",
      "      _issuesBySection = issues;",
      "      lastValidatedAt = DateTime.now();",
      "      notifyListeners();",
      "",
      "      // --- Prepare exportable snapshot ---",
      "      _lastExportSnapshot = _buildExportSnapshot();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'onboarding_review_validate_failed',",
      "        stack: stack.toString(),",
      "        source: 'OnboardingReviewProvider.validateAll',",
      "        severity: 'fatal',",
      "        contextData: {},",
      "      );",
      "      // For robustness, do not throw—leave last state unchanged.",
      "    }",
      "  }",
      "",
      "  /// Returns all referenced ingredient IDs across all menu items (for orphan/consistency checks).",
      "  List<String> _allReferencedIngredientIdsFromMenu() {",
      "    final ids = <String>{};",
      "    for (final item in menuItemProvider.menuItems) {",
      "      ids.addAll(item.includedIngredientIds);",
      "      // Optionally: Add customizations/add-ons if you want all possible references",
      "      ids.addAll(item.optionalAddOnIds);",
      "      ids.addAll(item.allGroupIngredientIds);",
      "    }",
      "    return ids.toList();",
      "  }",
      "",
      "  /// Build a JSON-serializable snapshot of onboarding state and issues for export/download.",
      "  Map<String, dynamic> _buildExportSnapshot() {",
      "    return {",
      "      'timestamp': DateTime.now().toIso8601String(),",
      "      'featureState': franchiseFeatureProvider.featureMetadata?.toMap(),",
      "      'ingredientTypes':",
      "          ingredientTypeProvider.ingredientTypes.map((t) => t.toMap()).toList(),",
      "      'ingredients':",
      "          ingredientMetadataProvider.ingredients.map((i) => i.toMap()).toList(),",
      "      'categories':",
      "          categoryProvider.categories.map((c) => c.toFirestore()).toList(),",
      "      'menuItems': menuItemProvider.menuItems.map((m) => m.toMap()).toList(),",
      "      'issues': allIssuesFlat",
      "          .map((i) => {",
      "                'section': i.section,",
      "                'itemId': i.itemId,",
      "                'itemDisplayName': i.itemDisplayName,",
      "                'severity': i.severity.name,",
      "                'code': i.code,",
      "                'message': i.message,",
      "                'affectedFields': i.affectedFields,",
      "                'isBlocking': i.isBlocking,",
      "                'fixRoute': i.fixRoute,",
      "                'itemLocator': i.itemLocator,",
      "                'resolutionHint': i.resolutionHint,",
      "                'actionLabel': i.actionLabel,",
      "                'detectedAt': i.detectedAt?.toIso8601String(),",
      "                'contextData': i.contextData,",
      "                'acknowledged': i.acknowledged,",
      "              })",
      "          .toList(),",
      "    };",
      "  }",
      "",
      "  /// Export onboarding data + issues as JSON (for audit, backup, or download)",
      "  String exportDataAsJson() => jsonEncode(_lastExportSnapshot);",
      "",
      "  /// Initiate onboarding publish (only if publishable).",
      "  ///",
      "  /// - Revalidates all state",
      "  /// - Sets onboardingStatus to 'complete', franchise status to 'active'",
      "  /// - Writes an audit log to Firestore",
      "  /// - Throws if not publishable",
      "  Future<void> publishOnboarding(",
      "      {required String franchiseId, required String userId}) async {",
      "    await validateAll();",
      "    if (!isPublishable) {",
      "      throw Exception(\"Cannot publish onboarding: critical issues remain.\");",
      "    }",
      "    try {",
      "      // 1. Mark onboardingStatus as 'complete' and status as 'active'",
      "      await firestoreService.setOnboardingComplete(franchiseId: franchiseId);",
      "",
      "      // 2. Write onboarding audit log (timestamp, userId, snapshot of state, issues)",
      "      await auditLogService.addLog(",
      "        franchiseId: franchiseId,",
      "        userId: userId,",
      "        action: 'onboarding_publish',",
      "        targetType: 'onboarding',",
      "        targetId: franchiseId,",
      "        details: _lastExportSnapshot,",
      "      );",
      "      // 3. Optionally, notify listeners, UI, etc.",
      "      notifyListeners();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'onboarding_publish_failed',",
      "        stack: stack.toString(),",
      "        source: 'OnboardingReviewProvider.publishOnboarding',",
      "        severity: 'fatal',",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "          'userId': userId,",
      "        },",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Refresh (manual or after returning from fixing an issue)",
      "  Future<void> refresh() => validateAll();",
      "",
      "  /// Public getter for the current validation issues.",
      "  /// Returns a flattened list from [_issuesBySection] for quick UI consumption.",
      "  List<OnboardingValidationIssue> get issues {",
      "    if (_issuesBySection.isEmpty) {",
      "      print(",
      "          '[OnboardingReviewProvider] ⚠️ issues getter called before any validation run.');",
      "      return const [];",
      "    }",
      "    final flat = _issuesBySection.values.expand((list) => list).toList();",
      "    print(",
      "        '[OnboardingReviewProvider] 📋 Returning ${flat.length} total issues across ${_issuesBySection.length} sections.');",
      "    return flat;",
      "  }",
      "",
      "  /// Alias for `issues` to maintain backward compatibility with older code.",
      "  List<OnboardingValidationIssue> get validationResults {",
      "    print(",
      "        '[OnboardingReviewProvider] 📋 validationResults getter called. Returning ${issues.length} issues.');",
      "    return issues;",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 415,
      "file_size": 17412,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\providers\\payout_filter_provider.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/core/models/payout_filter.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "/// Provider for managing payout table filter/search state.",
      "/// Integrates with FirestoreService's getPayoutsForFranchise().",
      "///",
      "/// Designed to be provided high in the widget tree for",
      "/// PayoutListScreen and related filter/search widgets.",
      "class PayoutFilterProvider extends ChangeNotifier {",
      "  /// Internal filter state.",
      "  PayoutFilter _filter = const PayoutFilter();",
      "",
      "  /// Last error caught (for developer-only debug UI).",
      "  String? _lastError;",
      "",
      "  /// Returns current filter state.",
      "  PayoutFilter get filter => _filter;",
      "",
      "  /// Returns the current status filter value.",
      "  String get status => _filter.status;",
      "",
      "  /// Returns the current search query value.",
      "  String get searchQuery => _filter.searchQuery;",
      "",
      "  /// Returns the last error (if any).",
      "  String? get lastError => _lastError;",
      "",
      "  /// Set a new filter (replaces all fields)",
      "  void setFilter(PayoutFilter filter) {",
      "    _filter = filter;",
      "    notifyListeners();",
      "  }",
      "",
      "  /// Set status filter only.",
      "  void setStatus(String status) {",
      "    _filter = _filter.copyWith(status: status);",
      "    notifyListeners();",
      "  }",
      "",
      "  /// Set the text search query.",
      "  void setSearchQuery(String query) {",
      "    _filter = _filter.copyWith(searchQuery: query);",
      "    notifyListeners();",
      "  }",
      "",
      "  /// Set last error (optional developer use, e.g. after a failed fetch)",
      "  void setError(Object? error, [StackTrace? stack, String? context]) {",
      "    _lastError = error?.toString();",
      "    ErrorLogger.log(",
      "      message: 'PayoutFilterProvider Error: $_lastError',",
      "      stack: stack?.toString(),",
      "      source: 'PayoutFilterProvider',",
      "      screen: context ?? 'filter',",
      "      severity: 'warning',",
      "    );",
      "    notifyListeners();",
      "  }",
      "",
      "  /// Resets all filters to default.",
      "  void clearFilters() {",
      "    _filter = const PayoutFilter();",
      "    notifyListeners();",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 65,
      "file_size": 2011,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\providers\\platform_financials_provider.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/core/models/platform_revenue_overview.dart';",
      "import 'package:franchise_admin_portal/core/models/platform_financial_kpis.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "/// Provider for platform-level revenue and KPI aggregates.",
      "/// Robust state management for the platform owner dashboard.",
      "class PlatformFinancialsProvider extends ChangeNotifier {",
      "  PlatformRevenueOverview? _overview;",
      "  PlatformFinancialKpis? _kpis;",
      "  bool _loading = false;",
      "  String? _error;",
      "  bool _disposed = false;",
      "",
      "  PlatformRevenueOverview? get overview => _overview;",
      "  PlatformFinancialKpis? get kpis => _kpis;",
      "  bool get loading => _loading;",
      "  String? get error => _error;",
      "",
      "  /// Call to fetch both aggregates for the dashboard.",
      "  Future<void> loadFinancials() async {",
      "    _loading = true;",
      "    _error = null;",
      "    if (!_disposed) notifyListeners();",
      "    try {",
      "      final results = await Future.wait([",
      "        FirestoreService().fetchPlatformRevenueOverview(),",
      "        FirestoreService().fetchPlatformFinancialKpis(),",
      "      ]);",
      "      _overview = results[0] as PlatformRevenueOverview;",
      "      _kpis = results[1] as PlatformFinancialKpis;",
      "      _loading = false;",
      "      if (!_disposed) notifyListeners();",
      "    } catch (e, stack) {",
      "      debugPrint('Firestore error in loadFinancials: $e');",
      "      debugPrint('Stack trace: $stack');",
      "      await ErrorLogger.log(",
      "        message: e.toString(),",
      "        stack: stack.toString(),",
      "        source: 'PlatformFinancialsProvider',",
      "        screen: 'loadFinancials',",
      "        severity: 'error',",
      "      );",
      "      _error = e.toString();",
      "      _loading = false;",
      "      if (!_disposed) notifyListeners();",
      "    }",
      "  }",
      "",
      "  /// Refresh on demand, or when settings change.",
      "  Future<void> refresh() => loadFinancials();",
      "",
      "  /// Clear all state (optional for logouts/tests)",
      "  void clear() {",
      "    _overview = null;",
      "    _kpis = null;",
      "    _loading = false;",
      "    _error = null;",
      "    if (!_disposed) notifyListeners();",
      "  }",
      "",
      "  @override",
      "  void dispose() {",
      "    _disposed = true;",
      "    super.dispose();",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 68,
      "file_size": 2239,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\providers\\platform_plan_selection_provider.dart",
    "content": [
      "// 📁 lib/core/providers/platform_plan_selection_provider.dart",
      "",
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/core/models/platform_plan_model.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/models/franchise_subscription_model.dart';",
      "import 'package:franchise_admin_portal/core/services/franchise_subscription_service.dart';",
      "",
      "class PlatformPlanSelectionProvider extends ChangeNotifier {",
      "  PlatformPlan? _selectedPlan;",
      "  bool _isLoading = false;",
      "  String? _errorMessage;",
      "  bool _success = false;",
      "",
      "  PlatformPlan? get selectedPlan => _selectedPlan;",
      "  bool get isLoading => _isLoading;",
      "  String? get errorMessage => _errorMessage;",
      "  bool get success => _success;",
      "",
      "  void selectPlan(PlatformPlan plan) {",
      "    _selectedPlan = plan;",
      "    _errorMessage = null;",
      "    _success = false;",
      "    notifyListeners();",
      "  }",
      "",
      "  void clear() {",
      "    _selectedPlan = null;",
      "    _errorMessage = null;",
      "    _success = false;",
      "    _isLoading = false;",
      "    notifyListeners();",
      "  }",
      "",
      "  /// Submits the currently selected plan for the given franchise.",
      "  Future<void> subscribeToPlan({",
      "    required BuildContext context,",
      "    required String franchiseId,",
      "    VoidCallback? onSuccess,",
      "  }) async {",
      "    final loc = AppLocalizations.of(context)!;",
      "    final plan = _selectedPlan;",
      "    if (plan == null) {",
      "      _errorMessage = loc.genericErrorOccurred;",
      "      notifyListeners();",
      "      return;",
      "    }",
      "",
      "    _isLoading = true;",
      "    _errorMessage = null;",
      "    _success = false;",
      "    notifyListeners();",
      "",
      "    try {",
      "      await FranchiseSubscriptionService().subscribeFranchiseToPlan(",
      "        franchiseId: franchiseId,",
      "        plan: plan,",
      "      );",
      "      _success = true;",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(content: Text(loc.subscriptionSuccessMessage)),",
      "      );",
      "",
      "      // ⬅️ Trigger success flow",
      "      if (onSuccess != null) onSuccess();",
      "    } catch (e, stack) {",
      "      _errorMessage = loc.genericErrorOccurred;",
      "      await ErrorLogger.log(",
      "        message: 'Plan subscription failed: $e',",
      "        stack: stack.toString(),",
      "        source: 'PlatformPlanSelectionProvider',",
      "        screen: 'available_platform_plans_screen',",
      "        severity: 'error',",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "          'planId': plan.id,",
      "        },",
      "      );",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(",
      "          content: Text(loc.genericErrorOccurred),",
      "          backgroundColor: Theme.of(context).colorScheme.error,",
      "        ),",
      "      );",
      "    } finally {",
      "      _isLoading = false;",
      "      notifyListeners();",
      "    }",
      "  }",
      "",
      "  FranchiseSubscription? _currentSubscription;",
      "",
      "  FranchiseSubscription? get currentSubscription => _currentSubscription;",
      "",
      "  Future<void> refreshSubscription(String franchiseId) async {",
      "    try {",
      "      final sub =",
      "          await FirestoreService().getFranchiseSubscription(franchiseId);",
      "      _currentSubscription = sub;",
      "      notifyListeners();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to refresh subscription for franchise: $franchiseId',",
      "        stack: stack.toString(),",
      "        source: 'PlatformPlanSelectionProvider',",
      "        screen: 'available_platform_plans_screen',",
      "        severity: 'warning',",
      "        contextData: {'franchiseId': franchiseId, 'exception': e.toString()},",
      "      );",
      "    }",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 114,
      "file_size": 3620,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\providers\\restaurant_type_provider.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "import 'package:franchise_admin_portal/core/models/restaurant_type.dart';",
      "",
      "class RestaurantTypeProvider with ChangeNotifier {",
      "  List<RestaurantType> _types = [];",
      "  List<RestaurantType> get types => _types;",
      "",
      "  Future<void> loadTypes() async {",
      "    final snapshot =",
      "        await FirebaseFirestore.instance.collection('restaurant_types').get();",
      "    _types =",
      "        snapshot.docs.map((doc) => RestaurantType.fromFirestore(doc)).toList();",
      "    notifyListeners();",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 16,
      "file_size": 575,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\providers\\role_guard.dart",
    "content": [
      "import 'package:provider/provider.dart';",
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/config/app_config.dart';",
      "import 'package:franchise_admin_portal/core/models/dashboard_section.dart';",
      "import 'package:franchise_admin_portal/core/models/user.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "// Update import to your actual user model/provider location",
      "",
      "/// Callback for custom logic",
      "typedef RoleGuardCondition = bool Function(User user);",
      "",
      "/// Flexible role-based access widget.",
      "/// Use anywhere you want to show/hide/protect features or screens by role.",
      "class RoleGuard extends StatelessWidget {",
      "  /// Allowed user roles, e.g. ['owner', 'admin', 'manager', 'developer']",
      "  final List<String>? allowedRoles;",
      "",
      "  /// Require at least one of these exact roles",
      "  final List<String>? requireAnyRole;",
      "",
      "  /// If set, require user to have *all* these roles",
      "  final List<String>? requireAllRoles;",
      "",
      "  /// A custom role-check function, e.g. (user) => user.isOwner && user.isDeveloper",
      "  final RoleGuardCondition? customCondition;",
      "",
      "  /// Widget shown if the user passes the guard.",
      "  final Widget child;",
      "",
      "  /// Widget shown if the user is unauthorized (default: nice error card)",
      "  final Widget? unauthorized;",
      "",
      "  /// If true, allows developer users to always pass the guard.",
      "  final bool developerBypass;",
      "",
      "  /// For audit/error reporting",
      "  final String? screen;",
      "  final String? featureName;",
      "",
      "  /// For future features/config integration",
      "  final AppConfig? appConfig;",
      "",
      "  const RoleGuard({",
      "    Key? key,",
      "    required this.child,",
      "    this.allowedRoles,",
      "    this.requireAnyRole,",
      "    this.requireAllRoles,",
      "    this.customCondition,",
      "    this.unauthorized,",
      "    this.developerBypass = true,",
      "    this.screen,",
      "    this.featureName,",
      "    this.appConfig,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    // ----",
      "    // Replace below with your actual User/profile/provider solution.",
      "    // This example assumes a top-level InheritedWidget/provider for user.",
      "    final user = context.watch<AdminUserProvider>().user;",
      "    debugPrint(",
      "        '[RoleGuard] User object: ${user?.email}, roles: ${user?.roles}');",
      "    final loc = AppLocalizations.of(context);",
      "    // Restrict access to incomplete onboarding (for franchisees)",
      "    if ((user?.isFranchisee ?? false) && !(user?.onboardingComplete ?? false)) {",
      "      return Scaffold(",
      "        body: Center(",
      "          child: _DefaultUnauthorizedWidget(",
      "            reason: loc?.onboardingRequiredBody ??",
      "                'You must complete onboarding to access this screen.',",
      "            loc: loc!,",
      "            colorScheme: Theme.of(context).colorScheme,",
      "          ),",
      "        ),",
      "      );",
      "    }",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    final _appConfig = appConfig ?? AppConfig.instance;",
      "    final _firestoreService = FirestoreService();",
      "",
      "    // ----",
      "    // Robust Role Logic:",
      "    bool passes = false;",
      "    String? errorDetail;",
      "",
      "    if (user == null) {",
      "      errorDetail = \"No user available (not authenticated)\";",
      "    } else if (developerBypass && (user.isDeveloper ?? false)) {",
      "      passes = true;",
      "    } else if (customCondition != null && customCondition!(user)) {",
      "      passes = true;",
      "    } else if (requireAllRoles != null && requireAllRoles!.isNotEmpty) {",
      "      passes = requireAllRoles!.every((r) => user.roles.contains(r));",
      "      if (!passes)",
      "        errorDetail = \"Missing one or more required roles: $requireAllRoles\";",
      "    } else if (requireAnyRole != null && requireAnyRole!.isNotEmpty) {",
      "      passes = requireAnyRole!.any((r) => user.roles.contains(r));",
      "      if (!passes)",
      "        errorDetail = \"Missing all of any allowed roles: $requireAnyRole\";",
      "    } else if (allowedRoles != null && allowedRoles!.isNotEmpty) {",
      "      debugPrint('[RoleGuard] Checking access for feature: $featureName');",
      "      debugPrint('[RoleGuard] allowedRoles: $allowedRoles');",
      "      debugPrint('[RoleGuard] requireAnyRole: $requireAnyRole');",
      "      debugPrint('[RoleGuard] requireAllRoles: $requireAllRoles');",
      "      debugPrint('[RoleGuard] developerBypass: $developerBypass');",
      "      passes = user.roles.any((r) => allowedRoles!.contains(r));",
      "      if (!passes)",
      "        errorDetail = \"User role(s) not in allowedRoles: $allowedRoles\";",
      "    } else {",
      "      // If no rule, allow everyone by default",
      "      passes = true;",
      "    }",
      "",
      "    if (passes) {",
      "      return child;",
      "    }",
      "",
      "    // 🔜 Future: More granular audit, config, feature toggles, etc.",
      "    ErrorLogger.log(",
      "      message: \"Unauthorized access attempt to $featureName: $errorDetail\",",
      "      source: 'RoleGuard',",
      "      screen: 'RoleGuard',",
      "      severity: 'warning',",
      "      contextData: {",
      "        'roles': user?.roles,",
      "        'feature': featureName,",
      "        'errorType': 'Unauthorized', // add any extra custom fields as needed",
      "      },",
      "    );",
      "",
      "    return unauthorized ??",
      "        _DefaultUnauthorizedWidget(",
      "          reason: errorDetail ?? loc.unauthorized_default_reason,",
      "          loc: loc,",
      "          colorScheme: colorScheme,",
      "        );",
      "  }",
      "}",
      "",
      "/// Default unauthorized widget shown by RoleGuard.",
      "class _DefaultUnauthorizedWidget extends StatelessWidget {",
      "  final String reason;",
      "  final AppLocalizations loc;",
      "  final ColorScheme colorScheme;",
      "  const _DefaultUnauthorizedWidget({",
      "    Key? key,",
      "    required this.reason,",
      "    required this.loc,",
      "    required this.colorScheme,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) => Card(",
      "        color: colorScheme.error.withOpacity(0.13),",
      "        margin: const EdgeInsets.symmetric(vertical: 16, horizontal: 0),",
      "        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),",
      "        child: Padding(",
      "          padding: const EdgeInsets.symmetric(vertical: 18, horizontal: 20),",
      "          child: Row(",
      "            children: [",
      "              Icon(Icons.lock_outline, color: colorScheme.error, size: 32),",
      "              const SizedBox(width: 14),",
      "              Expanded(",
      "                child: Column(",
      "                  crossAxisAlignment: CrossAxisAlignment.start,",
      "                  children: [",
      "                    Text(",
      "                      loc.unauthorized_title,",
      "                      style: Theme.of(context).textTheme.titleMedium?.copyWith(",
      "                            color: colorScheme.error,",
      "                            fontWeight: FontWeight.bold,",
      "                          ),",
      "                    ),",
      "                    const SizedBox(height: 3),",
      "                    Text(",
      "                      reason,",
      "                      style: Theme.of(context).textTheme.bodyMedium,",
      "                    ),",
      "                  ],",
      "                ),",
      "              ),",
      "            ],",
      "          ),",
      "        ),",
      "      );",
      "}",
      "",
      "/// Example user provider (replace with your own solution)",
      "class UserProvider extends InheritedWidget {",
      "  final User? user;",
      "",
      "  const UserProvider({",
      "    Key? key,",
      "    required Widget child,",
      "    this.user,",
      "  }) : super(key: key, child: child);",
      "",
      "  static UserProvider? of(BuildContext context) =>",
      "      context.dependOnInheritedWidgetOfExactType<UserProvider>();",
      "",
      "  @override",
      "  bool updateShouldNotify(covariant UserProvider oldWidget) =>",
      "      user != oldWidget.user;",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 217,
      "file_size": 7783,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\providers\\user_profile_notifier.dart",
    "content": [
      "import 'package:flutter/widgets.dart';",
      "import 'dart:async';",
      "import 'package:flutter/foundation.dart';",
      "import 'package:franchise_admin_portal/core/models/user.dart' as admin_user;",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:firebase_auth/firebase_auth.dart' as fb_auth;",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:firebase_core/firebase_core.dart';",
      "",
      "class UserProfileNotifier extends ChangeNotifier {",
      "  admin_user.User? _user;",
      "  admin_user.User? get user => _user;",
      "  FranchiseProvider? _lastFranchiseProvider;",
      "  StreamSubscription? _sub;",
      "",
      "  bool _loading = false;",
      "  bool get loading => _loading;",
      "",
      "  Object? _lastError;",
      "  Object? get lastError => _lastError;",
      "",
      "  FirestoreService? _lastFirestoreService;",
      "  String? _lastUid;",
      "",
      "  Future<void> loadUser() async {",
      "    if (Firebase.apps.isEmpty) {",
      "      final msg = '[UserProfileNotifier] loadUser: Firebase not initialized!';",
      "      debugPrint(msg);",
      "      await ErrorLogger.log(",
      "        message:",
      "            'UserProfileNotifier.loadUser called before Firebase initialized',",
      "        source: 'UserProfileNotifier',",
      "        severity: 'fatal',",
      "        screen: 'UserProfileNotifier',",
      "        contextData: {",
      "          'phase': 'loadUser',",
      "          'hint': 'Firebase.apps.isEmpty',",
      "          'widget': runtimeType.toString(),",
      "        },",
      "      );",
      "      return;",
      "    }",
      "    final firebaseUser = fb_auth.FirebaseAuth.instance.currentUser;",
      "    if (firebaseUser != null) {",
      "      listenToUser(",
      "        FirestoreService(),",
      "        firebaseUser.uid,",
      "      );",
      "    } else {",
      "      debugPrint('[UserProfileNotifier] loadUser: firebaseUser is null');",
      "      // You may want to log this as a warning as well if it's unexpected:",
      "      await ErrorLogger.log(",
      "        message: 'loadUser called but firebaseUser is null',",
      "        source: 'UserProfileNotifier',",
      "        severity: 'warning',",
      "        screen: 'UserProfileNotifier',",
      "      );",
      "    }",
      "  }",
      "",
      "  void listenToUser(FirestoreService firestoreService, String? uid,",
      "      [FranchiseProvider? franchiseProvider]) {",
      "    print('[UserProfileNotifier] listenToUser called for uid=$uid');",
      "    _lastFirestoreService = firestoreService;",
      "    _lastUid = uid;",
      "    _lastFranchiseProvider = franchiseProvider;",
      "",
      "    // Cancel existing subscription if any.",
      "    _sub?.cancel();",
      "",
      "    if (uid == null) {",
      "      print('[UserProfileNotifier] Skipping listen: missing uid.');",
      "      _user = null;",
      "      _loading = false;",
      "      _lastError = null;",
      "",
      "      if (franchiseProvider != null) {",
      "        franchiseProvider.clearFranchiseContext(); // ✅ Clear franchise state",
      "      }",
      "",
      "      _lastFranchiseProvider = null; // ✅ Only clear when uid is null",
      "      _deferNotifyListeners();",
      "      return;",
      "    }",
      "    print(",
      "        '[UserProfileNotifier] Attempting to subscribe: uid=$uid, firestoreService=$firestoreService');",
      "    _loading = true;",
      "    _lastError = null;",
      "    _deferNotifyListeners();",
      "",
      "    print(",
      "        '[UserProfileNotifier] Subscribing to delayedUserStream for uid=$uid');",
      "",
      "    _sub = delayedUserStream(firestoreService, uid).listen(",
      "      (u) {",
      "        _user = u;",
      "        _loading = false;",
      "        _lastError = null;",
      "        _deferNotifyListeners();",
      "",
      "        if (u != null && franchiseProvider != null) {",
      "          franchiseProvider.initializeWithUser(u);",
      "        }",
      "      },",
      "      onError: (err, stack) async {",
      "        print('[UserProfileNotifier] ERROR: $err\\nStack: $stack');",
      "        _loading = false;",
      "        _lastError = err;",
      "        _deferNotifyListeners();",
      "",
      "        final firebaseUser = fb_auth.FirebaseAuth.instance.currentUser;",
      "        ErrorLogger.log(",
      "          message: err.toString(),",
      "          source: 'UserProfileNotifier.listenToUser',",
      "          screen: 'HomeWrapper',",
      "          stack: stack?.toString(),",
      "          severity: 'error',",
      "          contextData: {",
      "            'userProfileLoading': true,",
      "            'uid': uid,",
      "            'userId': firebaseUser?.uid,",
      "            'errorType': err.runtimeType.toString(),",
      "          },",
      "        );",
      "        _lastFirestoreService = firestoreService;",
      "        _lastUid = uid;",
      "      },",
      "    );",
      "  }",
      "",
      "  void clear() {",
      "    print('[UserProfileNotifier] clear() called');",
      "    _sub?.cancel();",
      "    _user = null;",
      "    _loading = false;",
      "    _lastError = null;",
      "    _deferNotifyListeners();",
      "  }",
      "",
      "  @override",
      "  void dispose() {",
      "    print('[UserProfileNotifier] dispose() called');",
      "    _sub?.cancel();",
      "    super.dispose();",
      "  }",
      "",
      "  void _deferNotifyListeners() {",
      "    WidgetsBinding.instance.addPostFrameCallback((_) {",
      "      notifyListeners();",
      "    });",
      "  }",
      "",
      "  void reload() {",
      "    if (_lastFirestoreService != null &&",
      "        _lastUid != null &&",
      "        _lastFranchiseProvider != null) {",
      "      listenToUser(_lastFirestoreService!, _lastUid, _lastFranchiseProvider!);",
      "    }",
      "  }",
      "",
      "  Object? get error => lastError;",
      "  bool get isLoading => loading;",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 165,
      "file_size": 5106,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\services\\admin_auth_audit_service.dart",
    "content": [
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "import 'package:firebase_auth/firebase_auth.dart' as fb_auth;",
      "",
      "class AdminAuthAuditService {",
      "  final FirebaseFirestore _db;",
      "  final fb_auth.FirebaseAuth _auth;",
      "",
      "  AdminAuthAuditService({",
      "    FirebaseFirestore? firestore,",
      "    fb_auth.FirebaseAuth? firebaseAuth,",
      "  })  : _db = firestore ?? FirebaseFirestore.instance,",
      "        _auth = firebaseAuth ?? fb_auth.FirebaseAuth.instance;",
      "",
      "  Future<void> logEvent({",
      "    required String",
      "        type, // e.g., 'login', 'logout', 'impersonation', 'switchFranchise'",
      "    String? franchiseId,",
      "    Map<String, dynamic>? metadata,",
      "  }) async {",
      "    final user = _auth.currentUser;",
      "    if (user == null) return;",
      "",
      "    final logRef = _db.collection('admin_auth_audit_logs').doc();",
      "    await logRef.set({",
      "      'uid': user.uid,",
      "      'email': user.email,",
      "      'type': type,",
      "      'franchiseId': franchiseId,",
      "      'timestamp': FieldValue.serverTimestamp(),",
      "      'metadata': metadata ?? {},",
      "    });",
      "  }",
      "",
      "  Stream<List<Map<String, dynamic>>> streamRecentEvents({int limit = 50}) {",
      "    return _db",
      "        .collection('admin_auth_audit_logs')",
      "        .orderBy('timestamp', descending: true)",
      "        .limit(limit)",
      "        .snapshots()",
      "        .map((snap) => snap.docs.map((doc) => doc.data()).toList());",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 42,
      "file_size": 1332,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\services\\analytics_service.dart",
    "content": [
      "import 'package:cloud_functions/cloud_functions.dart';",
      "import 'package:firebase_analytics/firebase_analytics.dart';",
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "import 'package:logging/logging.dart';",
      "import 'package:franchise_admin_portal/core/models/analytics_summary.dart';",
      "",
      "/// AnalyticsService",
      "/// Used for logging admin/app events to Firebase Analytics,",
      "/// and for retrieving analytics metrics for the admin dashboard.",
      "class AnalyticsService {",
      "  late final FirebaseAnalytics _analytics;",
      "",
      "  AnalyticsService() {",
      "    _analytics = FirebaseAnalytics.instance;",
      "  }",
      "  final Logger _logger = Logger('AnalyticsService');",
      "",
      "  // --- Analytics Dashboard Methods ---",
      "",
      "  /// Returns a stream of AnalyticsSummary (dashboard metrics) for admin panels.",
      "  Stream<List<AnalyticsSummary>> getSummaryMetrics(String franchiseId) {",
      "    return FirebaseFirestore.instance",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection('analytics_summaries')",
      "        .snapshots()",
      "        .map((snapshot) => snapshot.docs",
      "            .map((doc) => AnalyticsSummary.fromFirestore(doc.data(), doc.id))",
      "            .toList());",
      "  }",
      "",
      "  /// Returns a Future<List<AnalyticsSummary>> for bulk export or reporting.",
      "  Future<List<AnalyticsSummary>> getAnalyticsSummaries(",
      "      String franchiseId) async {",
      "    final snapshot = await FirebaseFirestore.instance",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection('analytics_summaries')",
      "        .get();",
      "    return snapshot.docs",
      "        .map((doc) => AnalyticsSummary.fromFirestore(doc.data(), doc.id))",
      "        .toList();",
      "  }",
      "",
      "  /// Exports analytics summaries as a CSV string (for admin export dialog).",
      "  Future<String> exportSummary(String franchiseId) async {",
      "    final summaries = await getAnalyticsSummaries(franchiseId);",
      "",
      "    final buffer = StringBuffer();",
      "    // CSV Header",
      "    buffer.writeln(",
      "        'period,totalRevenue,totalOrders,retention,mostPopularItem,averageOrderValue');",
      "    for (final summary in summaries) {",
      "      buffer.writeln(",
      "          '${summary.period},${summary.totalRevenue},${summary.totalOrders},${summary.retention},${summary.mostPopularItem ?? \"\"},${summary.averageOrderValue}');",
      "    }",
      "    return buffer.toString();",
      "  }",
      "",
      "  // --- Event Logging (Admin/Backend Only) ---",
      "",
      "  Future<void> logEvent(String name, Map<String, dynamic>? parameters) async {",
      "    try {",
      "      await _analytics.logEvent(",
      "        name: name,",
      "        parameters: parameters?.cast<String, Object>(),",
      "      );",
      "      _logger.info('Logged event: $name with parameters: $parameters');",
      "    } catch (e, stack) {",
      "      _logger.severe('Analytics error ($name): $e', e, stack);",
      "    }",
      "  }",
      "",
      "  // ==========================",
      "  // === ADMIN/ADMIN PANEL ====",
      "  // ==========================",
      "",
      "  Future<void> logAdminMenuEditorViewed(String userId) async {",
      "    await logEvent('admin_menu_editor_viewed', {'admin_user_id': userId});",
      "  }",
      "",
      "  Future<void> logAdminMenuItemAction({",
      "    required String action, // add, update, delete, bulk_upload",
      "    String? menuItemId,",
      "    String? name,",
      "    int? count,",
      "    String? adminUserId,",
      "  }) async {",
      "    await logEvent('admin_menu_item_$action', {",
      "      if (adminUserId != null) 'admin_user_id': adminUserId,",
      "      if (menuItemId != null) 'menu_item_id': menuItemId,",
      "      if (name != null) 'name': name,",
      "      if (count != null) 'count': count,",
      "    });",
      "  }",
      "",
      "  Future<void> logAdminCategoryAction({",
      "    required String action, // add, update, delete, bulk_upload",
      "    String? categoryId,",
      "    String? name,",
      "    int? count,",
      "    String? adminUserId,",
      "  }) async {",
      "    await logEvent('admin_category_$action', {",
      "      if (adminUserId != null) 'admin_user_id': adminUserId,",
      "      if (categoryId != null) 'category_id': categoryId,",
      "      if (name != null) 'name': name,",
      "      if (count != null) 'count': count,",
      "    });",
      "  }",
      "",
      "  Future<void> logAdminBulkMenuUpload(",
      "      {required int count, String? adminUserId}) async {",
      "    await logEvent('admin_bulk_menu_upload', {",
      "      'count': count,",
      "      if (adminUserId != null) 'admin_user_id': adminUserId,",
      "    });",
      "  }",
      "",
      "  Future<void> logAdminMenuExport({int? count, String? adminUserId}) async {",
      "    await logEvent('admin_menu_export', {",
      "      if (count != null) 'count': count,",
      "      if (adminUserId != null) 'admin_user_id': adminUserId,",
      "    });",
      "  }",
      "",
      "  // ========================",
      "  // === ERROR/FEEDBACK =====",
      "  // ========================",
      "",
      "  Future<void> logError(",
      "      {required String source, required String message, String? stack}) async {",
      "    await logEvent('error', {",
      "      'source': source,",
      "      'message': message,",
      "      if (stack != null) 'stack': stack,",
      "    });",
      "  }",
      "",
      "  Future<void> logFeedbackSubmitted(",
      "      {required String feedbackId, required String userId}) async {",
      "    await logEvent('feedback_submitted', {",
      "      'feedback_id': feedbackId,",
      "      'user_id': userId,",
      "    });",
      "  }",
      "",
      "  // =======================",
      "  // === IMAGE EVENTS ======",
      "  // =======================",
      "",
      "  Future<void> logImageUpload({",
      "    required String menuItemId,",
      "    required String fileName,",
      "    String? adminUserId,",
      "  }) async {",
      "    await logEvent('menu_item_image_uploaded', {",
      "      'menu_item_id': menuItemId,",
      "      'file_name': fileName,",
      "      if (adminUserId != null) 'admin_user_id': adminUserId,",
      "    });",
      "  }",
      "",
      "  Future<void> logImageDelete({",
      "    required String menuItemId,",
      "    required String fileName,",
      "    String? adminUserId,",
      "  }) async {",
      "    await logEvent('menu_item_image_deleted', {",
      "      'menu_item_id': menuItemId,",
      "      'file_name': fileName,",
      "      if (adminUserId != null) 'admin_user_id': adminUserId,",
      "    });",
      "  }",
      "",
      "  // ========================",
      "  // === PERMISSIONS/AUDIT ===",
      "  // ========================",
      "",
      "  Future<void> logUnauthorizedAccess(",
      "      {required String attemptedAction, required String userId}) async {",
      "    await logEvent('unauthorized_access', {",
      "      'attempted_action': attemptedAction,",
      "      'user_id': userId,",
      "    });",
      "  }",
      "",
      "  // ========================",
      "  // === EXPORT/IMPORT ======",
      "  // ========================",
      "",
      "  Future<void> logExportAction({",
      "    required String type, // menu, category, order, etc",
      "    int? count,",
      "    String? userId,",
      "  }) async {",
      "    await logEvent('export_action', {",
      "      'type': type,",
      "      if (count != null) 'count': count,",
      "      if (userId != null) 'user_id': userId,",
      "    });",
      "  }",
      "",
      "  Future<void> logImportAction({",
      "    required String type,",
      "    int? count,",
      "    String? userId,",
      "  }) async {",
      "    await logEvent('import_action', {",
      "      'type': type,",
      "      if (count != null) 'count': count,",
      "      if (userId != null) 'user_id': userId,",
      "    });",
      "  }",
      "",
      "  /// Calls the cloud function 'rollupAnalyticsOnDemand' to trigger a manual rollup.",
      "  Future<void> runManualRollup(String franchiseId) async {",
      "    try {",
      "      final callable =",
      "          FirebaseFunctions.instance.httpsCallable('rollupAnalyticsOnDemand');",
      "      await callable.call({'franchiseId': franchiseId});",
      "    } catch (e) {",
      "      // Optionally handle/log the error here",
      "      rethrow; // or just throw to propagate error",
      "    }",
      "  }",
      "",
      "  // =======================",
      "  // === FUTURE EVENTS =====",
      "  // =======================",
      "  // Add new log methods here as new admin features are developed.",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 232,
      "file_size": 7359,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\services\\audit_log_service.dart",
    "content": [
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "import 'package:franchise_admin_portal/core/models/audit_log.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class AuditLogService {",
      "  CollectionReference auditLogsRef() =>",
      "      FirebaseFirestore.instance.collection('audit_logs');",
      "",
      "  /// Adds a generic, flexible audit log entry.",
      "  Future<void> addLog({",
      "    required String franchiseId,",
      "    required String userId,",
      "    String? userEmail,",
      "    required String action,",
      "    String? targetType,",
      "    String? targetId,",
      "    dynamic details, // Accepts String or Map",
      "  }) async {",
      "    final log = AuditLog(",
      "      id: '',",
      "      userId: userId,",
      "      userEmail: userEmail ?? '',",
      "      action: action,",
      "      targetType: targetType ?? '',",
      "      targetId: targetId ?? '',",
      "      details: details is Map ? details.toString() : details?.toString(),",
      "      timestamp: DateTime.now(),",
      "    );",
      "    final data = log.toFirestore();",
      "    data['franchiseId'] = franchiseId;",
      "    await auditLogsRef().add(data);",
      "  }",
      "",
      "  /// Shortcut for logging when an error log is viewed.",
      "  Future<void> logViewedErrorLog({",
      "    required String franchiseId,",
      "    required String errorLogId,",
      "    required String userId,",
      "    String? userEmail,",
      "  }) async {",
      "    await addLog(",
      "      franchiseId: franchiseId,",
      "      userId: userId,",
      "      userEmail: userEmail,",
      "      action: 'view_error_log',",
      "      targetType: 'error_log',",
      "      targetId: errorLogId,",
      "    );",
      "  }",
      "",
      "  /// Streams audit logs (filterable by targetType or userId).",
      "  Stream<List<AuditLog>> getLogs({",
      "    required String franchiseId,",
      "    String? targetType,",
      "    String? userId,",
      "  }) {",
      "    Query query = auditLogsRef()",
      "        .where('franchiseId', isEqualTo: franchiseId)",
      "        .orderBy('timestamp', descending: true);",
      "    if (targetType != null && targetType.isNotEmpty) {",
      "      query = query.where('targetType', isEqualTo: targetType);",
      "    }",
      "    if (userId != null && userId.isNotEmpty) {",
      "      query = query.where('userId', isEqualTo: userId);",
      "    }",
      "    return query.snapshots().map((snap) => snap.docs",
      "        .map((doc) =>",
      "            AuditLog.fromFirestore(doc.data() as Map<String, dynamic>, doc.id))",
      "        .toList());",
      "  }",
      "",
      "  /// Gets audit logs once (filterable by targetType or userId).",
      "  Future<List<AuditLog>> getLogsOnce({",
      "    required String franchiseId,",
      "    String? targetType,",
      "    String? userId,",
      "  }) async {",
      "    Query query = auditLogsRef()",
      "        .where('franchiseId', isEqualTo: franchiseId)",
      "        .orderBy('timestamp', descending: true);",
      "    if (targetType != null && targetType.isNotEmpty) {",
      "      query = query.where('targetType', isEqualTo: targetType);",
      "    }",
      "    if (userId != null && userId.isNotEmpty) {",
      "      query = query.where('userId', isEqualTo: userId);",
      "    }",
      "    final snap = await query.get();",
      "    return snap.docs",
      "        .map((doc) =>",
      "            AuditLog.fromFirestore(doc.data() as Map<String, dynamic>, doc.id))",
      "        .toList();",
      "  }",
      "",
      "  /// Logs a publish event for onboarding (with snapshot) to the top-level audit_logs collection.",
      "  Future<void> logOnboardingPublishAudit({",
      "    required String franchiseId,",
      "    required String userId,",
      "    required Map<String, dynamic> exportSnapshot,",
      "    String? userEmail,",
      "  }) async {",
      "    try {",
      "      await addLog(",
      "        franchiseId: franchiseId,",
      "        userId: userId,",
      "        userEmail: userEmail,",
      "        action: 'onboarding_publish',",
      "        targetType: 'onboarding',",
      "        targetId: franchiseId,",
      "        details: exportSnapshot,",
      "      );",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to log onboarding publish audit',",
      "        stack: stack.toString(),",
      "        source: 'AuditLogService.logOnboardingPublishAudit',",
      "        severity: 'error',",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "          'userId': userId,",
      "          'exportSnapshotKeys': exportSnapshot.keys.toList(),",
      "        },",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Fetches only onboarding publish/cancel/edit audit logs for a franchise.",
      "  Future<List<AuditLog>> getOnboardingAuditLogs(String franchiseId) async {",
      "    try {",
      "      // Filter for onboarding-related actions (publish/cancel/edit etc)",
      "      final query = auditLogsRef()",
      "          .where('franchiseId', isEqualTo: franchiseId)",
      "          .where('targetType', isEqualTo: 'onboarding')",
      "          .orderBy('timestamp', descending: true);",
      "",
      "      final snapshot = await query.get();",
      "      return snapshot.docs",
      "          .map((doc) => AuditLog.fromFirestore(",
      "              doc.data() as Map<String, dynamic>, doc.id))",
      "          .toList();",
      "    } catch (e, stack) {",
      "      // Optionally: log with ErrorLogger if desired",
      "      rethrow;",
      "    }",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 146,
      "file_size": 4791,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\services\\auth_service.dart",
    "content": [
      "import 'package:flutter/foundation.dart';",
      "import 'package:flutter/foundation.dart' show kIsWeb;",
      "import 'package:firebase_auth/firebase_auth.dart';",
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "import 'package:google_sign_in/google_sign_in.dart';",
      "import 'package:franchise_admin_portal/core/utils/log_utils.dart';",
      "import 'package:franchise_admin_portal/core/models/user.dart' as app;",
      "import 'dart:html' as html show window;",
      "",
      "class AuthService extends ChangeNotifier {",
      "  late final FirebaseAuth _auth;",
      "  late final FirebaseFirestore _firestore;",
      "  app.User? _profileUser; // Note: avoid name clash with Firebase User",
      "  User? get currentUser => _auth.currentUser;",
      "  Stream<User?> get authStateChanges => _auth.authStateChanges();",
      "  app.User? get profileUser => _profileUser;",
      "  String? _inviteToken;",
      "",
      "  AuthService() {",
      "    _auth = FirebaseAuth.instance;",
      "    _firestore = FirebaseFirestore.instance;",
      "  }",
      "",
      "  /// EMAIL SIGN-IN (for admin)",
      "  Future<User?> signInWithEmail(String email, String password) async {",
      "    try {",
      "      UserCredential result = await _auth.signInWithEmailAndPassword(",
      "        email: email,",
      "        password: password,",
      "      );",
      "      final user = result.user;",
      "      LogUtils.i('Admin signed in with email: $email');",
      "      notifyListeners();",
      "      return user;",
      "    } catch (e, stack) {",
      "      LogUtils.e('Admin email sign-in error', e, stack);",
      "      return null;",
      "    }",
      "  }",
      "",
      "  /// EMAIL REGISTRATION (optional, if ever used)",
      "  Future<User?> registerWithEmail(",
      "      String email, String password, String name) async {",
      "    try {",
      "      UserCredential result = await _auth.createUserWithEmailAndPassword(",
      "        email: email,",
      "        password: password,",
      "      );",
      "      await result.user?.updateDisplayName(name);",
      "      final user = result.user;",
      "      LogUtils.i('Admin registered with email: $email');",
      "      notifyListeners();",
      "      return user;",
      "    } catch (e, stack) {",
      "      LogUtils.e('Admin registration error', e, stack);",
      "      return null;",
      "    }",
      "  }",
      "",
      "  /// PASSWORD RESET (admin portal)",
      "  Future<void> resetPassword(String email) async {",
      "    try {",
      "      await _auth.sendPasswordResetEmail(email: email);",
      "      LogUtils.i('Password reset email sent: $email');",
      "    } catch (e, stack) {",
      "      LogUtils.e('Password reset error', e, stack);",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// GOOGLE SIGN-IN (optional for web/mobile)",
      "  Future<User?> signInWithGoogle() async {",
      "    try {",
      "      if (kIsWeb) {",
      "        GoogleAuthProvider googleProvider = GoogleAuthProvider();",
      "        final userCredential = await _auth.signInWithPopup(googleProvider);",
      "        final user = userCredential.user;",
      "        LogUtils.i(",
      "            'Google sign-in successful (web): ${user?.email ?? 'No email'}');",
      "        notifyListeners();",
      "        return user;",
      "      } else {",
      "        final GoogleSignIn googleSignIn = GoogleSignIn();",
      "        final GoogleSignInAccount? googleUser = await googleSignIn.signIn();",
      "        if (googleUser == null) {",
      "          LogUtils.w('Google sign-in canceled.');",
      "          return null;",
      "        }",
      "        final GoogleSignInAuthentication googleAuth =",
      "            await googleUser.authentication;",
      "        final AuthCredential credential = GoogleAuthProvider.credential(",
      "          accessToken: googleAuth.accessToken,",
      "          idToken: googleAuth.idToken,",
      "        );",
      "        final UserCredential authResult =",
      "            await _auth.signInWithCredential(credential);",
      "        final user = authResult.user;",
      "        LogUtils.i('Google sign-in successful: ${user?.email ?? 'No email'}');",
      "        notifyListeners();",
      "        return user;",
      "      }",
      "    } catch (e, stack) {",
      "      LogUtils.e('Google sign-in error', e, stack);",
      "      return null;",
      "    }",
      "  }",
      "",
      "  /// SIGN OUT (admin)",
      "  Future<void> signOut() async {",
      "    try {",
      "      await _auth.signOut();",
      "      LogUtils.i('Admin signed out.');",
      "    } catch (e, stack) {",
      "      LogUtils.e('Sign-out error', e, stack);",
      "    }",
      "  }",
      "",
      "  /// EMAIL VERIFICATION (optional)",
      "  Future<void> sendEmailVerification() async {",
      "    final user = _auth.currentUser;",
      "    if (user != null && !user.emailVerified) {",
      "      await user.sendEmailVerification();",
      "      LogUtils.i('Verification sent to: ${user.email}');",
      "    }",
      "  }",
      "",
      "  Future<void> signInWithPhone(",
      "    String phoneNumber,",
      "    Function(String verificationId, int? resendToken) codeSentCallback, {",
      "    Function? onError,",
      "  }) async {",
      "    try {",
      "      await _auth.verifyPhoneNumber(",
      "        phoneNumber: phoneNumber,",
      "        verificationCompleted: (PhoneAuthCredential credential) async {",
      "          await _auth.signInWithCredential(credential);",
      "        },",
      "        verificationFailed: (FirebaseAuthException e) {",
      "          if (onError != null) onError(e);",
      "        },",
      "        codeSent: codeSentCallback,",
      "        codeAutoRetrievalTimeout: (String verificationId) {},",
      "      );",
      "    } catch (e) {",
      "      if (onError != null) onError(e);",
      "    }",
      "  }",
      "",
      "  Future<User?> verifySmsCode(String verificationId, String smsCode) async {",
      "    final credential = PhoneAuthProvider.credential(",
      "      verificationId: verificationId,",
      "      smsCode: smsCode,",
      "    );",
      "    final result = await _auth.signInWithCredential(credential);",
      "    return result.user;",
      "  }",
      "",
      "  void saveInviteToken(String? token) {",
      "    print('[auth_service.dart] saveInviteToken called with token=$token');",
      "    _inviteToken = token;",
      "    // Persist for reload/redirect flow, especially on web:",
      "    if (token != null) {",
      "      if (kIsWeb) {",
      "        print(",
      "            '[auth_service.dart] saveInviteToken: saving token to localStorage');",
      "        html.window.localStorage['inviteToken'] = token;",
      "      }",
      "    }",
      "  }",
      "",
      "  String? getInviteToken() {",
      "    print('[auth_service.dart] getInviteToken called');",
      "    if (_inviteToken != null) {",
      "      print(",
      "          '[auth_service.dart] getInviteToken: returning from _inviteToken ($_inviteToken)');",
      "      return _inviteToken;",
      "    }",
      "    if (kIsWeb) {",
      "      final token = html.window.localStorage['inviteToken'];",
      "      print(",
      "          '[auth_service.dart] getInviteToken: returning from localStorage ($token)');",
      "      return token;",
      "    }",
      "    print('[auth_service.dart] getInviteToken: no token found, returning null');",
      "    return null;",
      "  }",
      "",
      "  void clearInviteToken() {",
      "    print('[auth_service.dart] clearInviteToken called');",
      "    _inviteToken = null;",
      "    if (kIsWeb) {",
      "      print(",
      "          '[auth_service.dart] clearInviteToken: removing token from localStorage');",
      "      html.window.localStorage.remove('inviteToken');",
      "    }",
      "  }",
      "",
      "  // All franchise-specific profile logic should be handled by a profile/provider class, not here.",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 199,
      "file_size": 6683,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\services\\firebase_storage_service.dart",
    "content": [
      "import 'dart:io';",
      "import 'package:firebase_storage/firebase_storage.dart';",
      "import 'package:uuid/uuid.dart';",
      "",
      "class FirebaseStorageService {",
      "  late final FirebaseStorage _storage;",
      "",
      "  FirebaseStorageService() {",
      "    _storage = FirebaseStorage.instance;",
      "  }",
      "",
      "  /// Uploads the image to Firebase Storage under the franchise-specific path.",
      "  /// Returns the public URL of the uploaded image.",
      "  Future<String> uploadFranchiseImage({",
      "    required File file,",
      "    required String franchiseId,",
      "    required String folder, // e.g. 'menu_items', 'ingredients'",
      "  }) async {",
      "    final String uniqueId = const Uuid().v4();",
      "    final String filePath = 'franchises/$franchiseId/$folder/$uniqueId.jpg';",
      "",
      "    final ref = _storage.ref().child(filePath);",
      "    final uploadTask = await ref.putFile(file);",
      "    final downloadUrl = await uploadTask.ref.getDownloadURL();",
      "",
      "    return downloadUrl;",
      "  }",
      "",
      "  /// Optional: Delete file from storage by URL",
      "  Future<void> deleteImageByUrl(String imageUrl) async {",
      "    try {",
      "      final ref = _storage.refFromURL(imageUrl);",
      "      await ref.delete();",
      "    } catch (_) {",
      "      // Suppress error if already deleted",
      "    }",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 38,
      "file_size": 1175,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\services\\firestore_service.dart",
    "content": [
      "import 'package:franchise_admin_portal/core/models/franchise_info.dart';",
      "import 'package:franchise_admin_portal/core/models/ingredient_metadata.dart';",
      "import 'package:franchise_admin_portal/core/models/address.dart';",
      "import 'dart:collection';",
      "import 'package:franchise_admin_portal/core/models/customization.dart';",
      "import 'package:cloud_firestore/cloud_firestore.dart' as firestore;",
      "import 'package:firebase_auth/firebase_auth.dart' as fb_auth;",
      "import 'package:franchise_admin_portal/config/app_config.dart';",
      "import 'package:franchise_admin_portal/core/models/message.dart';",
      "import 'package:franchise_admin_portal/core/models/category.dart' as model;",
      "import 'package:franchise_admin_portal/core/models/menu_item.dart';",
      "import 'package:franchise_admin_portal/core/models/promo.dart';",
      "import 'package:franchise_admin_portal/core/models/banner.dart';",
      "import 'package:franchise_admin_portal/core/models/chat.dart';",
      "import 'package:franchise_admin_portal/core/models/feedback_entry.dart'",
      "    as feedback_model;",
      "import 'package:franchise_admin_portal/core/models/inventory.dart';",
      "import 'package:franchise_admin_portal/core/models/audit_log.dart';",
      "import 'package:franchise_admin_portal/core/services/audit_log_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/export_utils.dart';",
      "import 'package:franchise_admin_portal/core/models/analytics_summary.dart';",
      "import 'package:async/async.dart';",
      "import 'package:franchise_admin_portal/core/models/user.dart' as app_user;",
      "import 'package:franchise_admin_portal/core/models/order.dart';",
      "import 'package:franchise_admin_portal/core/models/error_log.dart';",
      "import 'package:cloud_functions/cloud_functions.dart';",
      "import 'package:franchise_admin_portal/core/models/payout.dart';",
      "import 'package:franchise_admin_portal/core/models/report.dart';",
      "import 'package:franchise_admin_portal/core/models/invoice.dart';",
      "import 'package:franchise_admin_portal/core/models/bank_account.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/core/models/franchisee_invitation.dart';",
      "import 'package:franchise_admin_portal/core/services/payout_service.dart';",
      "import 'package:franchise_admin_portal/core/models/platform_revenue_overview.dart';",
      "import 'package:franchise_admin_portal/core/models/platform_financial_kpis.dart';",
      "import 'package:franchise_admin_portal/core/models/platform_invoice.dart';",
      "import 'package:franchise_admin_portal/core/models/platform_payment.dart';",
      "import 'package:flutter/foundation.dart';",
      "import 'package:franchise_admin_portal/core/models/platform_plan_model.dart';",
      "import 'package:franchise_admin_portal/core/models/franchise_subscription_model.dart';",
      "import 'package:franchise_admin_portal/core/models/ingredient_type_model.dart';",
      "import 'package:franchise_admin_portal/widgets/developer/error_logs_section.dart';",
      "import 'dart:convert';",
      "import 'package:franchise_admin_portal/core/models/size_template.dart';",
      "import 'package:franchise_admin_portal/core/models/menu_template_ref.dart';",
      "",
      "class FirestoreService {",
      "  late final firestore.FirebaseFirestore _db;",
      "  late final fb_auth.FirebaseAuth auth;",
      "  late final FirebaseFunctions functions;",
      "",
      "  FirestoreService() {",
      "    _db = firestore.FirebaseFirestore.instance;",
      "    auth = fb_auth.FirebaseAuth.instance;",
      "    functions = FirebaseFunctions.instance;",
      "  }",
      "  firestore.FirebaseFirestore get db => _db;",
      "  // --- [NEW]: Ingredient Metadata Caching ---",
      "  List<IngredientMetadata>? _cachedIngredientMetadata;",
      "  DateTime? _lastIngredientMetadataFetch;",
      "  String get _ingredientMetadata => 'ingredient_metadata';",
      "",
      "  String? get currentUserId => auth.currentUser?.uid;",
      "",
      "  // Collection name getters from AppConfig",
      "  String get _menuItems => AppConfig.menuItemsCollection;",
      "  String get _promotions => AppConfig.promotionsCollection;",
      "  String get _banners => AppConfig.bannersCollection;",
      "  String get _supportChats => AppConfig.supportChatsCollection;",
      "  String get _feedback => AppConfig.feedbackCollection;",
      "  String get _inventory => AppConfig.inventoryCollection;",
      "  String get _categories => AppConfig.categoriesCollection;",
      "",
      "  firestore.CollectionReference get invitationCollection =>",
      "      _db.collection('franchisee_invitations');",
      "",
      "  /// Get all ingredient metadata, with in-memory caching.",
      "  Future<List<IngredientMetadata>> getAllIngredientMetadata(String franchiseId,",
      "      {bool forceRefresh = false}) async {",
      "    if (!forceRefresh &&",
      "        _cachedIngredientMetadata != null &&",
      "        _lastIngredientMetadataFetch != null &&",
      "        DateTime.now().difference(_lastIngredientMetadataFetch!).inMinutes <",
      "            15) {",
      "      return _cachedIngredientMetadata!;",
      "    }",
      "    final snap = await _db",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection(_ingredientMetadata)",
      "        .get();",
      "    final result = snap.docs",
      "        .map((d) => IngredientMetadata.fromMap(d.data()))",
      "        .toList(growable: false);",
      "    _cachedIngredientMetadata = result;",
      "    _lastIngredientMetadataFetch = DateTime.now();",
      "    return result;",
      "  }",
      "",
      "  /// Get ingredient metadata by ID.",
      "  Future<List<IngredientMetadata>> getIngredientMetadataByIds(",
      "      String franchiseId, List<String> ids) async {",
      "    if (ids.isEmpty) return [];",
      "    try {",
      "      final snap = await _db",
      "          .collection('franchises')",
      "          .doc(franchiseId)",
      "          .collection(_ingredientMetadata)",
      "          .where(firestore.FieldPath.documentId, whereIn: ids)",
      "          .get();",
      "      return snap.docs",
      "          .map((d) => IngredientMetadata.fromMap(d.data()))",
      "          .toList(growable: false);",
      "    } catch (e, stack) {",
      "      _logFirestoreError('getIngredientMetadataByIds', e, stack);",
      "      return [];",
      "    }",
      "  }",
      "",
      "  /// Get all ingredient metadata as a map for fast lookups.",
      "  Future<Map<String, IngredientMetadata>> getIngredientMetadataMap(",
      "      String franchiseId,",
      "      {bool forceRefresh = false}) async {",
      "    final all =",
      "        await getAllIngredientMetadata(franchiseId, forceRefresh: forceRefresh);",
      "    return {for (final meta in all) meta.id: meta};",
      "  }",
      "",
      "  Future<List<Map<String, dynamic>>> fetchIngredientMetadataAsMaps(",
      "      String franchiseId,",
      "      {bool forceRefresh = false}) async {",
      "    final all =",
      "        await getAllIngredientMetadata(franchiseId, forceRefresh: forceRefresh);",
      "    return all.map((meta) => meta.toMap()).toList();",
      "  }",
      "",
      "  /// Given a list of ingredient IDs, return the unique set of allergens present.",
      "  Future<List<String>> getAllergensForIngredientIds(",
      "      String franchiseId, List<String>? ingredientIds) async {",
      "    if (ingredientIds == null || ingredientIds.isEmpty) return [];",
      "    final metaMap = await getIngredientMetadataMap(franchiseId);",
      "    final allergens = <String>{};",
      "    for (final rawId in ingredientIds) {",
      "      final id = rawId.trim();",
      "      final meta = metaMap[id];",
      "      if (meta != null && meta.allergens.isNotEmpty) {",
      "        allergens.addAll(meta.allergens);",
      "      }",
      "    }",
      "    return allergens.toList()..sort();",
      "  }",
      "",
      "  Future<List<String>> getAllergensForCustomizations(",
      "      String franchiseId, List<Customization> customizations) async {",
      "    final ingredientIds = <String>[];",
      "    void collectIds(List<Customization> list) {",
      "      for (final c in list) {",
      "        if (!c.isGroup && c.ingredientId != null) {",
      "          ingredientIds.add(c.ingredientId!);",
      "        }",
      "        if (c.options != null) {",
      "          collectIds(c.options!);",
      "        }",
      "      }",
      "    }",
      "",
      "    collectIds(customizations);",
      "    return getAllergensForIngredientIds(franchiseId, ingredientIds);",
      "  }",
      "",
      "  // === INVITE USERS ===",
      "  // Fetch invite data by token",
      "  Future<Map<String, dynamic>?> getFranchiseeInvitationByToken(",
      "      String token) async {",
      "    print(",
      "        '[firestore_service.dart] getFranchiseeInvitationByToken called with token=$token');",
      "    final snap = await invitationCollection.doc(token).get();",
      "    final data = snap.data();",
      "    if (data == null) {",
      "      print(",
      "          '[firestore_service.dart] getFranchiseeInvitationByToken: No invite doc found for token=$token');",
      "      return null;",
      "    }",
      "    print(",
      "        '[firestore_service.dart] getFranchiseeInvitationByToken: Invite doc loaded for token=$token data=$data');",
      "    return {",
      "      ...(data as Map<Object?, Object?>)",
      "          .map((k, v) => MapEntry(k.toString(), v)),",
      "      'id': snap.id,",
      "    };",
      "  }",
      "",
      "  // On acceptance of invite create new profile / fill franchise ID field",
      "  /// Creates a new franchise profile.",
      "  /// Returns the franchiseId (doc id).",
      "  /// Create a new franchise profile and return its franchiseId (doc ID).",
      "  Future<String> createFranchiseProfile({",
      "    required Map<String, dynamic> franchiseData,",
      "    required String invitedUserId,",
      "  }) async {",
      "    try {",
      "      // Determine franchiseId: use provided or generate from name",
      "      String? franchiseId = franchiseData['franchiseId'];",
      "",
      "      if (franchiseId == null || franchiseId.trim().isEmpty) {",
      "        final name = (franchiseData['name'] ?? '') as String;",
      "        if (name.trim().isEmpty) {",
      "          throw Exception(",
      "              'Franchise name is required to generate franchiseId.');",
      "        }",
      "",
      "        // Generate slug-style ID from franchise name",
      "        franchiseId = name.toLowerCase().replaceAll(RegExp(r'\\s+'), '');",
      "      }",
      "",
      "      final franchiseRef = _db.collection('franchises').doc(franchiseId);",
      "      final userRef = _db.collection('users').doc(invitedUserId);",
      "",
      "      // Write to /franchises/{franchiseId}",
      "      await franchiseRef.set({",
      "        ...franchiseData,",
      "        'franchiseId': franchiseId,",
      "        'ownerUserId': invitedUserId,",
      "        'status': 'active',",
      "        'createdAt': firestore.FieldValue.serverTimestamp(),",
      "        'updatedAt': firestore.FieldValue.serverTimestamp(),",
      "      }, firestore.SetOptions(merge: true));",
      "",
      "      // ✅ Update the invited user's franchise metadata",
      "      await userRef.set({",
      "        'franchiseIds': firestore.FieldValue.arrayUnion([franchiseId]),",
      "        'defaultFranchise': franchiseId,",
      "      }, firestore.SetOptions(merge: true));",
      "",
      "      return franchiseId;",
      "    } catch (e, st) {",
      "      print('[FirestoreService] createFranchiseProfile error: $e\\n$st');",
      "      await ErrorLogger.log(",
      "        message: 'Failed to create franchise profile: $e',",
      "        stack: st.toString(),",
      "        source: 'FirestoreService',",
      "        screen: 'createFranchiseProfile',",
      "        severity: 'error',",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  Future<void> updateUserClaims({",
      "    required String uid,",
      "    required List<String> franchiseIds,",
      "    List<String>? roles,",
      "    Map<String, dynamic>? additionalClaims,",
      "  }) async {",
      "    final callable = functions.httpsCallable('updateUserClaims');",
      "",
      "    final payload = {",
      "      'uid': uid,",
      "      'franchiseIds': franchiseIds,",
      "      if (roles != null) 'roles': roles,",
      "      if (additionalClaims != null) 'additionalClaims': additionalClaims,",
      "    };",
      "",
      "    print('[FirestoreService] updateUserClaims called with:');",
      "    print('  uid=$uid');",
      "    print('  franchiseIds=$franchiseIds');",
      "    if (roles != null) {",
      "      print('  roles=$roles');",
      "    } else {",
      "      print('  roles=null (preserve existing)');",
      "    }",
      "    if (additionalClaims != null) {",
      "      print('  additionalClaims=$additionalClaims');",
      "    } else {",
      "      print('  additionalClaims=null');",
      "    }",
      "",
      "    try {",
      "      final result = await callable.call(payload);",
      "      print(",
      "          '[FirestoreService] updateUserClaims success: result=${result.data}');",
      "    } catch (e, st) {",
      "      print('[FirestoreService] updateUserClaims ERROR: $e');",
      "      print('[FirestoreService] Stack trace:\\n$st');",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Update existing franchise profile fields.",
      "  Future<void> updateFranchiseProfile({",
      "    required String franchiseId,",
      "    required Map<String, dynamic> data,",
      "  }) async {",
      "    try {",
      "      await _db.collection('franchises').doc(franchiseId).set({",
      "        ...data,",
      "        'updatedAt': firestore.FieldValue.serverTimestamp(),",
      "      }, firestore.SetOptions(merge: true));",
      "    } catch (e, st) {",
      "      print('[FirestoreService] updateFranchiseProfile error: $e\\n$st');",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Save business hours array to /franchises/{franchiseId}",
      "  Future<void> saveFranchiseBusinessHours({",
      "    required String franchiseId,",
      "    required List<Map<String, dynamic>> hours,",
      "  }) async {",
      "    try {",
      "      await _db",
      "          .collection('franchises')",
      "          .doc(franchiseId)",
      "          .set({'hours': hours}, firestore.SetOptions(merge: true));",
      "    } catch (e, st) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to save business hours: $e',",
      "        stack: st.toString(),",
      "        source: 'FirestoreService',",
      "        severity: 'error',",
      "        screen: 'business_hours_editor',",
      "        contextData: {'franchiseId': franchiseId, 'hours': hours},",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Load business hours array from /franchises/{franchiseId}",
      "  Future<List<Map<String, dynamic>>> getFranchiseBusinessHours(",
      "      String franchiseId) async {",
      "    try {",
      "      final doc = await _db.collection('franchises').doc(franchiseId).get();",
      "      if (!doc.exists || !(doc.data()?['hours'] is List)) return [];",
      "      final List<dynamic> raw = doc.data()?['hours'] ?? [];",
      "      return raw.map((e) => Map<String, dynamic>.from(e)).toList();",
      "    } catch (e, st) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to load business hours: $e',",
      "        stack: st.toString(),",
      "        source: 'FirestoreService',",
      "        severity: 'error',",
      "        screen: 'business_hours_editor',",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      return [];",
      "    }",
      "  }",
      "",
      "  // Call cloud function to accept invitation",
      "  Future<void> callAcceptInvitationFunction(String token) async {",
      "    print(",
      "        '[firestore_service.dart] callAcceptInvitationFunction called with token=$token');",
      "    final functions = FirebaseFunctions.instance;",
      "    final acceptInvite = functions.httpsCallable('acceptInvitation');",
      "    await acceptInvite({'token': token});",
      "    print(",
      "        '[firestore_service.dart] callAcceptInvitationFunction: acceptInvitation function invoked for token=$token');",
      "  }",
      "",
      "  // Claim invitation",
      "  Future<void> claimInvitation(String token, String newUid) async {",
      "    // Simple Firestore update. (Could call a cloud function for security.)",
      "    final docRef = firestore.FirebaseFirestore.instance",
      "        .collection('franchisee_invitations')",
      "        .doc(token);",
      "    await docRef.update({'invitedUserId': newUid});",
      "  }",
      "",
      "  // === USERS (GLOBAL, INDUSTRY STANDARD) ===",
      "",
      "  Future<void> updateUserProfile(",
      "      String userId, Map<String, dynamic>? data) async {",
      "    print(",
      "        '[DEBUG] Calling updateUserProfile with userId=$userId and data=$data');",
      "    if (data == null || data.isEmpty) {",
      "      throw ArgumentError(",
      "          'updateUserProfile called with empty or null data for userId=$userId');",
      "    }",
      "",
      "    try {",
      "      await firestore.FirebaseFirestore.instance",
      "          .collection('users')",
      "          .doc(userId)",
      "          .set(data, firestore.SetOptions(merge: true));",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to update user profile: $e',",
      "        stack: stack.toString(),",
      "        source: 'FirestoreService',",
      "        screen: 'updateUserProfile',",
      "        severity: 'error',",
      "        contextData: {'userId': userId, ...?data},",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// (Optional) Upload profile photo, then update avatarUrl in user profile.",
      "  /// You must handle file upload in a separate service (Firebase Storage).",
      "  Future<void> updateUserAvatar(String userId, String avatarUrl) async {",
      "    return updateUserProfile(userId, {'avatarUrl': avatarUrl});",
      "  }",
      "",
      "  /// Add a user at top-level `/users`",
      "  Future<void> addUser(app_user.User user) async {",
      "    await _db.collection('users').doc(user.id).set(",
      "          user.toFirestore(),",
      "          firestore.SetOptions(merge: true),",
      "        );",
      "  }",
      "",
      "  /// Get a user from top-level `/users`",
      "  Future<app_user.User?> getUser(String userId) async {",
      "    print('[FirestoreService] getUser called with userId=$userId');",
      "    final doc = await _db.collection('users').doc(userId).get();",
      "    print(",
      "        '[FirestoreService] getUser Firestore response: exists=${doc.exists}, data=${doc.data()}');",
      "    if (!doc.exists) {",
      "      print('[FirestoreService] getUser: No user found for $userId');",
      "      return null;",
      "    }",
      "    final user = app_user.User.fromFirestore(doc.data()!, doc.id);",
      "    print(",
      "        '[FirestoreService] getUser: Created User model: email=${user.email}, roles=${user.roles}, isActive=${user.status == \"active\"}, id=${user.id}');",
      "    return user;",
      "  }",
      "",
      "  /// Update a user at top-level `/users`",
      "  Future<void> updateUser(app_user.User user) async {",
      "    await _db.collection('users').doc(user.id).update(user.toFirestore());",
      "  }",
      "",
      "  /// Delete a user from top-level `/users`",
      "  Future<void> deleteUser(String userId) async {",
      "    await _db.collection('users').doc(userId).delete();",
      "  }",
      "",
      "  /// Stream a single user from top-level `/users`",
      "  Stream<app_user.User?> userStream(String userId) {",
      "    return _db.collection('users').doc(userId).snapshots().map((doc) {",
      "      final data = doc.data();",
      "      return data != null ? app_user.User.fromFirestore(data, doc.id) : null;",
      "    });",
      "  }",
      "",
      "  /// Stream all users (optionally filtered by franchiseId)",
      "  Stream<List<app_user.User>> allUsers({String? franchiseId}) {",
      "    firestore.Query query = _db.collection('users');",
      "    if (franchiseId != null) {",
      "      query = query.where('franchiseIds', arrayContains: franchiseId);",
      "    }",
      "    return query.snapshots().map((snap) => snap.docs",
      "        .map((doc) {",
      "          final data = doc.data();",
      "          if (data != null) {",
      "            return app_user.User.fromFirestore(",
      "                data as Map<String, dynamic>, doc.id);",
      "          } else {",
      "            return null;",
      "          }",
      "        })",
      "        .where((user) => user != null)",
      "        .cast<app_user.User>()",
      "        .toList());",
      "  }",
      "",
      "  Future<List<app_user.User>> getAllUsers() async {",
      "    try {",
      "      final snap = await _db.collection('users').get();",
      "      return snap.docs.map((doc) {",
      "        final data = doc.data();",
      "        return app_user.User.fromFirestore(data, doc.id);",
      "      }).toList();",
      "    } catch (e, st) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to fetch all users: $e',",
      "        stack: st.toString(),",
      "        source: 'FirestoreService',",
      "        screen: 'getAllUsers',",
      "        severity: 'error',",
      "      );",
      "      return [];",
      "    }",
      "  }",
      "",
      "  // === USER ADDRESSES ===",
      "",
      "  /// Add an address to `/users/{uid}/addresses/{addressId}`",
      "  Future<void> addAddressForUser(String userId, Address address) async {",
      "    await _db",
      "        .collection('users')",
      "        .doc(userId)",
      "        .collection('addresses')",
      "        .doc(address.id)",
      "        .set(address.toFirestore());",
      "  }",
      "",
      "  /// Update an address",
      "  Future<void> updateAddressForUser(String userId, Address address) async {",
      "    await _db",
      "        .collection('users')",
      "        .doc(userId)",
      "        .collection('addresses')",
      "        .doc(address.id)",
      "        .update(address.toFirestore());",
      "  }",
      "",
      "  /// Remove an address",
      "  Future<void> removeAddressForUser(String userId, String addressId) async {",
      "    await _db",
      "        .collection('users')",
      "        .doc(userId)",
      "        .collection('addresses')",
      "        .doc(addressId)",
      "        .delete();",
      "  }",
      "",
      "  /// Get all addresses for user",
      "  Future<List<Address>> getAddressesForUser(String userId) async {",
      "    final snap =",
      "        await _db.collection('users').doc(userId).collection('addresses').get();",
      "    return snap.docs",
      "        .map((doc) => Address.fromFirestore(doc.data(), doc.id))",
      "        .toList();",
      "  }",
      "",
      "  // === FRANCHISE PROFILE SUBCOLLECTIONS ===",
      "",
      "  /// Get a user's profile for a specific franchise",
      "  Future<Map<String, dynamic>?> getFranchiseProfile(",
      "      String userId, String franchiseId) async {",
      "    final doc = await _db",
      "        .collection('users')",
      "        .doc(userId)",
      "        .collection('franchise_profiles')",
      "        .doc(franchiseId)",
      "        .get();",
      "    return doc.exists ? doc.data() : null;",
      "  }",
      "",
      "  /// Set or update a user's franchise profile",
      "  Future<void> setFranchiseProfile(",
      "      String userId, String franchiseId, Map<String, dynamic> data) async {",
      "    await _db",
      "        .collection('users')",
      "        .doc(userId)",
      "        .collection('franchise_profiles')",
      "        .doc(franchiseId)",
      "        .set(data, firestore.SetOptions(merge: true));",
      "  }",
      "",
      "  /// Stream a user's franchise profile",
      "  Stream<Map<String, dynamic>?> franchiseProfileStream(",
      "      String userId, String franchiseId) {",
      "    return _db",
      "        .collection('users')",
      "        .doc(userId)",
      "        .collection('franchise_profiles')",
      "        .doc(franchiseId)",
      "        .snapshots()",
      "        .map((doc) => doc.data());",
      "  }",
      "",
      "  /// Get favorites for user at a franchise",
      "  Stream<List<String>> favoritesMenuItemIdsStream(",
      "      String userId, String franchiseId) {",
      "    return _db",
      "        .collection('users')",
      "        .doc(userId)",
      "        .collection('franchise_profiles')",
      "        .doc(franchiseId)",
      "        .snapshots()",
      "        .map((doc) =>",
      "            List<String>.from(doc.data()?['favoritesMenuItemIds'] ?? []));",
      "  }",
      "",
      "  Future<List<String>> getFavoritesMenuItemIds(",
      "      String userId, String franchiseId) async {",
      "    final doc = await _db",
      "        .collection('users')",
      "        .doc(userId)",
      "        .collection('franchise_profiles')",
      "        .doc(franchiseId)",
      "        .get();",
      "    if (!doc.exists) return [];",
      "    final data = doc.data();",
      "    return List<String>.from(data?['favoritesMenuItemIds'] ?? []);",
      "  }",
      "",
      "  /// Add a favorite menu item for user at a franchise",
      "  Future<void> addFavoriteMenuItem(",
      "      String userId, String franchiseId, String menuItemId) async {",
      "    final docRef = _db",
      "        .collection('users')",
      "        .doc(userId)",
      "        .collection('franchise_profiles')",
      "        .doc(franchiseId);",
      "    await docRef.set({",
      "      'favoritesMenuItemIds': firestore.FieldValue.arrayUnion([menuItemId])",
      "    }, firestore.SetOptions(merge: true));",
      "  }",
      "",
      "  /// Remove a favorite menu item for user at a franchise",
      "  Future<void> removeFavoriteMenuItem(",
      "      String userId, String franchiseId, String menuItemId) async {",
      "    final docRef = _db",
      "        .collection('users')",
      "        .doc(userId)",
      "        .collection('franchise_profiles')",
      "        .doc(franchiseId);",
      "    await docRef.set({",
      "      'favoritesMenuItemIds': firestore.FieldValue.arrayRemove([menuItemId])",
      "    }, firestore.SetOptions(merge: true));",
      "  }",
      "",
      "  /// Get loyalty info for user at a franchise",
      "  Future<Map<String, dynamic>?> getLoyaltyForUser(",
      "      String userId, String franchiseId) async {",
      "    final doc = await _db",
      "        .collection('users')",
      "        .doc(userId)",
      "        .collection('franchise_profiles')",
      "        .doc(franchiseId)",
      "        .get();",
      "    if (!doc.exists) return null;",
      "    final data = doc.data();",
      "    return data?['loyalty'];",
      "  }",
      "",
      "  /// Add or update loyalty info for user at a franchise",
      "  Future<void> setLoyaltyForUser(",
      "      String userId, String franchiseId, Map<String, dynamic> loyalty) async {",
      "    final docRef = _db",
      "        .collection('users')",
      "        .doc(userId)",
      "        .collection('franchise_profiles')",
      "        .doc(franchiseId);",
      "    await docRef.set({'loyalty': loyalty}, firestore.SetOptions(merge: true));",
      "  }",
      "",
      "  // Order methods",
      "  /// Update order status for a specific order in a franchise",
      "  Future<void> updateOrderStatus(",
      "      String franchiseId, String orderId, String newStatus) async {",
      "    await _db",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection('orders')",
      "        .doc(orderId)",
      "        .update({",
      "      'status': newStatus,",
      "      'lastModified': firestore.FieldValue.serverTimestamp(),",
      "    });",
      "  }",
      "",
      "  /// Refund an order, with optional amount and reason",
      "  Future<void> refundOrder(String franchiseId, String orderId,",
      "      {double? amount, String? refundReason}) async {",
      "    await _db",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection('orders')",
      "        .doc(orderId)",
      "        .update({",
      "      'refundStatus': 'refunded',",
      "      if (amount != null) 'refundAmount': amount,",
      "      if (refundReason != null) 'refundReason': refundReason,",
      "      'refundedAt': firestore.FieldValue.serverTimestamp(),",
      "    });",
      "  }",
      "",
      "  /// Stream all orders for a franchise, ordered by latest first",
      "  Stream<List<Order>> getAllOrdersStream(String franchiseId) {",
      "    return _db",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection('orders')",
      "        .orderBy('timestamp', descending: true)",
      "        .snapshots()",
      "        .map((snapshot) => snapshot.docs.map((doc) {",
      "              final data = doc.data();",
      "              return Order.fromFirestore(data, doc.id);",
      "            }).toList());",
      "  }",
      "",
      "  // More per-franchise user data methods (orders, scheduled_orders, etc.) can be added here...",
      "",
      "  // === FEATURE TOGGLES ===",
      "",
      "  /// Get global feature toggles (for all franchises)",
      "  Future<Map<String, dynamic>> getGlobalFeatureToggles() async {",
      "    final doc = await _db.collection('config').doc('features').get();",
      "    return doc.exists ? Map<String, dynamic>.from(doc.data()!) : {};",
      "  }",
      "",
      "  /// Get franchise-specific feature toggles",
      "  Future<Map<String, dynamic>> getFranchiseFeatureToggles(",
      "      String franchiseId) async {",
      "    final doc = await _db",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection('config')",
      "        .doc('features')",
      "        .get();",
      "    return doc.exists ? Map<String, dynamic>.from(doc.data()!) : {};",
      "  }",
      "",
      "  /// Set franchise feature toggles",
      "  Future<void> setFranchiseFeatureToggles(",
      "      String franchiseId, Map<String, dynamic> toggles) async {",
      "    final docRef = _db",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection('config')",
      "        .doc('features');",
      "    await docRef.set(toggles, firestore.SetOptions(merge: true));",
      "  }",
      "",
      "  /// Stream franchise feature toggles",
      "  Stream<Map<String, dynamic>> streamFranchiseFeatureToggles(",
      "      String franchiseId) {",
      "    final docRef = _db",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection('config')",
      "        .doc('features');",
      "    return docRef.snapshots().map((doc) => doc.data() ?? {});",
      "  }",
      "",
      "  /// Updates a single toggle value in the franchise's config/features doc.",
      "  Future<void> updateFeatureToggle(",
      "      String franchiseId, String key, dynamic value) async {",
      "    final docRef = _db",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection('config')",
      "        .doc('features');",
      "    await docRef.set({key: value}, firestore.SetOptions(merge: true));",
      "  }",
      "",
      "  // === ERROR LOGS (AUDIT-READY, INDUSTRY STANDARD) ===",
      "",
      "  // Add an error log (global/platform-wide error)",
      "  Future<void> addErrorLogGlobal(ErrorLog log) async {",
      "    await _db.collection('error_logs').add(log.toFirestore());",
      "  }",
      "",
      "  // Update a global error log",
      "  Future<void> updateErrorLogGlobal(",
      "      String logId, Map<String, dynamic> updates) async {",
      "    await _db.collection('error_logs').doc(logId).update(updates);",
      "  }",
      "",
      "  // Get a global error log by ID",
      "  Future<ErrorLog?> getErrorLogGlobal(String logId) async {",
      "    final doc = await _db.collection('error_logs').doc(logId).get();",
      "    if (!doc.exists) return null;",
      "    return ErrorLog.fromMap(doc.data() as Map<String, dynamic>, doc.id);",
      "  }",
      "",
      "  // Stream all global error logs (optionally filtered)",
      "  Stream<List<ErrorLog>> streamErrorLogsGlobal({",
      "    String? franchiseId,",
      "    String? userId,",
      "    String? severity,",
      "    String? platform,",
      "    String? screen,",
      "    DateTime? start,",
      "    DateTime? end,",
      "    int limit = 100,",
      "  }) {",
      "    firestore.Query query = _db.collection('error_logs');",
      "",
      "    if (franchiseId != null && franchiseId != 'all') {",
      "      debugPrint('🔎 Filtering by franchiseId = $franchiseId');",
      "      query = query.where('franchiseId', isEqualTo: franchiseId);",
      "    } else {",
      "      debugPrint('🪟 No franchise filter applied');",
      "    }",
      "",
      "    if (userId != null) {",
      "      query = query.where('userId', isEqualTo: userId);",
      "    }",
      "    if (severity != null) {",
      "      query = query.where('severity', isEqualTo: severity);",
      "    }",
      "    if (screen != null) {",
      "      query = query.where('screen', isEqualTo: screen);",
      "    }",
      "",
      "    if (start != null) {",
      "      query = query.where(",
      "        'createdAt',",
      "        isGreaterThanOrEqualTo: firestore.Timestamp.fromDate(start),",
      "      );",
      "    }",
      "    if (end != null) {",
      "      final adjustedEnd = end.add(const Duration(days: 1));",
      "      query = query.where(",
      "        'createdAt',",
      "        isLessThan: firestore.Timestamp.fromDate(adjustedEnd),",
      "      );",
      "    }",
      "",
      "    // Always sort by createdAt for consistent ordering",
      "    query = query.orderBy('createdAt', descending: true);",
      "    query = query.limit(limit);",
      "",
      "    return query.snapshots().map((snap) {",
      "      final validDocs = snap.docs.where((doc) {",
      "        final data = doc.data() as Map<String, dynamic>;",
      "        return data.containsKey('createdAt') && data['createdAt'] != null;",
      "      }).toList();",
      "",
      "      debugPrint(",
      "          '📦 Filtered ErrorLog snapshot: ${validDocs.length} logs returned');",
      "",
      "      return validDocs",
      "          .map((doc) {",
      "            final data = doc.data() as Map<String, dynamic>;",
      "            try {",
      "              return ErrorLog.fromMap(data, doc.id);",
      "            } catch (e) {",
      "              debugPrint('❌ Failed to parse ErrorLog: ${doc.id} - $e');",
      "              return null;",
      "            }",
      "          })",
      "          .whereType<ErrorLog>()",
      "          .toList();",
      "    });",
      "  }",
      "",
      "  Future<List<ErrorLogSummary>> getErrorLogSummaries() async {",
      "    final snap = await _db",
      "        .collection('error_logs')",
      "        .limit(250)",
      "        .get(); // 🔥 remove ordering limit entirely for now",
      "",
      "    print('📦 Filtered ErrorLog snapshot: ${snap.docs.length} logs returned');",
      "",
      "    final logs = snap.docs",
      "        .map((doc) {",
      "          final data = doc.data() as Map<String, dynamic>?;",
      "",
      "          if (data == null) {",
      "            print('⛔️ Skipped log ${doc.id} – null data');",
      "            return null;",
      "          }",
      "          final tsRaw = data['timestamp'] ?? data['createdAt'];",
      "          if (tsRaw == null) {",
      "            print('⛔️ Skipped log ${doc.id} – missing timestamp/createdAt');",
      "            return null;",
      "          }",
      "          if (tsRaw is! firestore.Timestamp) {",
      "            print(",
      "                '⛔️ Skipped log ${doc.id} – invalid timestamp type: ${tsRaw.runtimeType}');",
      "            return null;",
      "          }",
      "",
      "          return ErrorLogSummary(",
      "            id: doc.id,",
      "            timestamp: tsRaw.toDate(),",
      "            message: data['message'] ?? '[No message]',",
      "            severity: data['severity'] ?? 'unknown',",
      "            screen: data['screen'] ?? 'unknown',",
      "            franchiseId: _extractFranchiseId(data['franchiseId']),",
      "          );",
      "        })",
      "        .whereType<ErrorLogSummary>()",
      "        .toList();",
      "",
      "    logs.sort((a, b) {",
      "      final cmp =",
      "          _severityScore(b.severity).compareTo(_severityScore(a.severity));",
      "      if (cmp != 0) return cmp;",
      "      return b.timestamp.compareTo(a.timestamp);",
      "    });",
      "",
      "    return logs.take(5).toList();",
      "  }",
      "",
      "  int _severityScore(String severity) {",
      "    switch (severity) {",
      "      case 'fatal':",
      "        return 4;",
      "      case 'error':",
      "        return 3;",
      "      case 'warning':",
      "        return 2;",
      "      case 'info':",
      "        return 1;",
      "      default:",
      "        return 0;",
      "    }",
      "  }",
      "",
      "  String? _extractFranchiseId(dynamic raw) {",
      "    // Handle cases where Firestore returns a DocumentReference",
      "    if (raw is String) return raw;",
      "    if (raw is firestore.DocumentReference) return raw.id;",
      "    return null;",
      "  }",
      "",
      "  Stream<List<ErrorLog>> streamErrorLogs(",
      "    String franchiseId, {",
      "    int limit = 50,",
      "    String? severity,",
      "    String? source,",
      "    String? screen,",
      "    DateTime? start,",
      "    DateTime? end,",
      "    String? search, // (not used directly unless you add full-text support)",
      "    bool archived = false,",
      "    bool? showResolved, // null = all, false = unresolved, true = resolved",
      "  }) {",
      "    firestore.Query query = _db",
      "        .collection('error_logs')",
      "        .where('franchiseId', isEqualTo: franchiseId);",
      "",
      "    if (severity != null &&",
      "        severity.isNotEmpty &&",
      "        severity != 'null' &&",
      "        severity != 'all') {",
      "      query = query.where('severity', isEqualTo: severity);",
      "    }",
      "    if (source != null && source.isNotEmpty) {",
      "      query = query.where('source', isEqualTo: source);",
      "    }",
      "    if (screen != null && screen.isNotEmpty) {",
      "      query = query.where('screen', isEqualTo: screen);",
      "    }",
      "",
      "    // Filter by archived status",
      "    query = query.where('archived', isEqualTo: archived);",
      "",
      "    // Only filter by resolved if showResolved is NOT null",
      "    if (showResolved != null) {",
      "      query = query.where('resolved', isEqualTo: showResolved);",
      "    }",
      "",
      "    if (start != null) {",
      "      query = query.where('timestamp',",
      "          isGreaterThanOrEqualTo: firestore.Timestamp.fromDate(start));",
      "    }",
      "    if (end != null) {",
      "      query = query.where('timestamp',",
      "          isLessThan: firestore.Timestamp.fromDate(end));",
      "    }",
      "",
      "    // Order and limit",
      "    query = query.orderBy('timestamp', descending: true).limit(limit);",
      "",
      "    return query.snapshots().map((snap) => snap.docs",
      "        .map((doc) =>",
      "            ErrorLog.fromMap(doc.data() as Map<String, dynamic>, doc.id))",
      "        .toList());",
      "  }",
      "",
      "  Future<void> deleteErrorLogGlobal(String logId) async {",
      "    await _db.collection('error_logs').doc(logId).delete();",
      "  }",
      "",
      "  /// Log schema error (template/menu-specific error)",
      "  Future<void> logSchemaError(",
      "    String franchiseId, {",
      "    required String message,",
      "    String? templateId,",
      "    String? menuItemId,",
      "    String? stackTrace,",
      "    String? userId,",
      "  }) async {",
      "    await ErrorLogger.log(",
      "      message: message,",
      "      stack: stackTrace,",
      "      source: 'customization_template_resolution',",
      "      contextData: {",
      "        'franchiseId': franchiseId,",
      "        if (templateId != null) 'templateId': templateId,",
      "        if (menuItemId != null) 'menuItemId': menuItemId,",
      "        if (userId != null) 'userId': userId,",
      "      },",
      "    );",
      "  }",
      "",
      "  /// Generic error logger (franchise-scoped, supports all error types)",
      "  Future<void> logError(",
      "    String? franchiseId, {",
      "    required String message,",
      "    required String source,",
      "    String? userId,",
      "    String? screen,",
      "    String? stackTrace,",
      "    String? errorType,",
      "    String? severity,",
      "    Map<String, dynamic>? contextData,",
      "    Map<String, dynamic>? deviceInfo,",
      "    String? assignedTo,",
      "  }) async {",
      "    print('Logging error for franchiseId=$franchiseId, message=$message');",
      "    try {",
      "      final data = <String, dynamic>{",
      "        'message': message,",
      "        'source': source,",
      "        if (userId != null) 'userId': userId,",
      "        if (screen != null) 'screen': screen,",
      "        if (stackTrace != null) 'stackTrace': stackTrace,",
      "        if (errorType != null) 'errorType': errorType,",
      "        if (severity != null) 'severity': severity,",
      "        if (contextData != null && contextData.isNotEmpty)",
      "          'contextData': contextData,",
      "        if (deviceInfo != null && deviceInfo.isNotEmpty)",
      "          'deviceInfo': deviceInfo,",
      "        if (assignedTo != null) 'assignedTo': assignedTo,",
      "        'timestamp': firestore.FieldValue.serverTimestamp(),",
      "        'resolved': false,",
      "        'archived': false,",
      "        'comments': <Map<String, dynamic>>[],",
      "      };",
      "      await _db.collection('error_logs').add({",
      "        ...data,",
      "        'franchiseId': franchiseId,",
      "      });",
      "    } catch (e, stack) {",
      "      print('[ERROR LOGGING FAILURE] $e\\n$stack');",
      "    }",
      "  }",
      "",
      "  // Update a log (mark as resolved/archived or add a comment)",
      "  Future<void> updateErrorLog(",
      "      String franchiseId, String logId, Map<String, dynamic> updates) async {",
      "    await _db.collection('error_logs').doc(logId).update(updates);",
      "  }",
      "",
      "  // Add a comment to an error log",
      "  Future<void> addCommentToErrorLog(",
      "      String franchiseId, String logId, Map<String, dynamic> comment) async {",
      "    await _db.collection('error_logs').doc(logId).update({",
      "      'comments': firestore.FieldValue.arrayUnion([comment]),",
      "      'updatedAt': firestore.FieldValue.serverTimestamp(),",
      "    });",
      "  }",
      "",
      "  // Mark an error log as resolved or archived",
      "  Future<void> setErrorLogStatus(String franchiseId, String logId,",
      "      {bool? resolved, bool? archived}) async {",
      "    final updates = <String, dynamic>{};",
      "    if (resolved != null) updates['resolved'] = resolved;",
      "    if (archived != null) updates['archived'] = archived;",
      "    updates['updatedAt'] = firestore.FieldValue.serverTimestamp();",
      "    await _db.collection('error_logs').doc(logId).update(updates);",
      "  }",
      "",
      "  Future<void> deleteErrorLog(String franchiseId, String logId) async {",
      "    await _db.collection('error_logs').doc(logId).delete();",
      "  }",
      "",
      "  // === AUDIT LOGS (ROOT AND FRANCHISE SCOPE) ===",
      "",
      "  /// Add a log to top-level `/audit_logs`",
      "  Future<void> addAuditLogGlobal(AuditLog log) async {",
      "    await _db.collection('audit_logs').add(log.toFirestore());",
      "  }",
      "",
      "  /// Get a single audit log by ID (top-level)",
      "  Future<AuditLog?> getAuditLogGlobal(String logId) async {",
      "    final doc = await _db.collection('audit_logs').doc(logId).get();",
      "    if (!doc.exists) return null;",
      "    return AuditLog.fromFirestore(doc.data()!, doc.id);",
      "  }",
      "",
      "  /// Stream audit logs (optionally filtered by franchiseId/userId/type)",
      "  Stream<List<AuditLog>> auditLogsStreamGlobal(",
      "      {String? franchiseId, String? userId, String? action}) {",
      "    firestore.Query query =",
      "        _db.collection('audit_logs').orderBy('timestamp', descending: true);",
      "    if (franchiseId != null) {",
      "      query = query.where('franchiseId', isEqualTo: franchiseId);",
      "    }",
      "    if (userId != null) {",
      "      query = query.where('userId', isEqualTo: userId);",
      "    }",
      "    if (action != null) {",
      "      query = query.where('action', isEqualTo: action);",
      "    }",
      "    return query.snapshots().map((snap) => snap.docs",
      "        .map((doc) {",
      "          final data = doc.data();",
      "          if (data != null) {",
      "            return AuditLog.fromFirestore(data as Map<String, dynamic>, doc.id);",
      "          } else {",
      "            return null;",
      "          }",
      "        })",
      "        .where((log) => log != null)",
      "        .cast<AuditLog>()",
      "        .toList());",
      "  }",
      "",
      "  // Add a log to franchise-specific `/franchises/{franchiseId}/audit_logs`",
      "  // Add an audit log to the root-level audit_logs collection",
      "  Future<void> addAuditLogFranchise(String franchiseId, AuditLog log) async {",
      "    final data = log.toFirestore();",
      "    data['franchiseId'] = franchiseId;",
      "    await _db.collection('audit_logs').add(data);",
      "  }",
      "",
      "// Get a single audit log from the root collection by ID",
      "  Future<AuditLog?> getAuditLogFranchise(",
      "      String franchiseId, String logId) async {",
      "    final doc = await _db.collection('audit_logs').doc(logId).get();",
      "    if (!doc.exists) return null;",
      "    // Optionally, you can check that doc.data()?['franchiseId'] == franchiseId if you want to enforce scoping here.",
      "    return AuditLog.fromFirestore(doc.data()!, doc.id);",
      "  }",
      "",
      "// Stream audit logs from the root collection, filtered by franchiseId (and optionally userId/action)",
      "  Stream<List<AuditLog>> auditLogsStreamFranchise(",
      "    String franchiseId, {",
      "    String? userId,",
      "    String? action,",
      "  }) {",
      "    firestore.Query query = _db",
      "        .collection('audit_logs')",
      "        .where('franchiseId', isEqualTo: franchiseId)",
      "        .orderBy('timestamp', descending: true);",
      "    if (userId != null) query = query.where('userId', isEqualTo: userId);",
      "    if (action != null) query = query.where('action', isEqualTo: action);",
      "    return query.snapshots().map((snap) => snap.docs",
      "        .map((doc) =>",
      "            AuditLog.fromFirestore(doc.data() as Map<String, dynamic>, doc.id))",
      "        .toList());",
      "  }",
      "",
      "  // --- STAFF/ADMIN USERS MANAGEMENT (FOR HQ/FRANCHISE DASHBOARDS) ---",
      "",
      "  /// Get all users with staff/admin roles for a franchise",
      "  Stream<List<app_user.User>> getStaffUsers(String franchiseId) {",
      "    return _db",
      "        .collection('users')",
      "        .where('franchiseIds', arrayContains: franchiseId)",
      "        .snapshots()",
      "        .map((snap) {",
      "      return snap.docs",
      "          .map((doc) => app_user.User.fromFirestore(doc.data(), doc.id))",
      "          .where((user) =>",
      "              user.roles.contains('staff') ||",
      "              user.roles.contains('manager') ||",
      "              user.roles.contains('admin') ||",
      "              user.roles.contains('hq_owner'))",
      "          .toList();",
      "    });",
      "  }",
      "",
      "  /// Add a staff/admin user (invite or onboarding logic should use this)",
      "  Future<void> addStaffUser({",
      "    required String name,",
      "    required String email,",
      "    String? phone,",
      "    required List<String> roles,",
      "    required List<String> franchiseIds,",
      "  }) async {",
      "    final docRef = _db.collection('users').doc();",
      "    await docRef.set({",
      "      'id': docRef.id,",
      "      'name': name,",
      "      'email': email,",
      "      'phone': phone ?? '',",
      "      'roles': roles,",
      "      'franchiseIds': franchiseIds,",
      "      'createdAt': firestore.FieldValue.serverTimestamp(),",
      "      'isActive': true,",
      "    });",
      "  }",
      "",
      "  /// Remove a staff user by userId (sets isActive to false for soft delete)",
      "  Future<void> removeStaffUser(String userId) async {",
      "    await _db.collection('users').doc(userId).update({'isActive': false});",
      "  }",
      "",
      "  /// Invite logic (optional): Add to an \"invites\" collection, then create user on accept...",
      "",
      "  // === FRANCHISE & BUSINESS LOGIC HELPERS ===",
      "",
      "  Future<List<FranchiseInfo>> fetchFranchiseList() async {",
      "    final snapshot = await _db.collection('franchises').get();",
      "    return snapshot.docs.map((doc) {",
      "      return FranchiseInfo.fromMap(doc.data(), doc.id);",
      "    }).toList();",
      "  }",
      "",
      "  Future<List<FranchiseInfo>> getFranchisesByIds(List<String> ids) async {",
      "    if (ids.isEmpty) return [];",
      "    final snapshot = await firestore.FirebaseFirestore.instance",
      "        .collection('franchises')",
      "        .where(firestore.FieldPath.documentId, whereIn: ids)",
      "        .get();",
      "",
      "    return snapshot.docs",
      "        .map((doc) => FranchiseInfo.fromMap(doc.data(), doc.id))",
      "        .toList();",
      "  }",
      "",
      "  Future<List<FranchiseInfo>> getFranchises() async {",
      "    final query = await _db.collection('franchises').get();",
      "    return query.docs",
      "        .map((doc) => FranchiseInfo.fromMap(doc.data(), doc.id))",
      "        .toList();",
      "  }",
      "",
      "  Future<List<FranchiseInfo>> getAllFranchises() async {",
      "    final snapshot = await firestore.FirebaseFirestore.instance",
      "        .collection('franchises')",
      "        .get();",
      "",
      "    return snapshot.docs",
      "        .map((doc) => FranchiseInfo.fromMap(doc.data(), doc.id))",
      "        .toList();",
      "  }",
      "",
      "  // --- PAYOUTS ---",
      "",
      "  Future<void> addOrUpdatePayout(Payout payout) async {",
      "    await _db",
      "        .collection('payouts')",
      "        .doc(payout.id)",
      "        .set(payout.toFirestore(), firestore.SetOptions(merge: true));",
      "  }",
      "",
      "  Future<Payout?> getPayoutById(String id) async {",
      "    final doc = await _db.collection('payouts').doc(id).get();",
      "    if (!doc.exists || doc.data() == null) return null;",
      "    return Payout.fromFirestore(doc.data()!, doc.id);",
      "  }",
      "",
      "  Future<void> deletePayout(String id) async {",
      "    await _db.collection('payouts').doc(id).delete();",
      "  }",
      "",
      "  Stream<List<Payout>> payoutsStream({String? franchiseId, String? status}) {",
      "    firestore.Query query = _db.collection('payouts');",
      "    if (franchiseId != null) {",
      "      query = query.where('franchiseId', isEqualTo: franchiseId);",
      "    }",
      "    if (status != null) {",
      "      query = query.where('status', isEqualTo: status);",
      "    }",
      "    return query.snapshots().map((snap) => snap.docs",
      "        .map((doc) =>",
      "            Payout.fromFirestore(doc.data() as Map<String, dynamic>, doc.id))",
      "        .toList());",
      "  }",
      "",
      "  Future<List<Map<String, dynamic>>> getPayoutsForFranchise({",
      "    required String franchiseId,",
      "    String? status,",
      "    String? searchQuery,",
      "  }) async {",
      "    final docRef = firestore.FirebaseFirestore.instance",
      "        .collection('franchises')",
      "        .doc(franchiseId);",
      "",
      "    firestore.Query<Map<String, dynamic>> query = firestore",
      "        .FirebaseFirestore.instance",
      "        .collection('payouts')",
      "        .where('franchiseId', isEqualTo: docRef);",
      "",
      "    if (status != null && status.isNotEmpty && status != 'all') {",
      "      query = query.where('status', isEqualTo: status);",
      "    }",
      "",
      "    final snap = await query.orderBy('scheduled_at', descending: true).get();",
      "",
      "    List<Map<String, dynamic>> payouts = snap.docs.map((doc) {",
      "      final rawData = doc.data();",
      "      final data =",
      "          (rawData is Map<String, dynamic>) ? rawData : <String, dynamic>{};",
      "",
      "      return {",
      "        'id': doc.id,",
      "        'status': data['status'] ?? '',",
      "        'amount':",
      "            (data['amount'] is num) ? (data['amount'] as num).toDouble() : 0.0,",
      "        'created_at': (data['scheduled_at'] is firestore.Timestamp)",
      "            ? (data['scheduled_at'] as firestore.Timestamp).toDate()",
      "            : null,",
      "        'sent_at': (data['sent_at'] is firestore.Timestamp)",
      "            ? (data['sent_at'] as firestore.Timestamp).toDate()",
      "            : null,",
      "        'failed_at': (data['failed_at'] is firestore.Timestamp)",
      "            ? (data['failed_at'] as firestore.Timestamp).toDate()",
      "            : null,",
      "        'method': data['method'] is String ? data['method'] as String : '',",
      "        'bank_account_last4': data['bank_account_last4']?.toString() ?? '',",
      "        'notes': data['notes'] is String ? data['notes'] as String : '',",
      "      };",
      "    }).toList();",
      "",
      "    // Local search filtering across all visible fields",
      "    if (searchQuery != null && searchQuery.trim().isNotEmpty) {",
      "      final q = searchQuery.trim().toLowerCase();",
      "      payouts = payouts.where((p) {",
      "        return (p['id'] ?? '').toString().toLowerCase().contains(q) ||",
      "            (p['status'] ?? '').toString().toLowerCase().contains(q) ||",
      "            (p['amount']?.toString() ?? '').toLowerCase().contains(q) ||",
      "            (p['method'] ?? '').toString().toLowerCase().contains(q) ||",
      "            (p['bank_account_last4'] ?? '')",
      "                .toString()",
      "                .toLowerCase()",
      "                .contains(q) ||",
      "            (p['notes'] ?? '').toString().toLowerCase().contains(q) ||",
      "            (p['created_at'] != null &&",
      "                p['created_at'].toString().toLowerCase().contains(q)) ||",
      "            (p['sent_at'] != null &&",
      "                p['sent_at'].toString().toLowerCase().contains(q)) ||",
      "            (p['failed_at'] != null &&",
      "                p['failed_at'].toString().toLowerCase().contains(q));",
      "      }).toList();",
      "    }",
      "",
      "    return payouts;",
      "  }",
      "",
      "  /// Search payouts with filters: status, date range, amount, method, account, user, search text.",
      "  Future<List<Payout>> fetchPayouts({",
      "    String? franchiseId,",
      "    String? status,",
      "    String? locationId,",
      "    DateTime? startDate,",
      "    DateTime? endDate,",
      "    String? search,",
      "    String? sortBy, // 'scheduled_at', 'amount', etc.",
      "    bool descending = true,",
      "    int? limit,",
      "    firestore.DocumentSnapshot? startAfter, // For paged results",
      "  }) async {",
      "    firestore.Query query = _db.collection('payouts');",
      "    if (franchiseId != null) {",
      "      query = query.where('franchiseId',",
      "          isEqualTo: _db.collection('franchises').doc(franchiseId));",
      "    }",
      "    if (status != null && status != 'all')",
      "      query = query.where('status', isEqualTo: status);",
      "    if (locationId != null) {",
      "      query = query.where('locationId',",
      "          isEqualTo: _db.collection('franchise_locations').doc(locationId));",
      "    }",
      "    if (startDate != null)",
      "      query = query.where('scheduled_at',",
      "          isGreaterThanOrEqualTo: firestore.Timestamp.fromDate(startDate));",
      "    if (endDate != null)",
      "      query = query.where('scheduled_at',",
      "          isLessThanOrEqualTo: firestore.Timestamp.fromDate(endDate));",
      "    if (search != null && search.isNotEmpty) {",
      "      // For ID or notes search (Firestore can't do full text, but support id/last4)",
      "      query = query",
      "          .where('notes', isGreaterThanOrEqualTo: search)",
      "          .where('notes', isLessThan: search + 'z');",
      "    }",
      "    if (sortBy != null)",
      "      query = query.orderBy(sortBy, descending: descending);",
      "    else",
      "      query = query.orderBy('scheduled_at', descending: descending);",
      "    if (startAfter != null) query = query.startAfterDocument(startAfter);",
      "    if (limit != null) query = query.limit(limit);",
      "    final snap = await query.get();",
      "    return snap.docs",
      "        .map((doc) =>",
      "            Payout.fromFirestore(doc.data() as Map<String, dynamic>, doc.id))",
      "        .toList();",
      "  }",
      "",
      "  // Full payout details, including audit trail",
      "  Future<Map<String, dynamic>?> getPayoutDetailsWithAudit(",
      "      String payoutId) async {",
      "    final doc = await _db.collection('payouts').doc(payoutId).get();",
      "    if (!doc.exists) return null;",
      "    final data = doc.data()!;",
      "    // Audit trail is array of maps, or fallback to empty",
      "    final auditTrail =",
      "        List<Map<String, dynamic>>.from(data['audit_trail'] ?? []);",
      "    return {...data, 'id': doc.id, 'audit_trail': auditTrail};",
      "  }",
      "",
      "// Append event to audit trail",
      "  Future<void> addPayoutAuditEvent(",
      "      String payoutId, Map<String, dynamic> event) async {",
      "    await _db.collection('payouts').doc(payoutId).update({",
      "      'audit_trail': firestore.FieldValue.arrayUnion([event]),",
      "      'updated_at': firestore.FieldValue.serverTimestamp(),",
      "    });",
      "  }",
      "",
      "  // Add (meta) attachment to payout (arrayUnion pattern)",
      "  Future<void> addAttachmentToPayout(",
      "      String payoutId, Map<String, dynamic> attachment) async {",
      "    await _db.collection('payouts').doc(payoutId).update({",
      "      'attachments': firestore.FieldValue.arrayUnion([attachment]),",
      "      'updated_at': firestore.FieldValue.serverTimestamp(),",
      "    });",
      "  }",
      "",
      "// Remove attachment (by full meta match or maybe by id/path)",
      "  Future<void> removeAttachmentFromPayout(",
      "      String payoutId, Map<String, dynamic> attachment) async {",
      "    await _db.collection('payouts').doc(payoutId).update({",
      "      'attachments': firestore.FieldValue.arrayRemove([attachment]),",
      "      'updated_at': firestore.FieldValue.serverTimestamp(),",
      "    });",
      "  }",
      "",
      "  // Bulk update payouts (status, sent, failed, etc.) by list of payoutIds",
      "  Future<void> bulkUpdatePayoutStatus(",
      "      List<String> payoutIds, String status) async {",
      "    final batch = _db.batch();",
      "    for (final id in payoutIds) {",
      "      batch.update(_db.collection('payouts').doc(id), {",
      "        'status': status,",
      "        'updated_at': firestore.FieldValue.serverTimestamp(),",
      "      });",
      "    }",
      "    await batch.commit();",
      "  }",
      "",
      "  /// Append a new comment/note to the payout (atomic, safe).",
      "  Future<void> addPayoutComment(",
      "      String payoutId, Map<String, dynamic> comment) async {",
      "    await _db.collection('payouts').doc(payoutId).update({",
      "      'comments': firestore.FieldValue.arrayUnion([comment]),",
      "      'updated_at': firestore.FieldValue.serverTimestamp(),",
      "    });",
      "  }",
      "",
      "  /// Fetch all comments (notes) for a specific payout by ID.",
      "  /// Returns a list of note maps. Includes audit trail if you want.",
      "  Future<List<Map<String, dynamic>>> getPayoutComments(String payoutId) async {",
      "    final doc = await _db.collection('payouts').doc(payoutId).get();",
      "    if (!doc.exists) return [];",
      "    final data = doc.data()!;",
      "    final comments = data['comments'] as List? ?? [];",
      "    return List<Map<String, dynamic>>.from(comments);",
      "  }",
      "",
      "  /// Optionally: Remove a comment (match by content or add a unique note ID/timestamp for robust remove)",
      "  Future<void> removePayoutComment(",
      "      String payoutId, Map<String, dynamic> comment) async {",
      "    await _db.collection('payouts').doc(payoutId).update({",
      "      'comments': firestore.FieldValue.arrayRemove([comment]),",
      "      'updated_at': firestore.FieldValue.serverTimestamp(),",
      "    });",
      "  }",
      "",
      "  Future<void> markPayoutSent(String payoutId, {DateTime? sentAt}) async {",
      "    await _db.collection('payouts').doc(payoutId).update({",
      "      'status': 'sent',",
      "      'sent_at': firestore.FieldValue.serverTimestamp(),",
      "      if (sentAt != null) 'sent_at': firestore.Timestamp.fromDate(sentAt),",
      "      'updated_at': firestore.FieldValue.serverTimestamp(),",
      "    });",
      "  }",
      "",
      "  Future<void> setPayoutStatus(String payoutId, String newStatus) async {",
      "    await _db.collection('payouts').doc(payoutId).update({",
      "      'status': newStatus,",
      "      'failed_at':",
      "          newStatus == 'failed' ? firestore.FieldValue.serverTimestamp() : null,",
      "      'sent_at':",
      "          newStatus == 'sent' ? firestore.FieldValue.serverTimestamp() : null,",
      "      // Optionally clear error fields if status != failed",
      "      if (newStatus != 'failed') ...{",
      "        'error_message': '',",
      "        'error_code': '',",
      "      },",
      "      'updated_at': firestore.FieldValue.serverTimestamp(),",
      "    });",
      "  }",
      "",
      "  Future<void> markPayoutFailed(String payoutId,",
      "      {String? errorMsg, String? errorCode}) async {",
      "    await _db.collection('payouts').doc(payoutId).update({",
      "      'status': 'failed',",
      "      'failed_at': firestore.FieldValue.serverTimestamp(),",
      "      if (errorMsg != null) 'error_message': errorMsg,",
      "      if (errorCode != null) 'error_code': errorCode,",
      "      'updated_at': firestore.FieldValue.serverTimestamp(),",
      "    });",
      "  }",
      "",
      "  Future<void> retryPayout(String payoutId) async {",
      "    // Update status to 'pending' or custom, clear error fields, append audit event, etc.",
      "    await _db.collection('payouts').doc(payoutId).update({",
      "      'status': 'pending',",
      "      'error_message': '',",
      "      'error_code': '',",
      "      'updated_at': firestore.FieldValue.serverTimestamp(),",
      "    });",
      "  }",
      "",
      "  Future<List<AuditLog>> getAuditLogsForPayout(String payoutId) async {",
      "    final snap = await _db",
      "        .collection('audit_logs')",
      "        .where('targetId', isEqualTo: payoutId)",
      "        .get();",
      "    return snap.docs",
      "        .map((doc) => AuditLog.fromFirestore(doc.data(), doc.id))",
      "        .toList();",
      "  }",
      "",
      "  // Bulk export (returns CSV or data list)",
      "  /// Exports payouts matching the given filters to a CSV string.",
      "  /// Filters must match your fetchPayouts() method signature and your Payout model fields.",
      "  Future<String> exportPayoutsToCsv({",
      "    String? franchiseId,",
      "    String? status,",
      "    String? locationId,",
      "    DateTime? startDate,",
      "    DateTime? endDate,",
      "    String? search,",
      "    String? sortBy, // e.g., 'scheduled_at', 'amount'",
      "    bool descending = true,",
      "    int? limit,",
      "  }) async {",
      "    // Fetch payouts using your existing method.",
      "    final payouts = await fetchPayouts(",
      "      franchiseId: franchiseId,",
      "      status: status,",
      "      locationId: locationId,",
      "      startDate: startDate,",
      "      endDate: endDate,",
      "      search: search,",
      "      sortBy: sortBy,",
      "      descending: descending,",
      "      limit: limit,",
      "    );",
      "",
      "    // CSV header (adjust/add fields as needed)",
      "    final csv = StringBuffer();",
      "    csv.writeln(",
      "        'ID,Amount,Currency,Status,Method,Scheduled At,Sent At,Failed At,Bank Account Last4,Notes,Failure Reason,Error Code,Error Message');",
      "",
      "    for (final p in payouts) {",
      "      // Format fields safely, escaping quotes in notes, handling nulls.",
      "      String formatDate(DateTime? dt) => dt != null ? dt.toIso8601String() : '';",
      "",
      "      String escape(String? value) =>",
      "          value == null ? '' : value.replaceAll('\"', '\"\"');",
      "",
      "      csv.writeln('${p.id},'",
      "          '${p.amount},'",
      "          '${p.currency},'",
      "          '${p.status},'",
      "          '${escape(p.method)},'",
      "          '${formatDate(p.scheduledAt)},'",
      "          '${formatDate(p.sentAt)},'",
      "          '${formatDate(p.failedAt)},'",
      "          '${escape(p.bankAccountLast4)},'",
      "          '\"${escape(p.notes)}\",'",
      "          '\"${escape(p.failureReason)}\",'",
      "          '\"${escape(p.errorCode)}\",'",
      "          '\"${escape(p.errorMessage)}\"');",
      "    }",
      "    return csv.toString();",
      "  }",
      "",
      "  // --- INVOICES ---",
      "  Future<Map<String, dynamic>> getInvoiceStatsForFranchise(",
      "      String franchiseId) async {",
      "    try {",
      "      final querySnapshot = await _db",
      "          .collection('invoices')",
      "          .where('franchiseId',",
      "              isEqualTo: _db.collection('franchises').doc(franchiseId))",
      "          .get();",
      "",
      "      final invoices = querySnapshot.docs",
      "          .map((doc) =>",
      "              Invoice.fromFirestore(doc.data() as Map<String, dynamic>, doc.id))",
      "          .toList();",
      "",
      "      final totalInvoices = invoices.length;",
      "      final openStatuses = {",
      "        InvoiceStatus.open,",
      "        InvoiceStatus.sent,",
      "        InvoiceStatus.viewed,",
      "        InvoiceStatus.draft,",
      "      };",
      "      final openInvoices =",
      "          invoices.where((inv) => openStatuses.contains(inv.status)).toList();",
      "      final overdueInvoices =",
      "          invoices.where((inv) => inv.status == InvoiceStatus.overdue).toList();",
      "      final paidInvoices =",
      "          invoices.where((inv) => inv.status == InvoiceStatus.paid).toList();",
      "",
      "      final totalOverdue =",
      "          overdueInvoices.fold<double>(0.0, (sum, inv) => sum + inv.total);",
      "      final outstandingBalance =",
      "          invoices.fold<double>(0.0, (sum, inv) => sum + inv.outstanding);",
      "",
      "      DateTime? lastInvoiceDate;",
      "      if (invoices.isNotEmpty) {",
      "        invoices.sort((a, b) =>",
      "            b.issuedAt?.compareTo(",
      "                a.issuedAt ?? DateTime.fromMillisecondsSinceEpoch(0)) ??",
      "            0);",
      "        lastInvoiceDate = invoices.first.issuedAt;",
      "      }",
      "",
      "      return {",
      "        'totalInvoices': totalInvoices,",
      "        'openInvoiceCount': openInvoices.length,",
      "        'overdueInvoiceCount': overdueInvoices.length,",
      "        'overdueAmount': totalOverdue,",
      "        'paidInvoiceCount': paidInvoices.length,",
      "        'outstandingBalance': outstandingBalance,",
      "        'lastInvoiceDate': lastInvoiceDate,",
      "      };",
      "    } catch (e, stackTrace) {",
      "      await ErrorLogger.log(",
      "        message: e.toString(),",
      "        stack: stackTrace.toString(),",
      "        source: 'FirestoreService',",
      "        screen: 'getInvoiceStatsForFranchise',",
      "        severity: 'error',",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  Future<List<Invoice>> fetchInvoicesFiltered({",
      "    required String franchiseId,",
      "    DateTime? startDate,",
      "    DateTime? endDate,",
      "  }) async {",
      "    firestore.Query query =",
      "        _db.collection('invoices').where('franchiseId', isEqualTo: franchiseId);",
      "",
      "    if (startDate != null) {",
      "      query = query.where('period_start',",
      "          isGreaterThanOrEqualTo: firestore.Timestamp.fromDate(startDate));",
      "    }",
      "    if (endDate != null) {",
      "      query = query.where('period_end',",
      "          isLessThanOrEqualTo: firestore.Timestamp.fromDate(endDate));",
      "    }",
      "",
      "    final snapshot = await query.get();",
      "    return snapshot.docs",
      "        .map((doc) =>",
      "            Invoice.fromFirestore(doc.data() as Map<String, dynamic>, doc.id))",
      "        .toList();",
      "  }",
      "",
      "  Future<void> addOrUpdateInvoice(Invoice invoice) async {",
      "    await _db",
      "        .collection('invoices')",
      "        .doc(invoice.id)",
      "        .set(invoice.toFirestore(), firestore.SetOptions(merge: true));",
      "  }",
      "",
      "  Future<Invoice?> getInvoiceById(String id) async {",
      "    final doc = await _db.collection('invoices').doc(id).get();",
      "    if (!doc.exists || doc.data() == null) return null;",
      "    return Invoice.fromFirestore(doc.data()!, doc.id);",
      "  }",
      "",
      "  Future<void> deleteInvoice(String id) async {",
      "    await _db.collection('invoices').doc(id).delete();",
      "  }",
      "",
      "  // dunning in invoices",
      "  Future<void> updateInvoiceDunningState(",
      "      String invoiceId, String dunningState) async {",
      "    await firestore.FirebaseFirestore.instance",
      "        .collection('invoices')",
      "        .doc(invoiceId)",
      "        .update({",
      "      'dunning_state': dunningState,",
      "      'updated_at': firestore.FieldValue.serverTimestamp(),",
      "    });",
      "  }",
      "",
      "  /// Add an overdue reminder to the invoice (atomic arrayUnion)",
      "  Future<void> addInvoiceOverdueReminder(",
      "      String invoiceId, Map<String, dynamic> reminder) async {",
      "    await firestore.FirebaseFirestore.instance",
      "        .collection('invoices')",
      "        .doc(invoiceId)",
      "        .update({",
      "      'overdue_reminders': firestore.FieldValue.arrayUnion([reminder]),",
      "      'updated_at': firestore.FieldValue.serverTimestamp(),",
      "    });",
      "  }",
      "",
      "  /// Set or update a payment plan object for an invoice",
      "  Future<void> setInvoicePaymentPlan(",
      "      String invoiceId, Map<String, dynamic> paymentPlan) async {",
      "    await firestore.FirebaseFirestore.instance",
      "        .collection('invoices')",
      "        .doc(invoiceId)",
      "        .update({",
      "      'payment_plan': paymentPlan,",
      "      'updated_at': firestore.FieldValue.serverTimestamp(),",
      "    });",
      "  }",
      "",
      "  /// Add an escalation event/history entry (atomic arrayUnion)",
      "  Future<void> addInvoiceEscalationEvent(",
      "      String invoiceId, Map<String, dynamic> escalationEvent) async {",
      "    await firestore.FirebaseFirestore.instance",
      "        .collection('invoices')",
      "        .doc(invoiceId)",
      "        .update({",
      "      'escalation_history': firestore.FieldValue.arrayUnion([escalationEvent]),",
      "      'updated_at': firestore.FieldValue.serverTimestamp(),",
      "    });",
      "  }",
      "",
      "  /// Fetch dunning workflow fields for an invoice",
      "  Future<Map<String, dynamic>?> getInvoiceWorkflowFields(",
      "      String invoiceId) async {",
      "    final doc = await firestore.FirebaseFirestore.instance",
      "        .collection('invoices')",
      "        .doc(invoiceId)",
      "        .get();",
      "    if (!doc.exists) return null;",
      "    final data = doc.data()!;",
      "    return {",
      "      'dunning_state': data['dunning_state'],",
      "      'overdue_reminders': data['overdue_reminders'],",
      "      'payment_plan': data['payment_plan'],",
      "      'escalation_history': data['escalation_history'],",
      "    };",
      "  }",
      "",
      "  /// Remove payment plan from invoice (if canceled or paid in full)",
      "  Future<void> removeInvoicePaymentPlan(String invoiceId) async {",
      "    await firestore.FirebaseFirestore.instance",
      "        .collection('invoices')",
      "        .doc(invoiceId)",
      "        .update({",
      "      'payment_plan': firestore.FieldValue.delete(),",
      "      'updated_at': firestore.FieldValue.serverTimestamp(),",
      "    });",
      "  }",
      "",
      "  Future<void> addInvoiceSupportNote(",
      "      String invoiceId, Map<String, dynamic> note) async {",
      "    await firestore.FirebaseFirestore.instance",
      "        .collection('invoices')",
      "        .doc(invoiceId)",
      "        .update({",
      "      'support_notes': firestore.FieldValue.arrayUnion([note]),",
      "      'updated_at': firestore.FieldValue.serverTimestamp(),",
      "    });",
      "  }",
      "",
      "  Future<void> addInvoiceAttachment(",
      "      String invoiceId, Map<String, dynamic> attachment) async {",
      "    await firestore.FirebaseFirestore.instance",
      "        .collection('invoices')",
      "        .doc(invoiceId)",
      "        .update({",
      "      'attached_files': firestore.FieldValue.arrayUnion([attachment]),",
      "      'updated_at': firestore.FieldValue.serverTimestamp(),",
      "    });",
      "  }",
      "",
      "  Future<void> addInvoiceAuditEvent(",
      "      String invoiceId, Map<String, dynamic> event) async {",
      "    await firestore.FirebaseFirestore.instance",
      "        .collection('invoices')",
      "        .doc(invoiceId)",
      "        .update({",
      "      'audit_trail': firestore.FieldValue.arrayUnion([event]),",
      "      'updated_at': firestore.FieldValue.serverTimestamp(),",
      "    });",
      "  }",
      "",
      "  // Call this before creating a new invoice, if you need sequential numbers.",
      "  Future<int> getNextInvoiceNumber() async {",
      "    final docRef = _db.collection('counters').doc('invoice_number');",
      "    return firestore.FirebaseFirestore.instance.runTransaction((txn) async {",
      "      final snapshot = await txn.get(docRef);",
      "      int current = (snapshot.data()?['value'] ?? 0) as int;",
      "      int next = current + 1;",
      "      txn.update(docRef, {'value': next});",
      "      return next;",
      "    });",
      "  }",
      "",
      "  Stream<List<Invoice>> invoicesStream({",
      "    String? franchiseId,",
      "    String? brandId,",
      "    String? locationId,",
      "    String? status,",
      "    DateTime? startDate,",
      "    DateTime? endDate,",
      "  }) {",
      "    print(",
      "        '[FirestoreService] invoicesStream called with params: franchiseId=$franchiseId, brandId=$brandId, locationId=$locationId, status=$status, startDate=$startDate, endDate=$endDate');",
      "",
      "    firestore.Query query = _db.collection('invoices');",
      "",
      "    if (franchiseId != null) {",
      "      final franchiseRef = _db.collection('franchises').doc(franchiseId);",
      "      print('[FirestoreService] Filtering by franchiseRef: $franchiseRef');",
      "      query = query.where('franchiseId', isEqualTo: franchiseRef);",
      "    }",
      "    if (brandId != null) {",
      "      print('[FirestoreService] Filtering by brandId: $brandId');",
      "      query = query.where('brandId', isEqualTo: brandId);",
      "    }",
      "    if (locationId != null) {",
      "      final locationRef = _db.collection('franchise_locations').doc(locationId);",
      "      print('[FirestoreService] Filtering by locationRef: $locationRef');",
      "      query = query.where('locationId', isEqualTo: locationRef);",
      "    }",
      "    if (status != null) {",
      "      print('[FirestoreService] Filtering by status: $status');",
      "      query = query.where('status', isEqualTo: status);",
      "    }",
      "    if (startDate != null) {",
      "      print('[FirestoreService] Filtering by period_start >= $startDate');",
      "      query = query.where('period_start',",
      "          isGreaterThanOrEqualTo: firestore.Timestamp.fromDate(startDate));",
      "    }",
      "    if (endDate != null) {",
      "      print('[FirestoreService] Filtering by period_end <= $endDate');",
      "      query = query.where('period_end',",
      "          isLessThanOrEqualTo: firestore.Timestamp.fromDate(endDate));",
      "    }",
      "",
      "    return query.snapshots().map((snap) {",
      "      print(",
      "          '[FirestoreService] invoicesStream snapshot received: ${snap.docs.length} documents');",
      "      final invoices = snap.docs.map((doc) {",
      "        print('[FirestoreService] Doc ${doc.id} data: ${doc.data()}');",
      "        return Invoice.fromFirestore(",
      "            doc.data() as Map<String, dynamic>, doc.id);",
      "      }).toList();",
      "      print(",
      "          '[FirestoreService] invoicesStream mapped ${invoices.length} invoices');",
      "      return invoices;",
      "    });",
      "  }",
      "",
      "  // --- REPORTS ---",
      "",
      "  Future<void> addOrUpdateReport(Report report) async {",
      "    await _db",
      "        .collection('reports')",
      "        .doc(report.id)",
      "        .set(report.toFirestore(), firestore.SetOptions(merge: true));",
      "  }",
      "",
      "  Future<Report?> getReportById(String id) async {",
      "    final doc = await _db.collection('reports').doc(id).get();",
      "    if (!doc.exists || doc.data() == null) return null;",
      "    return Report.fromFirestore(doc.data()!, doc.id);",
      "  }",
      "",
      "  Future<void> deleteReport(String id) async {",
      "    await _db.collection('reports').doc(id).delete();",
      "  }",
      "",
      "  Stream<List<Report>> reportsStream({String? franchiseId, String? type}) {",
      "    firestore.Query query = _db.collection('reports');",
      "    if (franchiseId != null) {",
      "      query = query.where('franchiseId', isEqualTo: franchiseId);",
      "    }",
      "    if (type != null) {",
      "      query = query.where('type', isEqualTo: type);",
      "    }",
      "    return query.snapshots().map((snap) => snap.docs",
      "        .map((doc) =>",
      "            Report.fromFirestore(doc.data() as Map<String, dynamic>, doc.id))",
      "        .toList());",
      "  }",
      "",
      "  // --- BANNERS ---",
      "  Future<void> addBanner(Banner banner) async =>",
      "      _db.collection(_banners).doc(banner.id).set(banner.toFirestore());",
      "",
      "  Future<void> updateBanner(Banner banner) async =>",
      "      _db.collection(_banners).doc(banner.id).update(banner.toFirestore());",
      "",
      "  Stream<List<Banner>> getBanners() => _db.collection(_banners).snapshots().map(",
      "        (snap) =>",
      "            snap.docs.map((d) => Banner.fromFirestore(d.data(), d.id)).toList(),",
      "      );",
      "",
      "  // --- CHAT SUPPORT / CHAT MANAGEMENT ---",
      "  Stream<List<Chat>> getSupportChats(String franchiseId) {",
      "    return _db",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection(_supportChats)",
      "        .orderBy('lastMessageAt', descending: true)",
      "        .snapshots()",
      "        .map((snap) =>",
      "            snap.docs.map((d) => Chat.fromFirestore(d.data(), d.id)).toList());",
      "  }",
      "",
      "  Future<void> deleteSupportChat(String franchiseId, String chatId) async {",
      "    await _db",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection(_supportChats)",
      "        .doc(chatId)",
      "        .delete();",
      "    await addAuditLogFranchise(",
      "      franchiseId,",
      "      AuditLog(",
      "        id: '', // Leave blank if your Firestore assigns an ID, or generate one if needed",
      "        action: 'delete_support_chat',",
      "        userId: currentUserId ?? 'unknown',",
      "        targetType: 'support_chat',",
      "        targetId: chatId,",
      "        details: 'Support chat deleted: $chatId', // Must be a String, not a Map",
      "        timestamp: DateTime.now(),",
      "        // userEmail and ipAddress optional",
      "      ),",
      "    );",
      "  }",
      "",
      "  Future<List<Chat>> getAllChats(String franchiseId) async {",
      "    final snap = await _db",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection(_supportChats)",
      "        .get();",
      "    return snap.docs.map((d) => Chat.fromFirestore(d.data(), d.id)).toList();",
      "  }",
      "",
      "  Stream<List<Chat>> streamAllChats(String franchiseId) {",
      "    return _db",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection(_supportChats)",
      "        .snapshots()",
      "        .map((snap) =>",
      "            snap.docs.map((d) => Chat.fromFirestore(d.data(), d.id)).toList());",
      "  }",
      "",
      "  Future<void> deleteChat(String franchiseId, String chatId) async {",
      "    await _db",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection(_supportChats)",
      "        .doc(chatId)",
      "        .delete();",
      "    await addAuditLogFranchise(",
      "      franchiseId,",
      "      AuditLog(",
      "        id: '', // Firestore will auto-assign; leave blank or generate if needed",
      "        action: 'delete_chat',",
      "        userId: currentUserId ?? 'unknown',",
      "        targetType: 'chat',",
      "        targetId: chatId,",
      "        details: null, // Or add a string if you want details",
      "        timestamp: DateTime.now(),",
      "        userEmail: null, // Or supply if available",
      "        ipAddress: null, // Or supply if available",
      "      ),",
      "    );",
      "  }",
      "",
      "  Future<void> sendMessage(",
      "    String franchiseId, {",
      "    required String chatId,",
      "    required String senderId,",
      "    required String content,",
      "    String role = 'user',",
      "  }) async {",
      "    final messageRef = _db",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection(_supportChats)",
      "        .doc(chatId)",
      "        .collection('messages')",
      "        .doc();",
      "    await messageRef.set({",
      "      'senderId': senderId,",
      "      'content': content,",
      "      'timestamp': firestore.FieldValue.serverTimestamp(),",
      "      'status': 'sent',",
      "      'role': role,",
      "    });",
      "    await _db",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection(_supportChats)",
      "        .doc(chatId)",
      "        .set({",
      "      'lastMessage': content,",
      "      'lastMessageAt': firestore.FieldValue.serverTimestamp(),",
      "      'lastSenderId': senderId,",
      "      'status': 'open',",
      "      'userId': senderId,",
      "    }, firestore.SetOptions(merge: true));",
      "  }",
      "",
      "  Future<void> sendSupportReply({",
      "    required String franchiseId,",
      "    required String chatId,",
      "    required String senderId,",
      "    required String content,",
      "  }) async {",
      "    await sendMessage(",
      "      franchiseId,",
      "      chatId: chatId,",
      "      senderId: senderId,",
      "      content: content,",
      "      role: 'support',",
      "    );",
      "  }",
      "",
      "  Stream<List<Message>> streamChatMessages(String franchiseId, String chatId) {",
      "    return _db",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection(_supportChats)",
      "        .doc(chatId)",
      "        .collection('messages')",
      "        .orderBy('timestamp', descending: false)",
      "        .snapshots()",
      "        .map((snap) => snap.docs",
      "            .map((doc) => Message.fromFirestore(doc.data(), doc.id))",
      "            .toList());",
      "  }",
      "",
      "  Stream<bool> streamSupportOnline() {",
      "    return _db",
      "        .collection('app_meta')",
      "        .doc('support_status')",
      "        .snapshots()",
      "        .map((doc) => doc.data()?['online'] == true);",
      "  }",
      "",
      "  // --- BANK ACCOUNTS ---",
      "",
      "  Future<void> addOrUpdateBankAccount(BankAccount account) async {",
      "    await _db",
      "        .collection('bank_accounts')",
      "        .doc(account.id)",
      "        .set(account.toFirestore(), firestore.SetOptions(merge: true));",
      "  }",
      "",
      "  Future<BankAccount?> getBankAccountById(String id) async {",
      "    final doc = await _db.collection('bank_accounts').doc(id).get();",
      "    if (!doc.exists || doc.data() == null) return null;",
      "    return BankAccount.fromFirestore(doc.data()!, doc.id);",
      "  }",
      "",
      "  Future<void> deleteBankAccount(String id) async {",
      "    await _db.collection('bank_accounts').doc(id).delete();",
      "  }",
      "",
      "  Stream<List<BankAccount>> bankAccountsStream({String? franchiseId}) {",
      "    firestore.Query query = _db.collection('bank_accounts');",
      "    if (franchiseId != null) {",
      "      query = query.where('franchiseId', isEqualTo: franchiseId);",
      "    }",
      "    return query.snapshots().map((snap) => snap.docs",
      "        .map((doc) => BankAccount.fromFirestore(",
      "            doc.data() as Map<String, dynamic>, doc.id))",
      "        .toList());",
      "  }",
      "",
      "  // --- ANALYTICS SUMMARY / EXPORT ---",
      "",
      "  Future<AnalyticsSummary?> getAnalyticsSummary(String franchiseId,",
      "      {required String period}) async {",
      "    final doc = await _db",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection('analytics_summaries')",
      "        .doc(period)",
      "        .get();",
      "    if (!doc.exists || doc.data() == null) return null;",
      "    return AnalyticsSummary.fromFirestore(doc.data()!, doc.id);",
      "  }",
      "",
      "  Future<String> exportAnalyticsToCsv(String franchiseId,",
      "      {required String period}) async {",
      "    final summary = await getAnalyticsSummary(franchiseId, period: period);",
      "    if (summary == null) return '';",
      "    return ExportUtils.analyticsSummaryToCsvNoContext(summary);",
      "  }",
      "",
      "  /// Returns total revenue for today",
      "  Future<double> getTotalRevenueToday(String franchiseId) async {",
      "    final now = DateTime.now();",
      "    final localMidnight = DateTime(now.year, now.month, now.day);",
      "    final utcStart = localMidnight.toUtc();",
      "    final utcEnd = utcStart.add(const Duration(days: 1));",
      "    final snapshot = await _db",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection('orders')",
      "        .where('timestamp',",
      "            isGreaterThanOrEqualTo: firestore.Timestamp.fromDate(utcStart))",
      "        .where('timestamp', isLessThan: firestore.Timestamp.fromDate(utcEnd))",
      "        .get();",
      "    double total = 0.0;",
      "    for (var doc in snapshot.docs) {",
      "      final data = doc.data();",
      "      final double amount = (data['total'] is int)",
      "          ? (data['total'] as int).toDouble()",
      "          : (data['total'] ?? 0.0) as double;",
      "      total += amount;",
      "    }",
      "    return total;",
      "  }",
      "",
      "  /// Returns total revenue for a given period: 'week' or 'month'",
      "  Future<double> getTotalRevenueForPeriod(",
      "      String franchiseId, String period) async {",
      "    final now = DateTime.now();",
      "    late DateTime start, end;",
      "    if (period == 'week') {",
      "      // Start of week (Monday)",
      "      start = now.subtract(Duration(days: now.weekday - 1));",
      "      start = DateTime(start.year, start.month, start.day);",
      "      end = start.add(const Duration(days: 7));",
      "    } else if (period == 'month') {",
      "      // Start of month",
      "      start = DateTime(now.year, now.month, 1);",
      "      end = (now.month < 12)",
      "          ? DateTime(now.year, now.month + 1, 1)",
      "          : DateTime(now.year + 1, 1, 1);",
      "    } else {",
      "      throw ArgumentError('Invalid period: $period');",
      "    }",
      "    // Convert local period boundaries to UTC for the Firestore query",
      "    final utcStart = start.toUtc();",
      "    final utcEnd = end.toUtc();",
      "",
      "    final snapshot = await _db",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection('orders')",
      "        .where('timestamp',",
      "            isGreaterThanOrEqualTo: firestore.Timestamp.fromDate(utcStart))",
      "        .where('timestamp', isLessThan: firestore.Timestamp.fromDate(utcEnd))",
      "        .get();",
      "",
      "    double total = 0.0;",
      "    for (var doc in snapshot.docs) {",
      "      final data = doc.data();",
      "      final double amount = (data['total'] is int)",
      "          ? (data['total'] as int).toDouble()",
      "          : (data['total'] ?? 0.0) as double;",
      "      total += amount;",
      "    }",
      "    return total;",
      "  }",
      "",
      "  /// Get the total number of orders for today for a franchise",
      "  Future<int> getTotalOrdersTodayCount({required String franchiseId}) async {",
      "    final now = DateTime.now();",
      "    final startOfDay = DateTime(now.year, now.month, now.day);",
      "    final endOfDay = startOfDay.add(const Duration(days: 1));",
      "",
      "    final snapshot = await _db",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection('orders')",
      "        .where('timestamp', isGreaterThanOrEqualTo: startOfDay)",
      "        .where('timestamp', isLessThan: endOfDay)",
      "        .get();",
      "",
      "    return snapshot.docs.length;",
      "  }",
      "",
      "  // --- UTILITIES ---",
      "",
      "  void _logFirestoreError(String context, Object e, [StackTrace? stack]) {",
      "    // Optional: Implement platform logging here",
      "    print('[FirestoreService][$context] Error: $e');",
      "    if (stack != null) print(stack);",
      "  }",
      "",
      "  // --- MENU ITEMS ---",
      "  Future<void> addMenuItem(String franchiseId, MenuItem item,",
      "      {String? userId}) async {",
      "    assert(item.categoryId.isNotEmpty, 'categoryId must not be empty');",
      "    final doc = _db",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection(_menuItems)",
      "        .doc();",
      "    final data = item.copyWith(id: doc.id).toFirestore();",
      "    data['customizations'] =",
      "        item.customizations.map((c) => c.toFirestore()).toList();",
      "    data['includedIngredients'] = item.includedIngredients ?? [];",
      "    data['optionalAddOns'] = item.optionalAddOns ?? [];",
      "    await doc.set(data);",
      "    await AuditLogService().addLog(",
      "      franchiseId: franchiseId,",
      "      action: 'add_menu_item',",
      "      userId: userId ?? currentUserId ?? 'unknown',",
      "      details: {'menuItemId': doc.id, 'name': item.name},",
      "    );",
      "  }",
      "",
      "  Future<void> updateMenuItem(String franchiseId, MenuItem item,",
      "      {String? userId}) async {",
      "    try {",
      "      final data = item.toFirestore();",
      "      if (item.customizations.isNotEmpty) {",
      "        data['customizations'] =",
      "            item.customizations.map((c) => c.toFirestore()).toList();",
      "      }",
      "      await _db",
      "          .collection('franchises')",
      "          .doc(franchiseId)",
      "          .collection(_menuItems)",
      "          .doc(item.id)",
      "          .update(data);",
      "      await AuditLogService().addLog(",
      "        franchiseId: franchiseId,",
      "        action: 'update_menu_item',",
      "        userId: userId ?? currentUserId ?? 'unknown',",
      "        details: {'menuItemId': item.id, 'name': item.name},",
      "      );",
      "    } catch (e, stack) {",
      "      _logFirestoreError('updateMenuItem', e, stack);",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  Future<void> deleteMenuItem(String franchiseId, String id,",
      "      {String? userId}) async {",
      "    try {",
      "      await _db",
      "          .collection('franchises')",
      "          .doc(franchiseId)",
      "          .collection(_menuItems)",
      "          .doc(id)",
      "          .delete();",
      "",
      "      await AuditLogService().addLog(",
      "        franchiseId: franchiseId,",
      "        action: 'delete_menu_item',",
      "        userId: userId ?? currentUserId ?? 'unknown',",
      "        details: {'menuItemId': id},",
      "      );",
      "    } catch (e, stack) {",
      "      // 🔥 ErrorLogger integration",
      "      await ErrorLogger.log(",
      "        message: 'Failed to delete menu item',",
      "        source: 'FirestoreService',",
      "        screen: 'firestore_service.dart',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "          'menuItemId': id,",
      "          'userId': userId ?? currentUserId ?? 'unknown',",
      "        },",
      "      );",
      "",
      "      // Also logs to local console for dev environment debugging",
      "      _logFirestoreError('deleteMenuItem', e, stack);",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Real-time listener for menu items (used in live UI).",
      "  Stream<List<MenuItem>> getMenuItems(String franchiseId,",
      "      {String? search, String? sortBy, bool descending = false}) {",
      "    firestore.Query query =",
      "        _db.collection('franchises').doc(franchiseId).collection(_menuItems);",
      "    if (search != null && search.trim().isNotEmpty) {",
      "      query = query",
      "          .where('name', isGreaterThanOrEqualTo: search)",
      "          .where('name', isLessThan: '${search}z');",
      "    }",
      "    if (sortBy != null && sortBy.isNotEmpty) {",
      "      query = query.orderBy(sortBy, descending: descending);",
      "    }",
      "    return query.snapshots().map((snap) => snap.docs",
      "        .map((d) =>",
      "            MenuItem.fromFirestore(d.data() as Map<String, dynamic>, d.id))",
      "        .toList());",
      "  }",
      "",
      "  Future<List<MenuItem>> getMenuItemsOnce(",
      "    String franchiseId,",
      "  ) async {",
      "    final snap = await _db",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection(_menuItems)",
      "        .get();",
      "    return snap.docs.map((d) {",
      "      final data = d.data();",
      "      if (data['customizations'] == null || data['customizations'] is! List) {",
      "        data['customizations'] = [];",
      "      }",
      "      return MenuItem.fromFirestore(data, d.id);",
      "    }).toList();",
      "  }",
      "",
      "  // get categories",
      "  Stream<List<model.Category>> getCategories(String franchiseId,",
      "      {String? search, String? sortBy, bool descending = false}) {",
      "    firestore.Query query =",
      "        _db.collection('franchises').doc(franchiseId).collection(_categories);",
      "",
      "    if (search != null && search.trim().isNotEmpty) {",
      "      query = query",
      "          .where('name', isGreaterThanOrEqualTo: search)",
      "          .where('name', isLessThan: '${search}z');",
      "    }",
      "",
      "    if (sortBy != null && sortBy.isNotEmpty) {",
      "      query = query.orderBy(sortBy, descending: descending);",
      "    }",
      "",
      "    return query.snapshots().map((snap) => snap.docs",
      "        .map((d) => model.Category.fromFirestore(",
      "            d.data() as Map<String, dynamic>, d.id))",
      "        .toList());",
      "  }",
      "",
      "  Future<void> addCategory({",
      "    required String franchiseId,",
      "    required model.Category category,",
      "    String? userId,",
      "  }) async {",
      "    final doc = _db",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection(_categories)",
      "        .doc();",
      "    final categoryWithId = model.Category(",
      "      id: doc.id,",
      "      name: category.name,",
      "      description: category.description,",
      "      image: category.image,",
      "    );",
      "    await doc.set(categoryWithId.toFirestore());",
      "  }",
      "",
      "  Future<void> updateCategory(String franchiseId, model.Category category,",
      "      {String? userId}) async {",
      "    await _db",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection(_categories)",
      "        .doc(category.id)",
      "        .update(category.toFirestore());",
      "    // Optionally log this action for auditing:",
      "    // await AuditLogService().addLog(...);",
      "  }",
      "",
      "  Future<void> deleteCategory({",
      "    required String franchiseId,",
      "    required String categoryId,",
      "    String? userId,",
      "  }) async {",
      "    try {",
      "      await _db",
      "          .collection('franchises')",
      "          .doc(franchiseId)",
      "          .collection('categories')",
      "          .doc(categoryId)",
      "          .delete();",
      "",
      "      // Optional: Add future audit logging here if needed",
      "      // await AuditLogService().addLog(...);",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to delete category',",
      "        source: 'FirestoreService',",
      "        screen: 'firestore_service.dart',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "          'categoryId': categoryId,",
      "          if (userId != null) 'userId': userId,",
      "        },",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  // get categories schema",
      "  /// Get a category schema by franchise and categoryId",
      "  Future<Map<String, dynamic>?> getCategorySchema(",
      "      String franchiseId, String categoryId) async {",
      "    try {",
      "      final doc = await _db",
      "          .collection('franchises')",
      "          .doc(franchiseId)",
      "          .collection('category_schemas')",
      "          .doc(categoryId)",
      "          .get();",
      "      return doc.exists ? doc.data() : null;",
      "    } catch (e, stack) {",
      "      _logFirestoreError('getCategorySchema', e, stack);",
      "      return null;",
      "    }",
      "  }",
      "",
      "  /// Get all category schema IDs for a franchise",
      "  Future<List<String>> getAllCategorySchemaIds(String franchiseId) async {",
      "    final snap = await _db",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection('category_schemas')",
      "        .get();",
      "    return snap.docs.map((d) => d.id).toList();",
      "  }",
      "",
      "  /// Get all customization templates from Firestore.",
      "  Future<Map<String, dynamic>> getCustomizationTemplates(",
      "    String franchiseId,",
      "  ) async {",
      "    try {",
      "      final snap = await _db",
      "          .collection('franchises')",
      "          .doc(franchiseId)",
      "          .collection('customization_templates')",
      "          .get();",
      "      final result = <String, dynamic>{};",
      "      for (final doc in snap.docs) {",
      "        result[doc.id] = doc.data();",
      "      }",
      "      return result;",
      "    } catch (e, stack) {",
      "      _logFirestoreError('getCustomizationTemplates', e, stack);",
      "      return {};",
      "    }",
      "  }",
      "",
      "  Future<List<Map<String, dynamic>>> fetchCustomizationTemplatesAsMaps(",
      "    String franchiseId,",
      "  ) async {",
      "    final snapshot = await firestore.FirebaseFirestore.instance",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection('customization_templates')",
      "        .get();",
      "",
      "    return snapshot.docs.map((doc) {",
      "      final data = doc.data();",
      "      return {",
      "        ...data,",
      "        'templateId': doc.id,",
      "      };",
      "    }).toList();",
      "  }",
      "",
      "  /// Get a single customization template by its ID.",
      "  Future<Map<String, dynamic>?> getCustomizationTemplate(",
      "      String franchiseId, String templateId) async {",
      "    try {",
      "      final doc = await _db",
      "          .collection('franchises')",
      "          .doc(franchiseId)",
      "          .collection('customization_templates')",
      "          .doc(templateId)",
      "          .get();",
      "      return doc.exists ? doc.data() : null;",
      "    } catch (e, stack) {",
      "      _logFirestoreError('getCustomizationTemplate', e, stack);",
      "      return null;",
      "    }",
      "  }",
      "",
      "  Future<List<Map<String, dynamic>>> resolveCustomizations(",
      "      String franchiseId, List<dynamic> rawCustomizations) async {",
      "    final List<Map<String, dynamic>> resolved = [];",
      "",
      "    for (final entry in rawCustomizations) {",
      "      if (entry is Map<String, dynamic> && entry.containsKey('templateRef')) {",
      "        final templateId = entry['templateRef'];",
      "        try {",
      "          final template =",
      "              await getCustomizationTemplate(franchiseId, templateId);",
      "          if (template != null) {",
      "            resolved.add(template);",
      "          }",
      "        } catch (e) {",
      "          await logSchemaError(",
      "            franchiseId,",
      "            message: 'Failed to load template',",
      "            templateId: templateId,",
      "            stackTrace: e.toString(),",
      "          );",
      "        }",
      "      } else if (entry is Map<String, dynamic>) {",
      "        resolved.add(entry);",
      "      }",
      "    }",
      "",
      "    return resolved;",
      "  }",
      "",
      "  Future<void> updateMenuItemCustomizations(String franchiseId,",
      "      String menuItemId, List<Customization> customizations) async {",
      "    await _db",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection(_menuItems)",
      "        .doc(menuItemId)",
      "        .update({",
      "      'customizations': customizations.map((c) => c.toFirestore()).toList(),",
      "      'lastModified': firestore.FieldValue.serverTimestamp(),",
      "      'lastModifiedBy': currentUserId ?? 'system',",
      "    });",
      "  }",
      "",
      "  Future<void> updateMenuItemCustomizationsWithAudit(",
      "      String franchiseId, String menuItemId, List<Customization> customizations,",
      "      {String? userId}) async {",
      "    await updateMenuItemCustomizations(franchiseId, menuItemId, customizations);",
      "    await AuditLogService().addLog(",
      "      franchiseId: franchiseId,",
      "      action: 'update_menu_item_customizations',",
      "      userId: userId ?? currentUserId ?? 'unknown',",
      "      details: {",
      "        'menuItemId': menuItemId,",
      "        'customizationsCount': customizations.length",
      "      },",
      "    );",
      "  }",
      "",
      "  Future<List<Customization>> getMenuItemCustomizations(",
      "      String franchiseId, String menuItemId) async {",
      "    final doc = await _db",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection(_menuItems)",
      "        .doc(menuItemId)",
      "        .get();",
      "    if (!doc.exists || doc.data() == null) return [];",
      "    final data = doc.data()!;",
      "    if (data['customizations'] == null) return [];",
      "    return (data['customizations'] as List<dynamic>)",
      "        .map((e) => Customization.fromFirestore(Map<String, dynamic>.from(e)))",
      "        .toList();",
      "  }",
      "",
      "  Future<List<MenuItem>> fetchMenuItems(String franchiseId) async {",
      "    try {",
      "      final snapshot = await _db",
      "          .collection('franchises')",
      "          .doc(franchiseId)",
      "          .collection(_menuItems)",
      "          .orderBy('sortOrder')",
      "          .get();",
      "",
      "      return snapshot.docs",
      "          .map((d) => MenuItem.fromFirestore(",
      "                d.data() as Map<String, dynamic>,",
      "                d.id,",
      "              ))",
      "          .toList();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to fetch menu items',",
      "        source: 'FirestoreService',",
      "        screen: 'menu_item_provider.dart',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  Stream<List<MenuItem>> getMenuItemsByIds(",
      "      String franchiseId, List<String> ids) {",
      "    if (ids.isEmpty) return Stream.value([]);",
      "    if (ids.length <= 10) {",
      "      return _db",
      "          .collection('franchises')",
      "          .doc(franchiseId)",
      "          .collection(_menuItems)",
      "          .where(firestore.FieldPath.documentId, whereIn: ids)",
      "          .snapshots()",
      "          .map((snap) => snap.docs",
      "              .map((d) => MenuItem.fromFirestore(d.data(), d.id))",
      "              .toList());",
      "    } else {",
      "      final batches = <Stream<List<MenuItem>>>[];",
      "      for (var i = 0; i < ids.length; i += 10) {",
      "        final batchIds =",
      "            ids.sublist(i, i + 10 > ids.length ? ids.length : i + 10);",
      "        batches.add(_db",
      "            .collection('franchises')",
      "            .doc(franchiseId)",
      "            .collection(_menuItems)",
      "            .where(firestore.FieldPath.documentId, whereIn: batchIds)",
      "            .snapshots()",
      "            .map((snap) => snap.docs",
      "                .map((d) => MenuItem.fromFirestore(d.data(), d.id))",
      "                .toList()));",
      "      }",
      "      return StreamZip(batches)",
      "          .map((listOfLists) => listOfLists.expand((x) => x).toList());",
      "    }",
      "  }",
      "",
      "  List<Customization> getCustomizationGroups(MenuItem item) {",
      "    return item.customizations.where((c) => c.isGroup).toList();",
      "  }",
      "",
      "  List<Customization> getPreselectedCustomizations(MenuItem item) {",
      "    List<Customization> flatten(List<Customization> list) {",
      "      return list",
      "          .expand(",
      "              (c) => c.isGroup && c.options != null ? flatten(c.options!) : [c])",
      "          .toList();",
      "    }",
      "",
      "    return flatten(item.customizations).where((c) => c.isDefault).toList();",
      "  }",
      "",
      "  Customization? findCustomizationOption(",
      "      List<Customization> groups, String idOrName) {",
      "    for (final group in groups) {",
      "      if (group.id == idOrName || group.name == idOrName) return group;",
      "      if (group.options != null) {",
      "        final found = findCustomizationOption(group.options!, idOrName);",
      "        if (found != null) return found;",
      "      }",
      "    }",
      "    return null;",
      "  }",
      "",
      "  // Inventory",
      "  /// Add an inventory record for a franchise",
      "  Future<void> addInventory(String franchiseId, Inventory inventory) async {",
      "    final doc = _db",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection(_inventory)",
      "        .doc();",
      "    await doc.set(inventory.copyWith(id: doc.id).toFirestore());",
      "  }",
      "",
      "  /// Update an inventory record",
      "  Future<void> updateInventory(String franchiseId, Inventory inventory) async {",
      "    await _db",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection(_inventory)",
      "        .doc(inventory.id)",
      "        .update(inventory.toFirestore());",
      "  }",
      "",
      "  /// Delete an inventory record",
      "  Future<void> deleteInventory(String franchiseId, String id) async {",
      "    await _db",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection(_inventory)",
      "        .doc(id)",
      "        .delete();",
      "  }",
      "",
      "  /// Get a stream of inventory transactions for a franchise",
      "  Stream<List<Inventory>> getInventory(String franchiseId) {",
      "    return _db",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection(_inventory)",
      "        .snapshots()",
      "        .map((snap) => snap.docs",
      "            .map((d) => Inventory.fromFirestore(d.data(), d.id))",
      "            .toList());",
      "  }",
      "",
      "  /// get cashflow for a franchise",
      "  /// Returns the most recent cash flow forecast for a franchise (or null if none)",
      "  Future<Map<String, dynamic>?> getCashFlowForecast(String franchiseId) async {",
      "    final snap = await _db",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection(",
      "            'cash_flow_forecasts') // Or adjust collection name as needed",
      "        .orderBy('period', descending: true)",
      "        .limit(1)",
      "        .get();",
      "",
      "    if (snap.docs.isEmpty) return null;",
      "    return snap.docs.first.data();",
      "  }",
      "",
      "  /// get franchise analytics summary",
      "  Future<Map<String, dynamic>> getFranchiseAnalyticsSummary(",
      "      String franchiseId) async {",
      "    final snap = await _db",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection('analytics_summaries')",
      "        .orderBy('period', descending: true)",
      "        .limit(1)",
      "        .get();",
      "",
      "    if (snap.docs.isEmpty) return {};",
      "    return snap.docs.first.data();",
      "  }",
      "",
      "  /// get outstanding invoices",
      "  Future<double> getOutstandingInvoices(String franchiseId) async {",
      "    final snap = await _db",
      "        .collection('invoices')",
      "        .where('franchiseId', isEqualTo: franchiseId)",
      "        .where('status', isEqualTo: 'sent')",
      "        .get();",
      "",
      "    double total = 0.0;",
      "    for (final doc in snap.docs) {",
      "      final data = doc.data();",
      "      if (data['paid_at'] == null) {",
      "        total += (data['total'] as num?)?.toDouble() ?? 0.0;",
      "      }",
      "    }",
      "    return total;",
      "  }",
      "",
      "  /// get last payout",
      "  Future<Map<String, dynamic>> getLastPayout(String franchiseId) async {",
      "    final snap = await _db",
      "        .collection('payouts')",
      "        .where('franchiseId', isEqualTo: franchiseId)",
      "        .orderBy('scheduled_at', descending: true)",
      "        .limit(1)",
      "        .get();",
      "",
      "    if (snap.docs.isEmpty) return {};",
      "    final data = snap.docs.first.data();",
      "    return {",
      "      'amount': data['amount'],",
      "      'date': data['scheduled_at']?.toDate()?.toIso8601String(),",
      "    };",
      "  }",
      "",
      "  // Get payout stats for franchise",
      "  Future<Map<String, int>> getPayoutStatsForFranchise(",
      "      String franchiseId) async {",
      "    try {",
      "      final query = firestore.FirebaseFirestore.instance",
      "          .collection('payouts')",
      "          .where('franchiseId', isEqualTo: franchiseId);",
      "",
      "      final snapshot = await query.get();",
      "",
      "      int pending = 0;",
      "      int sent = 0;",
      "      int failed = 0;",
      "",
      "      for (var doc in snapshot.docs) {",
      "        final data = doc.data();",
      "        final status = data['status'] as String? ?? '';",
      "",
      "        if (status == 'pending') {",
      "          pending++;",
      "        } else if (status == 'sent') {",
      "          sent++;",
      "        } else if (status == 'failed') {",
      "          failed++;",
      "        }",
      "        // You may add more status handling as needed.",
      "      }",
      "",
      "      return {",
      "        'pending': pending,",
      "        'sent': sent,",
      "        'failed': failed,",
      "      };",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'getPayoutStatsForFranchise failed: $e',",
      "        stack: stack.toString(),",
      "        source: 'FirestoreService',",
      "        screen: 'getPayoutStatsForFranchise',",
      "        severity: 'error',",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      // Return zeroed counts on failure for graceful UI degradation",
      "      return {",
      "        'pending': 0,",
      "        'sent': 0,",
      "        'failed': 0,",
      "      };",
      "    }",
      "  }",
      "",
      "  // Promo methods",
      "  Future<void> addPromo(String franchiseId, Promo promo) async => _db",
      "      .collection('franchises')",
      "      .doc(franchiseId)",
      "      .collection('promotions')",
      "      .doc(promo.id)",
      "      .set(promo.toFirestore());",
      "",
      "  Stream<List<Promo>> getPromos(String franchiseId) {",
      "    return _db",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection('promotions')",
      "        .snapshots()",
      "        .map((snap) =>",
      "            snap.docs.map((d) => Promo.fromFirestore(d.data(), d.id)).toList());",
      "  }",
      "",
      "  Future<void> updatePromo(String franchiseId, Promo promo) async => _db",
      "      .collection('franchises')",
      "      .doc(franchiseId)",
      "      .collection('promotions')",
      "      .doc(promo.id)",
      "      .update(promo.toFirestore());",
      "",
      "  Future<void> deletePromo(String franchiseId, String promoId) async => _db",
      "      .collection('franchises')",
      "      .doc(franchiseId)",
      "      .collection('promotions')",
      "      .doc(promoId)",
      "      .delete();",
      "",
      "  // Feedback methods",
      "  Stream<List<feedback_model.FeedbackEntry>> getFeedbackEntries(",
      "      String franchiseId) {",
      "    return _db",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection(_feedback)",
      "        .orderBy('timestamp', descending: true)",
      "        .snapshots()",
      "        .map((snap) => snap.docs",
      "            .map((d) =>",
      "                feedback_model.FeedbackEntry.fromFirestore(d.data(), d.id))",
      "            .toList());",
      "  }",
      "",
      "  Future<void> deleteFeedbackEntry(String franchiseId, String id) async {",
      "    await _db",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection(_feedback)",
      "        .doc(id)",
      "        .delete();",
      "    // Optional: log this with audit if you want",
      "  }",
      "",
      "  // support_requests",
      "  /// Adds a new support request",
      "  Future<firestore.DocumentReference> addSupportRequest(",
      "      Map<String, dynamic> data) async {",
      "    final now = firestore.FieldValue.serverTimestamp();",
      "    data['created_at'] ??= now;",
      "    data['updated_at'] ??= now;",
      "    return await firestore.FirebaseFirestore.instance",
      "        .collection('support_requests')",
      "        .add(data);",
      "  }",
      "",
      "  /// Updates an existing support request",
      "  Future<void> updateSupportRequest(",
      "      String requestId, Map<String, dynamic> updates) async {",
      "    updates['updated_at'] = firestore.FieldValue.serverTimestamp();",
      "    await firestore.FirebaseFirestore.instance",
      "        .collection('support_requests')",
      "        .doc(requestId)",
      "        .update(updates);",
      "  }",
      "",
      "  /// Get a support request by ID",
      "  Future<Map<String, dynamic>?> getSupportRequestById(String requestId) async {",
      "    final doc = await firestore.FirebaseFirestore.instance",
      "        .collection('support_requests')",
      "        .doc(requestId)",
      "        .get();",
      "    return doc.exists ? doc.data() as Map<String, dynamic> : null;",
      "  }",
      "",
      "  /// Stream support requests, optionally filtered by franchise/location/status/type",
      "  Stream<List<Map<String, dynamic>>> supportRequestsStream({",
      "    String? franchiseId,",
      "    String? locationId,",
      "    String? status,",
      "    String? type,",
      "    String? assignedTo,",
      "    String? openedBy,",
      "    int limit = 50,",
      "  }) {",
      "    firestore.Query query =",
      "        firestore.FirebaseFirestore.instance.collection('support_requests');",
      "    if (franchiseId != null) {",
      "      query = query.where('franchiseId', isEqualTo: franchiseId);",
      "    }",
      "    if (locationId != null) {",
      "      query = query.where('locationId', isEqualTo: locationId);",
      "    }",
      "    if (status != null) {",
      "      query = query.where('status', isEqualTo: status);",
      "    }",
      "    if (type != null) {",
      "      query = query.where('type', isEqualTo: type);",
      "    }",
      "    if (assignedTo != null) {",
      "      query = query.where('assigned_to', isEqualTo: assignedTo);",
      "    }",
      "    if (openedBy != null) {",
      "      query = query.where('opened_by', isEqualTo: openedBy);",
      "    }",
      "    query = query.orderBy('created_at', descending: true).limit(limit);",
      "",
      "    return query.snapshots().map((snap) =>",
      "        snap.docs.map((doc) => doc.data() as Map<String, dynamic>).toList());",
      "  }",
      "",
      "  /// Append a message to a support request (atomic arrayUnion)",
      "  Future<void> addMessageToSupportRequest(",
      "      String requestId, Map<String, dynamic> message) async {",
      "    await firestore.FirebaseFirestore.instance",
      "        .collection('support_requests')",
      "        .doc(requestId)",
      "        .update({",
      "      'messages': firestore.FieldValue.arrayUnion([message]),",
      "      'updated_at': firestore.FieldValue.serverTimestamp(),",
      "    });",
      "  }",
      "",
      "  /// Delete a support request",
      "  Future<void> deleteSupportRequest(String requestId) async {",
      "    await firestore.FirebaseFirestore.instance",
      "        .collection('support_requests')",
      "        .doc(requestId)",
      "        .delete();",
      "  }",
      "",
      "  /// Add a support note (internal only, atomic arrayUnion)",
      "  Future<void> addSupportNote(",
      "      String requestId, Map<String, dynamic> note) async {",
      "    await firestore.FirebaseFirestore.instance",
      "        .collection('support_requests')",
      "        .doc(requestId)",
      "        .update({",
      "      'support_notes': firestore.FieldValue.arrayUnion([note]),",
      "      'updated_at': firestore.FieldValue.serverTimestamp(),",
      "    });",
      "  }",
      "",
      "  /// Set or update ticket type taxonomy (e.g., 'billing', 'technical', etc.)",
      "  Future<void> updateSupportType(String requestId, String type) async {",
      "    await firestore.FirebaseFirestore.instance",
      "        .collection('support_requests')",
      "        .doc(requestId)",
      "        .update({",
      "      'type': type,",
      "      'updated_at': firestore.FieldValue.serverTimestamp(),",
      "    });",
      "  }",
      "",
      "  /// Link entities (e.g., invoiceId, paymentId) to a ticket",
      "  Future<void> linkEntitiesToSupportRequest(String requestId,",
      "      {String? invoiceId, String? paymentId}) async {",
      "    final update = <String, dynamic>{};",
      "    if (invoiceId != null) update['invoiceId'] = invoiceId;",
      "    if (paymentId != null) update['paymentId'] = paymentId;",
      "    update['updated_at'] = firestore.FieldValue.serverTimestamp();",
      "",
      "    await firestore.FirebaseFirestore.instance",
      "        .collection('support_requests')",
      "        .doc(requestId)",
      "        .update(update);",
      "  }",
      "",
      "  /// Update ticket status (with audit fields, e.g., close or escalate)",
      "  Future<void> updateSupportRequestStatus(",
      "    String requestId, {",
      "    required String status, // e.g. 'resolved', 'closed', etc.",
      "    String? lastUpdatedBy,",
      "    String? resolutionNotes,",
      "  }) async {",
      "    final update = <String, dynamic>{",
      "      'status': status,",
      "      'updated_at': firestore.FieldValue.serverTimestamp(),",
      "    };",
      "    if (lastUpdatedBy != null) update['last_updated_by'] = lastUpdatedBy;",
      "    if (resolutionNotes != null) update['resolution_notes'] = resolutionNotes;",
      "    if (status == 'closed' || status == 'resolved') {",
      "      update['closed_at'] = firestore.FieldValue.serverTimestamp();",
      "    }",
      "    await firestore.FirebaseFirestore.instance",
      "        .collection('support_requests')",
      "        .doc(requestId)",
      "        .update(update);",
      "  }",
      "",
      "  /// Get all support notes for a request",
      "  Future<List<Map<String, dynamic>>> getSupportNotes(String requestId) async {",
      "    final doc = await firestore.FirebaseFirestore.instance",
      "        .collection('support_requests')",
      "        .doc(requestId)",
      "        .get();",
      "    if (!doc.exists) return [];",
      "    final data = doc.data()!;",
      "    final notes = data['support_notes'] as List<dynamic>? ?? [];",
      "    return notes.cast<Map<String, dynamic>>();",
      "  }",
      "",
      "  /// Filter/stream tickets by type or status (for taxonomy/reporting)",
      "  Stream<List<Map<String, dynamic>>> supportRequestsByTypeOrStatus({",
      "    String? type,",
      "    String? status,",
      "    int limit = 50,",
      "  }) {",
      "    var query = firestore.FirebaseFirestore.instance",
      "        .collection('support_requests')",
      "        .orderBy('created_at', descending: true)",
      "        .limit(limit);",
      "",
      "    if (type != null) {",
      "      query = query.where('type', isEqualTo: type);",
      "    }",
      "    if (status != null) {",
      "      query = query.where('status', isEqualTo: status);",
      "    }",
      "",
      "    return query.snapshots().map((snap) =>",
      "        snap.docs.map((doc) => doc.data() as Map<String, dynamic>).toList());",
      "  }",
      "",
      "  // tax_reports",
      "  Future<firestore.DocumentReference> addTaxReport(",
      "      Map<String, dynamic> data) async {",
      "    final now = firestore.FieldValue.serverTimestamp();",
      "    data['created_at'] ??= now;",
      "    data['updated_at'] ??= now;",
      "    return await firestore.FirebaseFirestore.instance",
      "        .collection('tax_reports')",
      "        .add(data);",
      "  }",
      "",
      "  /// Update an existing tax report by ID",
      "  Future<void> updateTaxReport(",
      "      String reportId, Map<String, dynamic> updates) async {",
      "    updates['updated_at'] = firestore.FieldValue.serverTimestamp();",
      "    await firestore.FirebaseFirestore.instance",
      "        .collection('tax_reports')",
      "        .doc(reportId)",
      "        .update(updates);",
      "  }",
      "",
      "  /// Get a tax report by ID",
      "  Future<Map<String, dynamic>?> getTaxReportById(String reportId) async {",
      "    final doc = await firestore.FirebaseFirestore.instance",
      "        .collection('tax_reports')",
      "        .doc(reportId)",
      "        .get();",
      "    return doc.exists ? doc.data() as Map<String, dynamic> : null;",
      "  }",
      "",
      "  /// Stream tax reports, with filters",
      "  Stream<List<Map<String, dynamic>>> taxReportsStream({",
      "    String? franchiseId,",
      "    String? brandId,",
      "    String? reportType, // e.g., \"sales_tax\"",
      "    String? status, // e.g., \"filed\", \"pending\"",
      "    String? taxAuthority,",
      "    DateTime? filedAfter,",
      "    DateTime? filedBefore,",
      "    int limit = 100,",
      "  }) {",
      "    var query = firestore.FirebaseFirestore.instance",
      "        .collection('tax_reports')",
      "        .orderBy('created_at', descending: true)",
      "        .limit(limit);",
      "",
      "    if (franchiseId != null) {",
      "      query = query.where('franchiseId', isEqualTo: franchiseId);",
      "    }",
      "    if (brandId != null) {",
      "      query = query.where('brandId', isEqualTo: brandId);",
      "    }",
      "    if (reportType != null) {",
      "      query = query.where('report_type', isEqualTo: reportType);",
      "    }",
      "    if (status != null) {",
      "      query = query.where('status', isEqualTo: status);",
      "    }",
      "    if (taxAuthority != null) {",
      "      query = query.where('tax_authority', isEqualTo: taxAuthority);",
      "    }",
      "    if (filedAfter != null) {",
      "      query =",
      "          query.where('date_filed', isGreaterThanOrEqualTo: filedAfter.toUtc());",
      "    }",
      "    if (filedBefore != null) {",
      "      query =",
      "          query.where('date_filed', isLessThanOrEqualTo: filedBefore.toUtc());",
      "    }",
      "",
      "    return query.snapshots().map((snap) =>",
      "        snap.docs.map((doc) => doc.data() as Map<String, dynamic>).toList());",
      "  }",
      "",
      "  /// Delete a tax report by ID",
      "  Future<void> deleteTaxReport(String reportId) async {",
      "    await firestore.FirebaseFirestore.instance",
      "        .collection('tax_reports')",
      "        .doc(reportId)",
      "        .delete();",
      "  }",
      "",
      "  /// Add a reminder to a tax report (atomic arrayUnion)",
      "  Future<void> addTaxReportReminder(",
      "      String reportId, Map<String, dynamic> reminder) async {",
      "    await firestore.FirebaseFirestore.instance",
      "        .collection('tax_reports')",
      "        .doc(reportId)",
      "        .update({",
      "      'reminders_sent': firestore.FieldValue.arrayUnion([reminder]),",
      "      'updated_at': firestore.FieldValue.serverTimestamp(),",
      "    });",
      "  }",
      "",
      "  /// Attach a file to a tax report (atomic arrayUnion)",
      "  Future<void> addTaxReportAttachment(",
      "      String reportId, Map<String, dynamic> attachment) async {",
      "    await firestore.FirebaseFirestore.instance",
      "        .collection('tax_reports')",
      "        .doc(reportId)",
      "        .update({",
      "      'attached_files': firestore.FieldValue.arrayUnion([attachment]),",
      "      'updated_at': firestore.FieldValue.serverTimestamp(),",
      "    });",
      "  }",
      "",
      "  /// Invitation collection",
      "",
      "  /// Fetch all invitations (optionally filter by status, inviter, email, etc.)",
      "  Future<List<FranchiseeInvitation>> fetchInvitations({",
      "    String? status,",
      "    String? inviterUserId,",
      "    String? email,",
      "  }) async {",
      "    try {",
      "      firestore.Query query = invitationCollection;",
      "      if (status != null) {",
      "        query = query.where('status', isEqualTo: status);",
      "      }",
      "      if (inviterUserId != null) {",
      "        query = query.where('inviterUserId', isEqualTo: inviterUserId);",
      "      }",
      "      if (email != null) {",
      "        query = query.where('email', isEqualTo: email);",
      "      }",
      "      final snap = await query.orderBy('createdAt', descending: true).get();",
      "      return snap.docs.map((doc) => FranchiseeInvitation.fromDoc(doc)).toList();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to fetch invitations',",
      "        stack: stack.toString(),",
      "        source: 'FirestoreService.fetchInvitations',",
      "        screen: 'FranchiseeInvitation',",
      "        contextData: {",
      "          'exception': e.toString(),",
      "        },",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Listen to all invitations (stream for reactive UI)",
      "  Stream<List<FranchiseeInvitation>> invitationStream({",
      "    String? status,",
      "    String? inviterUserId,",
      "  }) {",
      "    firestore.Query query = invitationCollection;",
      "    if (status != null) {",
      "      query = query.where('status', isEqualTo: status);",
      "    }",
      "    if (inviterUserId != null) {",
      "      query = query.where('inviterUserId', isEqualTo: inviterUserId);",
      "    }",
      "    return query.orderBy('createdAt', descending: true).snapshots().map(",
      "        (snap) =>",
      "            snap.docs.map((doc) => FranchiseeInvitation.fromDoc(doc)).toList());",
      "  }",
      "",
      "  /// Fetch invitation by ID (returns null if not found)",
      "  Future<FranchiseeInvitation?> fetchInvitationById(String id) async {",
      "    try {",
      "      final doc = await invitationCollection.doc(id).get();",
      "      if (!doc.exists) return null;",
      "      return FranchiseeInvitation.fromDoc(doc);",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to fetch invitation by id',",
      "        stack: stack.toString(),",
      "        source: 'FirestoreService.fetchInvitationById',",
      "        screen: 'FranchiseeInvitation',",
      "        contextData: {'exception': e.toString(), 'id': id},",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Edit (patch) invitation metadata (admin usage only)",
      "  Future<void> updateInvitation(String id, Map<String, dynamic> data) async {",
      "    try {",
      "      await invitationCollection.doc(id).update(data);",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to update invitation',",
      "        stack: stack.toString(),",
      "        source: 'FirestoreService.updateInvitation',",
      "        screen: 'FranchiseeInvitation',",
      "        contextData: {'exception': e.toString(), 'id': id, 'data': data},",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Cancel or revoke an invitation (changes status, does not hard-delete)",
      "  Future<void> cancelInvitation(String id, {String? revokedByUserId}) async {",
      "    try {",
      "      await invitationCollection.doc(id).update({",
      "        'status': 'revoked',",
      "        if (revokedByUserId != null) 'revokedByUserId': revokedByUserId,",
      "        'revokedAt': firestore.Timestamp.now(),",
      "      });",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to cancel/revoke invitation',",
      "        stack: stack.toString(),",
      "        source: 'FirestoreService.cancelInvitation',",
      "        screen: 'FranchiseeInvitation',",
      "        contextData: {",
      "          'exception': e.toString(),",
      "          'id': id,",
      "          'revokedBy': revokedByUserId",
      "        },",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Delete an invitation (admin: hard delete)",
      "  Future<void> deleteInvitation(String id) async {",
      "    try {",
      "      await invitationCollection.doc(id).delete();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to delete invitation',",
      "        stack: stack.toString(),",
      "        source: 'FirestoreService.deleteInvitation',",
      "        screen: 'FranchiseeInvitation',",
      "        contextData: {'exception': e.toString(), 'id': id},",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Mark invitation as expired (set status, for automatic cleanup)",
      "  Future<void> expireInvitation(String id) async {",
      "    try {",
      "      await invitationCollection.doc(id).update({",
      "        'status': 'expired',",
      "        'expiredAt': firestore.Timestamp.now(),",
      "      });",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to expire invitation',",
      "        stack: stack.toString(),",
      "        source: 'FirestoreService.expireInvitation',",
      "        screen: 'FranchiseeInvitation',",
      "        contextData: {'exception': e.toString(), 'id': id},",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Mark invitation as re-sent (admin or automated resend)",
      "  Future<void> markInvitationResent(String id) async {",
      "    try {",
      "      await invitationCollection.doc(id).update({",
      "        'status': 'sent',",
      "        'lastSentAt': firestore.Timestamp.now(),",
      "      });",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to mark invitation as resent',",
      "        stack: stack.toString(),",
      "        source: 'FirestoreService.markInvitationResent',",
      "        screen: 'FranchiseeInvitation',",
      "        contextData: {'exception': e.toString(), 'id': id},",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  // PLATFORM dashboard methods",
      "  /// Returns platform-wide aggregate revenue stats for this year.",
      "  Future<PlatformRevenueOverview> fetchPlatformRevenueOverview() async {",
      "    try {",
      "      final now = DateTime.now();",
      "      final ytdStart = DateTime(now.year, 1, 1);",
      "",
      "      final query = _db.collection('invoices').where('period_start',",
      "          isGreaterThanOrEqualTo: firestore.Timestamp.fromDate(ytdStart));",
      "",
      "      final invoices = await query.get();",
      "",
      "      double totalRevenueYtd = 0;",
      "      double subscriptionRevenue = 0;",
      "      double royaltyRevenue = 0;",
      "      double overdueAmount = 0;",
      "",
      "      for (var doc in invoices.docs) {",
      "        final data = doc.data();",
      "        // Defensive casting for robustness",
      "        final amountDue = ((data['amount_due'] ?? 0) as num).toDouble();",
      "        final status = data['status']?.toString();",
      "        final type = data['type']?.toString()?.toLowerCase() ?? '';",
      "",
      "        // Sum revenue by type",
      "        totalRevenueYtd += amountDue;",
      "        if (type == 'subscription') {",
      "          subscriptionRevenue += amountDue;",
      "        } else if (type == 'royalty') {",
      "          royaltyRevenue += amountDue;",
      "        }",
      "",
      "        // Overdue",
      "        if (status == 'overdue' || status == 'unpaid') {",
      "          overdueAmount += amountDue;",
      "        }",
      "      }",
      "",
      "      return PlatformRevenueOverview(",
      "        totalRevenueYtd: totalRevenueYtd,",
      "        subscriptionRevenue: subscriptionRevenue,",
      "        royaltyRevenue: royaltyRevenue,",
      "        overdueAmount: overdueAmount,",
      "      );",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: e.toString(),",
      "        stack: stack.toString(),",
      "        source: 'FirestoreService',",
      "        screen: 'fetchPlatformRevenueOverview',",
      "        severity: 'error',",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Returns platform-wide financial KPIs: MRR, ARR, active franchises, recent payouts.",
      "  Future<PlatformFinancialKpis> fetchPlatformFinancialKpis() async {",
      "    try {",
      "      final now = DateTime.now();",
      "      final startOfMonth = DateTime(now.year, now.month, 1);",
      "",
      "      // Get all invoices for this month, type: subscription",
      "      final subQuery = _db",
      "          .collection('invoices')",
      "          .where('type', isEqualTo: 'subscription')",
      "          .where('period_start',",
      "              isGreaterThanOrEqualTo:",
      "                  firestore.Timestamp.fromDate(startOfMonth));",
      "      final subInvoices = await subQuery.get();",
      "",
      "      double mrr = 0;",
      "      final activeFranchiseIds = <String>{};",
      "      for (var doc in subInvoices.docs) {",
      "        final data = doc.data();",
      "        mrr += ((data['amount_due'] ?? 0) as num).toDouble();",
      "        final franchiseId = data['franchiseId']?.toString();",
      "        if (franchiseId != null && franchiseId.isNotEmpty) {",
      "          activeFranchiseIds.add(franchiseId);",
      "        }",
      "      }",
      "      double arr = mrr * 12;",
      "",
      "      // Get payouts for past 30 days using PayoutService",
      "      final recentPayouts =",
      "          await PayoutService().sumRecentPlatformPayouts(days: 30);",
      "",
      "      return PlatformFinancialKpis(",
      "        mrr: mrr,",
      "        arr: arr,",
      "        activeFranchises: activeFranchiseIds.length,",
      "        recentPayouts: recentPayouts,",
      "      );",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: e.toString(),",
      "        stack: stack.toString(),",
      "        source: 'FirestoreService',",
      "        screen: 'fetchPlatformFinancialKpis',",
      "        severity: 'error',",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  // Platform billing methods",
      "  /// Streams platform-issued invoices for the given franchisee.",
      "  /// Optionally filters by status ('paid', 'unpaid', 'overdue', etc).",
      "  Stream<List<PlatformInvoice>> platformInvoicesStream({",
      "    required String franchiseeId,",
      "    String? status,",
      "  }) {",
      "    try {",
      "      firestore.Query query = _db",
      "          .collection('platform_invoices')",
      "          .where('franchiseeId', isEqualTo: franchiseeId);",
      "",
      "      if (status != null && status.isNotEmpty) {",
      "        query = query.where('status', isEqualTo: status);",
      "      }",
      "",
      "      return query",
      "          .orderBy('dueDate', descending: true)",
      "          .snapshots()",
      "          .map((snapshot) {",
      "        return snapshot.docs",
      "            .map((doc) {",
      "              try {",
      "                return PlatformInvoice.fromMap(",
      "                    doc.id, doc.data() as Map<String, dynamic>);",
      "              } catch (e, stack) {",
      "                ErrorLogger.log(",
      "                  message: 'Failed to parse PlatformInvoice from Firestore: $e',",
      "                  stack: stack.toString(),",
      "                  source: 'FirestoreService',",
      "                  screen: 'platformInvoicesStream',",
      "                  contextData: {'docId': doc.id},",
      "                );",
      "                return null;",
      "              }",
      "            })",
      "            .whereType<PlatformInvoice>()",
      "            .toList();",
      "      });",
      "    } catch (e, stack) {",
      "      ErrorLogger.log(",
      "        message: 'Exception in platformInvoicesStream: $e',",
      "        stack: stack.toString(),",
      "        source: 'FirestoreService',",
      "        screen: 'platformInvoicesStream',",
      "        contextData: {'franchiseeId': franchiseeId, 'status': status},",
      "      );",
      "      return const Stream.empty();",
      "    }",
      "  }",
      "",
      "  Future<List<PlatformInvoice>> getPlatformInvoicesForUser(",
      "      String userId) async {",
      "    try {",
      "      debugPrint(",
      "          '[FirestoreService] getPlatformInvoicesForUser called for userId=$userId');",
      "",
      "      final querySnapshot = await _db",
      "          .collection('platform_invoices')",
      "          .where('franchiseeId', isEqualTo: userId)",
      "          .orderBy('dueDate', descending: true)",
      "          .get();",
      "",
      "      final invoices = querySnapshot.docs",
      "          .map((doc) {",
      "            try {",
      "              return PlatformInvoice.fromMap(",
      "                doc.id,",
      "                doc.data() as Map<String, dynamic>,",
      "              );",
      "            } catch (e, stack) {",
      "              ErrorLogger.log(",
      "                message: 'Failed to parse invoice doc: $e',",
      "                stack: stack.toString(),",
      "                source: 'FirestoreService.getPlatformInvoicesForUser',",
      "                screen: 'universal_profile_screen',",
      "                contextData: {'invoiceId': doc.id},",
      "              );",
      "              return null;",
      "            }",
      "          })",
      "          .whereType<PlatformInvoice>()",
      "          .toList();",
      "",
      "      debugPrint(",
      "          '[FirestoreService] Loaded ${invoices.length} invoices for user $userId');",
      "      return invoices;",
      "    } catch (e, stack) {",
      "      debugPrint('[FirestoreService] ERROR in getPlatformInvoicesForUser: $e');",
      "      await ErrorLogger.log(",
      "        message: 'Failed to load platform invoices: $e',",
      "        stack: stack.toString(),",
      "        source: 'FirestoreService.getPlatformInvoicesForUser',",
      "        screen: 'universal_profile_screen',",
      "        severity: 'error',",
      "        contextData: {'userId': userId},",
      "      );",
      "      return [];",
      "    }",
      "  }",
      "",
      "  Future<List<Map<String, dynamic>>> getPlatformPaymentsForUser(",
      "      String userId) async {",
      "    try {",
      "      debugPrint(",
      "          '[FirestoreService] getPlatformPaymentsForUser called for userId=$userId');",
      "",
      "      final query = await _db",
      "          .collection('platform_payments')",
      "          .where('franchiseeId', isEqualTo: userId)",
      "          .get();",
      "",
      "      final result = query.docs.map((d) => {...d.data(), 'id': d.id}).toList();",
      "      debugPrint(",
      "          '[FirestoreService] platform_payments results for $userId: ${result.length} docs');",
      "      for (var doc in result) {",
      "        debugPrint('[FirestoreService] Payment doc: $doc');",
      "      }",
      "",
      "      return result;",
      "    } catch (e, stack) {",
      "      debugPrint('[FirestoreService] ERROR in getPlatformPaymentsForUser: $e');",
      "      await ErrorLogger.log(",
      "        message: 'Failed to load platform payments: $e',",
      "        stack: stack.toString(),",
      "        source: 'FirestoreService',",
      "        screen: 'getPlatformPaymentsForUser',",
      "        severity: 'error',",
      "        contextData: {'userId': userId},",
      "      );",
      "      return [];",
      "    }",
      "  }",
      "",
      "  Future<void> savePlatformInvoiceFromWebhook(",
      "    Map<String, dynamic> eventData,",
      "    String invoiceId,",
      "  ) async {",
      "    try {",
      "      final invoice = PlatformInvoice.fromStripeWebhook(eventData, invoiceId);",
      "      final ref = firestore.FirebaseFirestore.instance",
      "          .collection('platform_invoices')",
      "          .doc(invoiceId);",
      "",
      "      await ref.set(invoice.toMap(), firestore.SetOptions(merge: true));",
      "",
      "      print('[FirestoreService] Invoice $invoiceId saved from webhook.');",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to save platform invoice from webhook: $e',",
      "        stack: stack.toString(),",
      "        source: 'FirestoreService',",
      "        screen: 'webhook_invoice_handler',",
      "        severity: 'error',",
      "        contextData: {",
      "          'invoiceId': invoiceId,",
      "          'eventType': eventData['type'],",
      "        },",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  Future<List<PlatformInvoice>> getPlatformInvoicesForFranchisee(",
      "      String franchiseeId) async {",
      "    try {",
      "      final snapshot = await _db",
      "          .collection('platform_invoices')",
      "          .where('franchiseeId', isEqualTo: franchiseeId)",
      "          .orderBy('dueDate', descending: true)",
      "          .get();",
      "",
      "      return snapshot.docs",
      "          .map((doc) => PlatformInvoice.fromMap(doc.id, doc.data()))",
      "          .toList();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to fetch platform invoices for $franchiseeId: $e',",
      "        stack: stack.toString(),",
      "        source: 'FirestoreService.getPlatformInvoicesForFranchisee',",
      "        screen: 'universal_profile_screen',",
      "      );",
      "      return [];",
      "    }",
      "  }",
      "",
      "  Future<void> createPlatformInvoice(PlatformInvoice invoice) async {",
      "    try {",
      "      await _db",
      "          .collection('platform_invoices')",
      "          .doc(invoice.id)",
      "          .set(invoice.toMap());",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to create platform invoice ${invoice.id}: $e',",
      "        stack: stack.toString(),",
      "        source: 'FirestoreService.createPlatformInvoice',",
      "        screen: 'invoice_admin',",
      "      );",
      "    }",
      "  }",
      "",
      "  Future<void> updatePlatformInvoiceStatus(",
      "      String invoiceId, String newStatus) async {",
      "    try {",
      "      await _db",
      "          .collection('platform_invoices')",
      "          .doc(invoiceId)",
      "          .update({'status': newStatus});",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message:",
      "            'Failed to update invoice status ($invoiceId -> $newStatus): $e',",
      "        stack: stack.toString(),",
      "        source: 'FirestoreService.updatePlatformInvoiceStatus',",
      "        screen: 'invoice_admin',",
      "      );",
      "    }",
      "  }",
      "",
      "  Future<List<PlatformPayment>> getPlatformPaymentsForFranchisee(",
      "      String franchiseeId) async {",
      "    try {",
      "      final snapshot = await _db",
      "          .collection('platform_payments')",
      "          .where('franchiseeId', isEqualTo: franchiseeId)",
      "          .orderBy('createdAt', descending: true)",
      "          .get();",
      "",
      "      return snapshot.docs",
      "          .map((doc) => PlatformPayment.fromMap(doc.id, doc.data()))",
      "          .toList();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to fetch platform payments for $franchiseeId: $e',",
      "        stack: stack.toString(),",
      "        source: 'FirestoreService.getPlatformPaymentsForFranchisee',",
      "        screen: 'universal_profile_screen',",
      "      );",
      "      return [];",
      "    }",
      "  }",
      "",
      "  Future<void> createPlatformPayment(PlatformPayment payment) async {",
      "    try {",
      "      await _db",
      "          .collection('platform_payments')",
      "          .doc(payment.id)",
      "          .set(payment.toMap());",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to create platform payment ${payment.id}: $e',",
      "        stack: stack.toString(),",
      "        source: 'FirestoreService.createPlatformPayment',",
      "        screen: 'developer_tools',",
      "      );",
      "    }",
      "  }",
      "",
      "  Future<void> markPlatformPaymentCompleted(String paymentId) async {",
      "    try {",
      "      await _db",
      "          .collection('platform_payments')",
      "          .doc(paymentId)",
      "          .update({'status': 'completed'});",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to mark platform payment $paymentId as completed: $e',",
      "        stack: stack.toString(),",
      "        source: 'FirestoreService.markPlatformPaymentCompleted',",
      "        screen: 'payment_processing',",
      "      );",
      "    }",
      "  }",
      "",
      "  Future<void> updatePlatformPaymentStatus(",
      "      String paymentId, String newStatus) async {",
      "    try {",
      "      await _db",
      "          .collection('platform_payments')",
      "          .doc(paymentId)",
      "          .update({'status': newStatus});",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message:",
      "            'Failed to update platform payment status ($paymentId -> $newStatus): $e',",
      "        stack: stack.toString(),",
      "        source: 'FirestoreService.updatePlatformPaymentStatus',",
      "        screen: 'payment_admin',",
      "      );",
      "    }",
      "  }",
      "",
      "  Future<void> markPlatformInvoicePaid(String invoiceId, String method) async {",
      "    try {",
      "      await _db.collection('platform_invoices').doc(invoiceId).update({",
      "        'status': 'paid',",
      "        'paidAt': firestore.FieldValue.serverTimestamp(),",
      "        'lastPaymentMethod': method, // 👈 optional field",
      "      });",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to mark invoice paid: $e',",
      "        stack: stack.toString(),",
      "        source: 'markPlatformInvoicePaid',",
      "        screen: 'pay_invoice_dialog',",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  static Future<List<FranchiseSubscription>> getFranchiseSubscriptions() async {",
      "    try {",
      "      final snap = await firestore.FirebaseFirestore.instance",
      "          .collection(\"franchise_subscriptions\")",
      "          .get();",
      "",
      "      return snap.docs",
      "          .map((doc) => FranchiseSubscription.fromMap(doc.id, doc.data()))",
      "          .toList();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to fetch franchise subscriptions',",
      "        stack: stack.toString(),",
      "        source: 'FirestoreService',",
      "        screen: 'firestore_service.dart',",
      "        severity: 'error',",
      "        contextData: {",
      "          'exception': e.toString(),",
      "        },",
      "      );",
      "      return [];",
      "    }",
      "  }",
      "",
      "  Future<FranchiseSubscription?> getFranchiseSubscription(",
      "      String franchiseId) async {",
      "    try {",
      "      final doc = await _db",
      "          .collection('franchise_subscriptions')",
      "          .doc(franchiseId)",
      "          .get();",
      "",
      "      if (doc.exists && doc.data() != null) {",
      "        return FranchiseSubscription.fromMap(doc.id, doc.data()!);",
      "      } else {",
      "        await ErrorLogger.log(",
      "          message: 'No subscription found for franchiseId: $franchiseId',",
      "          stack: '',",
      "          source: 'FirestoreService',",
      "          screen: 'firestore_service.dart',",
      "          severity: 'warning',",
      "          contextData: {'franchiseId': franchiseId},",
      "        );",
      "        return null;",
      "      }",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Error fetching franchise subscription',",
      "        stack: stack.toString(),",
      "        source: 'FirestoreService',",
      "        screen: 'firestore_service.dart',",
      "        severity: 'error',",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "          'exception': e.toString(),",
      "        },",
      "      );",
      "      return null;",
      "    }",
      "  }",
      "",
      "  Future<FranchiseSubscription?> getCurrentSubscriptionForFranchise(",
      "      String franchiseId) async {",
      "    try {",
      "      debugPrint(",
      "          '[FirestoreService] getCurrentSubscriptionForFranchise: franchiseId=$franchiseId');",
      "",
      "      final query = await _db",
      "          .collection('franchise_subscriptions')",
      "          .where('franchiseId', isEqualTo: franchiseId)",
      "          .where('active', isEqualTo: true)",
      "          .limit(1)",
      "          .get();",
      "",
      "      if (query.docs.isEmpty) {",
      "        debugPrint('[FirestoreService] No active subscription found.');",
      "        return null;",
      "      }",
      "",
      "      final doc = query.docs.first;",
      "      debugPrint('[FirestoreService] Active subscription found: ${doc.id}');",
      "      return FranchiseSubscription.fromMap(doc.id, doc.data());",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to load current subscription: $e',",
      "        source: 'FirestoreService',",
      "        screen: 'getCurrentSubscriptionForFranchise',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      return null;",
      "    }",
      "  }",
      "",
      "  Future<List<FranchiseSubscription>> getAllFranchiseSubscriptions() async {",
      "    try {",
      "      debugPrint(",
      "          '[FirestoreService] getAllFranchiseSubscriptions: Fetching all subscriptions...');",
      "",
      "      final snap = await _db.collection('franchise_subscriptions').get();",
      "",
      "      final list = snap.docs",
      "          .map((doc) => FranchiseSubscription.fromMap(doc.id, doc.data()))",
      "          .toList();",
      "",
      "      debugPrint('[FirestoreService] Retrieved ${list.length} subscriptions.');",
      "      return list;",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to fetch all franchise subscriptions: $e',",
      "        source: 'FirestoreService',",
      "        screen: 'getAllFranchiseSubscriptions',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "      );",
      "      return [];",
      "    }",
      "  }",
      "",
      "  Future<List<firestore.QueryDocumentSnapshot<Map<String, dynamic>>>>",
      "      getAllFranchiseSubscriptionsRaw() async {",
      "    final snap = await _db",
      "        .collection('franchise_subscriptions')",
      "        .orderBy('subscribedAt', descending: true)",
      "        .get();",
      "    return snap.docs;",
      "  }",
      "",
      "  Future<List<Map<String, dynamic>>> getStoreInvoicesForUser(",
      "      String userId) async {",
      "    final query = await _db",
      "        .collection('store_invoices')",
      "        .where('storeOwnerId', isEqualTo: userId)",
      "        .get();",
      "    return query.docs.map((d) => {...d.data(), 'id': d.id}).toList();",
      "  }",
      "",
      "  /// Returns a typed FranchiseInfo object for a given franchise ID.",
      "  Future<FranchiseInfo?> getFranchiseInfo(String franchiseId) async {",
      "    try {",
      "      final doc = await _db.collection('franchises').doc(franchiseId).get();",
      "      if (!doc.exists) {",
      "        await ErrorLogger.log(",
      "          message: 'Franchise document not found: $franchiseId',",
      "          source: 'FirestoreService.getFranchiseInfo',",
      "          screen: 'onboarding_menu_screen',",
      "          severity: 'warning',",
      "          contextData: {'franchiseId': franchiseId},",
      "        );",
      "        return null;",
      "      }",
      "      return FranchiseInfo.fromMap(doc.data()!, franchiseId);",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to fetch franchise info: $e',",
      "        stack: stack.toString(),",
      "        source: 'FirestoreService.getFranchiseInfo',",
      "        screen: 'onboarding_menu_screen',",
      "        severity: 'error',",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      return null;",
      "    }",
      "  }",
      "",
      "  /// ONBOARDING PROCESS",
      "  /// Get onboarding progress for a franchise",
      "  Future<Map<String, dynamic>?> getOnboardingProgress(",
      "      String franchiseId) async {",
      "    print(",
      "        '[DEBUG][FirestoreService.getOnboardingProgress] Called with franchiseId=\"$franchiseId\"');",
      "    try {",
      "      final doc =",
      "          await _db.collection('onboarding_progress').doc(franchiseId).get();",
      "      if (!doc.exists) return null;",
      "      return doc.data();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to fetch onboarding progress for $franchiseId',",
      "        stack: stack.toString(),",
      "        source: 'FirestoreService.getOnboardingProgress',",
      "        screen: 'onboarding_menu_screen',",
      "        severity: 'error',",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      return null;",
      "    }",
      "  }",
      "",
      "  /// Update onboarding step completion (merge true/false flag)",
      "  Future<void> updateOnboardingStep({",
      "    required String franchiseId,",
      "    required String stepKey,",
      "    required bool completed,",
      "  }) async {",
      "    try {",
      "      final docRef = _db.collection('onboarding_progress').doc(franchiseId);",
      "      await docRef.set({",
      "        stepKey: completed,",
      "        'updatedAt': firestore.FieldValue.serverTimestamp(),",
      "      }, firestore.SetOptions(merge: true));",
      "",
      "      // If all steps are complete, add final timestamp",
      "      if (_isFinalStep(stepKey, completed)) {",
      "        await docRef.set({",
      "          'completedAt': firestore.FieldValue.serverTimestamp(),",
      "        }, firestore.SetOptions(merge: true));",
      "      }",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to update onboarding step \"$stepKey\"',",
      "        stack: stack.toString(),",
      "        source: 'FirestoreService.updateOnboardingStep',",
      "        screen: 'onboarding_menu_screen',",
      "        severity: 'error',",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "          'stepKey': stepKey,",
      "          'completed': completed,",
      "        },",
      "      );",
      "    }",
      "  }",
      "",
      "  /// (Optional) Custom logic to determine if all final steps are complete",
      "  bool _isFinalStep(String key, bool completed) {",
      "    return key == 'review' && completed == true;",
      "  }",
      "",
      "  /// Marks onboarding as complete for a franchise, sets status to 'active', and logs the action.",
      "  Future<void> setOnboardingComplete({required String franchiseId}) async {",
      "    try {",
      "      await db.collection('franchises').doc(franchiseId).update({",
      "        'onboardingStatus': 'complete',",
      "        'onboardingCompletedAt': firestore.FieldValue.serverTimestamp(),",
      "        'status': 'active',",
      "      });",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to set onboarding complete for franchise',",
      "        stack: stack.toString(),",
      "        source: 'FirestoreService.setOnboardingComplete',",
      "        severity: 'error',",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// MERCHANT SIMULATION",
      "  /// Simulates a Stripe webhook event for testing.",
      "  /// Triggers the savePlatformInvoiceFromWebhook() logic with mock data.",
      "  Future<void> simulateWebhookEvent({",
      "    required String invoiceId,",
      "    required String eventType,",
      "    String status = 'paid',",
      "    double amount = 0.0,",
      "    String currency = 'USD',",
      "    String? planId,",
      "    String? subscriptionId,",
      "    String? receiptUrl,",
      "    DateTime? paidAt,",
      "    String paymentMethod = 'mock_card',",
      "    String paymentProvider = 'developer',",
      "  }) async {",
      "    try {",
      "      final timestamp = DateTime.now();",
      "      final paidAtMillis =",
      "          paidAt?.millisecondsSinceEpoch ?? timestamp.millisecondsSinceEpoch;",
      "",
      "      final eventData = {",
      "        'type': eventType,",
      "        'data': {",
      "          'object': {",
      "            'id': invoiceId,",
      "            'status': status,",
      "            'amount_due': (amount * 100).toInt(), // Simulate Stripe cents",
      "            'currency': currency.toLowerCase(),",
      "            'created': (timestamp.millisecondsSinceEpoch / 1000).round(),",
      "            'due_date': (timestamp",
      "                        .add(const Duration(days: 30))",
      "                        .millisecondsSinceEpoch /",
      "                    1000)",
      "                .round(),",
      "            'invoice_pdf': 'https://example.com/invoices/mock_$invoiceId.pdf',",
      "            'hosted_invoice_url':",
      "                receiptUrl ?? 'https://example.com/receipt/mock_$invoiceId',",
      "            'livemode': false,",
      "            'metadata': {",
      "              'franchiseeId': auth.currentUser?.uid ?? 'test_user',",
      "              if (planId != null) 'planId': planId,",
      "            },",
      "            'payment_intent': 'pi_mock_$invoiceId',",
      "            'subscription': subscriptionId,",
      "            'payment_settings': {",
      "              'payment_method_types': [paymentMethod],",
      "            },",
      "            'status_transitions': {",
      "              'paid_at': (paidAtMillis / 1000).round(),",
      "            },",
      "            'number': 'MOCK-$invoiceId',",
      "            'description': 'Simulated invoice for testing',",
      "          }",
      "        }",
      "      };",
      "",
      "      await savePlatformInvoiceFromWebhook(eventData, invoiceId);",
      "",
      "      debugPrint(",
      "          '[FirestoreService] Simulated webhook event \"$eventType\" for invoice $invoiceId');",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to simulate webhook event: $e',",
      "        stack: stack.toString(),",
      "        source: 'FirestoreService.simulateWebhookEvent',",
      "        screen: 'admin_webhook_simulator',",
      "        contextData: {",
      "          'invoiceId': invoiceId,",
      "          'eventType': eventType,",
      "        },",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  Future<void> logSimulatedWebhookEvent(Map<String, dynamic> data) async {",
      "    await _db.collection('simulated_webhooks').add(data);",
      "  }",
      "",
      "  Future<List<PlatformInvoice>> getTestPlatformInvoices({",
      "    required String franchiseeId,",
      "  }) async {",
      "    try {",
      "      var query = _db",
      "          .collection('platform_invoices')",
      "          .where('isTest', isEqualTo: true)",
      "          .where('franchiseeId', isEqualTo: franchiseeId);",
      "",
      "      final snapshot = await query.get();",
      "",
      "      return snapshot.docs",
      "          .map((doc) => PlatformInvoice.fromMap(doc.id, doc.data()))",
      "          .toList();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to fetch test invoices: $e',",
      "        stack: stack.toString(),",
      "        source: 'FirestoreService.getTestPlatformInvoices',",
      "        screen: 'admin_webhook_simulator',",
      "      );",
      "      return [];",
      "    }",
      "  }",
      "",
      "  // ONBOARDING TEMPLATE",
      "  static Future<void> copyIngredientTypesFromTemplate({",
      "    required String franchiseId,",
      "    required String templateId,",
      "  }) async {",
      "    final firestoreService = FirestoreService();",
      "",
      "    final sourceRef = firestoreService.db",
      "        .collection('onboarding_templates')",
      "        .doc(templateId)",
      "        .collection('ingredient_types');",
      "",
      "    final destRef = firestoreService.db",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection('ingredient_types');",
      "",
      "    try {",
      "      final snapshot = await sourceRef.get();",
      "",
      "      if (snapshot.docs.isEmpty) {",
      "        throw Exception('No ingredient types found in template \"$templateId\"');",
      "      }",
      "",
      "      final batch = firestoreService.db.batch();",
      "      final now = firestore.FieldValue.serverTimestamp();",
      "",
      "      for (final doc in snapshot.docs) {",
      "        final data = doc.data();",
      "",
      "        // Ensure overwrite-safe keys and inject created/updated",
      "        final destDoc = destRef.doc(doc.id);",
      "        batch.set(destDoc, {",
      "          ...data,",
      "          'createdAt': now,",
      "          'updatedAt': now,",
      "        });",
      "      }",
      "",
      "      await batch.commit();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'copyIngredientTypesFromTemplate failed',",
      "        stack: stack.toString(),",
      "        severity: 'error',",
      "        screen: 'ingredient_type_management_screen',",
      "        source: 'FirestoreService.copyIngredientTypesFromTemplate',",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "          'templateId': templateId,",
      "        },",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  Future<void> updateIngredientTypeSortOrders({",
      "    required String franchiseId,",
      "    required List<Map<String, dynamic>> sortedUpdates,",
      "  }) async {",
      "    final batch = _db.batch();",
      "",
      "    try {",
      "      for (final update in sortedUpdates) {",
      "        final String? id = update['id'];",
      "        final int? sortOrder = update['sortOrder'];",
      "",
      "        if (id == null || sortOrder == null) {",
      "          throw ArgumentError(",
      "              'Each update must include non-null \"id\" and \"sortOrder\".');",
      "        }",
      "",
      "        final docRef = _db",
      "            .collection('franchises')",
      "            .doc(franchiseId)",
      "            .collection('ingredient_types')",
      "            .doc(id);",
      "",
      "        batch.update(docRef, {",
      "          'sortOrder': sortOrder,",
      "          'updatedAt': firestore.FieldValue.serverTimestamp(),",
      "        });",
      "      }",
      "",
      "      await batch.commit();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to update ingredient type sort orders',",
      "        stack: stack.toString(),",
      "        severity: 'error',",
      "        source: 'firestore_service.dart',",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "          'updatesAttempted': sortedUpdates,",
      "          'errorType': e.runtimeType.toString(),",
      "        },",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  Future<void> replaceIngredientTypesFromJson({",
      "    required String franchiseId,",
      "    required List<IngredientType> items,",
      "  }) async {",
      "    final batch = _db.batch();",
      "    final collectionRef = _db",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection('ingredient_types');",
      "",
      "    try {",
      "      // Fetch all existing docs to delete",
      "      final existingSnap = await collectionRef.get();",
      "      for (final doc in existingSnap.docs) {",
      "        batch.delete(doc.reference);",
      "      }",
      "",
      "      // Insert all new docs",
      "      for (final type in items) {",
      "        final docRef =",
      "            collectionRef.doc(type.id ?? _db.collection('').doc().id);",
      "        batch.set(docRef, type.toMap());",
      "      }",
      "",
      "      await batch.commit();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to replace ingredient types from JSON',",
      "        source: 'FirestoreService',",
      "        screen: 'ingredient_type_management_screen',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "          'incomingItemCount': items.length,",
      "        },",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  Future<List<IngredientMetadata>> getIngredientMetadataTemplate(",
      "      String templateId) async {",
      "    try {",
      "      final snapshot = await _db",
      "          .collection('onboarding_templates')",
      "          .doc(templateId)",
      "          .collection('ingredient_metadata')",
      "          .get();",
      "",
      "      return snapshot.docs",
      "          .map((doc) => IngredientMetadata.fromMap(doc.data()))",
      "          .toList();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'ingredient_metadata_template_load_error',",
      "        source: 'FirestoreService',",
      "        stack: stack.toString(),",
      "        severity: 'error',",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  Future<void> importIngredientMetadataTemplate({",
      "    required String templateId,",
      "    required String franchiseId,",
      "  }) async {",
      "    try {",
      "      final templateDocs = await getIngredientMetadataTemplate(templateId);",
      "      final destRef = _db",
      "          .collection('franchises')",
      "          .doc(franchiseId)",
      "          .collection('ingredient_metadata');",
      "      final batch = _db.batch();",
      "",
      "      for (final item in templateDocs) {",
      "        batch.set(destRef.doc(item.id), item.toMap());",
      "      }",
      "",
      "      await batch.commit();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'importIngredientMetadataTemplate_failed',",
      "        source: 'FirestoreService',",
      "        screen: 'firestore_service.dart',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "        contextData: {",
      "          'templateId': templateId,",
      "          'franchiseId': franchiseId,",
      "        },",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  Future<List<IngredientMetadata>> fetchIngredientMetadata(",
      "      String franchiseId) async {",
      "    if (franchiseId.isEmpty || franchiseId == 'unknown') {",
      "      print(",
      "          '[ERROR][fetchIngredientMetadata] Called with empty/unknown franchiseId!');",
      "      await ErrorLogger.log(",
      "        message:",
      "            'fetchIngredientMetadata called with blank/unknown franchiseId',",
      "        stack: '',",
      "        source: 'FirestoreService',",
      "        screen: 'firestore_service.dart',",
      "        severity: 'error',",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      return [];",
      "    }",
      "    try {",
      "      final snapshot = await _db",
      "          .collection('franchises')",
      "          .doc(franchiseId)",
      "          .collection('ingredient_metadata')",
      "          .get();",
      "",
      "      return snapshot.docs",
      "          .map((doc) => IngredientMetadata.fromMap(doc.data()))",
      "          .toList();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'fetchIngredientMetadata failed',",
      "        stack: stack.toString(),",
      "        source: 'FirestoreService',",
      "        screen: 'firestore_service.dart',",
      "        severity: 'error',",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  Future<List<String>> fetchIngredientTypeIds(String franchiseId) async {",
      "    final snapshot = await db",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection('ingredient_types')",
      "        .get();",
      "",
      "    return snapshot.docs.map((doc) => doc.id).toList();",
      "  }",
      "",
      "  /// Fetches all categories for a given franchise",
      "  Future<List<model.Category>> fetchCategories(String franchiseId) async {",
      "    try {",
      "      print(",
      "          '[FirestoreService.fetchCategories] Fetching from /franchises/$franchiseId/categories');",
      "",
      "      final snapshot = await _db",
      "          .collection('franchises')",
      "          .doc(franchiseId)",
      "          .collection('categories')",
      "          .get();",
      "",
      "      return snapshot.docs",
      "          .map((doc) => model.Category.fromFirestore(doc.data(), doc.id))",
      "          .toList();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to fetch categories',",
      "        source: 'FirestoreService',",
      "        screen: 'firestore_service.dart',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Saves or updates a single category",
      "  Future<void> saveCategory(String franchiseId, model.Category category) async {",
      "    try {",
      "      await _db",
      "          .collection('franchises')",
      "          .doc(franchiseId)",
      "          .collection('categories')",
      "          .doc(category.id)",
      "          .set(category.toFirestore());",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to save category',",
      "        source: 'FirestoreService',",
      "        screen: 'firestore_service.dart',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "          'categoryId': category.id,",
      "          'categoryName': category.name,",
      "        },",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Bulk replace all categories (destructive save)",
      "  Future<void> replaceAllCategories(",
      "      String franchiseId, List<model.Category> categories) async {",
      "    final batch = _db.batch();",
      "    final colRef =",
      "        _db.collection('franchises').doc(franchiseId).collection('categories');",
      "",
      "    try {",
      "      // Clear existing",
      "      final existing = await colRef.get();",
      "      for (final doc in existing.docs) {",
      "        batch.delete(doc.reference);",
      "      }",
      "",
      "      // Add new",
      "      for (final category in categories) {",
      "        batch.set(colRef.doc(category.id), category.toFirestore());",
      "      }",
      "",
      "      await batch.commit();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to bulk replace categories',",
      "        source: 'FirestoreService',",
      "        screen: 'firestore_service.dart',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "          'newCount': categories.length,",
      "        },",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  Future<void> saveAllCategories(",
      "      String franchiseId, List<model.Category> categories) async {",
      "    final batch = _db.batch();",
      "    final colRef =",
      "        _db.collection('franchises').doc(franchiseId).collection('categories');",
      "",
      "    try {",
      "      for (final category in categories) {",
      "        final docRef = colRef.doc(category.id);",
      "        batch.set(docRef, category.toFirestore());",
      "      }",
      "",
      "      await batch.commit();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to batch save categories',",
      "        source: 'FirestoreService',",
      "        screen: 'firestore_service.dart',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "          'categoryCount': categories.length,",
      "        },",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// One-time fetch of menu items (used during onboarding load).",
      "  Future<List<MenuItem>> fetchMenuItemsOnce(String franchiseId) async {",
      "    try {",
      "      final snapshot = await _db",
      "          .collection('franchises')",
      "          .doc(franchiseId)",
      "          .collection('menu_items')",
      "          .orderBy('sortOrder', descending: false)",
      "          .get();",
      "",
      "      return snapshot.docs.map((doc) {",
      "        return MenuItem.fromFirestore(doc.data(), doc.id);",
      "      }).toList();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to fetch menu items',",
      "        source: 'FirestoreService',",
      "        screen: 'firestore_service.dart',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      return [];",
      "    }",
      "  }",
      "",
      "  Future<void> saveMenuItems(String franchiseId, List<MenuItem> items) async {",
      "    final batch = _db.batch();",
      "    final collection =",
      "        _db.collection('franchises').doc(franchiseId).collection('menu_items');",
      "",
      "    try {",
      "      for (int i = 0; i < items.length; i++) {",
      "        final item = items[i];",
      "",
      "        // 🚨 Skip if item.id is null or empty",
      "        if (item.id.isEmpty) {",
      "          await ErrorLogger.log(",
      "            message: 'MenuItem missing ID, skipping save',",
      "            source: 'FirestoreService',",
      "            screen: 'firestore_service.dart',",
      "            severity: 'warning',",
      "            contextData: {",
      "              'index': i,",
      "              'franchiseId': franchiseId,",
      "              'item': item.toMap(),",
      "            },",
      "          );",
      "          continue;",
      "        }",
      "",
      "        final ref = collection.doc(item.id);",
      "        final data = item.copyWith(sortOrder: i).toFirestore();",
      "        batch.set(ref, data, firestore.SetOptions(merge: true));",
      "      }",
      "",
      "      await batch.commit();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to batch save menu items',",
      "        source: 'FirestoreService',",
      "        screen: 'firestore_service.dart',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "        contextData: {'franchiseId': franchiseId, 'itemCount': items.length},",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  Future<void> reorderMenuItems(",
      "      String franchiseId, List<MenuItem> ordered) async {",
      "    final batch = _db.batch();",
      "    final collection =",
      "        _db.collection('franchises').doc(franchiseId).collection('menu_items');",
      "",
      "    try {",
      "      for (int i = 0; i < ordered.length; i++) {",
      "        final item = ordered[i];",
      "        final ref = collection.doc(item.id);",
      "        batch.update(ref, {'sortOrder': i});",
      "      }",
      "",
      "      await batch.commit();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to reorder menu items',",
      "        source: 'FirestoreService',",
      "        screen: 'firestore_service.dart',",
      "        severity: 'warning',",
      "        stack: stack.toString(),",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "          'itemCount': ordered.length,",
      "        },",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  // Add to FirestoreService",
      "  Future<List<MenuTemplateRef>> fetchMenuTemplateRefs({",
      "    required String restaurantType,",
      "  }) async {",
      "    try {",
      "      final snapshot = await firestore.FirebaseFirestore.instance",
      "          .collection('onboarding_templates')",
      "          .doc(restaurantType)",
      "          .collection('menu_items')",
      "          .get();",
      "",
      "      print('[DEBUG] 🔍 menu_items docs found: ${snapshot.docs.length}');",
      "",
      "      return snapshot.docs",
      "          .map((doc) => MenuTemplateRef.fromFirestore(doc.data()))",
      "          .toList();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to fetch menu template refs',",
      "        source: 'FirestoreService',",
      "        screen: 'firestore_service.dart',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "        contextData: {",
      "          'restaurantType': restaurantType,",
      "        },",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  static Future<List<Map<String, dynamic>>> decodeJsonList(String input) async {",
      "    try {",
      "      final parsed = jsonDecode(input);",
      "      if (parsed is! List) {",
      "        throw FormatException('Input JSON must be a list of objects.');",
      "      }",
      "",
      "      return List<Map<String, dynamic>>.from(parsed);",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to decode JSON input for feature/plans import',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "        source: 'FirestoreService.decodeJsonList',",
      "        contextData: {",
      "          'inputSnippet': input.length > 300 ? input.substring(0, 300) : input,",
      "          'error': e.toString(),",
      "        },",
      "      );",
      "      rethrow; // Allow UI or caller to handle",
      "    }",
      "  }",
      "",
      "  Future<List<SizeTemplate>> getSizeTemplatesForTemplate(",
      "      String restaurantType) async {",
      "    final snapshot = await _db",
      "        .collection('onboarding_templates')",
      "        .doc(restaurantType)",
      "        .collection('sizes')",
      "        .get();",
      "",
      "    return snapshot.docs.map((doc) => SizeTemplate.fromFirestore(doc)).toList();",
      "  }",
      "",
      "  static Future<List<IngredientType>> getIngredientTypes(",
      "      String franchiseId) async {",
      "    try {",
      "      final firestoreService = FirestoreService();",
      "      final snapshot = await firestoreService.db",
      "          .collection('franchises')",
      "          .doc(franchiseId)",
      "          .collection('ingredient_types')",
      "          .orderBy('sortOrder')",
      "          .get();",
      "",
      "      return snapshot.docs",
      "          .map((doc) => IngredientType.fromFirestore(doc))",
      "          .toList();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to fetch ingredient types',",
      "        source: 'IngredientTypeService',",
      "        screen: 'onboarding_ingredients_screen',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      return [];",
      "    }",
      "  }",
      "}",
      "",
      "extension IngredientOnboardingMethods on FirestoreService {",
      "  /// Stream all ingredient metadata for a franchise",
      "  Stream<List<IngredientMetadata>> streamIngredients(String franchiseId) {",
      "    try {",
      "      final firestoreService = FirestoreService();",
      "      final ref = firestoreService.db",
      "          .collection('franchises')",
      "          .doc(franchiseId)",
      "          .collection('ingredient_metadata')",
      "          .orderBy('name');",
      "      return ref.snapshots().map((snapshot) {",
      "        print(",
      "            '📥 Fetched ${snapshot.docs.length} ingredient docs from Firestore');",
      "        return snapshot.docs",
      "            .map((doc) {",
      "              try {",
      "                return IngredientMetadata.fromMap(doc.data());",
      "              } catch (e) {",
      "                print('❌ Error parsing doc ${doc.id}: $e');",
      "                return null;",
      "              }",
      "            })",
      "            .whereType<IngredientMetadata>()",
      "            .toList();",
      "      });",
      "    } catch (e, stack) {",
      "      ErrorLogger.log(",
      "        message: 'Failed to stream ingredients: $e',",
      "        source: 'FirestoreService',",
      "        screen: 'IngredientOnboarding',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      return const Stream.empty();",
      "    }",
      "  }",
      "",
      "  /// Add or update an ingredient (create if not exists)",
      "  Future<void> saveIngredient({",
      "    required String franchiseId,",
      "    required IngredientMetadata ingredient,",
      "  }) async {",
      "    try {",
      "      final firestoreService = FirestoreService();",
      "      final docRef = firestoreService.db",
      "          .collection('franchises')",
      "          .doc(franchiseId)",
      "          .collection('ingredient_metadata')",
      "          .doc(ingredient.id);",
      "",
      "      await docRef.set(ingredient.toMap(), firestore.SetOptions(merge: true));",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to save ingredient: $e',",
      "        source: 'FirestoreService',",
      "        screen: 'IngredientOnboarding',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "          'ingredientId': ingredient.id,",
      "        },",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Delete an ingredient by ID",
      "  Future<void> deleteIngredient({",
      "    required String franchiseId,",
      "    required String ingredientId,",
      "  }) async {",
      "    try {",
      "      final firestoreService = FirestoreService();",
      "      final docRef = firestoreService.db",
      "          .collection('franchises')",
      "          .doc(franchiseId)",
      "          .collection('ingredient_metadata')",
      "          .doc(ingredientId);",
      "",
      "      await docRef.delete();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to delete ingredient: $e',",
      "        source: 'FirestoreService',",
      "        screen: 'IngredientOnboarding',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "          'ingredientId': ingredientId,",
      "        },",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Creates or updates an ingredient_metadata document for the current franchise.",
      "  Future<void> createOrUpdateIngredientMetadata({",
      "    required String franchiseId,",
      "    required IngredientMetadata ingredient,",
      "  }) async {",
      "    try {",
      "      final docRef = db",
      "          .collection('franchises')",
      "          .doc(franchiseId)",
      "          .collection(_ingredientMetadata)",
      "          .doc(ingredient.id);",
      "",
      "      await docRef.set(ingredient.toMap(), firestore.SetOptions(merge: true));",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to create/update ingredient metadata',",
      "        stack: stack.toString(),",
      "        source: 'FirestoreService',",
      "        screen: 'ingredient_onboarding',",
      "        severity: 'error',",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "          'ingredientId': ingredient.id,",
      "        },",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  // Onboarding ingredients",
      "  static Future<List<IngredientType>> getIngredientTypes(",
      "      String franchiseId) async {",
      "    try {",
      "      final firestoreService = FirestoreService();",
      "      final snapshot = await firestoreService.db",
      "          .collection('franchises')",
      "          .doc(franchiseId)",
      "          .collection('ingredient_types')",
      "          .orderBy('sortOrder')",
      "          .get();",
      "",
      "      return snapshot.docs",
      "          .map((doc) => IngredientType.fromFirestore(doc))",
      "          .toList();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to fetch ingredient types',",
      "        source: 'IngredientTypeService',",
      "        screen: 'onboarding_ingredients_screen',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      return [];",
      "    }",
      "  }",
      "",
      "  static Future<void> addIngredientType(",
      "      String franchiseId, IngredientType type) async {",
      "    try {",
      "      final firestoreService = FirestoreService();",
      "      await firestoreService.db",
      "          .collection('franchises')",
      "          .doc(franchiseId)",
      "          .collection('ingredient_types')",
      "          .add(type.toMap());",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to add ingredient type',",
      "        source: 'IngredientTypeService',",
      "        screen: 'onboarding_ingredients_screen',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "          'ingredientType': type.toMap(),",
      "        },",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  static Future<void> updateIngredientType(",
      "      String franchiseId, String typeId, Map<String, dynamic> data) async {",
      "    try {",
      "      final firestoreService = FirestoreService();",
      "      await firestoreService.db",
      "          .collection('franchises')",
      "          .doc(franchiseId)",
      "          .collection('ingredient_types')",
      "          .doc(typeId)",
      "          .update(data);",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to update ingredient type',",
      "        source: 'IngredientTypeService',",
      "        screen: 'onboarding_ingredients_screen',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "          'typeId': typeId,",
      "          'updateData': data,",
      "        },",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "}",
      "",
      "// Helper: Delayed user stream",
      "Stream<app_user.User?> delayedUserStream(",
      "    FirestoreService fs, String uid) async* {",
      "  print('[delayedUserStream] Waiting to fetch user $uid');",
      "  await Future.delayed(const Duration(seconds: 1));",
      "  print('[delayedUserStream] Fetching user $uid from Firestore');",
      "  final user = await fs.getUser(uid);",
      "  print('[delayedUserStream] Got user: $user');",
      "  yield user;",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 4850,
      "file_size": 163024,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\services\\franchise_feature_service.dart",
    "content": [
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "import 'package:franchise_admin_portal/core/models/feature_metadata.dart'",
      "    show FeatureState;",
      "import 'package:franchise_admin_portal/core/models/feature_module.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:flutter/material.dart';",
      "",
      "class FranchiseFeatureService {",
      "  final FirebaseFirestore _firestore;",
      "",
      "  FranchiseFeatureService({FirebaseFirestore? firestore})",
      "      : _firestore = firestore ?? FirebaseFirestore.instance;",
      "",
      "  /// 🔹 Get the list of all features granted by the current plan",
      "  Future<List<String>> getGrantedFeaturesFromSubscription(",
      "      String franchiseId) async {",
      "    try {",
      "      final query = await _firestore",
      "          .collection('franchise_subscriptions')",
      "          .where('franchiseId', isEqualTo: franchiseId)",
      "          .where('status', isEqualTo: 'active')",
      "          .orderBy('startDate', descending: true)",
      "          .limit(1)",
      "          .get();",
      "",
      "      if (query.docs.isEmpty) return [];",
      "",
      "      final data = query.docs.first.data();",
      "      if (data == null || data['planSnapshot'] == null) return [];",
      "",
      "      final planSnapshot = data['planSnapshot'] as Map<String, dynamic>;",
      "      final features = planSnapshot['features'];",
      "",
      "      if (features is List) {",
      "        return features.map((f) => f.toString()).toList();",
      "      }",
      "",
      "      return [];",
      "    } catch (e, st) {",
      "      await ErrorLogger.log(",
      "        message:",
      "            'Failed to load granted features for franchise $franchiseId via query',",
      "        stack: st.toString(),",
      "        source: 'FranchiseFeatureService.getGrantedFeaturesFromSubscription',",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      return [];",
      "    }",
      "  }",
      "",
      "  /// 🔹 Load the feature metadata config for onboarding/use",
      "  Future<FeatureState?> getFeatureMetadata(String franchiseId) async {",
      "    if (franchiseId.isEmpty || franchiseId == 'unknown') {",
      "      await ErrorLogger.log(",
      "        message: 'getFeatureMetadata called with blank/unknown franchiseId',",
      "        stack: '',",
      "        source: 'franchise_feature_service.dart',",
      "        screen: 'franchise_feature_service.dart',",
      "        severity: 'warning',",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      return null;",
      "    }",
      "    try {",
      "      final docRef = _firestore",
      "          .collection('franchises')",
      "          .doc(franchiseId)",
      "          .collection('feature_metadata')",
      "          .doc(franchiseId);",
      "",
      "      final snapshot = await docRef.get();",
      "      if (!snapshot.exists || snapshot.data() == null) return null;",
      "",
      "      final rawData = snapshot.data()!;",
      "      final featureState = FeatureState.fromMap(rawData);",
      "",
      "      debugPrint(",
      "          '[FranchiseFeatureService] Loaded feature metadata for $franchiseId, '",
      "          'liveSnapshotEnabled=${featureState.liveSnapshotEnabled}');",
      "",
      "      return featureState;",
      "    } catch (e, st) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to get feature_metadata',",
      "        stack: st.toString(),",
      "        source: 'FranchiseFeatureService.getFeatureMetadata',",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      return null;",
      "    }",
      "  }",
      "",
      "  /// 🔹 Save the feature metadata (if valid)",
      "  Future<bool> saveFeatureMetadata({",
      "    required String franchiseId,",
      "    required FeatureState metadata,",
      "  }) async {",
      "    try {",
      "      final granted = await getGrantedFeaturesFromSubscription(franchiseId);",
      "      final errors = validateFeatureMetadata(",
      "        grantedFeatures: granted,",
      "        metadata: metadata,",
      "      );",
      "",
      "      if (errors.isNotEmpty) {",
      "        await ErrorLogger.log(",
      "          message: 'Invalid feature metadata attempted to be saved',",
      "          severity: 'warning',",
      "          source: 'FranchiseFeatureService.saveFeatureMetadata',",
      "          contextData: {'errors': errors, 'franchiseId': franchiseId},",
      "        );",
      "        return false;",
      "      }",
      "",
      "      final docRef = _firestore",
      "          .collection('franchises')",
      "          .doc(franchiseId)",
      "          .collection('feature_metadata')",
      "          .doc(franchiseId);",
      "",
      "      final saveMap = {",
      "        ...metadata.modules.map((k, v) => MapEntry(k, v.toMap())),",
      "        'liveSnapshotEnabled': metadata.liveSnapshotEnabled,",
      "      };",
      "",
      "      await docRef.set(saveMap, SetOptions(merge: true));",
      "",
      "      return true;",
      "    } catch (e, st) {",
      "      await ErrorLogger.log(",
      "        message: 'Exception while saving feature metadata',",
      "        stack: st.toString(),",
      "        source: 'FranchiseFeatureService.saveFeatureMetadata',",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      return false;",
      "    }",
      "  }",
      "",
      "  /// 🔹 Save a single module toggle",
      "  Future<void> updateModuleEnabled(",
      "      String franchiseId, String moduleKey, bool enabled) async {",
      "    final docRef = _firestore",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection('feature_metadata')",
      "        .doc(franchiseId);",
      "",
      "    await docRef.set({",
      "      moduleKey: {'enabled': enabled}",
      "    }, SetOptions(merge: true));",
      "  }",
      "",
      "  /// 🔹 Save toggles inside a module",
      "  Future<void> updateModuleFeatures(",
      "      String franchiseId, String moduleKey, Map<String, bool> updates) async {",
      "    final updatesMap =",
      "        updates.map((k, v) => MapEntry('$moduleKey.features.$k', v));",
      "",
      "    final docRef = _firestore",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection('feature_metadata')",
      "        .doc(franchiseId);",
      "",
      "    await docRef.set(updatesMap, SetOptions(merge: true));",
      "  }",
      "",
      "  /// 🔹 Remove a full module (e.g., inventory)",
      "  Future<void> removeModule(String franchiseId, String moduleKey) async {",
      "    final docRef = _firestore",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection('feature_metadata')",
      "        .doc(franchiseId);",
      "",
      "    await docRef.update({moduleKey: FieldValue.delete()});",
      "  }",
      "",
      "  /// 🔹 Remove one subfeature from module",
      "  Future<void> removeFeature(",
      "      String franchiseId, String moduleKey, String featureKey) async {",
      "    final docRef = _firestore",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection('feature_metadata')",
      "        .doc(franchiseId);",
      "",
      "    await docRef",
      "        .update({'$moduleKey.features.$featureKey': FieldValue.delete()});",
      "  }",
      "",
      "  /// 🔹 Legacy flat flags (optional legacy devtool support)",
      "  Future<Map<String, bool>> getFlatFeatureFlags(String franchiseId) async {",
      "    final docRef = _firestore",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection('config')",
      "        .doc('feature_flags');",
      "",
      "    final snapshot = await docRef.get();",
      "    if (!snapshot.exists || snapshot.data() == null) return {};",
      "",
      "    final raw = snapshot.data()!;",
      "    return raw.map((k, v) => MapEntry(k, v == true));",
      "  }",
      "",
      "  Future<void> saveFlatFeatureFlags(",
      "      String franchiseId, Map<String, bool> flags) async {",
      "    final docRef = _firestore",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection('config')",
      "        .doc('feature_flags');",
      "",
      "    await docRef.set(flags, SetOptions(merge: true));",
      "  }",
      "",
      "  /// 🔍 Schema validator for metadata enforcement",
      "  List<String> validateFeatureMetadata({",
      "    required List<String> grantedFeatures,",
      "    required FeatureState metadata,",
      "  }) {",
      "    final errors = <String>[];",
      "",
      "    metadata.modules.forEach((moduleKey, module) {",
      "      if (!grantedFeatures.contains(moduleKey)) {",
      "        errors.add('Module \"$moduleKey\" is not granted by the current plan.');",
      "      }",
      "",
      "      module.features.forEach((featureKey, enabled) {",
      "        if (enabled && !grantedFeatures.contains(moduleKey)) {",
      "          errors.add(",
      "              'Subfeature \"$moduleKey.$featureKey\" is enabled, but the parent module is not granted.');",
      "        }",
      "      });",
      "    });",
      "",
      "    return errors;",
      "  }",
      "",
      "  Future<bool> isLiveSnapshotEnabled(String franchiseId) async {",
      "    try {",
      "      final featureState = await getFeatureMetadata(franchiseId);",
      "      final enabled = featureState?.liveSnapshotEnabled ?? false;",
      "      debugPrint(",
      "          '[FranchiseFeatureService] liveSnapshotEnabled for $franchiseId: $enabled');",
      "      return enabled;",
      "    } catch (e, st) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to check liveSnapshotEnabled',",
      "        stack: st.toString(),",
      "        source: 'FranchiseFeatureService.isLiveSnapshotEnabled',",
      "        severity: 'error',",
      "        screen: 'franchise_feature_service.dart',",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      return false;",
      "    }",
      "  }",
      "",
      "  /// 🔹 Toggle the liveSnapshotEnabled flag in Firestore",
      "  Future<void> updateLiveSnapshotFlag(String franchiseId, bool enabled) async {",
      "    if (franchiseId.isEmpty || franchiseId == 'unknown') {",
      "      await ErrorLogger.log(",
      "        message: 'updateLiveSnapshotFlag called with blank/unknown franchiseId',",
      "        stack: '',",
      "        source: 'FranchiseFeatureService.updateLiveSnapshotFlag',",
      "        screen: 'franchise_feature_service.dart',",
      "        severity: 'warning',",
      "        contextData: {'franchiseId': franchiseId, 'requestedValue': enabled},",
      "      );",
      "      return;",
      "    }",
      "",
      "    try {",
      "      final docRef = _firestore",
      "          .collection('franchises')",
      "          .doc(franchiseId)",
      "          .collection('feature_metadata')",
      "          .doc(franchiseId);",
      "",
      "      await docRef.set(",
      "        {'liveSnapshotEnabled': enabled},",
      "        SetOptions(merge: true),",
      "      );",
      "",
      "      debugPrint(",
      "          '[FranchiseFeatureService] liveSnapshotEnabled updated → $enabled for franchiseId=$franchiseId');",
      "",
      "      await ErrorLogger.log(",
      "        message: 'liveSnapshotEnabled flag updated',",
      "        source: 'FranchiseFeatureService.updateLiveSnapshotFlag',",
      "        severity: 'info',",
      "        screen: 'franchise_feature_service.dart',",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "          'newValue': enabled,",
      "        },",
      "      );",
      "    } catch (e, st) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to update liveSnapshotEnabled flag',",
      "        stack: st.toString(),",
      "        source: 'FranchiseFeatureService.updateLiveSnapshotFlag',",
      "        severity: 'error',",
      "        screen: 'franchise_feature_service.dart',",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "          'requestedValue': enabled,",
      "        },",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 316,
      "file_size": 10430,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\services\\franchise_onboarding_service.dart",
    "content": [
      "// 📁 lib/core/services/franchise_onboarding_service.dart",
      "",
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class FranchiseOnboardingService {",
      "  late final FirebaseFirestore _db;",
      "",
      "  FranchiseOnboardingService() {",
      "    _db = FirebaseFirestore.instance;",
      "  }",
      "",
      "  /// Marks the franchise's onboarding status as completed.",
      "  Future<void> markOnboardingComplete(String franchiseId) async {",
      "    final franchiseRef = _db.collection('franchises').doc(franchiseId);",
      "",
      "    try {",
      "      await franchiseRef.update({",
      "        'onboardingStatus': 'complete',",
      "        'onboardingCompletedAt': FieldValue.serverTimestamp(),",
      "      });",
      "",
      "      await ErrorLogger.log(",
      "        message: 'Franchise onboarding marked complete',",
      "        source: 'FranchiseOnboardingService',",
      "        screen: 'available_platform_plans_screen',",
      "        severity: 'info',",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "        },",
      "      );",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to mark onboarding complete: $e',",
      "        source: 'FranchiseOnboardingService',",
      "        screen: 'available_platform_plans_screen',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "        },",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Returns whether the franchise is flagged as having completed onboarding.",
      "  Future<bool> isOnboardingComplete(String franchiseId) async {",
      "    try {",
      "      final doc = await _db.collection('franchises').doc(franchiseId).get();",
      "      return doc.data()?['onboardingStatus'] == 'complete';",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Error checking onboarding status: $e',",
      "        source: 'FranchiseOnboardingService',",
      "        screen: 'available_platform_plans_screen',",
      "        severity: 'warning',",
      "        stack: stack.toString(),",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "        },",
      "      );",
      "      return false;",
      "    }",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 66,
      "file_size": 2098,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\services\\franchise_subscription_service.dart",
    "content": [
      "// 📁 lib/core/services/franchise_subscription_service.dart",
      "",
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "import 'package:flutter/foundation.dart';",
      "import 'package:franchise_admin_portal/core/models/franchise_subscription_model.dart';",
      "import 'package:franchise_admin_portal/core/models/platform_plan_model.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class FranchiseSubscriptionService {",
      "  final FirebaseFirestore _db;",
      "",
      "  FranchiseSubscriptionService({FirebaseFirestore? firestoreInstance})",
      "      : _db = firestoreInstance ?? FirebaseFirestore.instance;",
      "",
      "  // ===========================================================================",
      "  // 🔥 Franchise Subscription – Core Lifecycle",
      "  // ===========================================================================",
      "",
      "  /// Subscribe a franchise to a new platform plan. Deactivates any active subscription first.",
      "  Future<void> subscribeFranchiseToPlan({",
      "    required String franchiseId,",
      "    required PlatformPlan plan,",
      "  }) async {",
      "    final batch = _db.batch();",
      "    final subscriptionsRef = _db.collection('franchise_subscriptions');",
      "",
      "    try {",
      "      // 🔁 Cancel existing active subscriptionso",
      "      final existing = await subscriptionsRef",
      "          .where('franchiseId', isEqualTo: franchiseId)",
      "          .where('active', isEqualTo: true)",
      "          .get();",
      "",
      "      for (final doc in existing.docs) {",
      "        batch.update(doc.reference, {",
      "          'active': false,",
      "          'status': 'cancelled',",
      "          'cancelledAt': FieldValue.serverTimestamp(),",
      "        });",
      "      }",
      "",
      "      // 🆕 Create new subscription",
      "      final newRef = subscriptionsRef.doc();",
      "      final billingCycleDays = plan.billingInterval == 'yearly' ? 365 : 30;",
      "",
      "      final newSubscriptionData = {",
      "        'franchiseId': franchiseId,",
      "        'platformPlanId': plan.id,",
      "        'subscribedAt': FieldValue.serverTimestamp(),",
      "        'startDate': FieldValue.serverTimestamp(),",
      "        'nextBillingDate': Timestamp.fromDate(",
      "          DateTime.now().add(Duration(days: billingCycleDays)),",
      "        ),",
      "        'billingCycleInDays': billingCycleDays,",
      "        'billingInterval': plan.billingInterval,",
      "        'autoRenew': true,",
      "        'priceAtSubscription': plan.price,",
      "        'active': true,",
      "        'status': 'active',",
      "        'planSnapshot': {",
      "          'name': plan.name,",
      "          'description': plan.description,",
      "          'features': plan.features,",
      "          'currency': plan.currency,",
      "          'price': plan.price,",
      "          'billingInterval': plan.billingInterval,",
      "          'isCustom': plan.isCustom,",
      "          'planVersion': plan.planVersion ?? 'v1',",
      "        },",
      "        'paymentProviderCustomerId': null,",
      "        'cardLast4': null,",
      "        'cardBrand': null,",
      "        'paymentMethodId': null,",
      "        'billingEmail': null,",
      "        'paymentStatus': null,",
      "        'receiptUrl': null,",
      "      };",
      "",
      "      debugPrint(",
      "          '[🔥DEBUG] Writing subscription for franchiseId=$franchiseId with planId=${plan.id}');",
      "      batch.set(newRef, newSubscriptionData);",
      "",
      "      // 🌱 Seed feature_metadata from plan features",
      "      // final Map<String, dynamic> featureMetadata = {",
      "      //   'modules': {",
      "      //     for (final featureKey in plan.features)",
      "      //       featureKey: {",
      "      //         'enabled': true,",
      "      //         'features': {'enabled': true},",
      "      //       },",
      "      //   },",
      "      //   'updatedAt': FieldValue.serverTimestamp(),",
      "      // };",
      "",
      "      await updateFeatureMetadataForPlanChange(",
      "        franchiseId: franchiseId,",
      "        grantedFeatures: plan.features,",
      "      );",
      "",
      "      // 🧾 Commit both subscription and feature writes",
      "      await batch.commit();",
      "      debugPrint('[🔥DEBUG] Subscription + feature metadata committed ✅');",
      "",
      "      await ErrorLogger.log(",
      "        message: 'Franchise subscribed to platform plan',",
      "        source: 'FranchiseSubscriptionService',",
      "        screen: 'confirm_plan_subscription_dialog',",
      "        severity: 'info',",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "          'planId': plan.id,",
      "          'planName': plan.name,",
      "        },",
      "      );",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to subscribe franchise to plan: $e',",
      "        source: 'FranchiseSubscriptionService',",
      "        screen: 'confirm_plan_subscription_dialog',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "          'planId': plan.id,",
      "        },",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Update an existing franchise subscription (merge)",
      "  Future<void> updateFranchiseSubscription({",
      "    required String documentId,",
      "    required Map<String, dynamic> data,",
      "  }) async {",
      "    try {",
      "      final docRef = _db.collection('franchise_subscriptions').doc(documentId);",
      "      await docRef.set(data, SetOptions(merge: true));",
      "",
      "      // 🔍 Optional logic: sync feature metadata if features or plan changed",
      "      final franchiseId = data['franchiseId'];",
      "      final planSnapshot = data['planSnapshot'];",
      "      final updatedFeatures = planSnapshot?['features'];",
      "",
      "      if (franchiseId != null &&",
      "          updatedFeatures is List &&",
      "          updatedFeatures.isNotEmpty) {",
      "        await updateFeatureMetadataForPlanChange(",
      "          franchiseId: franchiseId,",
      "          grantedFeatures: List<String>.from(updatedFeatures),",
      "        );",
      "      }",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to update franchise subscription',",
      "        stack: stack.toString(),",
      "        source: 'FranchiseSubscriptionService',",
      "        screen: 'updateFranchiseSubscription',",
      "        severity: 'error',",
      "        contextData: {'exception': e.toString(), 'inputData': data},",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  Future<void> updateFeatureMetadataForPlanChange({",
      "    required String franchiseId,",
      "    required List<String> grantedFeatures,",
      "  }) async {",
      "    final docRef = _db",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection('feature_metadata')",
      "        .doc(franchiseId);",
      "",
      "    // ⛔ Features are GRANTED, but disabled by default",
      "    final Map<String, dynamic> newMetadata = {",
      "      for (final featureKey in grantedFeatures)",
      "        featureKey: {",
      "          'enabled': false, // <- toggled during onboarding",
      "          'features': {},",
      "        },",
      "      'updatedAt': FieldValue.serverTimestamp(),",
      "    };",
      "",
      "    await docRef.set(newMetadata);",
      "  }",
      "",
      "  /// Save (create or overwrite) a subscription (move from FirestoreService)",
      "  Future<void> saveFranchiseSubscription(",
      "      FranchiseSubscription subscription) async {",
      "    try {",
      "      final docRef = subscription.id.isNotEmpty",
      "          ? _db.collection('franchise_subscriptions').doc(subscription.id)",
      "          : _db",
      "              .collection('franchise_subscriptions')",
      "              .doc(); // Will generate new ID",
      "",
      "      await docRef.set(",
      "        subscription.toFirestore(),",
      "        SetOptions(merge: true),",
      "      );",
      "",
      "      debugPrint(",
      "          '[FranchiseSubscriptionService] Saved subscription: ${docRef.id}');",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to save franchise subscription',",
      "        stack: stack.toString(),",
      "        source: 'FranchiseSubscriptionService',",
      "        screen: 'saveFranchiseSubscription',",
      "        severity: 'error',",
      "        contextData: {",
      "          'subscriptionId': subscription.id,",
      "          'franchiseId': subscription.franchiseId,",
      "        },",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Delete a specific franchise subscription",
      "  Future<void> deleteFranchiseSubscription(String id) async {",
      "    try {",
      "      await _db.collection('franchise_subscriptions').doc(id).delete();",
      "    } catch (e, st) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to delete franchise_subscription $id',",
      "        stack: st.toString(),",
      "        source: 'FranchiseSubscriptionService',",
      "        screen: 'deleteFranchiseSubscription',",
      "        severity: 'error',",
      "        contextData: {'subscriptionId': id, 'exception': e.toString()},",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Batch delete multiple franchise subscriptions (move from FirestoreService)",
      "  Future<void> deleteManyFranchiseSubscriptions(List<String> ids) async {",
      "    final batch = _db.batch();",
      "",
      "    try {",
      "      for (final id in ids) {",
      "        final docRef = _db.collection('franchise_subscriptions').doc(id);",
      "        batch.delete(docRef);",
      "      }",
      "",
      "      await batch.commit();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to delete multiple franchise subscriptions',",
      "        stack: stack.toString(),",
      "        source: 'FranchiseSubscriptionService',",
      "        screen: 'deleteManyFranchiseSubscriptions',",
      "        severity: 'error',",
      "        contextData: {'ids': ids, 'exception': e.toString()},",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  // ===========================================================================",
      "  // 🔎 Franchise Subscription – Queries",
      "  // ===========================================================================",
      "",
      "  /// Get all subscriptions (admin/global access)",
      "  Future<List<FranchiseSubscription>> getAllFranchiseSubscriptions() async {",
      "    try {",
      "      final snap = await _db.collection('franchise_subscriptions').get();",
      "      final list = snap.docs",
      "          .map((doc) => FranchiseSubscription.fromMap(doc.id, doc.data()))",
      "          .toList();",
      "",
      "      debugPrint(",
      "          '[FranchiseSubscriptionService] Fetched ${list.length} subscriptions.');",
      "      return list;",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to fetch franchise subscriptions',",
      "        source: 'FranchiseSubscriptionService',",
      "        screen: 'platform_owner_dashboard',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Stream all subscriptions in real-time (for dev tools UI)",
      "  Stream<List<FranchiseSubscription>> watchAllFranchiseSubscriptions() {",
      "    return _db",
      "        .collection('franchise_subscriptions')",
      "        .orderBy('subscribedAt', descending: true)",
      "        .snapshots()",
      "        .map((snap) => snap.docs",
      "            .map((doc) => FranchiseSubscription.fromMap(doc.id, doc.data()))",
      "            .toList());",
      "  }",
      "",
      "  /// Get current (active) subscription for franchise",
      "  Future<FranchiseSubscription?> getCurrentSubscription(",
      "      String franchiseId) async {",
      "    try {",
      "      print(",
      "          '[FranchiseSubscriptionService] getCurrentSubscription: Fetching for franchiseId=$franchiseId');",
      "      final querySnapshot = await _db",
      "          .collection('franchise_subscriptions')",
      "          .where('franchiseId', isEqualTo: franchiseId)",
      "          .where('status', isEqualTo: 'active')",
      "          .orderBy('startDate', descending: true)",
      "          .limit(1)",
      "          .get();",
      "",
      "      if (querySnapshot.docs.isEmpty) {",
      "        print(",
      "            '[FranchiseSubscriptionService] No active subscription found for franchiseId=$franchiseId');",
      "        return null;",
      "      }",
      "",
      "      final doc = querySnapshot.docs.first;",
      "      final sub = FranchiseSubscription.fromMap(doc.id, doc.data());",
      "      print(",
      "          '[FranchiseSubscriptionService] Loaded active subscription: ${sub.platformPlanId}');",
      "      return sub;",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Error loading active subscription: $e',",
      "        stack: stack.toString(),",
      "        source: 'FranchiseSubscriptionService',",
      "        screen: 'getCurrentSubscription',",
      "        severity: 'error',",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "        },",
      "      );",
      "      return null;",
      "    }",
      "  }",
      "",
      "  /// Get active subscription (older alt logic with `.active`)",
      "  Future<FranchiseSubscription?> getActiveSubscriptionForFranchise(",
      "      String franchiseId) async {",
      "    try {",
      "      final snap = await _db",
      "          .collection('franchise_subscriptions')",
      "          .where('franchiseId', isEqualTo: franchiseId)",
      "          .where('active', isEqualTo: true)",
      "          .limit(1)",
      "          .get();",
      "",
      "      if (snap.docs.isEmpty) return null;",
      "",
      "      final doc = snap.docs.first;",
      "      return FranchiseSubscription.fromMap(doc.id, doc.data());",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to get active subscription for franchise',",
      "        source: 'FranchiseSubscriptionService',",
      "        screen: 'franchise_subscription_check',",
      "        severity: 'warning',",
      "        stack: stack.toString(),",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      return null;",
      "    }",
      "  }",
      "",
      "  /// Stream active subscription for a franchise",
      "  Stream<FranchiseSubscription?> watchCurrentSubscription(String franchiseId) {",
      "    try {",
      "      print(",
      "          '[FranchiseSubscriptionService] watchCurrentSubscription: Listening for franchiseId=$franchiseId');",
      "      return _db",
      "          .collection('franchise_subscriptions')",
      "          .where('franchiseId', isEqualTo: franchiseId)",
      "          .where('active', isEqualTo: true)",
      "          .orderBy('startDate', descending: true)",
      "          .limit(1)",
      "          .snapshots()",
      "          .map((snapshot) {",
      "        if (snapshot.docs.isEmpty) {",
      "          print(",
      "              '[FranchiseSubscriptionService] Stream: No active subscription found.');",
      "          return null;",
      "        }",
      "",
      "        final doc = snapshot.docs.first;",
      "        final sub = FranchiseSubscription.fromMap(doc.id, doc.data());",
      "        print(",
      "            '[FranchiseSubscriptionService] Stream: Emitting active subscription: ${sub.platformPlanId}');",
      "        return sub;",
      "      }).handleError((error, stack) async {",
      "        print('[FranchiseSubscriptionService] Stream error: $error');",
      "        await ErrorLogger.log(",
      "          message: 'Stream error in watchCurrentSubscription: $error',",
      "          stack: stack.toString(),",
      "          source: 'FranchiseSubscriptionService',",
      "          screen: 'watchCurrentSubscription',",
      "          severity: 'error',",
      "          contextData: {",
      "            'franchiseId': franchiseId,",
      "          },",
      "        );",
      "      });",
      "    } catch (e, stack) {",
      "      ErrorLogger.log(",
      "        message: 'Failed to initialize watchCurrentSubscription: $e',",
      "        stack: stack.toString(),",
      "        source: 'FranchiseSubscriptionService',",
      "        screen: 'watchCurrentSubscription',",
      "        severity: 'fatal',",
      "        contextData: {",
      "          'franchiseId': franchiseId,",
      "        },",
      "      );",
      "      // Return an empty stream with null",
      "      return Stream.value(null);",
      "    }",
      "  }",
      "",
      "  /// Get subscription by Firestore document ID",
      "",
      "  // ===========================================================================",
      "  // 📦 Platform Plans – Management + Resolution",
      "  // ===========================================================================",
      "",
      "  /// Get a platform plan by ID",
      "  Future<PlatformPlan?> getPlatformPlanById(String planId) async {",
      "    try {",
      "      final doc = await _db.collection('platform_plans').doc(planId).get();",
      "",
      "      if (!doc.exists) {",
      "        await ErrorLogger.log(",
      "          message: 'PlatformPlan not found for ID: $planId',",
      "          source: 'FranchiseSubscriptionService',",
      "          screen: 'plan_resolution_fallback',",
      "          severity: 'warning',",
      "          contextData: {'missingId': planId},",
      "          stack: '',",
      "        );",
      "        return null;",
      "      }",
      "",
      "      return PlatformPlan.fromFirestore(doc);",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Error fetching PlatformPlan by ID: $planId',",
      "        source: 'FranchiseSubscriptionService',",
      "        screen: 'plan_resolution_fallback',",
      "        stack: stack.toString(),",
      "        severity: 'error',",
      "        contextData: {",
      "          'exception': e.toString(),",
      "          'planId': planId,",
      "        },",
      "      );",
      "      return null;",
      "    }",
      "  }",
      "",
      "  /// Get all platform plans",
      "  Future<List<PlatformPlan>> getAllPlatformPlans() async {",
      "    try {",
      "      debugPrint(",
      "          '[FranchiseSubscriptionService] getAllPlatformPlans: Fetching...');",
      "      final snap = await _db.collection('platform_plans').get();",
      "",
      "      final plans = snap.docs.map((doc) {",
      "        final plan = PlatformPlan.fromMap(doc.id, doc.data());",
      "        debugPrint('[FranchiseSubscriptionService] Loaded plan: ${plan.name}');",
      "        return plan;",
      "      }).toList();",
      "",
      "      debugPrint('[FranchiseSubscriptionService] Total plans: ${plans.length}');",
      "      return plans;",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Error loading platform plans: $e',",
      "        stack: stack.toString(),",
      "        source: 'FranchiseSubscriptionService',",
      "        screen: 'getAllPlatformPlans',",
      "        severity: 'error',",
      "      );",
      "      return [];",
      "    }",
      "  }",
      "",
      "  Future<List<PlatformPlan>> getPlatformPlans() async {",
      "    try {",
      "      debugPrint(",
      "          '[FranchiseSubscriptionService] getPlatformPlans: Fetching all plans...');",
      "      final snap = await _db.collection('platform_plans').get();",
      "",
      "      debugPrint(",
      "          '[FranchiseSubscriptionService] Retrieved ${snap.docs.length} documents');",
      "",
      "      final plans = snap.docs.map((doc) {",
      "        final plan = PlatformPlan.fromMap(doc.id, doc.data());",
      "        debugPrint(",
      "            '[FranchiseSubscriptionService] Plan loaded: ${plan.name} (active: ${plan.active})');",
      "        return plan;",
      "      }).toList();",
      "",
      "      debugPrint('[FranchiseSubscriptionService] Parsed ${plans.length} plans');",
      "      return plans;",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Error loading platform plans: $e',",
      "        stack: stack.toString(),",
      "        source: 'FranchiseSubscriptionService',",
      "        screen: 'getPlatformPlans',",
      "        severity: 'error',",
      "      );",
      "      return [];",
      "    }",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 518,
      "file_size": 17908,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\services\\invoice_service.dart",
    "content": [
      "// File: lib/core/services/invoice_service.dart",
      "import 'package:csv/csv.dart';",
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "import 'package:flutter/foundation.dart';",
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/core/models/invoice.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/widgets/dashboard/billing_summary_card.dart';",
      "import 'dart:convert';",
      "import 'dart:io';",
      "import 'package:path_provider/path_provider.dart';",
      "import 'package:franchise_admin_portal/core/models/platform_revenue_overview.dart';",
      "import 'package:franchise_admin_portal/core/services/payout_service.dart';",
      "import 'package:franchise_admin_portal/core/models/platform_financial_kpis.dart';",
      "",
      "/// Service class handling all Invoice-related Firestore operations.",
      "/// Integrates error logging, supports filtering, streaming, and atomic updates.",
      "/// Designed for franchise SaaS billing system.",
      "",
      "class InvoiceService {",
      "  final FirebaseFirestore _db;",
      "",
      "  InvoiceService({FirebaseFirestore? firestore})",
      "      : _db = firestore ?? FirebaseFirestore.instance;",
      "",
      "  /// Adds a new invoice or updates existing invoice document.",
      "  Future<void> addOrUpdateInvoice(Invoice invoice) async {",
      "    try {",
      "      await _db",
      "          .collection('invoices')",
      "          .doc(invoice.id)",
      "          .set(invoice.toFirestore(), SetOptions(merge: true));",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: e.toString(),",
      "        stack: stack.toString(),",
      "        source: 'InvoiceService',",
      "        screen: 'addOrUpdateInvoice',",
      "        severity: 'error',",
      "        contextData: {'invoiceId': invoice.id},",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Retrieves invoice by ID, or null if not found.",
      "  Future<Invoice?> getInvoiceById(String id) async {",
      "    try {",
      "      final doc = await _db.collection('invoices').doc(id).get();",
      "      if (!doc.exists || doc.data() == null) return null;",
      "      return Invoice.fromFirestore(doc.data()!, doc.id);",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: e.toString(),",
      "        stack: stack.toString(),",
      "        source: 'InvoiceService',",
      "        screen: 'getInvoiceById',",
      "        severity: 'error',",
      "        contextData: {'invoiceId': id},",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Deletes invoice document by ID.",
      "  Future<void> deleteInvoice(String id) async {",
      "    try {",
      "      await _db.collection('invoices').doc(id).delete();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: e.toString(),",
      "        stack: stack.toString(),",
      "        source: 'InvoiceService',",
      "        screen: 'deleteInvoice',",
      "        severity: 'error',",
      "        contextData: {'invoiceId': id},",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Streams invoices with optional filters.",
      "  /// Supports filtering by franchiseId, brandId, locationId, status, date ranges.",
      "  Stream<List<Invoice>> invoicesStream({",
      "    String? franchiseId,",
      "    String? brandId,",
      "    String? locationId,",
      "    String? status,",
      "    DateTime? startDate,",
      "    DateTime? endDate,",
      "  }) {",
      "    Query query = _db.collection('invoices');",
      "",
      "    if (franchiseId != null) {",
      "      query = query.where('franchiseId', isEqualTo: franchiseId);",
      "    }",
      "    if (brandId != null) {",
      "      query = query.where('brandId', isEqualTo: brandId);",
      "    }",
      "    if (locationId != null) {",
      "      query = query.where('locationId', isEqualTo: locationId);",
      "    }",
      "    if (status != null) {",
      "      query = query.where('status', isEqualTo: status);",
      "    }",
      "    if (startDate != null) {",
      "      query = query.where('period_start',",
      "          isGreaterThanOrEqualTo: Timestamp.fromDate(startDate));",
      "    }",
      "    if (endDate != null) {",
      "      query = query.where('period_end',",
      "          isLessThanOrEqualTo: Timestamp.fromDate(endDate));",
      "    }",
      "",
      "    return query.snapshots().map((snap) => snap.docs",
      "        .map((doc) =>",
      "            Invoice.fromFirestore(doc.data() as Map<String, dynamic>, doc.id))",
      "        .toList());",
      "  }",
      "",
      "  /// Updates the dunning state of an invoice.",
      "  Future<void> updateInvoiceDunningState(",
      "      String invoiceId, String dunningState) async {",
      "    try {",
      "      await _db.collection('invoices').doc(invoiceId).update({",
      "        'dunning_state': dunningState,",
      "        'updated_at': FieldValue.serverTimestamp(),",
      "      });",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: e.toString(),",
      "        stack: stack.toString(),",
      "        source: 'InvoiceService',",
      "        screen: 'updateInvoiceDunningState',",
      "        severity: 'error',",
      "        contextData: {'invoiceId': invoiceId, 'dunningState': dunningState},",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Adds an overdue reminder to the invoice (atomic arrayUnion).",
      "  Future<void> addInvoiceOverdueReminder(",
      "      String invoiceId, Map<String, dynamic> reminder) async {",
      "    try {",
      "      await _db.collection('invoices').doc(invoiceId).update({",
      "        'overdue_reminders': FieldValue.arrayUnion([reminder]),",
      "        'updated_at': FieldValue.serverTimestamp(),",
      "      });",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: e.toString(),",
      "        stack: stack.toString(),",
      "        source: 'InvoiceService',",
      "        screen: 'addInvoiceOverdueReminder',",
      "        severity: 'error',",
      "        contextData: {'invoiceId': invoiceId},",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Sets or updates a payment plan object for an invoice.",
      "  Future<void> setInvoicePaymentPlan(",
      "      String invoiceId, Map<String, dynamic> paymentPlan) async {",
      "    try {",
      "      await _db.collection('invoices').doc(invoiceId).update({",
      "        'payment_plan': paymentPlan,",
      "        'updated_at': FieldValue.serverTimestamp(),",
      "      });",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: e.toString(),",
      "        stack: stack.toString(),",
      "        source: 'InvoiceService',",
      "        screen: 'setInvoicePaymentPlan',",
      "        severity: 'error',",
      "        contextData: {'invoiceId': invoiceId},",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Adds an escalation event/history entry (atomic arrayUnion).",
      "  Future<void> addInvoiceEscalationEvent(",
      "      String invoiceId, Map<String, dynamic> escalationEvent) async {",
      "    try {",
      "      await _db.collection('invoices').doc(invoiceId).update({",
      "        'escalation_history': FieldValue.arrayUnion([escalationEvent]),",
      "        'updated_at': FieldValue.serverTimestamp(),",
      "      });",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: e.toString(),",
      "        stack: stack.toString(),",
      "        source: 'InvoiceService',",
      "        screen: 'addInvoiceEscalationEvent',",
      "        severity: 'error',",
      "        contextData: {'invoiceId': invoiceId},",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Fetches dunning workflow related fields for an invoice.",
      "  Future<Map<String, dynamic>?> getInvoiceWorkflowFields(",
      "      String invoiceId) async {",
      "    try {",
      "      final doc = await _db.collection('invoices').doc(invoiceId).get();",
      "      if (!doc.exists) return null;",
      "      final data = doc.data()!;",
      "      return {",
      "        'dunning_state': data['dunning_state'],",
      "        'overdue_reminders': data['overdue_reminders'],",
      "        'payment_plan': data['payment_plan'],",
      "        'escalation_history': data['escalation_history'],",
      "      };",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: e.toString(),",
      "        stack: stack.toString(),",
      "        source: 'InvoiceService',",
      "        screen: 'getInvoiceWorkflowFields',",
      "        severity: 'error',",
      "        contextData: {'invoiceId': invoiceId},",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Removes payment plan from invoice.",
      "  Future<void> removeInvoicePaymentPlan(String invoiceId) async {",
      "    try {",
      "      await _db.collection('invoices').doc(invoiceId).update({",
      "        'payment_plan': FieldValue.delete(),",
      "        'updated_at': FieldValue.serverTimestamp(),",
      "      });",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: e.toString(),",
      "        stack: stack.toString(),",
      "        source: 'InvoiceService',",
      "        screen: 'removeInvoicePaymentPlan',",
      "        severity: 'error',",
      "        contextData: {'invoiceId': invoiceId},",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Adds a support note (atomic arrayUnion).",
      "  Future<void> addInvoiceSupportNote(",
      "      String invoiceId, Map<String, dynamic> note) async {",
      "    try {",
      "      await _db.collection('invoices').doc(invoiceId).update({",
      "        'support_notes': FieldValue.arrayUnion([note]),",
      "        'updated_at': FieldValue.serverTimestamp(),",
      "      });",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: e.toString(),",
      "        stack: stack.toString(),",
      "        source: 'InvoiceService',",
      "        screen: 'addInvoiceSupportNote',",
      "        severity: 'error',",
      "        contextData: {'invoiceId': invoiceId},",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Adds an attachment (atomic arrayUnion).",
      "  Future<void> addInvoiceAttachment(",
      "      String invoiceId, Map<String, dynamic> attachment) async {",
      "    try {",
      "      await _db.collection('invoices').doc(invoiceId).update({",
      "        'attached_files': FieldValue.arrayUnion([attachment]),",
      "        'updated_at': FieldValue.serverTimestamp(),",
      "      });",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: e.toString(),",
      "        stack: stack.toString(),",
      "        source: 'InvoiceService',",
      "        screen: 'addInvoiceAttachment',",
      "        severity: 'error',",
      "        contextData: {'invoiceId': invoiceId},",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  static Future<BillingSummaryData> getBillingSummary(",
      "      {required String franchiseId}) async {",
      "    // Example Firestore structure (adjust as needed)",
      "    final invoices = await FirebaseFirestore.instance",
      "        .collection('invoices')",
      "        .where('franchiseId', isEqualTo: franchiseId)",
      "        .get();",
      "    double outstanding = 0;",
      "    int overdue = 0;",
      "    double paidLast30 = 0;",
      "    final now = DateTime.now();",
      "    for (var doc in invoices.docs) {",
      "      final data = doc.data();",
      "      if (data['status'] == 'overdue') overdue++;",
      "      if (data['status'] == 'unpaid' || data['status'] == 'overdue') {",
      "        outstanding += (data['amount_due'] ?? 0) * 1.0;",
      "      }",
      "      if (data['status'] == 'paid') {",
      "        final paidDate = (data['paid_at'] as Timestamp?)?.toDate();",
      "        if (paidDate != null && now.difference(paidDate).inDays <= 30) {",
      "          paidLast30 += (data['amount_paid'] ?? 0) * 1.0;",
      "        }",
      "      }",
      "    }",
      "    return BillingSummaryData(",
      "      totalOutstanding: outstanding,",
      "      overdueCount: overdue,",
      "      paidLast30Days: paidLast30,",
      "    );",
      "  }",
      "",
      "  static Future<String> downloadSummary({",
      "    required String franchiseId,",
      "    BuildContext? context,",
      "  }) async {",
      "    try {",
      "      // 1. Query all invoices for the franchise",
      "      final invoices = await FirebaseFirestore.instance",
      "          .collection('invoices')",
      "          .where('franchiseId', isEqualTo: franchiseId)",
      "          .get();",
      "",
      "      // 2. Prepare CSV rows",
      "      final csvRows = <List<String>>[",
      "        [",
      "          'Invoice ID',",
      "          'Status',",
      "          'Amount Due',",
      "          'Amount Paid',",
      "          'Due Date',",
      "          'Paid At',",
      "          'Created At'",
      "        ]",
      "      ];",
      "      for (var doc in invoices.docs) {",
      "        final data = doc.data();",
      "        csvRows.add([",
      "          doc.id,",
      "          data['status']?.toString() ?? '',",
      "          (data['amount_due'] ?? '').toString(),",
      "          (data['amount_paid'] ?? '').toString(),",
      "          (data['due_date'] is Timestamp)",
      "              ? (data['due_date'] as Timestamp).toDate().toIso8601String()",
      "              : '',",
      "          (data['paid_at'] is Timestamp)",
      "              ? (data['paid_at'] as Timestamp).toDate().toIso8601String()",
      "              : '',",
      "          (data['created_at'] is Timestamp)",
      "              ? (data['created_at'] as Timestamp).toDate().toIso8601String()",
      "              : '',",
      "        ]);",
      "      }",
      "      final csvString =",
      "          const ListToCsvConverter().convert(csvRows); // Uses csv package",
      "",
      "      // 3. Save to file (for mobile/desktop), or return string (web)",
      "      if (kIsWeb) {",
      "        // Web: just return the CSV string for triggering download",
      "        return csvString;",
      "      } else {",
      "        // Mobile/Desktop: save to Downloads or App Directory",
      "        final directory = await getApplicationDocumentsDirectory();",
      "        final filePath =",
      "            '${directory.path}/billing_summary_${DateTime.now().millisecondsSinceEpoch}.csv';",
      "        final file = File(filePath);",
      "        await file.writeAsString(csvString);",
      "        return filePath;",
      "      }",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'downloadSummary failed: $e',",
      "        stack: stack.toString(),",
      "        source: 'InvoiceService',",
      "        screen: 'downloadSummary',",
      "        severity: 'error',",
      "        contextData: {'franchiseId': franchiseId},",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Platform-wide aggregate: Returns revenue, subscription, royalty, overdue for YTD.",
      "  Future<PlatformRevenueOverview> fetchPlatformRevenueOverview() async {",
      "    try {",
      "      final now = DateTime.now();",
      "      final ytdStart = DateTime(now.year, 1, 1);",
      "",
      "      final query = _db.collection('invoices').where('period_start',",
      "          isGreaterThanOrEqualTo: Timestamp.fromDate(ytdStart));",
      "",
      "      final invoices = await query.get();",
      "",
      "      double totalRevenueYtd = 0;",
      "      double subscriptionRevenue = 0;",
      "      double royaltyRevenue = 0;",
      "      double overdueAmount = 0;",
      "",
      "      for (var doc in invoices.docs) {",
      "        final data = doc.data();",
      "        final amountDue = (data['amount_due'] ?? 0).toDouble();",
      "        final status = data['status']?.toString();",
      "        final type = data['type']?.toString()?.toLowerCase() ?? '';",
      "",
      "        // Sum revenue by type",
      "        totalRevenueYtd += amountDue;",
      "        if (type == 'subscription') {",
      "          subscriptionRevenue += amountDue;",
      "        } else if (type == 'royalty') {",
      "          royaltyRevenue += amountDue;",
      "        }",
      "",
      "        // Overdue",
      "        if (status == 'overdue' || status == 'unpaid') {",
      "          overdueAmount += amountDue;",
      "        }",
      "      }",
      "",
      "      return PlatformRevenueOverview(",
      "        totalRevenueYtd: totalRevenueYtd,",
      "        subscriptionRevenue: subscriptionRevenue,",
      "        royaltyRevenue: royaltyRevenue,",
      "        overdueAmount: overdueAmount,",
      "      );",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: e.toString(),",
      "        stack: stack.toString(),",
      "        source: 'InvoiceService',",
      "        screen: 'fetchPlatformRevenueOverview',",
      "        severity: 'error',",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Platform-wide KPIs: MRR, ARR, Active Franchises, Recent Payouts.",
      "  /// Assumes MRR = current month's subscription invoices; ARR = MRR * 12.",
      "  Future<PlatformFinancialKpis> fetchPlatformFinancialKpis() async {",
      "    try {",
      "      final now = DateTime.now();",
      "      final startOfMonth = DateTime(now.year, now.month, 1);",
      "",
      "      // Get all invoices for this month, type: subscription",
      "      final subQuery = _db",
      "          .collection('invoices')",
      "          .where('type', isEqualTo: 'subscription')",
      "          .where('period_start',",
      "              isGreaterThanOrEqualTo: Timestamp.fromDate(startOfMonth));",
      "      final subInvoices = await subQuery.get();",
      "",
      "      double mrr = 0;",
      "      for (var doc in subInvoices.docs) {",
      "        final data = doc.data();",
      "        mrr += (data['amount_due'] ?? 0).toDouble();",
      "      }",
      "      double arr = mrr * 12;",
      "",
      "      // Count active franchises (any invoice this month)",
      "      final activeFranchiseIds = <String>{};",
      "      for (var doc in subInvoices.docs) {",
      "        final data = doc.data();",
      "        final franchiseId = data['franchiseId']?.toString();",
      "        if (franchiseId != null && franchiseId.isNotEmpty) {",
      "          activeFranchiseIds.add(franchiseId);",
      "        }",
      "      }",
      "",
      "      // Get payouts for past 30 days (delegate to PayoutService for platform-wide)",
      "      final recentPayouts =",
      "          await PayoutService().sumRecentPlatformPayouts(days: 30);",
      "",
      "      return PlatformFinancialKpis(",
      "        mrr: mrr,",
      "        arr: arr,",
      "        activeFranchises: activeFranchiseIds.length,",
      "        recentPayouts: recentPayouts,",
      "      );",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: e.toString(),",
      "        stack: stack.toString(),",
      "        source: 'InvoiceService',",
      "        screen: 'fetchPlatformFinancialKpis',",
      "        severity: 'error',",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 501,
      "file_size": 16637,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\services\\notification_service.dart",
    "content": [
      "import 'package:firebase_messaging/firebase_messaging.dart';",
      "import 'package:logging/logging.dart';",
      "import 'package:franchise_admin_portal/config/feature_config.dart';",
      "",
      "class NotificationService {",
      "  late final FirebaseMessaging _messaging;",
      "  final Logger _logger = Logger('NotificationService');",
      "",
      "  static final NotificationService _instance = NotificationService._internal();",
      "  NotificationService._internal() {",
      "    _messaging = FirebaseMessaging.instance;",
      "  }",
      "",
      "  static NotificationService get instance => _instance;",
      "",
      "  /// Call this at app startup to request notification permissions and set up handlers.",
      "  Future<void> initialize() async {",
      "    try {",
      "      NotificationSettings settings = await _messaging.requestPermission();",
      "      if (settings.authorizationStatus == AuthorizationStatus.authorized) {",
      "        _logger.info('Notification permission granted');",
      "      } else {",
      "        _logger.warning('Notification permission denied: $settings');",
      "      }",
      "",
      "      FirebaseMessaging.onMessage.listen((RemoteMessage message) {",
      "        _logger.info(",
      "            'Received foreground notification: ${message.notification?.title}');",
      "        // Optionally, handle notification display in-app here",
      "      });",
      "",
      "      FirebaseMessaging.onBackgroundMessage(",
      "          _firebaseMessagingBackgroundHandler);",
      "    } catch (e) {",
      "      _logger.severe('Notification initialization error: $e');",
      "    }",
      "  }",
      "",
      "  /// Returns the current device's FCM token (for push notifications).",
      "  Future<String?> getToken() async {",
      "    try {",
      "      return await _messaging.getToken();",
      "    } catch (e) {",
      "      _logger.severe('Error getting FCM token: $e');",
      "      return null;",
      "    }",
      "  }",
      "",
      "  /// Simulate sending a notification.",
      "  /// In production, POST to your backend server which will send via FCM Admin SDK.",
      "  Future<void> sendNotification(String token, String title, String body) async {",
      "    _logger.info('Request to send notification to $token: $title - $body');",
      "    if (!FeatureConfig.instance.statusEnabled) {",
      "      _logger.info('Notifications are disabled by feature toggle.');",
      "      return;",
      "    }",
      "    // Note: For Flutter web, direct client-to-client notifications are NOT possible.",
      "    // Your backend (Node.js, Python, etc) must send notifications via FCM Admin SDK.",
      "    // This is just a stub for admin simulation/testing.",
      "  }",
      "}",
      "",
      "/// Handler for background push notifications.",
      "/// Register this in your main() with FirebaseMessaging.onBackgroundMessage.",
      "Future<void> _firebaseMessagingBackgroundHandler(RemoteMessage message) async {",
      "  Logger('NotificationService')",
      "      .info('Handling background message: ${message.notification?.title}');",
      "  // Implement any background logic here, e.g., updating badges, state, etc.",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 69,
      "file_size": 2761,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\services\\payout_service.dart",
    "content": [
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "/// Service class for platform-wide and franchise payout operations.",
      "/// Integrates error logging and Firestore queries for SaaS use.",
      "class PayoutService {",
      "  final FirebaseFirestore _db;",
      "",
      "  PayoutService({FirebaseFirestore? firestore})",
      "      : _db = firestore ?? FirebaseFirestore.instance;",
      "",
      "  /// Returns the sum of all payouts across the platform in the past [days] days.",
      "  Future<double> sumRecentPlatformPayouts({int days = 30}) async {",
      "    try {",
      "      final now = DateTime.now();",
      "      final since = now.subtract(Duration(days: days));",
      "      final query = _db.collection('payouts').where('created_at',",
      "          isGreaterThanOrEqualTo: Timestamp.fromDate(since));",
      "      final docs = await query.get();",
      "",
      "      double sum = 0;",
      "      for (var doc in docs.docs) {",
      "        final data = doc.data();",
      "        sum += (data['amount'] ?? 0).toDouble();",
      "      }",
      "      return sum;",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: e.toString(),",
      "        stack: stack.toString(),",
      "        source: 'PayoutService',",
      "        screen: 'sumRecentPlatformPayouts',",
      "        severity: 'error',",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  // 💡 Future Feature Placeholder:",
      "  // Add more aggregation, filtering, and payout-related methods here for the platform/HQ/franchise levels as needed.",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 41,
      "file_size": 1455,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\services\\promo_service.dart",
    "content": [
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "import 'package:logging/logging.dart';",
      "import 'package:franchise_admin_portal/core/models/promo.dart';",
      "",
      "class PromoService {",
      "  late final FirebaseFirestore _db;",
      "  final Logger _logger = Logger('PromoService');",
      "",
      "  PromoService() {",
      "    _db = FirebaseFirestore.instance;",
      "  }",
      "",
      "  // Apply a promo to the cart",
      "  Future<bool> applyPromo(String franchiseId, String promoId, String userId,",
      "      List<dynamic> cartItems) async {",
      "    try {",
      "      DocumentSnapshot promoDoc = await _db",
      "          .collection('franchises')",
      "          .doc(franchiseId)",
      "          .collection('promotions')",
      "          .doc(promoId)",
      "          .get();",
      "",
      "      if (!promoDoc.exists) {",
      "        _logger.warning('Promo $promoId does not exist');",
      "        return false;",
      "      }",
      "",
      "      Promo promo =",
      "          Promo.fromFirestore(promoDoc.data() as Map<String, dynamic>, promoId);",
      "",
      "      if (!promo.active || promo.endDate.isBefore(DateTime.now())) {",
      "        _logger.warning('Promo $promoId is inactive or expired');",
      "        return false;",
      "      }",
      "",
      "      // Validate minimum order value",
      "      double cartTotal = cartItems.fold(",
      "          0.0, (total, item) => total + (item['price'] * item['quantity']));",
      "      if (cartTotal < promo.minOrderValue) {",
      "        _logger.warning(",
      "            'Cart total $cartTotal is below promo minimum ${promo.minOrderValue}');",
      "        return false;",
      "      }",
      "",
      "      // Validate applicable items",
      "      if (promo.items.isNotEmpty) {",
      "        bool validItems =",
      "            cartItems.any((item) => promo.items.contains(item['itemId']));",
      "        if (!validItems) {",
      "          _logger.warning('No applicable items for promo $promoId');",
      "          return false;",
      "        }",
      "      }",
      "",
      "      // Check max uses",
      "      if (promo.maxUses > 0) {",
      "        if (promo.maxUsesType == 'total') {",
      "          QuerySnapshot uses = await _db",
      "              .collection('franchises')",
      "              .doc(franchiseId)",
      "              .collection('orders')",
      "              .where('promoId', isEqualTo: promoId)",
      "              .get();",
      "          if (uses.docs.length >= promo.maxUses) {",
      "            _logger.warning('Promo $promoId has reached max uses');",
      "            return false;",
      "          }",
      "        } else if (promo.maxUsesType == 'per_user') {",
      "          QuerySnapshot uses = await _db",
      "              .collection('franchises')",
      "              .doc(franchiseId)",
      "              .collection('orders')",
      "              .where('userId', isEqualTo: userId)",
      "              .where('promoId', isEqualTo: promoId)",
      "              .get();",
      "          if (uses.docs.length >= promo.maxUses) {",
      "            _logger.warning(",
      "                'User $userId has reached max uses for promo $promoId');",
      "            return false;",
      "          }",
      "        }",
      "      }",
      "",
      "      // Apply promo to cart (update cart with discount)",
      "      _logger.info('Applying promo $promoId to cart for user $userId');",
      "      // TODO: Update cart with promo discount",
      "      return true;",
      "    } catch (e) {",
      "      _logger.severe('Error applying promo $promoId: $e');",
      "      return false;",
      "    }",
      "  }",
      "",
      "  // Fetch available promos",
      "  Stream<List<Promo>> getAvailablePromos(String franchiseId) {",
      "    return _db",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection('promotions')",
      "        .where('active', isEqualTo: true)",
      "        .where('endDate', isGreaterThan: Timestamp.now())",
      "        .snapshots()",
      "        .map((snapshot) => snapshot.docs",
      "            .map((doc) => Promo.fromFirestore(doc.data(), doc.id))",
      "            .toList());",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 108,
      "file_size": 3597,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\services\\enrichment\\franchise_subscription_enricher.dart",
    "content": [
      "import 'package:franchise_admin_portal/core/models/franchise_subscription_model.dart';",
      "import 'package:franchise_admin_portal/core/models/enriched/enriched_franchise_subscription.dart';",
      "import 'package:franchise_admin_portal/core/models/user.dart' as app_user;",
      "import 'package:franchise_admin_portal/core/models/franchise_info.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:flutter/material.dart';",
      "",
      "/// Utility to batch enrich franchise subscriptions with franchise + owner data.",
      "class FranchiseSubscriptionEnricher {",
      "  final FirestoreService firestoreService;",
      "",
      "  FranchiseSubscriptionEnricher(this.firestoreService);",
      "",
      "  /// Fetches enriched data for all franchise subscriptions.",
      "  Future<List<EnrichedFranchiseSubscription>> enrichAllSubscriptions() async {",
      "    try {",
      "      final subscriptions =",
      "          await firestoreService.getAllFranchiseSubscriptions();",
      "      final franchiseIds = subscriptions.map((s) => s.franchiseId).toSet();",
      "",
      "      final franchises = await firestoreService.fetchFranchiseList();",
      "      final Map<String, FranchiseInfo> franchiseMap = {",
      "        for (final f in franchises) f.id: f",
      "      };",
      "",
      "      final users = await firestoreService.getAllUsers();",
      "      final Map<String, app_user.User> tempMap = {};",
      "      for (final u in users) {",
      "        for (final fid in u.franchiseIds) {",
      "          tempMap.putIfAbsent(",
      "              fid, () => u); // inserts only first user per franchise",
      "        }",
      "      }",
      "      final ownerMap = tempMap;",
      "      debugPrint('[Enricher] Loaded ${users.length} users for owner mapping');",
      "      for (final entry in ownerMap.entries) {",
      "        debugPrint(",
      "          '[Enricher] FranchiseId: ${entry.key} → Owner: ${entry.value.name} (${entry.value.email})',",
      "        );",
      "      }",
      "",
      "      return subscriptions.map((sub) {",
      "        return EnrichedFranchiseSubscription(",
      "          subscription: sub,",
      "          franchise: franchiseMap[sub.franchiseId],",
      "          owner: ownerMap[sub.franchiseId],",
      "        );",
      "      }).toList();",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to enrich subscriptions',",
      "        source: 'FranchiseSubscriptionEnricher',",
      "        screen: 'franchise_subscription_enricher',",
      "        severity: 'error',",
      "        stack: stack.toString(),",
      "      );",
      "      return [];",
      "    }",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 61,
      "file_size": 2453,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\utils\\error_logger.dart",
    "content": [
      "import 'dart:convert';",
      "import 'package:http/http.dart' as http;",
      "import 'package:firebase_auth/firebase_auth.dart';",
      "import 'package:firebase_core/firebase_core.dart';",
      "",
      "/// Robust Error Logger for all app error logging.",
      "/// Routes unauth/public errors to logPublicError function.",
      "/// Routes authenticated errors to logAppError function.",
      "class ErrorLogger {",
      "  static const String _publicLogUrl =",
      "      'https://us-central1-doughboyspizzeria-2b3d2.cloudfunctions.net/logPublicError';",
      "  static const String _privateLogUrl =",
      "      'https://us-central1-doughboyspizzeria-2b3d2.cloudfunctions.net/logAppError';",
      "",
      "  /// Logs an error to the appropriate endpoint based on authentication status.",
      "  /// Optionally pass extra [contextData] for deeper troubleshooting.",
      "  static Future<void> log({",
      "    required String message,",
      "    String? stack,",
      "    String? source,",
      "    String? severity,",
      "    String? screen,",
      "    Map<String, dynamic>? contextData,",
      "  }) async {",
      "    if (Firebase.apps.isEmpty) {",
      "      print('[ErrorLogger] log() called before Firebase initialized!');",
      "      // Optionally: fallback to console-only log or queue for later, if needed.",
      "      return;",
      "    }",
      "",
      "    final user = FirebaseAuth.instance.currentUser;",
      "    final isAuthenticated = user != null;",
      "",
      "    final url = isAuthenticated ? _privateLogUrl : _publicLogUrl;",
      "",
      "    // Always enrich with basic info",
      "    final enrichedContext = <String, dynamic>{",
      "      ...?contextData,",
      "      if (isAuthenticated) 'userId': user!.uid,",
      "      if (isAuthenticated && user.email != null) 'userEmail': user.email,",
      "    };",
      "",
      "    final body = {",
      "      'message': message,",
      "      'stack': stack ?? '',",
      "      'source': source ?? '',",
      "      'severity': severity ?? (isAuthenticated ? 'error' : 'public'),",
      "      'screen': screen ?? '',",
      "      'contextData': enrichedContext,",
      "    };",
      "",
      "    try {",
      "      final response = await http.post(",
      "        Uri.parse(url),",
      "        headers: {'Content-Type': 'application/json'},",
      "        body: jsonEncode(body),",
      "      );",
      "",
      "      if (response.statusCode != 200) {",
      "        // Log to console if the server endpoint failed",
      "        print(",
      "            '[ErrorLogger] Failed to log error to $url: ${response.statusCode} ${response.body}');",
      "      }",
      "    } catch (e, st) {",
      "      print('[ErrorLogger] Exception during error log: $e\\n$st');",
      "    }",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 68,
      "file_size": 2356,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\utils\\export_utils.dart",
    "content": [
      "// File: lib/core/utils/export_utils.dart",
      "",
      "import 'dart:convert';",
      "import 'package:franchise_admin_portal/core/models/invoice.dart';",
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/models/analytics_summary.dart';",
      "import 'package:franchise_admin_portal/core/models/audit_log.dart';",
      "import 'package:franchise_admin_portal/core/models/category.dart';",
      "import 'package:franchise_admin_portal/core/models/menu_item.dart';",
      "import 'package:franchise_admin_portal/core/models/promo.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "/// =======================",
      "/// ExportUtils",
      "/// =======================",
      "/// Helper functions for exporting lists of app models to CSV or JSON.",
      "/// Designed for admin backup, data auditing, and export/download screens.",
      "/// Integrates localization and error logging.",
      "/// =======================",
      "",
      "class ExportUtils {",
      "  ExportUtils._();",
      "",
      "  /// Exports a list of MenuItem objects to CSV string.",
      "  /// Includes key fields, nutrition, tags, and customizations as JSON.",
      "  static String menuItemsToCsv(BuildContext context, List<MenuItem> items) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[ExportUtils] loc is null! Localization not available for this context.');",
      "      return 'Localization missing! [debug]';",
      "    }",
      "    final csv = StringBuffer();",
      "    try {",
      "      csv.writeln([",
      "        loc.menuItemId,",
      "        loc.menuItemName,",
      "        loc.category,",
      "        loc.categoryId,",
      "        loc.description,",
      "        loc.price,",
      "        loc.availability,",
      "        loc.taxCategory,",
      "        loc.sku,",
      "        loc.image,",
      "        loc.dietaryTags,",
      "        loc.allergens,",
      "        loc.prepTime,",
      "        loc.nutrition,",
      "        loc.customizations,",
      "        loc.customizationGroups,",
      "      ].map(_escape).join(','));",
      "",
      "      for (final item in items) {",
      "        csv.writeln([",
      "          _escape(item.id),",
      "          _escape(item.name),",
      "          _escape(item.category),",
      "          _escape(item.categoryId ?? ''),",
      "          _escape(item.description),",
      "          item.price.toStringAsFixed(2),",
      "          item.availability ? 'TRUE' : 'FALSE',",
      "          _escape(item.taxCategory),",
      "          _escape(item.sku ?? ''),",
      "          _escape(item.image ?? ''),",
      "          _escape(item.dietaryTags.join(';')),",
      "          _escape(item.allergens.join(';')),",
      "          item.prepTime?.toString() ?? '',",
      "          _escape(jsonEncode(item.nutrition?.toMap() ?? {})),",
      "          _escape(",
      "              jsonEncode(item.customizations.map((c) => c.toMap()).toList())),",
      "          _escape(jsonEncode(item.customizationGroups ?? [])),",
      "        ].join(','));",
      "      }",
      "    } catch (e, stack) {",
      "      ErrorLogger.log(",
      "        message: e.toString(),",
      "        stack: stack.toString(),",
      "        source: 'ExportUtils',",
      "        screen: 'menuItemsToCsv',",
      "        severity: 'error',",
      "        contextData: {'itemCount': items.length},",
      "      );",
      "    }",
      "    return csv.toString();",
      "  }",
      "",
      "  /// Exports a list of Category objects to CSV string.",
      "  static String categoriesToCsv(BuildContext context, List<Category> cats) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[ExportUtils] loc is null! Localization not available for this context.');",
      "      return 'Localization missing! [debug]';",
      "    }",
      "    final csv = StringBuffer();",
      "    try {",
      "      csv.writeln([",
      "        loc.categoryId,",
      "        loc.categoryName,",
      "        loc.description,",
      "        loc.image,",
      "      ].map(_escape).join(','));",
      "",
      "      for (final c in cats) {",
      "        csv.writeln([",
      "          _escape(c.id),",
      "          _escape(c.name),",
      "          _escape(c.description ?? ''),",
      "          _escape(c.image ?? ''),",
      "        ].join(','));",
      "      }",
      "    } catch (e, stack) {",
      "      ErrorLogger.log(",
      "        message: e.toString(),",
      "        stack: stack.toString(),",
      "        source: 'ExportUtils',",
      "        screen: 'categoriesToCsv',",
      "        severity: 'error',",
      "        contextData: {'categoryCount': cats.length},",
      "      );",
      "    }",
      "    return csv.toString();",
      "  }",
      "",
      "  /// Exports a list of AuditLog entries to CSV.",
      "  static String auditLogsToCsv(BuildContext context, List<AuditLog> logs) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[ExportUtils] loc is null! Localization not available for this context.');",
      "      return 'Localization missing! [debug]';",
      "    }",
      "    final csv = StringBuffer();",
      "    try {",
      "      csv.writeln([",
      "        loc.auditLogId,",
      "        loc.action,",
      "        loc.userId,",
      "        loc.timestamp,",
      "        loc.ipAddress,",
      "        loc.details,",
      "      ].map(_escape).join(','));",
      "",
      "      for (final log in logs) {",
      "        csv.writeln([",
      "          _escape(log.id),",
      "          _escape(log.action),",
      "          _escape(log.userId),",
      "          _escape(log.timestamp.toIso8601String()),",
      "          _escape(log.ipAddress ?? ''),",
      "          _escape(jsonEncode(log.details ?? {})),",
      "        ].join(','));",
      "      }",
      "    } catch (e, stack) {",
      "      ErrorLogger.log(",
      "        message: e.toString(),",
      "        stack: stack.toString(),",
      "        source: 'ExportUtils',",
      "        screen: 'auditLogsToCsv',",
      "        severity: 'error',",
      "        contextData: {'logCount': logs.length},",
      "      );",
      "    }",
      "    return csv.toString();",
      "  }",
      "",
      "  /// Exports a list of Promo objects to CSV string.",
      "  static String promosToCsv(BuildContext context, List<Promo> promos) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[ExportUtils] loc is null! Localization not available for this context.');",
      "      return 'Localization missing! [debug]';",
      "    }",
      "    final csv = StringBuffer();",
      "    try {",
      "      csv.writeln([",
      "        loc.promoId,",
      "        loc.name,",
      "        loc.description,",
      "        loc.discount,",
      "        loc.code,",
      "        loc.active,",
      "        loc.type,",
      "        loc.applicableItems,",
      "        loc.maxUses,",
      "        loc.maxUsesType,",
      "        loc.minOrderValue,",
      "        loc.startDate,",
      "        loc.endDate,",
      "        loc.segment,",
      "        loc.timeRules,",
      "      ].map(_escape).join(','));",
      "",
      "      for (final promo in promos) {",
      "        csv.writeln([",
      "          _escape(promo.id),",
      "          _escape(promo.name),",
      "          _escape(promo.description ?? ''),",
      "          promo.discount.toStringAsFixed(2),",
      "          _escape(promo.code ?? ''),",
      "          promo.active ? 'TRUE' : 'FALSE',",
      "          _escape(promo.type ?? ''),",
      "          _escape(jsonEncode(promo.applicableItems ?? [])),",
      "          promo.maxUses?.toString() ?? '',",
      "          _escape(promo.maxUsesType ?? ''),",
      "          promo.minOrderValue?.toString() ?? '',",
      "          promo.startDate?.toIso8601String() ?? '',",
      "          promo.endDate?.toIso8601String() ?? '',",
      "          _escape(jsonEncode(promo.segment ?? {})),",
      "          _escape(jsonEncode(promo.timeRules ?? {})),",
      "        ].join(','));",
      "      }",
      "    } catch (e, stack) {",
      "      ErrorLogger.log(",
      "        message: e.toString(),",
      "        stack: stack.toString(),",
      "        source: 'ExportUtils',",
      "        screen: 'promosToCsv',",
      "        severity: 'error',",
      "        contextData: {'promoCount': promos.length},",
      "      );",
      "    }",
      "    return csv.toString();",
      "  }",
      "",
      "  /// Exports a single AnalyticsSummary to CSV string (single row).",
      "  static String analyticsSummaryToCsv(",
      "      BuildContext context, AnalyticsSummary summary) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[ExportUtils] loc is null! Localization not available for this context.');",
      "      return 'Localization missing! [debug]';",
      "    }",
      "    final csv = StringBuffer();",
      "    try {",
      "      csv.writeln([",
      "        loc.period,",
      "        loc.totalOrders,",
      "        loc.totalRevenue,",
      "        loc.averageOrderValue,",
      "        loc.mostPopularItem,",
      "        loc.retention,",
      "        loc.uniqueCustomers,",
      "        loc.cancelledOrders,",
      "        loc.addOnRevenue,",
      "        loc.toppingCounts,",
      "        loc.comboCounts,",
      "        loc.addOnCounts,",
      "        loc.orderStatusBreakdown,",
      "        loc.franchiseId,",
      "      ].map(_escape).join(','));",
      "",
      "      csv.writeln([",
      "        _escape(summary.period),",
      "        summary.totalOrders.toString(),",
      "        summary.totalRevenue.toStringAsFixed(2),",
      "        summary.averageOrderValue.toStringAsFixed(2),",
      "        _escape(summary.mostPopularItem),",
      "        summary.retention.toStringAsFixed(3),",
      "        summary.uniqueCustomers.toString(),",
      "        summary.cancelledOrders.toString(),",
      "        summary.addOnRevenue.toStringAsFixed(2),",
      "        _escape(jsonEncode(summary.toppingCounts)),",
      "        _escape(jsonEncode(summary.comboCounts)),",
      "        _escape(jsonEncode(summary.addOnCounts)),",
      "        _escape(jsonEncode(summary.orderStatusBreakdown)),",
      "        _escape(summary.franchiseId),",
      "      ].join(','));",
      "    } catch (e, stack) {",
      "      ErrorLogger.log(",
      "        message: e.toString(),",
      "        stack: stack.toString(),",
      "        source: 'ExportUtils',",
      "        screen: 'analyticsSummaryToCsv',",
      "        severity: 'error',",
      "      );",
      "    }",
      "    return csv.toString();",
      "  }",
      "",
      "  /// Exports multiple AnalyticsSummary objects to CSV string (multiple rows).",
      "  static String analyticsSummariesToCsv(",
      "      BuildContext context, List<AnalyticsSummary> summaries) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[ExportUtils] loc is null! Localization not available for this context.');",
      "      return 'Localization missing! [debug]';",
      "    }",
      "    final csv = StringBuffer();",
      "    try {",
      "      csv.writeln([",
      "        loc.period,",
      "        loc.totalOrders,",
      "        loc.totalRevenue,",
      "        loc.averageOrderValue,",
      "        loc.mostPopularItem,",
      "        loc.retention,",
      "        loc.uniqueCustomers,",
      "        loc.cancelledOrders,",
      "        loc.addOnRevenue,",
      "        loc.toppingCounts,",
      "        loc.comboCounts,",
      "        loc.addOnCounts,",
      "        loc.orderStatusBreakdown,",
      "        loc.franchiseId,",
      "      ].map(_escape).join(','));",
      "",
      "      for (final summary in summaries) {",
      "        csv.writeln([",
      "          _escape(summary.period),",
      "          summary.totalOrders.toString(),",
      "          summary.totalRevenue.toStringAsFixed(2),",
      "          summary.averageOrderValue.toStringAsFixed(2),",
      "          _escape(summary.mostPopularItem),",
      "          summary.retention.toStringAsFixed(3),",
      "          summary.uniqueCustomers.toString(),",
      "          summary.cancelledOrders.toString(),",
      "          summary.addOnRevenue.toStringAsFixed(2),",
      "          _escape(jsonEncode(summary.toppingCounts)),",
      "          _escape(jsonEncode(summary.comboCounts)),",
      "          _escape(jsonEncode(summary.addOnCounts)),",
      "          _escape(jsonEncode(summary.orderStatusBreakdown)),",
      "          _escape(summary.franchiseId),",
      "        ].join(','));",
      "      }",
      "    } catch (e, stack) {",
      "      ErrorLogger.log(",
      "        message: e.toString(),",
      "        stack: stack.toString(),",
      "        source: 'ExportUtils',",
      "        screen: 'analyticsSummariesToCsv',",
      "        severity: 'error',",
      "      );",
      "    }",
      "    return csv.toString();",
      "  }",
      "",
      "  /// Escapes CSV field per RFC4180, handles nulls safely.",
      "  static String _escape(String? s) {",
      "    if (s == null || s.isEmpty) return '';",
      "    if (s.contains(',') ||",
      "        s.contains('\"') ||",
      "        s.contains('\\n') ||",
      "        s.contains('\\r')) {",
      "      return '\"${s.replaceAll('\"', '\"\"')}\"';",
      "    }",
      "    return s;",
      "  }",
      "",
      "  /// Generic helper to convert list of maps to CSV with optional headers.",
      "  static String mapsToCsv(List<Map<String, dynamic>> data,",
      "      {List<String>? headers}) {",
      "    if (data.isEmpty) return '';",
      "    final csv = StringBuffer();",
      "    final headerFields = headers ?? data.first.keys.toList();",
      "    csv.writeln(headerFields.join(','));",
      "    for (final map in data) {",
      "      csv.writeln(",
      "          headerFields.map((h) => _escape(map[h]?.toString() ?? '')).join(','));",
      "    }",
      "    return csv.toString();",
      "  }",
      "",
      "  static String analyticsSummaryToCsvNoContext(AnalyticsSummary summary) {",
      "    // Use hardcoded English strings or keys instead of localized ones.",
      "    final csv = StringBuffer();",
      "    csv.writeln(",
      "        \"period,totalOrders,totalRevenue,averageOrderValue,mostPopularItem,retention,uniqueCustomers,cancelledOrders,addOnRevenue,toppingCounts,comboCounts,addOnCounts,orderStatusBreakdown,franchiseId\");",
      "    csv.writeln([",
      "      summary.period,",
      "      summary.totalOrders.toString(),",
      "      summary.totalRevenue.toStringAsFixed(2),",
      "      summary.averageOrderValue.toStringAsFixed(2),",
      "      summary.mostPopularItem,",
      "      summary.retention.toStringAsFixed(3),",
      "      summary.uniqueCustomers.toString(),",
      "      summary.cancelledOrders.toString(),",
      "      summary.addOnRevenue.toStringAsFixed(2),",
      "      jsonEncode(summary.toppingCounts),",
      "      jsonEncode(summary.comboCounts),",
      "      jsonEncode(summary.addOnCounts),",
      "      jsonEncode(summary.orderStatusBreakdown),",
      "      summary.franchiseId,",
      "    ].join(','));",
      "    return csv.toString();",
      "  }",
      "",
      "  static String invoicesToCsv(BuildContext context, List<Invoice> invoices) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[ExportUtils] loc is null! Localization not available for this context.');",
      "      return 'Localization missing! [debug]';",
      "    }",
      "    final csv = StringBuffer();",
      "    csv.writeln([",
      "      loc.invoiceNumber,",
      "      loc.status,",
      "      loc.total,",
      "      loc.currency,",
      "      loc.issueDate,",
      "      loc.dueDate,",
      "      loc.paid,",
      "    ].map(_escape).join(','));",
      "",
      "    for (final inv in invoices) {",
      "      csv.writeln([",
      "        _escape(inv.invoiceNumber),",
      "        _escape(inv.status.toString().split('.').last),",
      "        inv.total.toStringAsFixed(2),",
      "        _escape(inv.currency),",
      "        _escape(inv.issuedAt != null",
      "            ? MaterialLocalizations.of(context).formatShortDate(inv.issuedAt!)",
      "            : ''),",
      "        _escape(inv.dueAt != null",
      "            ? MaterialLocalizations.of(context).formatShortDate(inv.dueAt!)",
      "            : ''),",
      "        inv.paidAt != null ? 'TRUE' : 'FALSE',",
      "      ].join(','));",
      "    }",
      "    return csv.toString();",
      "  }",
      "",
      "  // ===========================",
      "  // Future Feature Placeholders:",
      "  // - XLSX / PDF export support",
      "  // - Locale-aware date formatting options",
      "  // - Export progress streaming for large data sets",
      "  // ===========================",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 436,
      "file_size": 14461,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\utils\\formatting.dart",
    "content": [
      "import 'package:intl/intl.dart';",
      "import 'package:flutter/widgets.dart';",
      "",
      "// Accepts context and value, uses the current app locale:",
      "String currencyFormat(BuildContext context, num value) {",
      "  final locale = Localizations.localeOf(context).toString();",
      "  final format = NumberFormat.simpleCurrency(locale: locale);",
      "  final result = format.format(value);",
      "  //print('currencyFormat output: $result');",
      "  return format.format(value);",
      "}",
      "",
      "String formatCurrency(num amount, [String currency = 'USD']) {",
      "  // Simple version, you may want intl/NumberFormat for real apps",
      "  return '\\$${amount.toStringAsFixed(2)}'; // TODO: Support multi-currency",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 16,
      "file_size": 652,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\utils\\franchise_utils.dart",
    "content": [
      "import 'package:provider/provider.dart';",
      "import 'package:flutter/widgets.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/user_profile_notifier.dart';",
      "",
      "String getScopedFranchiseId(BuildContext context) {",
      "  final user = Provider.of<UserProfileNotifier>(context, listen: false).user;",
      "  final provider = Provider.of<FranchiseProvider>(context, listen: false);",
      "",
      "  if (user == null) return 'unknown';",
      "",
      "  if (user.isDeveloper) return provider.franchiseId;",
      "  return user.defaultFranchise ?? provider.franchiseId;",
      "}",
      "",
      "Future<void> navigateAfterFranchiseSelection(",
      "  BuildContext context,",
      "  String franchiseId,",
      ") async {",
      "  print(",
      "      '[DEBUG-NAV] Called navigateAfterFranchiseSelection with franchiseId=\"$franchiseId\" '",
      "      'user=\"${Provider.of<UserProfileNotifier>(context, listen: false).user}\" '",
      "      'isDeveloper=${Provider.of<UserProfileNotifier>(context, listen: false).user?.isDeveloper}');",
      "  final franchiseProvider =",
      "      Provider.of<FranchiseProvider>(context, listen: false);",
      "  final user = Provider.of<UserProfileNotifier>(context, listen: false).user;",
      "",
      "  franchiseProvider.setFranchiseId(franchiseId);",
      "",
      "  if (user != null && user.isDeveloper) {",
      "    print(",
      "        '[DEBUG-NAV] Navigating to /developer/dashboard from navigateAfterFranchiseSelection');",
      "    Navigator.of(context).pushReplacementNamed('/developer/dashboard');",
      "  } else {",
      "    print(",
      "        '[DEBUG-NAV] Navigating to /admin/dashboard from navigateAfterFranchiseSelection');",
      "    Navigator.of(context).pushReplacementNamed('/admin/dashboard');",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 39,
      "file_size": 1652,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\utils\\log_utils.dart",
    "content": [
      "import 'package:flutter/foundation.dart' show kIsWeb;",
      "import 'package:logger/logger.dart';",
      "",
      "// Only import dart:io and path_provider if not on web",
      "// ignore: uri_does_not_exist",
      "import 'dart:io' if (dart.library.io) 'dart:io';",
      "// ignore: uri_does_not_exist",
      "import 'package:path_provider/path_provider.dart'",
      "    if (dart.library.io) 'package:path_provider/path_provider.dart';",
      "",
      "class LogUtils {",
      "  static final Logger _logger = Logger(",
      "    printer: PrettyPrinter(",
      "      methodCount: 2,",
      "      errorMethodCount: 8,",
      "      lineLength: 100,",
      "      colors: true,",
      "      printEmojis: true,",
      "      dateTimeFormat: DateTimeFormat.onlyTimeAndSinceStart,",
      "    ),",
      "  );",
      "",
      "  static File? _logFile;",
      "",
      "  /// Initializes the log file location (call once, e.g., in main())",
      "  static Future<void> init() async {",
      "    if (kIsWeb) return; // Skip file logging on web",
      "    final directory = await getApplicationDocumentsDirectory();",
      "    final path = '${directory.path}/app_log.txt';",
      "    _logFile = File(path);",
      "  }",
      "",
      "  /// Writes a message to the file (appends with timestamp)",
      "  static Future<void> logToFile(String message) async {",
      "    if (kIsWeb) return; // No-op on web",
      "    if (_logFile == null) await init();",
      "    final timestamp = DateTime.now().toIso8601String();",
      "    await _logFile?.writeAsString('[$timestamp] $message\\n',",
      "        mode: FileMode.append);",
      "  }",
      "",
      "  /// Info log",
      "  static void i(String message) {",
      "    _logger.i(message);",
      "    logToFile(message);",
      "  }",
      "",
      "  /// Error log",
      "  static void e(String message, [dynamic error, StackTrace? stack]) {",
      "    _logger.e(message, error: error, stackTrace: stack);",
      "    logToFile('ERROR: $message\\n${error ?? ''}\\n${stack ?? ''}');",
      "  }",
      "",
      "  /// Debug log",
      "  static void d(String message) {",
      "    _logger.d(message);",
      "    logToFile('DEBUG: $message');",
      "  }",
      "",
      "  /// Warning log",
      "  static void w(String message) {",
      "    _logger.w(message);",
      "    logToFile('WARNING: $message');",
      "  }",
      "",
      "  /// Trace log",
      "  static void t(String message) {",
      "    _logger.t(message);",
      "    logToFile('TRACE: $message');",
      "  }",
      "",
      "  /// Log exception",
      "  static void logException(dynamic error, StackTrace? stack,",
      "      {String? context}) {",
      "    final msg = context != null ? '[$context] $error' : '$error';",
      "    e(msg, error, stack);",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 78,
      "file_size": 2274,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\utils\\onboarding_navigation_utils.dart",
    "content": [
      "// lib/core/utils/onboarding_navigation_utils.dart",
      "//",
      "// Navigation utilities for the Onboarding flow.",
      "// Keeps routing keys, arguments, and normalization consistent.",
      "",
      "import 'package:flutter/material.dart';",
      "import 'package:flutter/foundation.dart' show VisibleForTesting;",
      "import 'package:franchise_admin_portal/core/models/onboarding_validation_issue.dart';",
      "",
      "/// Canonical argument keys used across onboarding routes.",
      "class OnboardingNavKeys {",
      "  OnboardingNavKeys._();",
      "",
      "  static const section = 'section';",
      "  static const sectionKey = 'sectionKey';",
      "  static const focusItemId = 'focusItemId';",
      "  static const locator = 'locator';",
      "  static const focusFields = 'focusFields';",
      "  static const legacyItemId = 'itemId';",
      "  static const legacyIngredientId = 'ingredientId';",
      "  static const createMode = 'createMode';",
      "  static const highlight = 'highlight';",
      "  static const severity = 'severity';",
      "  static const message = 'message';",
      "}",
      "",
      "/// Human-readable section labels shown in UI.",
      "class OnboardingSections {",
      "  OnboardingSections._();",
      "",
      "  static const features = 'Features';",
      "  static const ingredientTypes = 'Ingredient Types';",
      "  static const ingredients = 'Ingredients';",
      "  static const categories = 'Categories';",
      "  static const menuItems = 'Menu Items';",
      "  static const reviewPublish = 'Review & Publish';",
      "",
      "  static const all = <String>[",
      "    features,",
      "    ingredientTypes,",
      "    ingredients,",
      "    categories,",
      "    menuItems,",
      "    reviewPublish,",
      "  ];",
      "}",
      "",
      "/// Mapping between human-facing names/aliases and internal dashboard keys.",
      "const Map<String, String> _sectionKeyMap = {",
      "  // Internal routing keys",
      "  'onboardingmenu': 'onboardingMenu',",
      "  'onboardingfeaturesetup': 'onboarding_feature_setup',",
      "  'onboardingingredienttypes': 'onboardingIngredientTypes',",
      "  'onboardingingredients': 'onboardingIngredients',",
      "  'onboardingcategories': 'onboardingCategories',",
      "  'onboardingmenuitems': 'onboardingMenuItems',",
      "  'onboardingreview': 'onboardingReview',",
      "",
      "  // Aliases",
      "  'features': 'onboarding_feature_setup',",
      "  'feature setup': 'onboarding_feature_setup',",
      "  'ingredienttypes': 'onboardingIngredientTypes',",
      "  'ingredient types': 'onboardingIngredientTypes',",
      "  'ingredients': 'onboardingIngredients',",
      "  'categories': 'onboardingCategories',",
      "  'menuitems': 'onboardingMenuItems',",
      "  'menu items': 'onboardingMenuItems',",
      "  'review': 'onboardingReview',",
      "  'review&publish': 'onboardingReview',",
      "  'overview': 'onboardingMenu',",
      "};",
      "",
      "String _dashboardSectionRoute(String sectionKey) =>",
      "    '/dashboard?section=$sectionKey';",
      "",
      "/// Container for parsed onboarding navigation context.",
      "class OnboardingNavContext {",
      "  final String? section;",
      "  final String? sectionKey;",
      "  final String? focusItemId;",
      "  final String? locator;",
      "  final List<String> focusFields;",
      "  final bool? createMode;",
      "  final bool? highlight;",
      "  final String? severity;",
      "  final String? message;",
      "",
      "  const OnboardingNavContext({",
      "    this.section,",
      "    this.sectionKey,",
      "    this.focusItemId,",
      "    this.locator,",
      "    this.focusFields = const [],",
      "    this.createMode,",
      "    this.highlight,",
      "    this.severity,",
      "    this.message,",
      "  });",
      "",
      "  Map<String, dynamic> toArgs() {",
      "    final map = <String, dynamic>{};",
      "",
      "    if (_isNonEmpty(section)) map[OnboardingNavKeys.section] = section;",
      "    if (_isNonEmpty(sectionKey)) map[OnboardingNavKeys.sectionKey] = sectionKey;",
      "",
      "    if (_isNonEmpty(focusItemId)) {",
      "      map[OnboardingNavKeys.focusItemId] = focusItemId;",
      "      if (section == OnboardingSections.ingredients) {",
      "        map[OnboardingNavKeys.legacyIngredientId] = focusItemId;",
      "      } else {",
      "        map[OnboardingNavKeys.legacyItemId] = focusItemId;",
      "      }",
      "    }",
      "",
      "    if (_isNonEmpty(locator)) {",
      "      map[OnboardingNavKeys.locator] = locator;",
      "    }",
      "",
      "    if (focusFields.isNotEmpty) {",
      "      map[OnboardingNavKeys.focusFields] = List<String>.from(focusFields);",
      "    }",
      "",
      "    if (createMode != null) {",
      "      map[OnboardingNavKeys.createMode] = createMode;",
      "    }",
      "",
      "    if (highlight != null) {",
      "      map[OnboardingNavKeys.highlight] = highlight;",
      "    }",
      "",
      "    if (_isNonEmpty(severity)) map[OnboardingNavKeys.severity] = severity;",
      "    if (_isNonEmpty(message)) map[OnboardingNavKeys.message] = message;",
      "",
      "    return map;",
      "  }",
      "}",
      "",
      "class OnboardingNavigationUtils {",
      "  /// Build navigation arguments from section and issue.",
      "  static Map<String, dynamic> buildOnboardingNavArgs({",
      "    required String section,",
      "    required OnboardingValidationIssue issue,",
      "  }) {",
      "    final normalizedSection = _normalizeSection(section);",
      "    final sectionKey = _sectionKeyMap[normalizedSection] ?? normalizedSection;",
      "",
      "    final ctx = OnboardingNavContext(",
      "      section: normalizedSection,",
      "      sectionKey: sectionKey,",
      "      focusItemId: _pickFocusItemId(issue),",
      "      locator: _pickLocator(issue),",
      "      focusFields: List<String>.from(issue.affectedFields),",
      "      createMode: _deriveCreateMode(issue),",
      "      highlight: true,",
      "      severity: _stringifySeverity(issue.severity),",
      "      message: _emptyToNull(issue.message),",
      "    );",
      "",
      "    final args = ctx.toArgs();",
      "",
      "    if (!_isNonEmpty(args[OnboardingNavKeys.legacyItemId]) &&",
      "        !_isNonEmpty(args[OnboardingNavKeys.legacyIngredientId]) &&",
      "        _isNonEmpty(ctx.focusItemId)) {",
      "      args[OnboardingNavKeys.legacyItemId] = ctx.focusItemId;",
      "    }",
      "",
      "    if (!_isNonEmpty(ctx.focusItemId) && ctx.createMode != true) {",
      "      args[OnboardingNavKeys.highlight] = false;",
      "    }",
      "",
      "    debugPrint(",
      "      '[OnboardingNavigationUtils] buildOnboardingNavArgs → section=\"$section\" normalized=\"$normalizedSection\" args=$args',",
      "    );",
      "",
      "    return Map<String, dynamic>.unmodifiable(args);",
      "  }",
      "",
      "  /// Resolve a dashboard route from a raw section name or key.",
      "  static String resolveRoute(String section, OnboardingValidationIssue? issue) {",
      "    final normalizedSection = _normalizeSection(section);",
      "    debugPrint(",
      "        '[OnboardingNavigationUtils] resolveRoute: input=\"$section\" normalized=\"$normalizedSection\"');",
      "",
      "    switch (normalizedSection) {",
      "      case 'onboardingMenu':",
      "        return _dashboardSectionRoute('onboardingMenu');",
      "      case 'onboarding_feature_setup':",
      "        return _dashboardSectionRoute('onboarding_feature_setup');",
      "      case 'onboardingIngredientTypes':",
      "        return _dashboardSectionRoute('onboardingIngredientTypes');",
      "      case 'onboardingIngredients':",
      "        return _dashboardSectionRoute('onboardingIngredients');",
      "      case 'onboardingCategories':",
      "        return _dashboardSectionRoute('onboardingCategories');",
      "      case 'onboardingMenuItems':",
      "        return _dashboardSectionRoute('onboardingMenuItems');",
      "      case 'onboardingReview':",
      "        return _dashboardSectionRoute('onboardingReview');",
      "      default:",
      "        debugPrint(",
      "            '[OnboardingNavigationUtils][WARN] No mapping for normalizedSection=\"$normalizedSection\"');",
      "        return '';",
      "    }",
      "  }",
      "",
      "  /// Public wrapper to normalize a section string for routing.",
      "  /// Converts human-friendly names (e.g., \"Ingredients\") to",
      "  /// dashboard routing keys (e.g., \"onboardingIngredients\").",
      "  /// Safe to call from any UI or provider code before calling resolveRoute().",
      "  static String normalizeForRouting(String section) {",
      "    return _normalizeSection(section);",
      "  }",
      "}",
      "",
      "/// --- Internal helpers ---",
      "String _normalizeSection(String section) {",
      "  final trimmedLower = section.trim().toLowerCase();",
      "  return _sectionKeyMap[trimmedLower] ?? section.trim();",
      "}",
      "",
      "String? _pickFocusItemId(OnboardingValidationIssue issue) =>",
      "    _emptyToNull(issue.itemId);",
      "",
      "String? _pickLocator(OnboardingValidationIssue issue) =>",
      "    _emptyToNull(issue.itemLocator);",
      "",
      "bool _deriveCreateMode(OnboardingValidationIssue issue) {",
      "  if (_isNonEmpty(issue.itemId)) return false;",
      "  final label = _emptyToNull(issue.actionLabel)?.toLowerCase() ?? '';",
      "  return label.contains('add') ||",
      "      label.contains('create') ||",
      "      label.contains('new');",
      "}",
      "",
      "String? _emptyToNull(String? v) {",
      "  if (v == null) return null;",
      "  final s = v.trim();",
      "  return s.isEmpty ? null : s;",
      "}",
      "",
      "bool _isNonEmpty(Object? v) {",
      "  if (v == null) return false;",
      "  if (v is String) return v.trim().isNotEmpty;",
      "  return true;",
      "}",
      "",
      "String? _stringifySeverity(OnboardingIssueSeverity? s) {",
      "  switch (s) {",
      "    case OnboardingIssueSeverity.critical:",
      "      return 'critical';",
      "    case OnboardingIssueSeverity.warning:",
      "      return 'warning';",
      "    case OnboardingIssueSeverity.info:",
      "      return 'info';",
      "    default:",
      "      return null;",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 258,
      "file_size": 8541,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\utils\\schema_templates.dart",
    "content": [
      "// lib/core/utils/schema_templates.dart",
      "",
      "const List<Map<String, dynamic>> pizzaShopIngredientMetadataTemplate = [",
      "  {",
      "    \"id\": \"cheese_mozzarella\",",
      "    \"name\": \"Mozzarella\",",
      "    \"typeId\": \"cheese\",",
      "    \"type\": \"Cheese\",",
      "    \"allergens\": [\"dairy\"],",
      "    \"removable\": true,",
      "    \"supportsExtra\": true,",
      "    \"sidesAllowed\": false,",
      "    \"notes\": \"Classic mozzarella cheese\",",
      "    \"outOfStock\": false,",
      "    \"imageUrl\": null,",
      "    \"amountSelectable\": true,",
      "    \"amountOptions\": [\"Light\", \"Regular\", \"Extra\"]",
      "  },",
      "  {",
      "    \"id\": \"meat_pepperoni\",",
      "    \"name\": \"Pepperoni\",",
      "    \"typeId\": \"meat\",",
      "    \"type\": \"Meat\",",
      "    \"allergens\": [],",
      "    \"removable\": true,",
      "    \"supportsExtra\": true,",
      "    \"sidesAllowed\": true,",
      "    \"notes\": \"Spicy pepperoni slices\",",
      "    \"outOfStock\": false,",
      "    \"imageUrl\": null,",
      "    \"amountSelectable\": true,",
      "    \"amountOptions\": [\"Light\", \"Regular\", \"Extra\"]",
      "  },",
      "  // Add more ingredient metadata entries here...",
      "];",
      "",
      "const List<Map<String, dynamic>> pizzaShopIngredientTypesTemplate = [",
      "  {",
      "    \"name\": \"Cheese\",",
      "    \"description\": \"All cheese types used in pizzas and other items.\",",
      "    \"sortOrder\": 1,",
      "    \"systemTag\": \"cheese\",",
      "    \"visibleInApp\": true,",
      "  },",
      "  {",
      "    \"name\": \"Sauce\",",
      "    \"description\": \"Various pizza sauces.\",",
      "    \"sortOrder\": 2,",
      "    \"systemTag\": \"sauce\",",
      "    \"visibleInApp\": true,",
      "  },",
      "  {",
      "    \"name\": \"Meat\",",
      "    \"description\": \"Meat toppings including pepperoni, sausage, etc.\",",
      "    \"sortOrder\": 3,",
      "    \"systemTag\": \"meat\",",
      "    \"visibleInApp\": true,",
      "  },",
      "  {",
      "    \"name\": \"Veggies\",",
      "    \"description\": \"Vegetable toppings such as onions, peppers, mushrooms.\",",
      "    \"sortOrder\": 4,",
      "    \"systemTag\": \"vegetable\",",
      "    \"visibleInApp\": true,",
      "  },",
      "  {",
      "    \"name\": \"Specialty\",",
      "    \"description\": \"Specialty or unique ingredient types.\",",
      "    \"sortOrder\": 5,",
      "    \"systemTag\": \"specialty\",",
      "    \"visibleInApp\": true,",
      "  },",
      "  // Add more ingredient type entries as needed...",
      "];",
      "",
      "const List<Map<String, dynamic>> pizzaShopCategoriesTemplate = [",
      "  {",
      "    \"id\": \"pizza\",",
      "    \"name\": \"Pizza\",",
      "    \"description\":",
      "        \"Our signature pizzas including build-your-own and specialties.\",",
      "    \"sortOrder\": 0",
      "  },",
      "  {",
      "    \"id\": \"calzones\",",
      "    \"name\": \"Calzones\",",
      "    \"description\": \"Stuffed calzones with various fillings.\",",
      "    \"sortOrder\": 1",
      "  },",
      "  {",
      "    \"id\": \"salads\",",
      "    \"name\": \"Salads\",",
      "    \"description\": \"Fresh salads with a variety of toppings and dressings.\",",
      "    \"sortOrder\": 2",
      "  },",
      "  {",
      "    \"id\": \"drinks\",",
      "    \"name\": \"Drinks\",",
      "    \"description\": \"Fountain drinks, bottled beverages, and more.\",",
      "    \"sortOrder\": 3",
      "  },",
      "  {",
      "    \"id\": \"desserts\",",
      "    \"name\": \"Desserts\",",
      "    \"description\": \"Sweet treats to complete your meal.\",",
      "    \"sortOrder\": 4",
      "  },",
      "];"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 108,
      "file_size": 2785,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\utils\\user_permissions.dart",
    "content": [
      "import 'package:franchise_admin_portal/core/models/user.dart' as admin_user;",
      "",
      "/// Centralized permission checks for roles across the app.",
      "/// This avoids repeating `user?.isOwner || user?.isManager || ...` everywhere.",
      "class UserPermissions {",
      "  /// True if the user is a platform owner",
      "  static bool isPlatformOwner(admin_user.User? user) {",
      "    return user?.hasAnyRole(['platform_owner']) ?? false;",
      "  }",
      "",
      "  /// True if the user is an HQ owner (franchisee primary account holder)",
      "  static bool isHqOwner(admin_user.User? user) {",
      "    return user?.hasAnyRole(['hq_owner']) ?? false;",
      "  }",
      "",
      "  /// Can edit menu items (add/edit/customize)",
      "  static bool canEditMenu(admin_user.User? user) {",
      "    return user?.hasAnyRole([",
      "          'platform_owner',",
      "          'hq_owner',",
      "          'manager',",
      "          'developer',",
      "          'admin',",
      "        ]) ??",
      "        false;",
      "  }",
      "",
      "  /// Can delete or export menu items",
      "  static bool canDeleteMenu(admin_user.User? user) {",
      "    return user?.hasAnyRole([",
      "          'platform_owner',",
      "          'hq_owner',",
      "          'developer',",
      "          'admin',",
      "        ]) ??",
      "        false;",
      "  }",
      "",
      "  /// Can view or manage orders",
      "  static bool canAccessOrders(admin_user.User? user) {",
      "    return user?.hasAnyRole([",
      "          'platform_owner',",
      "          'hq_owner',",
      "          'manager',",
      "          'developer',",
      "          'admin',",
      "        ]) ??",
      "        false;",
      "  }",
      "",
      "  /// Can process refunds",
      "  static bool canRefundOrders(admin_user.User? user) {",
      "    return user?.hasAnyRole([",
      "          'platform_owner',",
      "          'hq_owner',",
      "          'manager',",
      "        ]) ??",
      "        false;",
      "  }",
      "",
      "  /// Can access subscription management",
      "  static bool canManageSubscriptions(admin_user.User? user) {",
      "    return user?.hasAnyRole([",
      "          'platform_owner',",
      "          'hq_owner',",
      "          'developer',",
      "        ]) ??",
      "        false;",
      "  }",
      "",
      "  /// Can access sensitive platform configuration",
      "  static bool isPlatformPrivileged(admin_user.User? user) {",
      "    return user?.hasAnyRole([",
      "          'platform_owner',",
      "          'developer',",
      "        ]) ??",
      "        false;",
      "  }",
      "",
      "  static bool canAccessMenuEditor(admin_user.User user) => user.hasAnyRole(",
      "      ['platform_owner', 'hq_owner', 'manager', 'developer', 'admin']);",
      "",
      "  static bool canManageCategories(admin_user.User? user) {",
      "    return user?.hasAnyRole([",
      "          'platform_owner',",
      "          'hq_owner',",
      "          'manager',",
      "          'developer',",
      "          'admin',",
      "        ]) ??",
      "        false;",
      "  }",
      "",
      "  static bool canAccessPromos(admin_user.User? user) {",
      "    return user?.hasAnyRole([",
      "          'platform_owner',",
      "          'hq_owner',",
      "          'manager',",
      "          'developer',",
      "          'admin',",
      "          'staff',",
      "        ]) ??",
      "        false;",
      "  }",
      "",
      "  static bool canEditPromos(admin_user.User? user) {",
      "    return user?.hasAnyRole([",
      "          'platform_owner',",
      "          'hq_owner',",
      "          'manager',",
      "          'developer',",
      "          'admin',",
      "        ]) ??",
      "        false;",
      "  }",
      "",
      "  static bool canAccessPromoManagement(admin_user.User? user) {",
      "    return user?.hasAnyRole([",
      "          'platform_owner',",
      "          'hq_owner',",
      "          'manager',",
      "          'developer',",
      "          'admin',",
      "          'staff',",
      "        ]) ??",
      "        false;",
      "  }",
      "",
      "  static bool canManageStaff(admin_user.User? user) {",
      "    return user?.hasAnyRole([",
      "          'platform_owner',",
      "          'hq_owner',",
      "          'manager',",
      "          'admin',",
      "          'developer',",
      "        ]) ??",
      "        false;",
      "  }",
      "",
      "  static bool canAccessChatManagement(admin_user.User? user) {",
      "    return user?.hasAnyRole([",
      "          'platform_owner',",
      "          'hq_owner',",
      "          'manager',",
      "          'developer',",
      "          'admin',",
      "        ]) ??",
      "        false;",
      "  }",
      "}",
      "",
      "/// Optional: role-checking extension on the user model",
      "extension UserRoleHelpers on admin_user.User {",
      "  /// Returns true if user has any of the roles in [roles]",
      "  bool hasAnyRole(List<String> roles) {",
      "    return roles.any((role) => this.roles.contains(role));",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 158,
      "file_size": 4074,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\utils\\features\\enum_platform_features.dart",
    "content": [
      "enum PlatformFeature {",
      "  webOrdering,",
      "  supportChat,",
      "  staffAccess,",
      "  schemaManagement,",
      "  promoBanners,",
      "  pluginRegistry,",
      "  orderTracking,",
      "  nutritionalInfo,",
      "  multiLocation,",
      "  mobileOrdering,",
      "  menuItemCustomization,",
      "  loyalty,",
      "  languageSupport,",
      "  inventory,",
      "  feedback,",
      "  featureToggles,",
      "  discountCodes,",
      "  comboMeals,",
      "  chatSupport,",
      "  brandingCustomization,",
      "  analyticsReporting,",
      "}",
      "",
      "extension PlatformFeatureExtension on PlatformFeature {",
      "  String get key => toString().split('.').last.snakeCase();",
      "}",
      "",
      "extension StringCasingExtension on String {",
      "  String snakeCase() {",
      "    return replaceAllMapped(RegExp(r'([A-Z])'), (match) => '_${match.group(0)}')",
      "        .toLowerCase()",
      "        .replaceFirst('_', '');",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 35,
      "file_size": 750,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\utils\\features\\feature_extensions.dart",
    "content": [
      "import 'package:flutter/widgets.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_feature_provider.dart';",
      "",
      "extension FeatureContextExtension on BuildContext {",
      "  /// Shorthand for checking top-level feature availability",
      "  bool hasFeature(String module) {",
      "    final provider = read<FranchiseFeatureProvider>();",
      "    return provider.hasFeature(module);",
      "  }",
      "",
      "  /// Shorthand for checking if a feature is fully enabled",
      "  bool isFeatureEnabled(String module) {",
      "    final provider = read<FranchiseFeatureProvider>();",
      "    return provider.isModuleEnabled(module);",
      "  }",
      "",
      "  /// Shorthand for checking if a subfeature is enabled",
      "  bool isSubFeatureEnabled(String module, String feature) {",
      "    final provider = read<FranchiseFeatureProvider>();",
      "    return provider.isSubfeatureEnabled(module, feature);",
      "  }",
      "",
      "  /// Return a readable instance without triggering rebuilds",
      "  T read<T>() => Provider.of<T>(this, listen: false);",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 26,
      "file_size": 998,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\utils\\features\\feature_gate.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_feature_provider.dart';",
      "import 'package:franchise_admin_portal/core/utils/features/feature_lock_overlay.dart';",
      "",
      "/// Defines how the fallback content should behave if the feature is not granted or enabled.",
      "enum FeatureFallbackStyle {",
      "  /// Completely hides the widget from the layout.",
      "  hidden,",
      "",
      "  /// Shows the widget dimmed and disabled.",
      "  dimmed,",
      "",
      "  /// Displays the widget with a centered lock overlay for upsell/education.",
      "  lockedBanner,",
      "}",
      "",
      "///",
      "/// 🚪 FeatureGate",
      "///",
      "/// Centralized feature-gating widget supporting `.hidden`, `.dimmed`, and `.lockedBanner` styles.",
      "///",
      "/// ✅ Use for:",
      "/// - Gating optional sections, cards, tabs, fields, or advanced inputs.",
      "/// - Educating or upselling on locked features.",
      "///",
      "/// ❌ Avoid when:",
      "/// - You need backend-level access control (this is UI-only).",
      "/// - You want zero layout impact (use `hidden` only).",
      "///",
      "class FeatureGate extends StatelessWidget {",
      "  final String module;",
      "  final String? feature;",
      "  final bool requireEnabled;",
      "  final FeatureFallbackStyle fallbackStyle;",
      "",
      "  final String? tooltipMessage; // for dimmed",
      "  final String? lockedMessage; // for lockedBanner",
      "  final VoidCallback? onTapUpgrade; // for lockedBanner",
      "",
      "  final Widget? loading;",
      "  final Widget child;",
      "",
      "  const FeatureGate({",
      "    Key? key,",
      "    required this.module,",
      "    this.feature,",
      "    this.requireEnabled = true,",
      "    this.fallbackStyle = FeatureFallbackStyle.hidden,",
      "    this.tooltipMessage,",
      "    this.lockedMessage,",
      "    this.onTapUpgrade,",
      "    this.loading,",
      "    required this.child,",
      "  }) : super(key: key);",
      "",
      "  bool _isPermitted(FranchiseFeatureProvider provider) {",
      "    if (!provider.hasFeature(module)) return false;",
      "    if (!requireEnabled) return true;",
      "    if (feature != null) return provider.isSubfeatureEnabled(module, feature!);",
      "    return provider.isModuleEnabled(module);",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final provider = context.watch<FranchiseFeatureProvider>();",
      "",
      "    if (!provider.isInitialized) {",
      "      return loading ?? const SizedBox.shrink();",
      "    }",
      "",
      "    final isAllowed = _isPermitted(provider);",
      "    if (isAllowed) return child;",
      "",
      "    switch (fallbackStyle) {",
      "      case FeatureFallbackStyle.hidden:",
      "        return const SizedBox.shrink();",
      "",
      "      case FeatureFallbackStyle.dimmed:",
      "        return Tooltip(",
      "          message:",
      "              tooltipMessage ?? 'This feature is not available in your plan.',",
      "          child: IgnorePointer(",
      "            ignoring: true,",
      "            child: Opacity(opacity: 0.4, child: child),",
      "          ),",
      "        );",
      "",
      "      case FeatureFallbackStyle.lockedBanner:",
      "        return Stack(",
      "          children: [",
      "            Opacity(opacity: 0.35, child: child),",
      "            FeatureLockOverlay(",
      "              lockedMessage: lockedMessage,",
      "              onTapUpgrade: onTapUpgrade,",
      "            ),",
      "          ],",
      "        );",
      "    }",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 101,
      "file_size": 3069,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\utils\\features\\feature_gate_banner.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_feature_provider.dart';",
      "",
      "///",
      "/// 🔒 FeatureGateBanner",
      "///",
      "/// A premium gating wrapper that overlays a semi-transparent lock banner",
      "/// over its child when the required feature or subfeature is not available.",
      "///",
      "/// Use this when:",
      "/// - ✅ You want to **educate** or **upsell** locked features.",
      "/// - ✅ You want to **visually indicate** restricted sections during onboarding.",
      "/// - ✅ You want the layout to remain consistent, but clearly restricted.",
      "///",
      "/// Avoid this when:",
      "/// - ❌ The gated content could break layout if visible but unusable.",
      "/// - ❌ You require total exclusion (use `FeatureGate` with `hidden` style instead).",
      "///",
      "/// ---",
      "///",
      "/// Example:",
      "/// ```dart",
      "/// FeatureGateBanner(",
      "///   module: 'inventory',",
      "///   feature: 'liveTracking',",
      "///   lockedMessage: 'Upgrade to enable inventory tracking',",
      "///   onTapUpgrade: () => context.pushNamed('/platform/plans'),",
      "///   child: InventorySectionCard(),",
      "/// )",
      "/// ```",
      "class FeatureGateBanner extends StatelessWidget {",
      "  final String module;",
      "  final String? feature;",
      "  final bool requireEnabled;",
      "",
      "  /// Optional custom locked message (defaults to generic).",
      "  final String? lockedMessage;",
      "",
      "  /// Optional upgrade button callback",
      "  final VoidCallback? onTapUpgrade;",
      "",
      "  /// Optional banner background color",
      "  final Color bannerColor;",
      "",
      "  /// Optional lock icon to override default",
      "  final IconData lockIcon;",
      "",
      "  /// Widget to show when access is allowed",
      "  final Widget child;",
      "",
      "  const FeatureGateBanner({",
      "    Key? key,",
      "    required this.module,",
      "    this.feature,",
      "    this.requireEnabled = true,",
      "    this.lockedMessage,",
      "    this.onTapUpgrade,",
      "    this.bannerColor = const Color(0xAA000000),",
      "    this.lockIcon = Icons.lock_outline,",
      "    required this.child,",
      "  }) : super(key: key);",
      "",
      "  bool _isPermitted(FranchiseFeatureProvider provider) {",
      "    if (!provider.hasFeature(module)) return false;",
      "    if (!requireEnabled) return true;",
      "    if (feature != null) {",
      "      return provider.isSubfeatureEnabled(module, feature!);",
      "    }",
      "    return provider.isModuleEnabled(module);",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final featureProvider = context.watch<FranchiseFeatureProvider>();",
      "",
      "    if (!featureProvider.isInitialized) {",
      "      return const SizedBox.shrink();",
      "    }",
      "",
      "    final isAllowed = _isPermitted(featureProvider);",
      "",
      "    if (isAllowed) return child;",
      "",
      "    return Stack(",
      "      children: [",
      "        Opacity(opacity: 0.35, child: child),",
      "        Positioned.fill(",
      "          child: Container(",
      "            color: bannerColor,",
      "            alignment: Alignment.center,",
      "            child: Column(",
      "              mainAxisSize: MainAxisSize.min,",
      "              children: [",
      "                Icon(lockIcon, size: 36, color: Colors.white),",
      "                const SizedBox(height: 8),",
      "                Text(",
      "                  lockedMessage ?? 'This feature is unavailable in your plan.',",
      "                  style: const TextStyle(color: Colors.white, fontSize: 14),",
      "                  textAlign: TextAlign.center,",
      "                ),",
      "                if (onTapUpgrade != null) ...[",
      "                  const SizedBox(height: 12),",
      "                  ElevatedButton(",
      "                    onPressed: onTapUpgrade,",
      "                    child: const Text('Upgrade'),",
      "                  ),",
      "                ],",
      "              ],",
      "            ),",
      "          ),",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 116,
      "file_size": 3594,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\utils\\features\\feature_gate_wrapper.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/core/utils/features/feature_gate.dart';",
      "",
      "///",
      "/// 🧱 FeatureGateWrapper",
      "///",
      "/// Lightweight wrapper for gating a widget with configurable fallback style,",
      "/// using the full FeatureGate behind the scenes.",
      "///",
      "/// Great for centralized usage when dynamically toggling fallback types.",
      "///",
      "class FeatureGateWrapper extends StatelessWidget {",
      "  final String module;",
      "  final String? feature;",
      "  final bool requireEnabled;",
      "  final FeatureFallbackStyle fallbackStyle;",
      "  final String? tooltipMessage;",
      "  final String? lockedMessage;",
      "  final VoidCallback? onTapUpgrade;",
      "  final Widget child;",
      "",
      "  const FeatureGateWrapper({",
      "    Key? key,",
      "    required this.module,",
      "    this.feature,",
      "    this.requireEnabled = true,",
      "    this.fallbackStyle = FeatureFallbackStyle.hidden,",
      "    this.tooltipMessage,",
      "    this.lockedMessage,",
      "    this.onTapUpgrade,",
      "    required this.child,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return FeatureGate(",
      "      module: module,",
      "      feature: feature,",
      "      requireEnabled: requireEnabled,",
      "      fallbackStyle: fallbackStyle,",
      "      tooltipMessage: tooltipMessage,",
      "      lockedMessage: lockedMessage,",
      "      onTapUpgrade: onTapUpgrade,",
      "      child: child,",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 47,
      "file_size": 1338,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\utils\\features\\feature_guard.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_feature_provider.dart';",
      "",
      "/// A flexible widget that only shows [child] if the specified feature/module is",
      "/// available in the franchise plan, and optionally also enabled by the franchisee.",
      "///",
      "/// Priority:",
      "/// - If [requireEnabled] == false → show [child] if module exists in plan.",
      "/// - If [requireEnabled] == true:",
      "///   - If [feature] is provided → check subfeature enabled.",
      "///   - Else → check module enabled.",
      "///",
      "/// Use this guard in onboarding flows, developer tools, and screen sections.",
      "///",
      "/// Example:",
      "/// ```dart",
      "/// FeatureGuard(",
      "///   module: 'inventory',",
      "///   feature: 'liveTracking',",
      "///   requireEnabled: true,",
      "///   loading: CircularProgressIndicator(),",
      "///   fallback: Text('Upgrade to unlock inventory tracking'),",
      "///   child: InventoryManager(),",
      "/// )",
      "/// ```",
      "class FeatureGuard extends StatelessWidget {",
      "  /// The top-level module key (e.g., \"inventory\", \"nutrition\")",
      "  final String module;",
      "",
      "  /// Optional subfeature key within the module (e.g., \"liveTracking\")",
      "  final String? feature;",
      "",
      "  /// Whether the feature must be enabled (e.g., franchise toggle) or just present in the plan",
      "  final bool requireEnabled;",
      "",
      "  /// Widget shown while `FranchiseFeatureProvider` is not yet ready",
      "  final Widget? loading;",
      "",
      "  /// Widget to show if the feature is not granted/enabled",
      "  final Widget fallback;",
      "",
      "  /// Widget to show if the feature is allowed",
      "  final Widget child;",
      "",
      "  const FeatureGuard({",
      "    Key? key,",
      "    required this.module,",
      "    this.feature,",
      "    this.requireEnabled = true,",
      "    this.loading,",
      "    required this.fallback,",
      "    required this.child,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final featureProvider = context.watch<FranchiseFeatureProvider>();",
      "",
      "    if (!featureProvider.isInitialized) {",
      "      return loading ?? const SizedBox.shrink();",
      "    }",
      "",
      "    final isGranted = featureProvider.hasFeature(module);",
      "",
      "    if (!isGranted) {",
      "      assert(() {",
      "        debugPrint('⚠️ FeatureGuard: Module \"$module\" not found in plan.');",
      "        return true;",
      "      }());",
      "      return fallback;",
      "    }",
      "",
      "    if (!requireEnabled) {",
      "      return child;",
      "    }",
      "",
      "    if (feature != null) {",
      "      final isSubfeatureActive =",
      "          featureProvider.isSubfeatureEnabled(module, feature!);",
      "      return isSubfeatureActive ? child : fallback;",
      "    }",
      "",
      "    final isModuleActive = featureProvider.isModuleEnabled(module);",
      "    return isModuleActive ? child : fallback;",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 87,
      "file_size": 2658,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\utils\\features\\feature_guard_wrapper.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_feature_provider.dart';",
      "",
      "/// Defines how `FeatureGuardWrapper` handles feature-gated content.",
      "enum FeatureFallbackStyle {",
      "  /// Completely removes the widget from the tree (same as FeatureGuard).",
      "  hidden,",
      "",
      "  /// Displays the widget with reduced opacity and disables interaction.",
      "  /// Useful for education or upsell nudging.",
      "  dimmed,",
      "}",
      "",
      "///",
      "/// 🧱 FeatureGuardWrapper",
      "///",
      "/// A flexible wrapper that conditionally hides or disables its child based on",
      "/// a platform feature toggle (and optionally a nested subfeature).",
      "///",
      "/// Use this when:",
      "/// - ✅ You want to **educate** the user about a locked feature.",
      "/// - ✅ You want to **upsell** with a disabled UI (dimmed).",
      "/// - ✅ You want to gracefully **gate** non-critical widgets.",
      "///",
      "/// Avoid this when:",
      "/// - ❌ The gated content would break layout or flow when visible but disabled.",
      "/// - ❌ You want to fully eliminate logic branches (use FeatureGuard instead).",
      "///",
      "/// Example:",
      "/// ```dart",
      "/// FeatureGuardWrapper(",
      "///   module: 'nutrition',",
      "///   fallbackStyle: FeatureFallbackStyle.dimmed,",
      "///   tooltipMessage: 'Upgrade your plan to access nutrition tracking.',",
      "///   child: NutritionEditor(),",
      "/// )",
      "/// ```",
      "///",
      "class FeatureGuardWrapper extends StatelessWidget {",
      "  final String module;",
      "  final String? feature;",
      "  final bool requireEnabled;",
      "",
      "  /// Choose between `.hidden` or `.dimmed` fallback behavior.",
      "  final FeatureFallbackStyle fallbackStyle;",
      "",
      "  /// Optional tooltip or hover text shown over dimmed content.",
      "  final String? tooltipMessage;",
      "",
      "  /// Widget to render if the feature is available/enabled.",
      "  final Widget child;",
      "",
      "  const FeatureGuardWrapper({",
      "    Key? key,",
      "    required this.module,",
      "    this.feature,",
      "    this.requireEnabled = true,",
      "    this.fallbackStyle = FeatureFallbackStyle.hidden,",
      "    this.tooltipMessage,",
      "    required this.child,",
      "  }) : super(key: key);",
      "",
      "  bool _isPermitted(FranchiseFeatureProvider featureProvider) {",
      "    if (!featureProvider.hasFeature(module)) return false;",
      "    if (!requireEnabled) return true;",
      "    if (feature != null) {",
      "      return featureProvider.isSubfeatureEnabled(module, feature!);",
      "    }",
      "    return featureProvider.isModuleEnabled(module);",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final featureProvider = context.watch<FranchiseFeatureProvider>();",
      "",
      "    if (!featureProvider.isInitialized) {",
      "      return const SizedBox.shrink();",
      "    }",
      "",
      "    final isAllowed = _isPermitted(featureProvider);",
      "",
      "    // ✅ Feature is active → show as-is",
      "    if (isAllowed) return child;",
      "",
      "    // ❌ Feature blocked → determine fallback behavior",
      "    switch (fallbackStyle) {",
      "      case FeatureFallbackStyle.hidden:",
      "        return const SizedBox.shrink();",
      "",
      "      case FeatureFallbackStyle.dimmed:",
      "        return Tooltip(",
      "          message:",
      "              tooltipMessage ?? 'This feature is unavailable for your plan.',",
      "          child: IgnorePointer(",
      "            ignoring: true,",
      "            child: Opacity(",
      "              opacity: 0.4,",
      "              child: child,",
      "            ),",
      "          ),",
      "        );",
      "    }",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 105,
      "file_size": 3284,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\utils\\features\\feature_lock_overlay.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "",
      "///",
      "/// 🔐 FeatureLockOverlay",
      "///",
      "/// A flexible widget that overlays a centered lock icon, message, and optional",
      "/// upgrade button over a blurred or dimmed background.",
      "///",
      "/// Use this as the **visual overlay component** inside:",
      "/// - `FeatureGateBanner` (section overlays)",
      "/// - `FeatureGateModal` (coming soon)",
      "/// - Any dimmed card or locked list tile",
      "///",
      "/// ---",
      "///",
      "/// ✅ Use when:",
      "/// - You want a **consistent visual style** for locked features.",
      "/// - You're gating a **card**, **container**, or **section** with meaningful content.",
      "///",
      "/// ❌ Avoid when:",
      "/// - You're gating small elements (e.g. toggle switch only).",
      "/// - You want full invisibility (`FeatureFallbackStyle.hidden` is better).",
      "///",
      "class FeatureLockOverlay extends StatelessWidget {",
      "  final String? lockedMessage;",
      "  final VoidCallback? onTapUpgrade;",
      "  final Color backgroundColor;",
      "  final IconData lockIcon;",
      "",
      "  const FeatureLockOverlay({",
      "    Key? key,",
      "    this.lockedMessage,",
      "    this.onTapUpgrade,",
      "    this.backgroundColor = const Color(0xAA000000),",
      "    this.lockIcon = Icons.lock_outline,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Positioned.fill(",
      "      child: Container(",
      "        color: backgroundColor,",
      "        alignment: Alignment.center,",
      "        padding: const EdgeInsets.symmetric(horizontal: 16),",
      "        child: Column(",
      "          mainAxisSize: MainAxisSize.min,",
      "          children: [",
      "            Icon(lockIcon, size: 36, color: Colors.white),",
      "            const SizedBox(height: 8),",
      "            Text(",
      "              lockedMessage ?? 'This feature is unavailable in your plan.',",
      "              style: const TextStyle(color: Colors.white, fontSize: 14),",
      "              textAlign: TextAlign.center,",
      "            ),",
      "            if (onTapUpgrade != null) ...[",
      "              const SizedBox(height: 12),",
      "              ElevatedButton(",
      "                onPressed: onTapUpgrade,",
      "                child: const Text('Upgrade'),",
      "              ),",
      "            ],",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 67,
      "file_size": 2127,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\utils\\features\\feature_toggle_scaffold.dart",
    "content": [
      "// 🔧 Feature Toggle Registration Scaffold",
      "// Used in onboarding_feature_setup_screen.dart or devtools",
      "",
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/core/utils/features/enum_platform_features.dart';",
      "import 'package:franchise_admin_portal/core/utils/features/feature_gate.dart';",
      "",
      "class FeatureToggleScaffold extends StatelessWidget {",
      "  final Map<String, bool> currentState;",
      "  final void Function(String module, bool value) onToggle;",
      "",
      "  const FeatureToggleScaffold({",
      "    Key? key,",
      "    required this.currentState,",
      "    required this.onToggle,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return ListView(",
      "      children: PlatformFeature.values.map((feature) {",
      "        final key = feature.key;",
      "        final displayName = key.replaceAll('_', ' ').toUpperCase();",
      "",
      "        return SwitchListTile.adaptive(",
      "          value: currentState[key] ?? false,",
      "          title: Text(displayName),",
      "          subtitle: Text('Feature module: $key'),",
      "          onChanged: (value) => onToggle(key, value),",
      "        );",
      "      }).toList(),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 34,
      "file_size": 1131,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\core\\utils\\features\\form_validators.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "",
      "/// A utility class for reusable form field validators",
      "class FormValidators {",
      "  /// Ensures that the field is not null or empty",
      "  static String? requiredField(String? value) {",
      "    if (value == null || value.trim().isEmpty) {",
      "      return 'This field is required.';",
      "    }",
      "    return null;",
      "  }",
      "",
      "  /// Ensures the value is a valid positive number (for decimals or ints)",
      "  static String? nonNegativeNumber(String? value) {",
      "    if (value == null || value.trim().isEmpty) {",
      "      return 'Enter a number.';",
      "    }",
      "",
      "    final number = double.tryParse(value.trim());",
      "    if (number == null || number < 0) {",
      "      return 'Must be 0 or greater.';",
      "    }",
      "",
      "    return null;",
      "  }",
      "",
      "  /// Ensures that a dropdown or multiselect has a value",
      "  static String? requiredDropdown(dynamic value) {",
      "    if (value == null || (value is String && value.trim().isEmpty)) {",
      "      return 'Please make a selection.';",
      "    }",
      "    return null;",
      "  }",
      "",
      "  /// Ensures that a list has at least one value (for tag or chip-based inputs)",
      "  static String? requireAtLeastOne(List<dynamic>? items) {",
      "    if (items == null || items.isEmpty) {",
      "      return 'At least one must be selected.';",
      "    }",
      "    return null;",
      "  }",
      "",
      "  /// Ensures price format is valid (e.g., two decimal places)",
      "  static String? validPriceFormat(String? value) {",
      "    if (value == null || value.trim().isEmpty) {",
      "      return 'Enter a price.';",
      "    }",
      "",
      "    final number = double.tryParse(value.trim());",
      "    if (number == null || number < 0) {",
      "      return 'Must be a valid non-negative price.';",
      "    }",
      "",
      "    final parts = value.trim().split('.');",
      "    if (parts.length == 2 && parts[1].length > 2) {",
      "      return 'Max 2 decimal places allowed.';",
      "    }",
      "",
      "    return null;",
      "  }",
      "",
      "  /// Ensures the string length doesn't exceed a threshold",
      "  static String? maxLength(String? value, int limit) {",
      "    if (value != null && value.length > limit) {",
      "      return 'Maximum $limit characters allowed.';",
      "    }",
      "    return null;",
      "  }",
      "",
      "  /// Optional field: if not empty, must be a valid number",
      "  static String? optionalNumber(String? value) {",
      "    if (value == null || value.trim().isEmpty) return null;",
      "",
      "    final number = double.tryParse(value.trim());",
      "    if (number == null) return 'Must be a valid number.';",
      "    return null;",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 78,
      "file_size": 2348,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\l10n\\app_en.arb",
    "content": [
      "{",
      "  \"add\": \"Add\",",
      "  \"addAddress\": \"Add Address\",",
      "  \"addFavorite\": \"Add to Favorites\",",
      "  \"addMoreItems\": \"Add More Items\",",
      "  \"addScheduledOrder\": \"Add Scheduled Order\",",
      "  \"addToCart\": \"Add to Cart\",",
      "  \"addToFavoritesTooltip\": \"Add to favorites\",",
      "  \"address\": \"Address\",",
      "  \"addressAdded\": \"Address added\",",
      "  \"addressRemoved\": \"Address removed\",",
      "  \"alreadyHaveAccount\": \"Already have an account?\",",
      "  \"always\": \"Always\",",
      "  \"and\": \"and\",",
      "  \"applePay\": \"Apple Pay\",",
      "  \"appleSignInComingSoon\": \"Sign in with Apple (coming soon)\",",
      "  \"applyPromo\": \"Apply Promo\",",
      "  \"applyPromoCta\": \"Apply Promo\",",
      "  \"areYouSure\": \"Are you sure?\",",
      "  \"back\": \"Back\",",
      "  \"backToHome\": \"Back to Home\",",
      "  \"backToMenu\": \"Back to Menu\",",
      "  \"bannerCtaText\": \"Learn More\",",
      "  \"brandLogo\": \"Doughboys Pizzeria Logo\",",
      "  \"browseCategoryCta\": \"Browse\",",
      "  \"businessHours\": \"Business hours\",",
      "  \"cancel\": \"Cancel\",",
      "  \"cancelOrder\": \"Cancel Order\",",
      "  \"cart\": \"Cart\",",
      "  \"cartCleared\": \"Cart cleared\",",
      "  \"cartIsEmpty\": \"Your cart is empty.\",",
      "  \"cartTooltip\": \"View Cart\",",
      "  \"categoriesTitle\": \"Categories\",",
      "  \"categoryAppetizers\": \"Appetizers\",",
      "  \"categoryCalzones\": \"Calzones\",",
      "  \"categoryDesserts\": \"Desserts\",",
      "  \"categoryDinners\": \"Dinners\",",
      "  \"categoryDrinks\": \"Drinks\",",
      "  \"categoryFoodQuality\": \"Food Quality\",",
      "  \"categoryOrderAccuracy\": \"Order Accuracy\",",
      "  \"categoryPizzas\": \"Pizzas\",",
      "  \"categorySalads\": \"Salads\",",
      "  \"categoryService\": \"Service\",",
      "  \"categorySubs\": \"Subs\",",
      "  \"categoryDeliverySpeed\": \"Delivery Speed\",",
      "  \"chatSupportTitle\": \"Chat Support\",",
      "  \"chatWithUs\": \"Chat with Us\",",
      "  \"checkBackSoon\": \"Check back soon for more promotions.\",",
      "  \"checkConnectionAndTryAgain\": \"Check your connection and try again.\",",
      "  \"checkConnectionToReload\": \"Check your connection to reload.\",",
      "  \"checkout\": \"Checkout\",",
      "  \"chooseDeliveryTime\": \"Choose Delivery Time\",",
      "  \"choosePickupTime\": \"Choose Pickup Time\",",
      "  \"city\": \"City\",",
      "  \"cityRequired\": \"City is required\",",
      "  \"close\": \"Close\",",
      "  \"confirm\": \"Confirm\",",
      "  \"confirmDeleteAccount\": \"Are you sure you want to delete your account?\",",
      "  \"confirmPassword\": \"Confirm Password\",",
      "  \"continueAsGuest\": \"Continue as Guest\",",
      "  \"continueAsGuestButton\": \"Continue as Guest\",",
      "  \"continueButton\": \"Continue\",",
      "  \"couldNotLaunchUrl\": \"Could not launch URL\",",
      "  \"couldNotLoadPromotions\": \"Could not load promotions.\",",
      "  \"create\": \"Create\",",
      "  \"createAccount\": \"Create Account\",",
      "  \"creditDebitCard\": \"Credit/Debit Card\",",
      "  \"currencyFormat\": \"${value}\",",
      "  \"customizationComingSoon\": \"Customization options coming soon!\",",
      "  \"customizationPrice\": \"+{price}\",",
      "  \"customizations\": \"Customizations\",",
      "  \"customize\": \"Customize\",",
      "  \"customizeAndAddToCart\": \"Customize & Add to Cart\",",
      "  \"date\": \"Date\",",
      "  \"defaultBannerCta\": \"Learn More\",",
      "  \"delete\": \"Delete\",",
      "  \"deleteAccount\": \"Delete Account\",",
      "  \"deleteAddress\": \"Delete Address\",",
      "  \"delivery\": \"Delivery\",",
      "  \"deliveryAddresses\": \"Delivery Addresses\",",
      "  \"deliveryFee\": \"Delivery Fee\",",
      "  \"deliveryType\": \"Delivery\",",
      "  \"description\": \"Description\",",
      "  \"dontHaveAccount\": \"Don’t have an account?\",",
      "  \"edit\": \"Edit\",",
      "  \"editAddress\": \"Edit Address\",",
      "  \"editScheduledOrder\": \"Edit Scheduled Order\",",
      "  \"email\": \"Email\",",
      "  \"emptyCart\": \"Empty Cart\",",
      "  \"emptyStateMessage\": \"There’s nothing here yet!\",",
      "  \"enterName\": \"Enter your name\",",
      "  \"error\": \"Error\",",
      "  \"errorLoadingCart\": \"Error loading cart.\",",
      "  \"favoriteOrderItems\": \"Items: {items}\",",
      "  \"@favoriteOrderItems\": {",
      "    \"description\": \"Shows items in favorite order\",",
      "    \"placeholders\": {",
      "      \"items\": {}",
      "    }",
      "  },",
      "  \"favoriteOrders\": \"Favorite Orders\",",
      "  \"favorites\": \"Favorites\",",
      "  \"fieldRequired\": \"This field is required.\",",
      "  \"feedback\": \"Feedback\",",
      "  \"feedbackBackToMenu\": \"Back to Menu\",",
      "  \"feedbackCommentsLabel\": \"Additional comments (optional)\",",
      "  \"feedbackOfflineBody\": \"Feedback queued and will be submitted when online.\",",
      "  \"feedbackOfflineTitle\": \"Offline Mode\",",
      "  \"feedbackPromptTitle\": \"How was your order?\",",
      "  \"feedbackScreenTitle\": \"Order Feedback\",",
      "  \"feedbackStarTooltip\": \"{stars, plural, one {# star} other {# stars}}\",",
      "  \"feedbackSubmitAnonymous\": \"Submit anonymously\",",
      "  \"feedbackSubmitButton\": \"Submit Feedback\",",
      "  \"feedbackSubmitted\": \"Feedback submitted. Thank you!\",",
      "  \"feedbackThankYouBody\": \"Your feedback has been submitted.\",",
      "  \"feedbackThankYouTitle\": \"Thank You!\",",
      "  \"forgotPassword\": \"Forgot Password?\",",
      "  \"frequency\": \"Frequency\",",
      "  \"frequencyDaily\": \"Daily\",",
      "  \"frequencyMonthly\": \"Monthly\",",
      "  \"frequencyWeekly\": \"Weekly\",",
      "  \"googlePay\": \"Google Pay\",",
      "  \"guestCheckout\": \"Continue as Guest\",",
      "  \"help\": \"Help\",",
      "  \"hidePassword\": \"Hide Password\",",
      "  \"ingredients\": \"Ingredients\",",
      "  \"instructions\": \"Instructions\",",
      "  \"invalidEmail\": \"Invalid email address.\",",
      "  \"invalidPassword\": \"Invalid password.\",",
      "  \"invalidPromo\": \"Invalid promo code.\",",
      "  \"invalidZip\": \"Invalid ZIP code\",",
      "  \"itemAdded\": \"Item added to cart\",",
      "  \"itemDetails\": \"Item Details\",",
      "  \"itemRemovedFromCart\": \"Item removed from cart\",",
      "  \"itemUnavailable\": \"Item is unavailable.\",",
      "  \"items\": \"Items:\",",
      "  \"labelExample\": \"Label (e.g., Home)\",",
      "  \"labelRequired\": \"Label is required\",",
      "  \"language\": \"Language\",",
      "  \"languageEnglish\": \"English\",",
      "  \"languageSetTo\": \"Language set to {lang}\",",
      "  \"languageSpanish\": \"Spanish\",",
      "  \"lastName\": \"Last Name\",",
      "  \"leaveFeedback\": \"Leave Feedback\",",
      "  \"loading\": \"Loading...\",",
      "  \"loadingError\": \"Error loading data.\",",
      "  \"loyalty\": \"Loyalty\",",
      "  \"loyaltyAndRewards\": \"Loyalty & Rewards\",",
      "  \"loyaltyErrorLoading\": \"Error loading loyalty data.\",",
      "  \"loyaltyLastRedeemed\": \"Last redeemed:\",",
      "  \"loyaltyLevel\": \"Level {level}\",",
      "  \"loyaltyNoActivitySubtitle\": \"Order more to start earning points and rewards.\",",
      "  \"loyaltyNoActivityTitle\": \"No loyalty activity yet!\",",
      "  \"loyaltyNextReward\": \"Next reward in {points} pts\",",
      "  \"loyaltyOrderNow\": \"Order Now\",",
      "  \"loyaltyPoints\": \"{points} pts\",",
      "  \"loyaltyRankLegend\": \"Legend\",",
      "  \"loyaltyRankNewbie\": \"Newbie\",",
      "  \"loyaltyRankPro\": \"Pro\",",
      "  \"loyaltyRankRegular\": \"Regular\",",
      "  \"loyaltyYourRewards\": \"Your Rewards\",",
      "  \"mainMenuTitle\": \"Main Menu\",",
      "  \"menuBeingUpdated\": \"Our menu is being updated. Please check back soon.\",",
      "  \"menuCategoryLabel\": \"Menu category: {categoryName}\",",
      "  \"@menuCategoryLabel\": {",
      "    \"description\": \"Label for menu category used by screen readers for accessibility\",",
      "    \"placeholders\": {",
      "      \"categoryName\": {}",
      "    }",
      "  },",
      "  \"menuItems\": \"Menu Items\",",
      "  \"menuLoadError\": \"Menu could not be loaded.\",",
      "  \"menuUnavailable\": \"Menu unavailable. Check your connection.\",",
      "  \"message\": \"Message\",",
      "  \"mustAcceptTerms\": \"You must accept the Terms & Privacy Policy to continue.\",",
      "  \"mustSignInForAddresses\": \"You must be signed in to manage addresses.\",",
      "  \"mustSignInForCart\": \"You must be signed in to view your cart.\",",
      "  \"mustSignInForChat\": \"You must be signed in to use chat support.\",",
      "  \"mustSignInForFavorites\": \"You must be signed in to view favorites.\",",
      "  \"mustSignInForScheduledOrders\": \"You must be signed in to view scheduled orders.\",",
      "  \"myAccount\": \"My Account\",",
      "  \"name\": \"Name\",",
      "  \"networkError\": \"Network error. Please try again.\",",
      "  \"newScheduledOrder\": \"New Scheduled Order\",",
      "  \"next\": \"Next\",",
      "  \"nextRunDate\": \"Next Run Date\",",
      "  \"no\": \"No\",",
      "  \"noAddressesSaved\": \"No addresses saved\",",
      "  \"noCategories\": \"No categories available.\",",
      "  \"noCategoriesAvailable\": \"No categories available.\",",
      "  \"noFavoriteMenuItems\": \"No favorite menu items\",",
      "  \"noFavoriteOrdersSaved\": \"No favorite orders saved\",",
      "  \"noMessages\": \"No messages yet.\",",
      "  \"noPastOrders\": \"No past orders\",",
      "  \"noPromotions\": \"No current promotions.\",",
      "  \"noResults\": \"No results found.\",",
      "  \"noScheduledOrders\": \"No scheduled orders\",",
      "  \"notFound\": \"Not Found\",",
      "  \"notSignedIn\": \"Not signed in\",",
      "  \"nutrition\": \"Nutrition Info\",",
      "  \"offline\": \"Offline\",",
      "  \"offlineMenu\": \"You’re offline. Menu unavailable.\",",
      "  \"ok\": \"OK\",",
      "  \"optional\": \"Optional\",",
      "  \"orderCancelled\": \"Order cancelled.\",",
      "  \"orderConfirmed\": \"Order Confirmed!\",",
      "  \"orderDateAndTotal\": \"{date} - ${total}\",",
      "  \"@orderDateAndTotal\": {",
      "    \"description\": \"Order date and total, e.g. '2024-06-01 - $22.99'\",",
      "    \"placeholders\": {",
      "      \"date\": {},",
      "      \"total\": {}",
      "    }",
      "  },",
      "  \"orderFailed\": \"Order failed\",",
      "  \"orderHistory\": \"Order History\",",
      "  \"orderNowCta\": \"Order Now\",",
      "  \"orderNumber\": \"Order #\",",
      "  \"orderNumberWithId\": \"Order #{id}\",",
      "  \"@orderNumberWithId\": {",
      "    \"description\": \"Order number with ID shown in order lists/cards\",",
      "    \"placeholders\": {",
      "      \"id\": {}",
      "    }",
      "  },",
      "  \"orderPlaced\": \"Order placed!\",",
      "  \"orderSummary\": \"Order Summary\",",
      "  \"orderTotal\": \"Total\",",
      "  \"orders\": \"Orders\",",
      "  \"password\": \"Password\",",
      "  \"passwordResetFailed\": \"Password reset failed. Try again later.\",",
      "  \"passwordResetSent\": \"Password reset email sent\",",
      "  \"passwordStrength\": \"Password strength\",",
      "  \"passwordTooShort\": \"Password must be at least 6 characters\",",
      "  \"passwordsDoNotMatch\": \"Passwords do not match.\",",
      "  \"pause\": \"Pause\",",
      "  \"pauseSchedule\": \"Pause schedule\",",
      "  \"paymentFailed\": \"Payment failed.\",",
      "  \"paymentMethod\": \"Payment Method\",",
      "  \"phoneNumber\": \"Phone Number\",",
      "  \"pickTime\": \"Pick Time\",",
      "  \"pickup\": \"Pickup\",",
      "  \"placeOrder\": \"Place Order\",",
      "  \"pleaseSelectTime\": \"Please select a time.\",",
      "  \"points\": \"Points\",",
      "  \"posSystem\": \"POS System (Mock/API Demo)\",",
      "  \"poweredBy\": \"Powered by Dough Boys Tech\",",
      "  \"previous\": \"Previous\",",
      "  \"price\": \"Price\",",
      "  \"privacyPolicy\": \"Privacy Policy\",",
      "  \"proceedToCheckout\": \"Proceed to Checkout\",",
      "  \"profile\": \"Profile\",",
      "  \"promo\": \"Promo\",",
      "  \"promoApplied\": \"Promo applied!\",",
      "  \"promoCode\": \"Promo Code\",",
      "  \"promoDiscount\": \"Promo Discount\",",
      "  \"promotionsLoadError\": \"Could not load promotions.\",",
      "  \"quantity\": \"Quantity\",",
      "  \"quantityAtLeastOne\": \"Quantity must be at least 1.\",",
      "  \"ratingRequiredError\": \"Please select a star rating.\",",
      "  \"redeem\": \"Redeem\",",
      "  \"rememberMe\": \"Remember me\",",
      "  \"remove\": \"Remove\",",
      "  \"removeFavorite\": \"Remove from Favorites\",",
      "  \"removeFromCart\": \"Remove\",",
      "  \"removeFromFavoritesTooltip\": \"Remove from favorites\",",
      "  \"required\": \"Required\",",
      "  \"resetPassword\": \"Reset Password\",",
      "  \"resume\": \"Resume\",",
      "  \"retry\": \"Retry\",",
      "  \"reviewOrder\": \"Review Order\",",
      "  \"rewardAvailableSemantic\": \"Reward available\",",
      "  \"rewardClaim\": \"Claim\",",
      "  \"rewardClaimed\": \"Claimed\",",
      "  \"rewardClaimedSemantic\": \"Reward claimed\",",
      "  \"rewardClaimedSuccess\": \"Reward successfully claimed!\",",
      "  \"rewardRedeemed\": \"Reward redeemed!\",",
      "  \"reorder\": \"Reorder\",",
      "  \"reorderNotImplemented\": \"Reorder not implemented\",",
      "  \"rewards\": \"Rewards\",",
      "  \"returnToHome\": \"Return to Home\",",
      "  \"save\": \"Save\",",
      "  \"scheduledOrderSubtitle\": \"Frequency: {frequency}, Next: {nextRun}\\\\nItems: {items}\",",
      "  \"@scheduledOrderSubtitle\": {",
      "    \"description\": \"Subtitle for scheduled orders in the list\",",
      "    \"placeholders\": {",
      "      \"frequency\": {},",
      "      \"nextRun\": {},",
      "      \"items\": {}",
      "    }",
      "  },",
      "  \"scheduledOrders\": \"Scheduled Orders\",",
      "  \"search\": \"Search\",",
      "  \"searchMenu\": \"Search Menu...\",",
      "  \"seeLess\": \"See Less\",",
      "  \"seeMore\": \"See More\",",
      "  \"selectItems\": \"Select Items:\",",
      "  \"selectLanguage\": \"Select Language\",",
      "  \"selectTime\": \"Select Time\",",
      "  \"send\": \"Send\",",
      "  \"sendResetLink\": \"Send Reset Link\",",
      "  \"shopNow\": \"Shop Now\",",
      "  \"showPassword\": \"Show Password\",",
      "  \"signIn\": \"Sign In\",",
      "  \"signInButton\": \"Sign In\",",
      "  \"signInFailed\": \"Sign in failed. Please check your credentials.\",",
      "  \"signInNow\": \"Sign in now\",",
      "  \"signInProfileError\": \"Sign in succeeded but could not load profile. Try again.\",",
      "  \"signInToFavoriteTooltip\": \"Sign in to favorite\",",
      "  \"signInToOrder\": \"Log in to place your order.\",",
      "  \"signOut\": \"Sign Out\",",
      "  \"signUp\": \"Sign Up\",",
      "  \"signUpFailed\": \"Sign up failed. Try a different email.\",",
      "  \"signUpNow\": \"Sign up now\",",
      "  \"signUpNowButton\": \"Sign Up Now\",",
      "  \"signUpProfileFailed\": \"Sign up succeeded but profile setup failed. Try again.\",",
      "  \"startShopping\": \"Start Shopping\",",
      "  \"state\": \"State\",",
      "  \"stateRequired\": \"State is required\",",
      "  \"status\": \"Status\",",
      "  \"street\": \"Street\",",
      "  \"streetRequired\": \"Street is required\",",
      "  \"strong\": \"Strong\",",
      "  \"subtotal\": \"Subtotal\",",
      "  \"support\": \"Support\",",
      "  \"supportIsOnline\": \"{franchiseName} support is online\",",
      "  \"@supportIsOnline\": {",
      "    \"description\": \"Support chat is online with dynamic franchise name\",",
      "    \"placeholders\": {",
      "      \"franchiseName\": {}",
      "    }",
      "  },",
      "  \"supportWillReplySoon\": \"{franchiseName} support will reply soon\",",
      "  \"@supportWillReplySoon\": {",
      "    \"description\": \"Support chat offline message with dynamic franchise name\",",
      "    \"placeholders\": {",
      "      \"franchiseName\": {}",
      "    }",
      "  },",
      "  \"tax\": \"Tax\",",
      "  \"termsAndPrivacyPolicy\": \"By continuing, you agree to our Terms & Privacy Policy.\",",
      "  \"termsOfService\": \"Terms of Service\",",
      "  \"thankYouForYourOrder\": \"Thank you for your order!\",",
      "  \"time\": \"Time\",",
      "  \"total\": \"Total\",",
      "  \"trackOrder\": \"Track Order\",",
      "  \"tryAgain\": \"Try Again\",",
      "  \"tryAgainLater\": \"Please try again later.\",",
      "  \"typeYourMessage\": \"Type your message...\",",
      "  \"unknownError\": \"An unknown error occurred.\",",
      "  \"update\": \"Update\",",
      "  \"validEmailRequired\": \"Enter a valid email\",",
      "  \"viewAll\": \"View All\",",
      "  \"viewDetails\": \"View Details\",",
      "  \"viewMenu\": \"View Menu\",",
      "  \"weak\": \"Weak\",",
      "  \"welcome\": \"Welcome\",",
      "  \"welcomeSubtitle\": \"Order your favorite pizza or sign in for a full experience.\",",
      "  \"welcomeTitle\": \"Welcome to {franchiseName}\",",
      "  \"@welcomeTitle\": {",
      "    \"description\": \"Welcome headline with dynamic franchise name\",",
      "    \"placeholders\": {",
      "      \"franchiseName\": {}",
      "    }",
      "  },",
      "  \"welcomeTitleHint\": \"Welcome headline with dynamic franchise name\",",
      "  \"welcomeUser\": \"Welcome, {name}!\",",
      "  \"@welcomeUser\": {",
      "    \"description\": \"Personalized welcome message for signed-in user\",",
      "    \"placeholders\": {",
      "      \"name\": {}",
      "    }",
      "  },",
      "  \"yes\": \"Yes\",",
      "  \"yourCartIsEmpty\": \"Your cart is empty\",",
      "  \"yourOrderIdIs\": \"Your order ID is:\",",
      "  \"zipCode\": \"ZIP Code\",",
      "  \"zipRequired\": \"ZIP is required\",",
      "  \"medium\": \"Medium\",",
      "  \"iAgreeToThe\": \"I agree to the\",",
      "  \"sortByPopularity\": \"Popularity\",",
      "  \"sortByPrice\": \"Price\",",
      "  \"sortByName\": \"Name\",",
      "  \"logInToOrder\": \"Log in to place your order.\",",
      "  \"addedToCartMessage\": \"Added to cart!\",",
      "  \"clearCart\": \"Clear Cart\",",
      "  \"clearCartConfirmation\": \"Are you sure you want to clear your cart?\",",
      "  \"removeItem\": \"Remove item\",",
      "  \"selectedTimeOutsideBusinessHours\": \"Selected time is outside business hours.\",",
      "  \"orderType\": \"Order Type\",",
      "  \"cashPayment\": \"Cash (Pay at Pickup/Delivery)\",",
      "  \"logoErrorTooltip\": \"App logo unavailable\",",
      "  \"loyaltyRewardClaimedOn\": \"Claimed on {date}\",",
      "  \"@loyaltyRewardClaimedOn\": {",
      "    \"description\": \"Shows when the loyalty reward was claimed\",",
      "    \"placeholders\": {",
      "      \"date\": {}",
      "    }",
      "  },",
      "  \"loyaltyRewardRequiredPoints\": \"{points} pts required\",",
      "  \"@loyaltyRewardRequiredPoints\": {",
      "    \"description\": \"Number of points required for reward\",",
      "    \"placeholders\": {",
      "      \"points\": {}",
      "    }",
      "  },",
      "  \"sortBy\": \"Sort by\",",
      "  \"addCategoryPrompt\": \"Get started by adding a new category.\",",
      "  \"categoryName\": \"Category Name\",",
      "  \"categoryDescription\": \"Description (optional)\",",
      "  \"categoryImageUrl\": \"Image URL or Asset Path (optional)\",",
      "  \"nameRequired\": \"Name is required.\",",
      "  \"saveFailed\": \"Failed to save. Try again.\",",
      "  \"deleteFailed\": \"Failed to delete. Try again.\",",
      "  \"loadFailed\": \"Failed to load categories.\",",
      "  \"manageCategories\": \"Manage Categories\",",
      "  \"addCategory\": \"Add Category\",",
      "  \"editCategory\": \"Edit Category\",",
      "  \"deleteCategory\": \"Delete Category\",",
      "  \"deleteCategoryConfirm\": \"Delete category \\\"{name}\\\"? This cannot be undone.\",",
      "  \"categorySaved\": \"Category saved.\",",
      "  \"categoryDeleted\": \"Category deleted.\",",
      "  \"bulkUpload\": \"Bulk Upload\",",
      "  \"bulkUploadCategories\": \"Bulk Upload Categories\",",
      "  \"bulkUploadInstructions\": \"Paste a CSV (name,image,description) with one category per line below. First line is header.\",",
      "  \"bulkUploadPasteCsv\": \"Paste CSV data here\",",
      "  \"bulkUploadSuccess\": \"Categories uploaded successfully.\",",
      "  \"bulkUploadError\": \"Error uploading categories.\",",
      "  \"upload\": \"Upload\",",
      "  \"adminCategoryManagement\": \"Category Management\",",
      "  \"noCategoriesFound\": \"No categories found.\",",
      "  \"noCategoriesAdminHint\": \"Start by adding a new category or using bulk upload.\",",
      "  \"loadError\": \"Error loading categories.\",",
      "  \"searchCategories\": \"Search categories...\",",
      "  \"requiredField\": \"This field is required.\",",
      "  \"adminSearchHint\": \"Search...\",",
      "  \"clear\": \"Clear\",",
      "  \"categoryAdded\": \"Category added successfully.\",",
      "  \"categoryUpdated\": \"Category updated successfully.\",",
      "  \"errorLoadingCategories\": \"Error loading categories.\",",
      "  \"pleaseTryAgain\": \"Please try again.\",",
      "  \"noCategoriesMessage\": \"No categories found. Add your first category to get started.\",",
      "  \"menuEditorTitle\": \"Menu Editor\",",
      "  \"addItem\": \"Add Item\",",
      "  \"bulkDelete\": \"Delete Selected\",",
      "  \"itemUpdated\": \"Menu item updated.\",",
      "  \"itemDeleted\": \"Menu item deleted.\",  ",
      "  \"customizationsUpdated\": \"Customizations updated.\",",
      "  \"exportMenu\": \"Export Menu (CSV)\",",
      "  \"exportStarted\": \"Export started...\",",
      "  \"bulkImport\": \"Bulk Import\",",
      "  \"bulkImportSuccess\": \"Bulk import completed.\",",
      "  \"deleteItemsTitle\": \"Delete Menu Items\",",
      "  \"deleteItemsPrompt\": \"Are you sure you want to delete {count} menu items?\",",
      "  \"undo\": \"Undo\",  ",
      "  \"searchMenuHint\": \"Search menu items, SKU, or category...\",",
      "  \"colImage\": \"Image\",",
      "  \"colName\": \"Name\",",
      "  \"colCategory\": \"Category\",",
      "  \"colPrice\": \"Price\",",
      "  \"colAvailable\": \"Available\",",
      "  \"colSKU\": \"SKU\",",
      "  \"colDietary\": \"Dietary\",",
      "  \"colAllergens\": \"Allergens\",",
      "  \"colActions\": \"Actions\",",
      "  \"bulkActionsSelected\": \"{count} selected\",",
      "  \"clearSelection\": \"Clear Selection\",",
      "  \"errorLoadingMenu\": \"Error loading menu items\",",
      "  \"noCategoriesMsg\": \"Create at least one category before adding menu items.\",",
      "  \"noMenuItems\": \"No menu items yet\",",
      "  \"noMenuItemsMsg\": \"Add your first menu item.\",",
      "  \"addCustomization\": \"Add Customization\",",
      "  \"editCustomization\": \"Edit Customization\",",
      "  \"deleteCustomization\": \"Delete Customization\",",
      "  \"customizationName\": \"Option Name\",",
      "  \"customizationPrice\": \"Option Price\",",
      "  \"deleteConfirm\": \"Delete\",",
      "  \"bulkEdit\": \"Bulk Edit\",",
      "  \"bulkUpdate\": \"Bulk Update\",",
      "  \"auditLog\": \"Audit Log\",",
      "  \"auditLogEntry\": \"Entry\",",
      "  \"auditAction\": \"Action\",",
      "  \"auditUser\": \"User\",",
      "  \"auditTargetType\": \"Target Type\",",
      "  \"auditTargetId\": \"Target ID\",",
      "  \"auditTimestamp\": \"Timestamp\",",
      "  \"auditDetails\": \"Details\",",
      "  \"auditIpAddress\": \"IP Address\",",
      "  \"auditLogEmpty\": \"No audit log entries yet.\",",
      "  \"auditLogLoadError\": \"Failed to load audit log.\",",
      "  \"auditLogFilterByType\": \"Filter by target type\",",
      "  \"auditLogFilterByUser\": \"Filter by user\",",
      "  \"auditLogSearch\": \"Search audit log...\",",
      "  \"auditLogViewDetails\": \"View Details\",",
      "  \"exportMenu\": \"Export Menu\",",
      "  \"exportMenuTitle\": \"Export Menu to CSV\",",
      "  \"exportMenuInstructions\": \"Export all menu items and categories to a CSV file for backup or audit.\",",
      "  \"exportMenuSuccess\": \"Menu exported successfully.\",",
      "  \"exportMenuFailed\": \"Menu export failed.\",",
      "  \"downloadCsv\": \"Download CSV\",",
      "  \"type\": \"Type\",",
      "  \"singleSelect\": \"Single Select\",",
      "  \"multiSelect\": \"Multi Select\",",
      "  \"quantitySelect\": \"Quantity Select\",",
      "  \"minSelect\": \"Min Select\",",
      "  \"maxSelect\": \"Max Select\",",
      "  \"addOption\": \"Add Option\",",
      "  \"noCustomizations\": \"No customization groups added.\",",
      "  \"setAsDefault\": \"Set as default\",",
      "  \"bulkUploadNoData\": \"No data detected.\",",
      "  \"bulkUploadPreview\": \"Preview ({count} items):\",",
      "  \"adminDashboardTitle\": \"Admin Dashboard\",",
      "  \"unauthorizedAccess\": \"You do not have permission to access the admin dashboard.\",",
      "  \"menuEditorTitle\": \"Menu Editor\",",
      "  \"categoryManagementTitle\": \"Category Management\",",
      "  \"inventoryManagementTitle\": \"Inventory Management\",",
      "  \"orderAnalyticsTitle\": \"Order Analytics\",",
      "  \"feedbackManagementTitle\": \"Feedback Management\",",
      "  \"promoManagementTitle\": \"Promo Management\",",
      "  \"staffAccessTitle\": \"Staff Access\",",
      "  \"featureSettingsTitle\": \"Feature Settings\",",
      "  \"inventory\": \"Inventory\",",
      "  \"addInventory\": \"Add Inventory\",",
      "  \"editInventory\": \"Edit Inventory\",",
      "  \"deleteInventoryTitle\": \"Delete Inventory Item?\",",
      "  \"deleteInventoryPrompt\": \"Are you sure you want to delete {name}?\",",
      "  \"inventoryAdded\": \"Inventory item added.\",",
      "  \"inventoryUpdated\": \"Inventory item updated.\",",
      "  \"inventoryDeleted\": \"Inventory item deleted.\",",
      "  \"errorLoadingInventory\": \"Error loading inventory\",",
      "  \"noInventory\": \"No inventory found.\",",
      "  \"noInventoryMsg\": \"No inventory items are currently available.\",",
      "  \"inventorySearchHint\": \"Search inventory by name or SKU...\",",
      "  \"adminChatManagementTitle\": \"Chat Management\",",
      "  \"adminFeatureSettingsTitle\": \"Feature Settings\",",
      "  \"adminFeedbackManagementTitle\": \"Feedback Management\",",
      "  \"adminAnalyticsDashboardTitle\": \"Analytics Dashboard\",",
      "  \"adminPromoManagementTitle\": \"Promo Management\",",
      "  \"adminBulkUploadPromo\": \"Bulk Upload Promos\",",
      "  \"adminExportPromo\": \"Export Promos\",",
      "  \"adminCreatePromo\": \"Create Promo\",",
      "  \"adminEditPromo\": \"Edit Promo\",",
      "  \"adminExportAnalytics\": \"Export Analytics\",",
      "  \"adminFeedbackDetail\": \"Feedback Details\",",
      "  \"adminFeatureToggle\": \"Feature Toggles\",",
      "  \"adminReplyChat\": \"Reply to Chat\",",
      "  \"adminUploadAll\": \"Upload All\",",
      "  \"adminChooseFile\": \"Choose File (JSON/CSV)\",",
      "  \"adminNoFeedback\": \"No feedback submitted yet.\",",
      "  \"adminNoChats\": \"No support chats yet.\",",
      "  \"adminNoPromos\": \"No promotions yet.\",",
      "  \"adminNoFeatures\": \"No features found.\",",
      "  \"adminCancel\": \"Cancel\",",
      "  \"adminSave\": \"Save\",",
      "  \"adminSend\": \"Send\",",
      "  \"adminDelete\": \"Delete\",",
      "  \"adminClose\": \"Close\",",
      "  \"adminExport\": \"Export\",",
      "  \"adminActive\": \"Active\",",
      "  \"adminStartDate\": \"Start Date\",",
      "  \"adminEndDate\": \"End Date\",",
      "  \"adminMaxUses\": \"Max Uses\",",
      "  \"adminMaxUsesType\": \"Max Uses Type\",",
      "  \"adminDiscount\": \"Discount\",",
      "  \"adminType\": \"Type\",",
      "  \"adminMinOrderValue\": \"Min Order Value\",",
      "  \"adminPromoTitle\": \"Title\",",
      "  \"adminPromoDescription\": \"Description\",",
      "  \"adminPromoItems\": \"Applicable Items\",",
      "  \"adminDeletePromoConfirm\": \"Are you sure you want to delete this promotion?\",",
      "  \"adminDeleteChatConfirm\": \"Are you sure you want to delete this chat thread?\",",
      "  \"adminDeleteFeedbackConfirm\": \"Are you sure you want to delete this feedback?\",",
      "  \"adminPreview\": \"Preview\",",
      "  \"adminExportedTo\": \"Exported to: {path}\",",
      "  \"adminExporting\": \"Exporting...\",",
      "  \"adminUploadFailed\": \"Failed to parse file: {error}\",",
      "  \"adminUploadSuccess\": \"Promo upload complete.\",",
      "  \"adminPromoExportSuccess\": \"Promos exported successfully.\",",
      "  \"adminAnalyticsExportSuccess\": \"Analytics exported successfully.\",",
      "  \"adminFieldRequired\": \"Required\",",
      "  \"adminPromoBulkUploadDesc\": \"Import multiple promos from a JSON or CSV file.\",",
      "  \"adminPromoExportDesc\": \"Export all active promos to CSV.\",",
      "  \"adminAnalyticsExportDesc\": \"Export summary analytics to CSV.\",",
      "  \"adminFeedbackDetailCategories\": \"Categories\",",
      "  \"adminFeedbackDetailRating\": \"Rating\",",
      "  \"adminFeedbackDetailComment\": \"Comment\",",
      "  \"adminFeedbackDetailTimestamp\": \"Timestamp\",",
      "  \"adminFeedbackDetailUserId\": \"User ID\",",
      "  \"adminFeedbackDetailOrderId\": \"Order ID\",",
      "  \"adminFeedbackDetailAnonymous\": \"Anonymous\",",
      "  \"adminSendReply\": \"Send Reply\",",
      "  \"adminReplySent\": \"Reply sent.\",",
      "  \"adminReplyFailed\": \"Failed to send reply.\",",
      "  \"sku\": \"SKU\",",
      "  \"available\": \"Available\",",
      "  \"stock\": \"Stock\",",
      "  \"threshold\": \"Low Stock Threshold\",",
      "  \"unitType\": \"Unit Type\",",
      "  \"editInventory\": \"Edit Inventory\",",
      "  \"addInventory\": \"Add Inventory\",",
      "  \"inventoryAdded\": \"Inventory item added.\",",
      "  \"inventoryUpdated\": \"Inventory item updated.\",",
      "  \"deleteInventoryTitle\": \"Delete Inventory Item\",",
      "  \"deleteInventoryPrompt\": \"Are you sure you want to delete {name}?\",",
      "  \"inventoryDeleted\": \"Inventory item deleted.\",",
      "  \"undo\": \"Undo\",",
      "  \"inventorySearchHint\": \"Search inventory...\",",
      "  \"errorLoadingInventory\": \"Error loading inventory.\",",
      "  \"noInventory\": \"No Inventory\",",
      "  \"noInventoryMsg\": \"No inventory items found.\",",
      "  \"staffAccessTitle\": \"Staff Access\",",
      "  \"staffAddStaffTooltip\": \"Add Staff\",",
      "  \"staffNoStaffTitle\": \"No Staff\",",
      "  \"staffNoStaffMessage\": \"No staff members have been added yet.\",",
      "  \"staffAddStaffDialogTitle\": \"Add Staff Member\",",
      "  \"staffNameLabel\": \"Name\",",
      "  \"staffEmailLabel\": \"Email\",",
      "  \"staffRoleLabel\": \"Role\",",
      "  \"staffRoleOwner\": \"Owner\",",
      "  \"staffRoleManager\": \"Manager\",",
      "  \"staffRoleStaff\": \"Staff\",",
      "  \"staffAddButton\": \"Add\",",
      "  \"staffRemoveTooltip\": \"Remove\",",
      "  \"staffRemoveDialogTitle\": \"Remove Staff\",",
      "  \"staffRemoveDialogBody\": \"Are you sure you want to remove this staff member?\",",
      "  \"staffRemoveButton\": \"Remove\",",
      "  \"cancelButton\": \"Cancel\",",
      "  \"staffNameRequired\": \"Name is required.\",",
      "  \"staffEmailRequired\": \"Email is required.\",",
      "  \"adminPanel\": \"Admin Panel\",",
      "  \"adminPanelTooltip\": \"Go to Admin Dashboard\",",
      "  \"unauthorizedAdminMessage\": \"Unauthorized — You do not have permission to access this page.\",",
      "  \"returnToHomeButton\": \"Return to Home\",",
      "  \"pleaseSelectRequired\": \"Please select required options\",",
      "  \"pleaseSelectAtLeast\": \"Please select at least {num} options for {name}.\",",
      "  \"tooManySelected\": \"You have selected too many options for {name}. Maximum allowed is {max}.\",",
      "  \"outOfStock\": \"Out of stock\",",
      "  \"outOfStockLabel\": \"Out of stock\",",
      "  \"cartEmpty\": \"Your cart is empty.\",",
      "  \"completeProfileTitle\": \"Complete Your Profile\",",
      "  \"completeProfileMessage\": \"Please review and update your name and phone number before continuing. You only need to do this once.\",",
      "  \"saveAndContinue\": \"Save & Continue\",",
      "  \"skipForNow\": \"Skip for now\",",
      "  \"invalidPhoneNumber\": \"Enter a valid phone number.\",",
      "  \"enterName\": \"Please enter your name.\",",
      "  \"unexpectedError\": \"An unexpected error occurred.\",",
      "  \"includedIngredientsLabel\": \"Current Ingredients\",",
      "  \"chooseCrustTypeLabel\": \"Crust Type\",",
      "  \"chooseCookTypeLabel\": \"Cook Type\",",
      "  \"chooseCutStyleLabel\": \"Cut Style\",",
      "  \"chooseDressingLabel\": \"Dressing\",",
      "  \"chooseSideLabel\": \"Choose Side\",",
      "  \"portionWhole\": \"Whole\",",
      "  \"portionLeft\": \"Left\",",
      "  \"portionRight\": \"Right\",",
      "  \"extraLabel\": \"Extra\",",
      "  \"doubleLabel\": \"Double\",",
      "  \"addToppingLimitNotice\": \"First {count} toppings included\",",
      "  \"additionalDressingNotice\": \"Additional dressings: {price} each\",",
      "  \"currentIngredients\": \"Current Ingredients\",",
      "  \"meatsLabel\": \"Meats\",",
      "  \"vegetablesLabel\": \"Vegetables\",",
      "  \"cheesesLabel\": \"Cheeses\",",
      "  \"saucesLabel\": \"Sauces\",",
      "  \"crustTypeLabel\": \"Crust Type\",",
      "  \"cookTypeLabel\": \"Cook Type\",",
      "  \"cutStyleLabel\": \"Cut Style\",",
      "  \"portionWhole\": \"Whole\",",
      "  \"portionLeft\": \"Left Side\",",
      "  \"portionRight\": \"Right Side\",",
      "  \"extra\": \"Extra\",",
      "  \"double\": \"Double\",",
      "  \"customizationsUpdated\": \"Customizations updated successfully.\",",
      "  \"bulkImportSuccess\": \"Bulk menu import complete.\",",
      "  \"exportStarted\": \"Menu export started.\",",
      "  \"itemAdded\": \"Menu item added.\",",
      "  \"itemUpdated\": \"Menu item updated.\",",
      "  \"itemDeleted\": \"Menu item deleted.\",",
      "  \"undo\": \"Undo\",",
      "  \"clearSelection\": \"Clear Selection\",",
      "  \"bulkDelete\": \"Delete Selected\",",
      "  \"customize\": \"Customize\",",
      "  \"addChipHint\": \"Add {label}\",",
      "  \"caloriesLabel\": \"Calories\",",
      "  \"fatLabel\": \"Fat (g)\",",
      "  \"carbsLabel\": \"Carbs (g)\",",
      "  \"proteinLabel\": \"Protein (g)\",",
      "  \"featureSettingsTitle\": \"Feature Settings\",",
      "  \"unauthorizedPleaseLogin\": \"Unauthorized — Please log in.\",",
      "  \"unauthorizedNoPermission\": \"Unauthorized — You do not have permission to access this page.\",",
      "  \"returnToHome\": \"Return to Home\",",
      "  \"noFeaturesFound\": \"No features found.\",",
      "  \"ok\": \"OK\",",
      "  \"unauthorizedTitle\": \"Unauthorized\",",
      "  \"unauthorizedFeatureChange\": \"You do not have permission to perform this action. This attempt has been logged.\",",
      "  \"featureDisplayName\": \"{key, select, loyaltyEnabled{Loyalty} inventoryEnabled{Inventory} statusEnabled{Order Status} segmentationEnabled{Segmentation} dynamicPricingEnabled{Dynamic Pricing} nutritionEnabled{Nutrition} recurrenceEnabled{Recurring Orders} languageEnabled{Multi-language} supportEnabled{Support} trackOrderEnabled{Order Tracking} enableGuestMode{Guest Mode} enableDemoMode{Demo Mode} forceLogin{Force Login} googleAuthEnabled{Google Auth} facebookAuthEnabled{Facebook Auth} appleAuthEnabled{Apple Auth} phoneAuthEnabled{Phone Auth} adminDashboardEnabled{Admin Dashboard} bannerPromoManagementEnabled{Banner & Promo Management} feedbackManagementEnabled{Feedback Management} analyticsDashboardEnabled{Analytics Dashboard} staffAccessEnabled{Staff Access} featureToggleUIEnabled{Feature Toggle UI} chatManagementEnabled{Chat Management} promoBulkUploadEnabled{Promo Bulk Upload} promoExportEnabled{Promo Export} analyticsExportEnabled{Analytics Export} other{{key}}}\",",
      "  \"signInToOrderMessage\": \"Please sign in to add items to your cart.\",",
      "  \"cartAddError\": \"Failed to add item to cart. Please try again.\",",
      "  \"addedToCartMessage\": \"Item added to cart!\",",
      "  \"cartTooltip\": \"View Cart\",",
      "  \"includedToppings\": \"Included: \",",
      "  \"whole\": \"Whole\",",
      "  \"left\": \"Left\",",
      "  \"right\": \"Right\",",
      "  \"doubleTopping\": \"Double\",",
      "  \"firstNFreeLabel\": \"First N Free\",",
      "  \"firstNFree\": \"First N Free\",",
      "  \"groupUpcharge\": \"Group Upcharge\",",
      "  \"groupTag\": \"Group Tag\",",
      "  \"allowExtra\": \"Allow Extra\",",
      "  \"allowSide\": \"Allow Side\",",
      "  \"upchargePerSize\": \"Upcharge Per Size\",",
      "  \"tag\": \"Tag\",",
      "  \"portion\": \"Portion\",",
      "  \"extra\": \"Extra\",",
      "  \"doubleTopping\": \"Double\",",
      "  \"whole\": \"Whole\",",
      "  \"left\": \"Left\",",
      "  \"right\": \"Right\",",
      "    \"cannotBeRemoved\": \"Cannot be removed\",",
      "  \"optionalAddOnsLabel\": \"Optional Add-Ons\",",
      "  \"warning\": \"Warning\",",
      "  \"itemsInCartCouldContain\": \"Items in cart could contain the following allergens: {allergens}\",",
      "  \"leftSide\": \"Left\",",
      "  \"rightSide\": \"Right\",",
      "  \"currentIngredientsLabel\": \"Current Ingredients\",",
      "  \"sizeLabel\": \"Size\",",
      "  \"sizeLabelHint\": \"Select the size for your item\",",
      "  \"additionalToppingCostLabel\": \"Additional topping cost:\",",
      "  \"chooseFlavorsLabel\": \"Choose Flavors\",",
      "  \"ingredientRemovedLabel\": \"Removed\",",
      "  \"notImplemented\": \"This feature is not yet implemented.\",",
      "  \"noPromotionsAvailable\": \"No promotions are currently available.\",",
      "  \"notSignedIn\": \"Not signed in\",",
      "  \"pleaseSignInToAccessProfile\": \"Please sign in to access your profile.\",",
      "  \"profileNotFound\": \"Profile not found\",",
      "  \"couldNotRetrieveProfile\": \"We couldn't retrieve your profile data.\",",
      "  \"signOutConfirmationMessage\": \"Are you sure you want to sign out?\",",
      "  \"editPhoneNumber\": \"Edit Phone Number\",",
      "  \"editName\": \"Edit Name\",",
      "  \"addressUpdated\": \"Address updated\",",
      "  \"all\": \"All\",",
      "  \"unauthorizedMessage\": \"Unauthorized — You do not have permission to access this page.\",",
      "  \"returnHome\": \"Return to Home\",",
      "  \"colColumns\": \"Columns\",",
      "  \"importCSV\": \"Import CSV\",",
      "  \"showDeleted\": \"Show Deleted\",",
      "  \"exportCSV\": \"Export CSV\",",
      "  \"resetTemplate\": \"Reset\",",
      "  \"importCSVPlaceholder\": \"File picker not implemented yet.\",",
      "  \"unauthorizedDialogMessage\": \"You do not have permission to perform this action. This attempt has been logged.\",",
      "  \"exportMenu\": \"Export Menu Data\",",
      "  \"exportStarted\": \"Menu export generated.\",",
      "  \"exportSuccess\": \"CSV download completed.\",",
      "  \"exportError\": \"Failed to download CSV.\",",
      "  \"share\": \"Share\",",
      "  \"shareError\": \"Failed to share file.\",",
      "  \"download\": \"Download\",",
      "  \"close\": \"Close\",",
      "  \"addMenuItem\": \"Add Menu Item\",",
      "  \"lockedCustomizationGroupTooltip\": \"This customization group is enforced by your restaurant’s menu template.\",",
      "  \"requiredCustomizationGroupMissing\": \"Missing required group: {groupLabel}\",",
      "  \"templateCustomizationResolved\": \"Customization group loaded from template.\",",
      "  \"customizationGroupLocked\": \"Locked Group\",",
      "  \"customizationTemplateHint\": \"This group follows a preset customization template.\",",
      "  \"sauces\": \"Sauces\",",
      "  \"portion\": \"Portion\",",
      "  \"reset\": \"Reset\",",
      "  \"light\": \"Light\",",
      "  \"regular\": \"Regular\",",
      "  \"extra\": \"Extra\",",
      "  \"pleaseSelectBothHalves\": \"Please select both halves or none!\",",
      "  \"orderingFeedbackPromptTitle\": \"How was your ordering experience?\",",
      "  \"orderingFeedbackInstructions\": \"Tell us about the app, checkout, or anything confusing or helpful!\",",
      "  \"categoryEaseOfUse\": \"Ease of use\",",
      "  \"categoryCheckoutProcess\": \"Checkout process\",",
      "  \"categoryFindingItems\": \"Finding items\",",
      "  \"categoryPaymentOptions\": \"Payment options\",",
      "  \"feedbackAlreadySubmitted\": \"Feedback submitted – thank you!\",",
      "  \"feedbackAlreadySubmittedTitle\": \"Feedback submitted\",",
      "  \"feedbackAlreadySubmittedSubtitle\": \"Thank you!\",",
      "  \"feedbackManagement\": \"Feedback Management\",",
      "  \"allTypes\": \"All Types\",",
      "  \"filterAppFeedback\": \"App Feedback\",",
      "  \"filterOrderFeedback\": \"Order Feedback\",",
      "  \"sortRecent\": \"Most Recent\",",
      "  \"sortOldest\": \"Oldest\",",
      "  \"sortLowest\": \"Lowest Rating\",",
      "  \"sortHighest\": \"Highest Rating\",",
      "  \"searchFeedback\": \"Search feedback…\",",
      "  \"noFeedbackSubmitted\": \"No feedback submitted yet.\",",
      "  \"delete\": \"Delete\",",
      "  \"deleteFeedback\": \"Delete Feedback\",",
      "  \"deleteFeedbackConfirm\": \"Are you sure you want to delete this feedback?\",",
      "  \"close\": \"Close\",",
      "  \"orderIdLabel\": \"Order ID\",",
      "  \"noMessage\": \"No message\",",
      "  \"submitted\": \"Submitted\",",
      "  \"refresh\": \"Refresh\",",
      "  \"feedbackAnonymous\": \"Anonymous\",",
      "  \"notesLabel\": \"Notes\",",
      "  \"categorySelected\": \"Category selected\",",
      "  \"adminSignInTitle\": \"Admin Sign-In\",",
      "  \"adminSignInDescription\": \"Sign in to manage orders, staff, and restaurant data.\",",
      "  \"adminOnlyNotice\": \"This portal is for authorized restaurant administrators only.\",",
      "  \"addMenuTab\": \"Add Menus\",",
      "  \"editItem\": \"Edit Item\",",
      "  \"selectItemToEdit\": \"Select item to edit\",",
      "  \"helpDialogContent\": \"Help and support info goes here.\",",
      "  \"themeModeLabel\": \"Dark Mode\",",
      "  \"languageLabel\": \"Language\",",
      "  \"languageSettingNote\": \"Select your preferred language.\",",
      "  \"profileLabel\": \"Profile\",",
      "  \"signOut\": \"Sign Out\",",
      "  \"chatManagementTitle\": \"Chat Management\",",
      "  \"settings\": \"Settings\",",
      "  \"unavailable\": \"Unavailable\",",
      "  \"unauthorizedAccessTitle\": \"Unauthorized Access\",",
      "  \"unauthorizedAccessMessage\": \"You do not have permission to view this page. Please contact an administrator if you believe this is an error.\",",
      "  \"returnHome\": \"Return to Home\",",
      "  \"errorLogManagementTitle\": \"Error Log Management\",",
      "  \"toggleArchivedTooltip\": \"Show or hide archived error logs\",",
      "  \"showingArchived\": \"Showing Archived\",",
      "  \"hideArchived\": \"Hide Archived\",",
      "  \"resolvedFilterTooltip\": \"Filter by resolved/unresolved status\",",
      "  \"resolved\": \"Resolved\",",
      "  \"all\": \"All\",",
      "  \"unresolvedOnly\": \"Unresolved Only\",",
      "  \"resolvedOnly\": \"Resolved Only\",",
      "  \"errorLoadingTitle\": \"Error Loading Logs\",",
      "  \"errorLoadingMessage\": \"There was a problem loading error logs. Please try again.\",",
      "  \"retry\": \"Retry\",",
      "  \"noErrorLogsTitle\": \"No Error Logs\",",
      "  \"noErrorLogsMessage\": \"No error logs were found matching your filters.\",",
      "  \"messageTooltip\": \"The error message\",",
      "  \"userId\": \"User ID\",",
      "  \"userIdTooltip\": \"ID of the user who experienced the error\",",
      "  \"resolved\": \"Resolved\",",
      "  \"resolvedTooltip\": \"Resolved status\",",
      "  \"unresolvedOnly\": \"Unresolved Only\",",
      "  \"archived\": \"Archived\",",
      "  \"archivedTooltip\": \"Archived status\",",
      "  \"notArchived\": \"Not Archived\",",
      "  \"timeTooltip\": \"The time this error log was recorded\",",
      "  \"severity\": \"Severity\",",
      "  \"severityTooltip\": \"The severity level of the error\",",
      "  \"source\": \"Source\",",
      "  \"sourceTooltip\": \"The source of the error (API, client, etc.)\",",
      "  \"screen\": \"Screen\",",
      "  \"screenTooltip\": \"The screen where the error occurred\",",
      "  \"errorDetailsTitle\": \"Error Details\",",
      "  \"stackTraceSection\": \"Stack Trace\",",
      "  \"contextDataSection\": \"Context Data\",",
      "  \"deviceInfoSection\": \"Device Info\",",
      "  \"commentsSection\": \"Comments\",",
      "  \"resolved\": \"Resolved\",",
      "  \"unresolvedOnly\": \"Unresolved\",",
      "  \"resolvedTooltip\": \"This error is marked as resolved\",",
      "  \"unresolvedTooltip\": \"This error is not resolved\",",
      "  \"archived\": \"Archived\",",
      "  \"notArchived\": \"Not Archived\",",
      "  \"archivedTooltip\": \"This error is archived\",",
      "  \"notArchivedTooltip\": \"This error is not archived\",",
      "  \"active\": \"Active\",",
      "  \"userIdTooltip\": \"ID of the user who experienced the error\",",
      "  \"userLabel\": \"User\",",
      "  \"addCommentHint\": \"Add a comment...\",",
      "  \"addCommentTooltip\": \"Add your comment to this error log\",",
      "  \"commentAdded\": \"Comment added.\",",
      "  \"copy\": \"Copy\",",
      "  \"copiedJson\": \"Copied error JSON!\",",
      "  \"copyErrorTooltip\": \"Copy error details as JSON\",",
      "  \"resolve\": \"Resolve\",",
      "  \"unresolve\": \"Unresolve\",",
      "  \"resolveTooltip\": \"Mark this error as resolved\",",
      "  \"unresolveTooltip\": \"Mark this error as unresolved\",",
      "  \"archive\": \"Archive\",",
      "  \"unarchive\": \"Unarchive\",",
      "  \"archiveTooltip\": \"Archive this error log\",",
      "  \"unarchiveTooltip\": \"Unarchive this error log\",",
      "  \"close\": \"Close\",",
      "  \"closeTooltip\": \"Close this dialog\",",
      "  \"justNow\": \"Just now\",",
      "  \"minutesAgo\": \"{minutes} minutes ago\",",
      "  \"hoursAgo\": \"{hours} hours ago\",",
      "  \"daysAgo\": \"{days} days ago\",",
      "  \"fatal\": \"Fatal\",",
      "  \"info\": \"Info\",",
      "  \"sourceTooltip\": \"Filter by error source\",",
      "  \"dateRangeTooltip\": \"Select a date range for error logs\",",
      "  \"dateRange\": \"Date Range\",",
      "  \"clearDateFilter\": \"Clear date filter\",",
      "  \"screenTooltip\": \"Filter by screen name\",",
      "  \"searchTooltip\": \"Search error log messages\",",
      "  \"totalErrorsTooltip\": \"Total number of errors: {total}\",",
      "  \"criticalErrorsTooltip\": \"Number of critical or fatal errors: {count}\",",
      "  \"warningErrorsTooltip\": \"Number of warning-level errors: {count}\",",
      "  \"infoErrorsTooltip\": \"Number of info-level errors: {count}\",",
      "  \"critical\": \"Critical\",",
      "  \"warnings\": \"Warnings\",",
      "  \"bulkSelection\": \"Bulk selection\",",
      "  \"selectedCount\": \"{count, plural, =0{No items selected} one{1 item selected} other{{count} items selected}}\",",
      "  \"export\": \"Export\",",
      "  \"failedToSaveCategory\": \"Failed to save category. Please try again.\",",
      "  \"sortByDescription\": \"Sort by description\",",
      "  \"sortAscending\": \"Sort ascending\",",
      "  \"sortDescending\": \"Sort descending\",",
      "  \"reload\": \"Reload\",",
      "  \"failedToSaveCategory\": \"Failed to save category. Please try again.\",",
      "  \"failedToDeleteCategory\": \"Failed to delete category. Please try again.\",",
      "  \"failedToRestoreCategory\": \"Failed to restore category. Please try again.\",",
      "  \"paidFeatureAdminOnly\": \"This is a paid feature and can only be toggled by a developer or platform admin.\",",
      "  \"toggleUpdateFailed\": \"Failed to update feature toggle. Please try again.\",",
      "  \"featureToggleLoadError\": \"Failed to load feature toggles.\",",
      "  \"retryButton\": \"Retry\",",
      "  \"ownerTogglesSection\": \"Features You Can Control\",",
      "  \"devOnlyTogglesSection\": \"Developer/Platform Only Features\",",
      "  \"switchFranchise\": \"Switch Franchise\",",
      "  \"developerDashboardTitle\": \"Developer Dashboard\",",
      "  \"accountDetails\": \"Account Details\",",
      "  \"role\": \"Role\",",
      "  \"status\": \"Status\",",
      "  \"language\": \"Language\",",
      "  \"defaultFranchise\": \"Default Franchise\",",
      "  \"themeMode\": \"Theme Mode\",",
      "  \"systemDefault\": \"System Default\",",
      "  \"notifications\": \"Notifications\",",
      "  \"enabled\": \"Enabled\",",
      "  \"futureFeatures\": \"Future Features\",",
      "  \"unauthorizedAccess\": \"Unauthorized access. Developer/admin role required.\",",
      "  \"staffDirectory\": \"Staff Directory\",",
      "  \"errorLoadingStaff\": \"Error loading staff list.\",",
      "  \"noStaffFound\": \"No staff members found.\",",
      "  \"onboardingChecklist\": \"Onboarding Checklist\",",
      "  \"markAsComplete\": \"Mark as Complete\",",
      "  \"profileCompleted\": \"Profile Completed\",",
      "  \"menuUploaded\": \"Menu Uploaded\",",
      "  \"inventoryLoaded\": \"Inventory Loaded\",",
      "  \"staffInvited\": \"Staff Invited\",",
      "  \"testOrderPlaced\": \"Test Order Placed\",",
      "  \"errorLoadingFranchises\": \"Error loading franchises.\",",
      "  \"noFranchisesFound\": \"No franchises found.\",",
      "  \"loadingPleaseWait\": \"Loading please wait..\",",
      "  \"failedToLoadFranchises\": \"Failed to load franchises. Please try again.\",",
      "  \"allFranchisesLabel\": \"All Franchises\",",
      "  \"dashboardOverview\": \"Overview\",",
      "  \"dashboardErrorLoadingStats\": \"Failed to load dashboard statistics.\",",
      "  \"analyticsTrendsComingSoon\": \"Analytics Trends (Coming Soon)\",",
      "  \"analyticsTrendsDesc\": \"Advanced business trends, customer segmentation, and growth predictions coming soon.\",",
      "  \"aiInsightsComingSoon\": \"AI Insights (Coming Soon)\",",
      "  \"aiInsightsDesc\": \"AI-powered suggestions, anomaly detection, and forecasts will appear here.\",",
      "  \"dashboardRevenue\": \"Revenue\",",
      "  \"dashboardOrders\": \"Orders\",",
      "  \"dashboardUniqueCustomers\": \"Unique Customers\",",
      "  \"dashboardTopSeller\": \"Top Seller\",",
      "  \"dashboardAvgOrderValue\": \"Avg. Order Value\",",
      "  \"dashboardAppVersion\": \"App Version\",",
      "  \"dashboardHealthGood\": \"System Health: Good\",",
      "  \"dashboardHealthWarning\": \"System Health: Warning\",",
      "  \"dashboardHealthError\": \"System Health: Error\",",
      "  \"dashboardLastSync\": \"Last Sync\",",
      "  \"developerMetricsComingSoon\": \"Developer Metrics (Coming Soon)\",",
      "  \"developerMetricsDesc\": \"Detailed system metrics and advanced developer tools will be shown here.\",",
      "  \"allFranchisesLabel\": \"All Franchises\",",
      "  \"impersonationToolsTitle\": \"User Impersonation Tools\",",
      "  \"impersonationToolsDesc\": \"Search and impersonate users within this franchise for debugging and support. All actions are logged. Impersonation is only available for developer accounts.\",",
      "  \"impersonationToolsLoadError\": \"Failed to load user list.\",",
      "  \"impersonationToolsSearchHint\": \"Search by email or role...\",",
      "  \"impersonationToolsNoUsersFound\": \"No users found for this franchise.\",",
      "  \"impersonationToolsRoleLabel\": \"Role\",",
      "  \"impersonationToolsImpersonate\": \"Impersonate\",",
      "  \"impersonationToolsImpersonating\": \"Impersonating\",",
      "  \"impersonationToolsRecentImpersonations\": \"Recent Impersonations\",",
      "  \"impersonationToolsAuditTrailComingSoon\": \"Audit Trail (Coming Soon)\",",
      "  \"impersonationToolsAuditTrailDesc\": \"Detailed history of impersonation activity for compliance and monitoring.\",",
      "  \"impersonationToolsRolePreviewComingSoon\": \"Role Preview (Coming Soon)\",",
      "  \"impersonationToolsRolePreviewDesc\": \"Preview data access and permissions for the target user before impersonating.\",",
      "  \"unauthorizedAccess\": \"Unauthorized access.\",",
      "  \"errorLogsSectionTitle\": \"Error Logs\",",
      "  \"errorLogsSectionDesc\": \"Latest and most critical error logs for this franchise. Use filters to focus on specific severity levels. Switch to 'All Franchises' to review system-wide issues.\",",
      "  \"errorLogsSectionError\": \"Failed to load error logs.\",",
      "  \"errorLogsSectionEmpty\": \"No error logs found for the selected filters.\",",
      "  \"errorLogsSectionViewAll\": \"View All\",",
      "  \"errorLogsSectionSeverityFilter\": \"Severity:\",",
      "  \"errorLogsSectionFilterAny\": \"Any\",",
      "  \"errorLogsSectionSeverityError\": \"Error\",",
      "  \"errorLogsSectionSeverityWarning\": \"Warning\",",
      "  \"errorLogsSectionSeverityFatal\": \"Fatal\",",
      "  \"errorLogsSectionAt\": \"At\",",
      "  \"errorLogsSectionAnalyticsComingSoon\": \"Error Analytics (Coming Soon)\",",
      "  \"errorLogsSectionAnalyticsDesc\": \"Visualizations, charts, and error breakdowns coming soon.\",",
      "  \"errorLogsSectionAIInsightsComingSoon\": \"AI Error Insights (Coming Soon)\",",
      "  \"errorLogsSectionAIInsightsDesc\": \"AI-powered error clustering and root-cause suggestions are on the way.\",",
      "  \"comingSoon\": \"Coming soon!\",",
      "  \"featureTogglesSectionTitle\": \"Feature Toggles\",",
      "  \"featureTogglesSectionDesc\": \"Manage feature flags for this franchise. Only enabled features will be active for staff and users. Switch to 'All Franchises' to review defaults.\",",
      "  \"featureTogglesSectionError\": \"Failed to load feature toggles.\",",
      "  \"featureTogglesSectionEmpty\": \"No feature toggles found for this franchise.\",",
      "  \"featureTogglesSectionAuditTrailComingSoon\": \"Audit Trail (Coming Soon)\",",
      "  \"featureTogglesSectionAuditTrailDesc\": \"Feature toggle change history for tracking and compliance.\",",
      "  \"featureTogglesSectionAIBasedComingSoon\": \"AI-based Feature Suggestions (Coming Soon)\",",
      "  \"featureTogglesSectionAIBasedDesc\": \"Smart, usage-driven suggestions for enabling features.\",",
      "  \"featureTogglesSectionNoGlobalToggle\": \"Cannot toggle features globally. Select a franchise to enable/disable.\",",
      "  \"pluginRegistrySectionTitle\": \"Plugin Registry\",",
      "  \"pluginRegistrySectionDesc\": \"Manage integrations and plugins for this franchise. Enable, disable, or troubleshoot connections. Switch to 'All Franchises' to view system-wide status.\",",
      "  \"pluginRegistrySectionError\": \"Failed to load plugin data.\",",
      "  \"pluginRegistrySectionEmpty\": \"No plugins registered for this franchise.\",",
      "  \"pluginRegistrySectionMonitoringComingSoon\": \"Plugin Monitoring (Coming Soon)\",",
      "  \"pluginRegistrySectionMonitoringDesc\": \"Realtime plugin logs, uptime and error notifications coming soon.\",",
      "  \"pluginRegistrySectionMarketplaceComingSoon\": \"Plugin Marketplace (Coming Soon)\",",
      "  \"pluginRegistrySectionMarketplaceDesc\": \"Discover, install, and manage new integrations from a curated plugin marketplace.\",",
      "  \"pluginRegistrySectionNoGlobalToggle\": \"Cannot change plugin status globally. Select a franchise to enable/disable.\",",
      "  \"pluginRegistrySectionStatusConnected\": \"Connected\",",
      "  \"pluginRegistrySectionStatusError\": \"Error\",",
      "  \"pluginRegistrySectionStatusDisconnected\": \"Disconnected\",",
      "  \"pluginRegistrySectionLastSync\": \"Last Sync\",",
      "  \"allFranchisesLabel\": \"All Franchises\",",
      "  \"schemaBrowserSectionTitle\": \"Schema Browser\",",
      "  \"schemaBrowserSectionDesc\": \"Browse, inspect, and manage menu/category/modifier schemas for this franchise. Select a schema to see version info and details. Switch to 'All Franchises' to review shared schemas.\",",
      "  \"schemaBrowserSectionError\": \"Failed to load schema metadata.\",",
      "  \"schemaBrowserSectionEmpty\": \"No schemas found for this franchise.\",",
      "  \"schemaBrowserSectionSchemaDetails\": \"Schema Details\",",
      "  \"schemaBrowserSectionDetailsPlaceholder\": \"Schema fields, validation state, and JSON preview will appear here.\",",
      "  \"schemaBrowserSectionStatusActive\": \"Active\",",
      "  \"schemaBrowserSectionStatusDeprecated\": \"Deprecated\",",
      "  \"schemaBrowserSectionDiffsComingSoon\": \"Schema Diffs (Coming Soon)\",",
      "  \"schemaBrowserSectionDiffsDesc\": \"View schema diffs, compare versions, and see breaking changes across deployments.\",",
      "  \"schemaBrowserSectionValidationComingSoon\": \"Schema Validation (Coming Soon)\",",
      "  \"schemaBrowserSectionValidationDesc\": \"Automated validation, problem highlighting, and quick fixes for schemas.\",",
      "  \"schemaBrowserSectionLastUpdated\": \"Last Updated\",",
      "  \"schemaBrowserSectionUpdated\": \"Updated\",",
      "  \"auditTrailSectionTitle\": \"Audit Trail\",",
      "  \"auditTrailSectionDesc\": \"Timeline of data changes (menu, franchise, settings, users). Filter by action type or user. Select 'All Franchises' for a global view.\",",
      "  \"auditTrailSectionError\": \"Failed to load audit trail.\",",
      "  \"auditTrailSectionEmpty\": \"No audit entries found for the selected filters.\",",
      "  \"auditTrailSectionTypeFilter\": \"Type\",",
      "  \"auditTrailSectionActorFilter\": \"Actor\",",
      "  \"auditTrailSectionFilterAny\": \"Any\",",
      "  \"auditTrailSectionAt\": \"At\",",
      "  \"auditTrailSectionBy\": \"By\",",
      "  \"auditTrailSectionRevertComingSoon\": \"Revert/Restore (Coming Soon)\",",
      "  \"auditTrailSectionRevertDesc\": \"Quickly undo changes or restore previous data states from the audit trail.\",",
      "  \"auditTrailSectionExplainComingSoon\": \"Explain (Coming Soon)\",",
      "  \"auditTrailSectionExplainDesc\": \"Explain audit entries, highlight risks, and use AI for impact analysis.\",",
      "  \"developerErrorLogsScreenTitle\": \"Developer Error Logs\",",
      "  \"developerErrorLogsScreenError\": \"Failed to load error logs.\",",
      "  \"developerErrorLogsScreenEmpty\": \"No error logs match the current filters.\",",
      "  \"developerErrorLogsScreenFranchise\": \"Franchise\",",
      "  \"developerErrorLogsScreenSeverity\": \"Severity\",",
      "  \"developerErrorLogsScreenUser\": \"User\",",
      "  \"developerErrorLogsScreenDevice\": \"Device\",",
      "  \"developerErrorLogsScreenAt\": \"At\",",
      "  \"developerErrorLogsScreenStackTrace\": \"Stack Trace\",",
      "  \"developerErrorLogsScreenFilterAny\": \"Any\",",
      "  \"developerErrorLogsScreenDateRange\": \"Date Range\",",
      "  \"developerErrorLogsScreenAllDates\": \"All Dates\",",
      "  \"developerErrorLogsScreenTrendsComingSoon\": \"Trends & Analytics (Coming Soon)\",",
      "  \"developerErrorLogsScreenTrendsDesc\": \"Error type trends, top failing screens, and system anomaly detection.\",",
      "  \"developerErrorLogsScreenAIInsightsComingSoon\": \"AI Root Cause Analysis (Coming Soon)\",",
      "  \"developerErrorLogsScreenAIInsightsDesc\": \"Cluster similar errors, get likely causes and suggestions powered by AI.\",",
      "  \"adminErrorLogsScreenTitle\": \"Error Logs\",",
      "  \"adminErrorLogsScreenError\": \"Failed to load error logs.\",",
      "  \"adminErrorLogsScreenEmpty\": \"No error logs for your location in the selected date range.\",",
      "  \"adminErrorLogsScreenSeverity\": \"Severity\",",
      "  \"adminErrorLogsScreenAt\": \"At\",",
      "  \"adminErrorLogsScreenDateRange\": \"Date Range\",",
      "  \"adminErrorLogsScreenAllDates\": \"All Dates\",",
      "  \"adminErrorLogsScreenFilterAny\": \"Any\",",
      "  \"adminErrorLogsScreenSupportComingSoon\": \"Support Actions (Coming Soon)\",",
      "  \"adminErrorLogsScreenSupportDesc\": \"Contact support, mark as resolved, or escalate issues directly from this screen.\",",
      "  \"adminErrorLogsScreenTrendsComingSoon\": \"Trends & Patterns (Coming Soon)\",",
      "  \"adminErrorLogsScreenTrendsDesc\": \"See frequent issues, system health, and actionable tips to reduce problems.\",",
      "  \"impersonationDialogTitle\": \"Impersonate User\",",
      "  \"impersonationDialogButton\": \"Impersonate\",",
      "  \"impersonationDialogSearchHint\": \"Search by email or name...\",",
      "  \"impersonationDialogSelectUserFirst\": \"Select a user to impersonate.\",",
      "  \"impersonationDialogSuccessPrefix\": \"Now impersonating\",",
      "  \"impersonationDialogError\": \"Failed to load users.\",",
      "  \"impersonationDialogNoUsersFound\": \"No users found.\",",
      "  \"impersonationDialogSecurityNotice\": \"You are about to impersonate another user. All actions will be logged and audited. Do not share sensitive or personal customer data. Exiting impersonation restores your own access and context.\",",
      "  \"impersonationDialogAuditTrailComingSoon\": \"Audit Trail (Coming Soon)\",",
      "  \"impersonationDialogAuditTrailDesc\": \"View impersonation history, export logs, and enforce audit controls.\",",
      "  \"impersonationDialogAdvancedToolsComingSoon\": \"Advanced Tools (Coming Soon)\",",
      "  \"impersonationDialogAdvancedToolsDesc\": \"Session timeouts, role-limited impersonation, and support diagnostics.\",",
      "  \"closeButtonLabel\": \"Close\",",
      "  \"pluginConfigDialogTitle\": \"Plugin Config\",",
      "  \"pluginConfigDialogDesc\": \"View and update configuration for this plugin. Changes will take effect immediately.\",",
      "  \"pluginConfigDialogError\": \"Failed to load or save plugin configuration.\",",
      "  \"pluginConfigDialogNoFields\": \"This plugin has no configurable fields.\",",
      "  \"pluginConfigDialogSaveButton\": \"Save\",",
      "  \"pluginConfigDialogSaved\": \"Plugin configuration saved.\",",
      "  \"pluginConfigDialogHistoryComingSoon\": \"History (Coming Soon)\",",
      "  \"pluginConfigDialogHistoryDesc\": \"View and restore previous configuration states.\",",
      "  \"pluginConfigDialogValidationComingSoon\": \"Validation & Test (Coming Soon)\",",
      "  \"pluginConfigDialogValidationDesc\": \"Run plugin-specific validation, test API keys, and get troubleshooting help.\",",
      "  \"unauthorizedAccess\": \"Unauthorized access.\",",
      "  \"cancelButtonLabel\": \"Cancel\",",
      "  \"pluginRegistrySectionConfigureButton\": \"Configure\",",
      "  \"ownerHQDashboardTitle\": \"Franchise HQ Dashboard\",",
      "  \"franchiseFinancials\": \"Financial Overview\",",
      "  \"multiBrandSnapshot\": \"Multi-Brand Overview\",",
      "  \"franchiseAlerts\": \"Alerts\",",
      "  \"quickLinks\": \"Quick Links\",",
      "  \"comingSoonFeatures\": \"Future Features\",",
      "  \"monthlyRevenue\": \"Monthly Revenue\",",
      "  \"pendingRoyalties\": \"Pending Royalties\",",
      "  \"activeStores\": \"Stores Reporting\",",
      "  \"overdueFees\": \"Overdue Fees\",",
      "  \"outstandingInvoices\": \"Outstanding Invoices\",",
      "  \"openInvoices\": \"Open\",",
      "  \"overdue\": \"Overdue\",",
      "  \"viewInvoices\": \"View All Invoices\",",
      "  \"payoutStatus\": \"Payouts\",",
      "  \"pending\": \"Pending\",",
      "  \"sent\": \"Sent\",",
      "  \"failed\": \"Failed\",",
      "  \"viewPayouts\": \"View All Payouts\",",
      "  \"locations\": \"Stores\",",
      "  \"noBrands\": \"No additional brands linked.\",",
      "  \"switchBrand\": \"Switch Brand\",",
      "  \"overduePaymentAlert\": \"Overdue franchise payment: Store #101\",",
      "  \"complianceAlert\": \"Compliance document missing: W-9 required\",",
      "  \"storePausedAlert\": \"Store #104 is paused for the season\",",
      "  \"noAlerts\": \"No active alerts.\",",
      "  \"alertHistory\": \"View Alert History\",",
      "  \"bankAccounts\": \"Bank Accounts\",",
      "  \"reporting\": \"Reports\",",
      "  \"billingSupport\": \"Billing Support\",",
      "  \"unauthorizedAccessTitle\": \"Unauthorized\",",
      "  \"unauthorizedAccessMessage\": \"You do not have permission to access this page.\",",
      "  \"returnHome\": \"Return to Home\",",
      "  \"announcements\": \"HQ Announcements\",",
      "  \"announcementsDesc\": \"Coming soon: Company-wide bulletins and major updates.\",",
      "  \"taxDocs\": \"1099/W-9 Export\",",
      "  \"taxDocsDesc\": \"Generate and export annual payout tax forms for all franchisees.\",",
      "  \"multiCurrency\": \"Multi-Currency\",",
      "  \"multiCurrencyDesc\": \"Enable international/multi-currency payment support.\",",
      "  \"bulkOps\": \"Bulk Operations\",",
      "  \"bulkOpsDesc\": \"Send invoices, set fees, or pause multiple stores at once.\",",
      "  \"integrations\": \"Accounting/API Integrations\",",
      "  \"integrationsDesc\": \"Connect with QuickBooks, Xero, Sage, and more.\",",
      "  \"scheduledReports\": \"Scheduled Reports\",",
      "  \"scheduledReportsDesc\": \"Schedule, download, or auto-email custom finance reports.\",",
      "  \"kpiFinancials\": \"Financial KPIs\",",
      "  \"kpiRevenue\": \"Revenue\",",
      "  \"kpiOutstanding\": \"Outstanding\",",
      "  \"kpiLastPayout\": \"Last Payout\",",
      "  \"kpiAvgOrder\": \"Avg. Order\",",
      "  \"kpiPayoutDate\": \"Date\",",
      "  \"featureComingSoon\": \"{feature} (coming soon)\",",
      "  \"errorLoadingKpi\": \"Failed to load KPIs.\",",
      "  \"errorLoadingSection\": \"Error loading section\",",
      "  \"featureComingSoonCashFlow\": \"Cash Flow Forecast (coming soon)\",",
      "  \"featureComingSoonRevenueTrends\": \"Per-Location Revenue Trends (coming soon)\",",
      "  \"noFranchisesAvailable\": \"No Franchises Available.\",",
      "  \"openingBalance\": \"Opening Balance\",",
      "  \"projectedInflow\": \"Projected Inflow\",",
      "  \"projectedOutflow\": \"Projected Outflow\",",
      "  \"projectedClosing\": \"Projected Closing\",",
      "  \"appLandingHeroHeadline\": \"All-in-One Franchise & Restaurant Management\",",
      "  \"appLandingHeroSubheadline\": \"Mobile Ordering, Customization, Analytics, and Powerful Admin Tools for Modern Franchises.\",",
      "  \"appLandingAboutTitle\": \"About Doughboys Franchise Admin Portal\",",
      "  \"appLandingAboutBody\": \"Doughboys Pizzeria empowers franchises with a unified platform for online ordering, menu management, analytics, inventory, staff management, and more.\",",
      "  \"appLandingFeaturesTitle\": \"Key Features\",",
      "  \"featureMobileOrdering\": \"Mobile Ordering for Customers\",",
      "  \"featureFranchiseManagement\": \"Franchise Management for Owners and Admins\",",
      "  \"featureCustomMenus\": \"Customizable Menus & Ingredients\",",
      "  \"featureFinancialTools\": \"Financial & Inventory Tools\",",
      "  \"featureRoleBasedAccess\": \"Role-Based Secure Access\",",
      "  \"featureAnalytics\": \"Detailed Analytics & Insights\",",
      "  \"featureSupportTools\": \"Integrated Support & Feedback Tools\",",
      "  \"appLandingGalleryTitle\": \"Screenshots & Gallery\",",
      "  \"appLandingDemoTitle\": \"See It In Action\",",
      "  \"appLandingDemoSubtitle\": \"Watch a quick walkthrough of our app.\",",
      "  \"bookDemo\": \"Book a Demo\",",
      "  \"login\": \"Login\",",
      "  \"videoDemoPlaceholder\": \"Demo Video Coming Soon\",",
      "  \"watchDemo\": \"Watch Demo\",",
      "  \"devPanelTitle\": \"Developer Panel\",",
      "  \"devPanelDesc\": \"Internal tools for development, QA, and debugging.\",",
      "  \"devPanelFeatureToggles\": \"Feature Toggles\",",
      "  \"futureFeaturesTitle\": \"What's Coming Next?\",",
      "  \"futureFeaturesBody\": \"New modules for delivery tracking, marketing automation, and more coming soon.\",",
      "  \"copyright\": \"Copyright\",",
      "  \"allRightsReserved\": \"All rights reserved.\",",
      "  \"noValidRoleFound\": \"No valid role found for your account. Please contact support.\",",
      "  \"claimsRefreshFailed\": \"Failed to refresh your access permissions. Please try again or contact support.\",",
      "  \"profileLoadTimeout\": \"Profile loading timed out.\",",
      "  \"tryAgainOrContactSupport\": \"Please try again or contact support if the issue persists.\",",
      "  \"profileLoadFailed\": \"Failed to load your profile.\",",
      "  \"syncingRolesPleaseWait\": \"Syncing your access permissions, please wait...\",",
      "  \"redirectingToDeveloperDashboard\": \"Redirecting to developer dashboard...\",",
      "  \"redirecting\": \"Redirecting...\",",
      "  \"loadingProfileAndPermissions\": \"Loading your profile and permissions...\",",
      "  \"developerMode\": \"Developer Mode\",",
      "  \"devPanelDesc\": \"Developer-only tools and debug information.\",",
      "  \"forceClaimsRefresh\": \"Force Claims Refresh\",",
      "  \"signOut\": \"Sign Out\",",
      "  \"tryAgain\": \"Try Again\",",
      "  \"futureFeaturesTitle\": \"Upcoming Features\",",
      "  \"futureFeaturesBody\": \"We’re working on additional profile and access controls. Stay tuned!\",",
      "  \"redirectingToOwnerHQDashboard\": \"Redirecting to HQ Dashboard\",",
      "  \"selectFranchiseToManage\": \"Select Franchise To Manage\",",
      "  \"dashboard_active_alerts\": \"Active Alerts\",",
      "  \"dashboard_alerts_filter_tooltip\": \"Filter alerts (coming soon)\",",
      "  \"dashboard_alerts_error\": \"Unable to load alerts.\",",
      "  \"dashboard_no_active_alerts\": \"No active alerts\",",
      "  \"dashboard_see_all_alerts\": \"See all alerts\",",
      "  \"unauthorized_title\": \"Access Denied\",",
      "  \"unauthorized_default_reason\": \"You do not have permission to view this section.\",",
      "  \"alert_dismissed_success\": \"Alert dismissed.\",",
      "  \"alert_dismissed_error\": \"Failed to dismiss alert.\",",
      "  \"alert_dismiss_button\": \"Dismiss\",",
      "  \"alert_time\": \"Time\",",
      "  \"alert_dismissed_on\": \"Dismissed On\",",
      "  \"alert_type\": \"Type\",",
      "  \"alert_type_generic\": \"General\",",
      "  \"alert_custom_fields\": \"Custom Fields\",",
      "  \"alert_dismissed_success\": \"Alert dismissed.\",",
      "  \"alert_dismissed_error\": \"Failed to dismiss alert.\",",
      "  \"alert_dismiss_button\": \"Dismiss\",",
      "  \"menuItemId\": \"Menu Item ID\",",
      "  \"menuItemName\": \"Menu Item Name\",",
      "  \"category\": \"Category\",",
      "  \"categoryId\": \"Category ID\",",
      "  \"description\": \"Description\",",
      "  \"price\": \"Price\",",
      "  \"availability\": \"Availability\",",
      "  \"taxCategory\": \"Tax Category\",",
      "  \"sku\": \"SKU\",",
      "  \"image\": \"Image\",",
      "  \"dietaryTags\": \"Dietary Tags\",",
      "  \"allergens\": \"Allergens\",",
      "  \"prepTime\": \"Preparation Time\",",
      "  \"nutrition\": \"Nutrition\",",
      "  \"customizations\": \"Customizations\",",
      "  \"customizationGroups\": \"Customization Groups\",",
      "  \"categoryId\": \"Category ID\",",
      "  \"categoryName\": \"Category Name\",",
      "  \"auditLogId\": \"Audit Log ID\",",
      "  \"action\": \"Action\",",
      "  \"userId\": \"User ID\",",
      "  \"timestamp\": \"Timestamp\",",
      "  \"ipAddress\": \"IP Address\",",
      "  \"details\": \"Details\",",
      "  \"promoId\": \"Promo ID\",",
      "  \"name\": \"Name\",",
      "  \"discount\": \"Discount\",",
      "  \"code\": \"Code\",",
      "  \"active\": \"Active\",",
      "  \"type\": \"Type\",",
      "  \"applicableItems\": \"Applicable Items\",",
      "  \"maxUses\": \"Max Uses\",",
      "  \"maxUsesType\": \"Max Uses Type\",",
      "  \"minOrderValue\": \"Minimum Order Value\",",
      "  \"startDate\": \"Start Date\",",
      "  \"endDate\": \"End Date\",",
      "  \"segment\": \"Segment\",",
      "  \"timeRules\": \"Time Rules\",",
      "  \"period\": \"Period\",",
      "  \"totalOrders\": \"Total Orders\",",
      "  \"totalRevenue\": \"Total Revenue\",",
      "  \"averageOrderValue\": \"Average Order Value\",",
      "  \"mostPopularItem\": \"Most Popular Item\",",
      "  \"retention\": \"Retention\",",
      "  \"uniqueCustomers\": \"Unique Customers\",",
      "  \"cancelledOrders\": \"Cancelled Orders\",",
      "  \"addOnRevenue\": \"Add-on Revenue\",",
      "  \"toppingCounts\": \"Topping Counts\",",
      "  \"comboCounts\": \"Combo Counts\",",
      "  \"addOnCounts\": \"Add-on Counts\",",
      "  \"orderStatusBreakdown\": \"Order Status Breakdown\",",
      "  \"franchiseId\": \"Franchise ID\",",
      "  \"noFranchiseSelected\": \"No franchise selected.\",",
      "  \"invoiceListTitle\": \"Invoices\",",
      "  \"searchInvoices\": \"Search invoices\",",
      "  \"errorLoadingInvoices\": \"Error loading invoices.\",",
      "  \"noInvoicesFound\": \"No invoices found.\",",
      "  \"filterByStatus\": \"Filter by status\",",
      "  \"allStatuses\": \"All statuses\",",
      "  \"invoiceNumber\": \"Invoice Number\",",
      "  \"paid\": \"Paid\",",
      "  \"draft\": \"Draft\",",
      "  \"refunded\": \"Refunded\",",
      "  \"voided\": \"Voided\",",
      "  \"sent\": \"Sent\",",
      "  \"overdue\": \"Overdue\",",
      "  \"failed\": \"Failed\",",
      "  \"noInvoices\": \"No Invoices\",",
      "  \"invoice\": \"Invoice\",",
      "  \"errorLoadingInvoice\": \"Error loading invoice.\",",
      "  \"invoiceNotFound\": \"Invoice not found.\",",
      "  \"issueDate\": \"Issue Date\",",
      "  \"dueDate\": \"Due Date\",",
      "  \"currency\": \"Currency\",",
      "  \"noLineItems\": \"No line items available.\",",
      "  \"lineItems\": \"Line Items\",",
      "  \"totals\": \"Totals\",",
      "  \"noAuditTrail\": \"No audit trail available.\",",
      "  \"auditTrail\": \"Audit Trail\",",
      "  \"noSupportNotes\": \"No support notes available.\",",
      "  \"supportNotes\": \"Support Notes\",",
      "  \"paid\": \"Paid\",",
      "  \"draft\": \"Draft\",",
      "  \"refunded\": \"Refunded\",",
      "  \"voided\": \"Voided\",",
      "  \"sent\": \"Sent\",",
      "  \"overdue\": \"Overdue\",",
      "  \"failed\": \"Failed\",",
      "  \"archived\": \"Archived\",",
      "  \"viewed\": \"Viewed\",",
      "  \"exportInvoices\": \"Export Invoices\",",
      "  \"selectDate\": \"Select Date\",",
      "  \"exportFormat\": \"Export Format\",",
      "  \"exportFailed\": \"Export failed. Please try again.\",",
      "  \"byUser\": \"By user\",",
      "  \"eventCreated\": \"Created\",",
      "  \"eventSent\": \"Sent\",",
      "  \"eventViewed\": \"Viewed\",",
      "  \"eventPaid\": \"Paid\",",
      "  \"eventOverdue\": \"Overdue\",",
      "  \"eventRefunded\": \"Refunded\",",
      "  \"eventVoided\": \"Voided\",",
      "  \"eventFailed\": \"Failed\",",
      "  \"searchInvoices\": \"Search invoices\",",
      "  \"filterByStatus\": \"Filter by status\",",
      "  \"allStatuses\": \"All statuses\",",
      "  \"sortBy\": \"Sort by\",",
      "  \"sortDateDesc\": \"Date (Newest first)\",",
      "  \"sortDateAsc\": \"Date (Oldest first)\",",
      "  \"sortTotalDesc\": \"Total (High to Low)\",",
      "  \"sortTotalAsc\": \"Total (Low to High)\",",
      "  \"actionCompleted\": \"Action completed successfully.\",",
      "  \"actionFailed\": \"Action failed. Please try again.\",",
      "  \"markSelectedPaid\": \"Mark Selected as Paid\",",
      "  \"sendPaymentReminder\": \"Send Payment Reminder\",",
      "  \"invoices\": \"Invoices\",",
      "  \"viewAllInvoices\": \"View All Invoices\",",
      "  \"noOverdueInvoices\": \"No Overdue Invoices\",",
      "  \"open\": \"Open\",",
      "  \"createInvoice\": \"Create Invoice\",",
      "  \"totalInvoices\": \"Total Invoices\",",
      "  \"overdueInvoices\": \"Overdue Invoices\",",
      "  \"paidInvoices\": \"Paid Invoices\",",
      "  \"outstandingBalance\": \"Outstanding Balance\",",
      "  \"lastInvoiceDate\": \"Last Invoice Date\",",
      "  \"billingSummary\": \"Billing Summary\",",
      "  \"failedToLoadSummary\": \"Failed to load summary. Please try again.\",",
      "  \"totalOutstanding\": \"Total Outstanding\",",
      "  \"paidLastNDays\": \"Paid in last {days} days\",",
      "  \"payNow\": \"Pay Now\",",
      "  \"downloadSummary\": \"Download Summary\",",
      "  \"downloadStarted\": \"Download started...\",",
      "  \"downloadFailed\": \"Download failed\",",
      "  \"payoutAlert\": \"Payout alert\",",
      "  \"amount\": \"Amount\",",
      "  \"createdAt\": \"Created\",",
      "  \"sentAt\": \"Sent At\",",
      "  \"failedAt\": \"Failed At\",",
      "  \"payoutMethod\": \"Method\",",
      "  \"bankAccount\": \"Account\",",
      "  \"notes\": \"Notes\",",
      "  \"payoutId\": \"Payout ID\",",
      "  \"noPayoutsFound\": \"No payouts found.\",",
      "  \"noDataFound\": \"No data found.\",",
      "  \"payoutNotFound\": \"Payout not found.\",",
      "  \"payoutDetail\": \"Payout Detail\",",
      "  \"failureReason\": \"Failure Reason\",",
      "  \"noAuditTrailFound\": \"No audit trail found.\",",
      "  \"attachments\": \"Attachments\",",
      "  \"by\": \"by\",",
      "  \"selectedItemsCount\": \"{count} selected\",",
      "  \"exportSelected\": \"Export selected\",",
      "  \"markAsSent\": \"Mark as sent\",",
      "  \"markAsFailed\": \"Mark as failed\",",
      "  \"addAttachment\": \"Add attachment\",",
      "  \"addNote\": \"Add note\",",
      "  \"approveSelected\": \"Approve selected\",",
      "  \"deleteSelected\": \"Delete selected\",",
      "  \"attachFile\": \"Attach file\",",
      "  \"uploading\": \"Uploading...\",",
      "  \"featureDeveloperOnly\": \"This feature is for developer use only.\",",
      "  \"addNoteHint\": \"Add a note...\",",
      "  \"noNotesYet\": \"No notes yet.\",",
      "  \"failedToSave\": \"Failed to save note.\",",
      "  \"failedToDelete\": \"Failed To Delete.\",",
      "  \"deleteNote\": \"Delete Note\",",
      "  \"confirmDeleteNote\": \"Confirm Delete Note\",",
      "  \"removeAttachment\": \"Remove Attachment\",",
      "  \"bulkStatusSuccess\": \"Bulk Success\",",
      "  \"deleteSuccess\": \"Delete Successfull\",",
      "  \"resetToPending\": \"Reset Status To Pending\",",
      "  \"searchPayoutsHint\": \"Search Payouts\",",
      "  \"ownerHQDashboardTitle\": \"HQ Owner Dashboard\",",
      "  \"platformOwner\": \"Platform Owner\",",
      "  \"inviteFranchiseesTitle\": \"Invite Franchisees\",",
      "  \"inviteFranchisee\": \"Invite Franchisee\",",
      "  \"pendingInvitations\": \"Pending Invitations\",",
      "  \"noPendingInvitations\": \"No pending invitations.\",",
      "  \"franchiseNetworkTitle\": \"Franchise Network\",",
      "  \"viewAllFranchises\": \"View All\",",
      "  \"noFranchisesFound\": \"No franchises found.\",",
      "  \"globalFinancialsTitle\": \"Global Financials\",",
      "  \"overdueInvoices\": \"Overdue Invoices\",",
      "  \"noFinancialData\": \"No financial data available.\",",
      "  \"platformAnalyticsTitle\": \"Platform Analytics\",",
      "  \"totalFranchises\": \"Total Franchises\",",
      "  \"activeUsers\": \"Active Users\",",
      "  \"totalOrders\": \"Total Orders\",",
      "  \"analyticsComingSoon\": \"Analytics coming soon.\",",
      "  \"platformSettingsTitle\": \"Platform Settings\",",
      "  \"platformSettingsComingSoon\": \"Settings feature coming soon.\",",
      "  \"ownerAnnouncementsTitle\": \"Announcements\",",
      "  \"sendAnnouncement\": \"Send Announcement\",",
      "  \"noAnnouncements\": \"No announcements yet.\",",
      "  \"futureFeaturesTitle\": \"Future Features\",",
      "  \"futureFeaturesBody\": \"More advanced controls for platform owners coming soon.\",",
      "  \"redirectingToPlatformOwnerDashboard\": \"Redirecting To Platform Owner Dashboard\",",
      "  \"platformOwnerDashboardTitle\": \"Platform Owner\",",
      "  \"inviteStatusPending\": \"Pending\",",
      "  \"inviteStatusSent\": \"Sent\",",
      "  \"inviteStatusAccepted\": \"Accepted\",",
      "  \"inviteStatusRevoked\": \"Revoked\",",
      "  \"inviteStatusExpired\": \"Expired\",",
      "  \"revokeInvitation\": \"Revoke Invitation\",",
      "  \"confirmRevokeInvitation\": \"Are you sure you want to revoke this invitation?\",",
      "  \"revoke\": \"Revoke\",",
      "  \"invitationRevoked\": \"Invitation revoked.\",",
      "  \"resendInvitation\": \"Resend Invitation\",",
      "  \"franchiseName\": \"Franchise Name\",",
      "  \"franchiseNameHint\": \"e.g. Pizza Hub\",",
      "  \"roleLabel\": \"{role, select,hq_owner{HQ Owner} owner{Owner} admin{Admin} manager{Manager} staff{Staff} other{User}}\",",
      "  \"invite\": \"Invite\",",
      "  \"invitationSent\": \"Invitation sent successfully!\",",
      "  \"inviteErrorGeneric\": \"Failed to send invitation. Please try again.\",",
      "  \"platformKpiMrr\": \"MRR\",",
      "  \"platformKpiArr\": \"ARR\",",
      "  \"platformKpiActiveFranchises\": \"Active Franchises\",",
      "  \"platformKpiRecentPayouts\": \"Recent Payouts\",",
      "  \"platformStatTotalRevenueYtd\": \"Total Revenue (YTD)\",",
      "  \"platformStatSubscriptionRevenue\": \"Subscription Revenue\",",
      "  \"platformStatRoyaltyRevenue\": \"Royalty Revenue\",",
      "  \"platformStatOverdueAmount\": \"Outstanding/Overdue\",",
      "  \"platformOwnerRevenueSummaryTitle\": \"Platform Revenue Overview\",",
      "  \"genericErrorOccurred\": \"An error occurred.\",",
      "  \"failedToLoadData\": \"Failed to load data.\",",
      "  \"account\": \"Account\",",
      "  \"unauthorized\": \"Unauthorized\",",
      "  \"billingAndPayments\": \"Billing & Payments\",",
      "  \"storeBilling\": \"Store Billing\",",
      "  \"securitySettings\": \"Security Settings\",",
      "  \"organization\": \"Organization\",",
      "  \"roles\": \"Roles\",",
      "  \"profileEditContactSupport\": \"Need to update your profile? Contact support.\",",
      "  \"platformOwnerDescription\": \"You are the platform owner. Manage platform-wide settings, billing, and analytics from the platform dashboard.\",",
      "  \"goToPlatformAdmin\": \"Go to Platform Admin\",",
      "  \"noBillingRecords\": \"No billing records found.\",",
      "  \"payments\": \"Payments\",",
      "  \"securityFeaturesComingSoon\": \"More security features coming soon.\",",
      "  \"needHelpContact\": \"Need help? Contact support below.\",",
      "  \"contactSupport\": \"Contact Support\",",
      "  \"paymentMethodManagementComing\": \"Payment method management coming soon.\",",
      "  \"downloadReceiptsExportComing\": \"Download receipts/export coming soon.\",",
      "  \"upgradePlanAddOnsComing\": \"Upgrade plan and add-ons coming soon.\",",
      "  \"phone\": \"Phone\",",
      "  \"acceptInvitation\": \"Accept Invitation\",",
      "  \"inviteNotFound\": \"Invitation not found.\",",
      "  \"inviteRevoked\": \"This invitation has been revoked.\",",
      "  \"inviteAlreadyAccepted\": \"This invitation has already been accepted.\",",
      "  \"inviteWelcome\": \"Welcome, {email}! You're invited to join the portal.\",",
      "  \"inviteForFranchise\": \"Invited for franchise: {franchiseName}\",",
      "  \"inviteSetPassword\": \"Set your password to activate your account.\",",
      "  \"password\": \"Password\",",
      "  \"confirmPassword\": \"Confirm Password\",",
      "  \"passwordTooShort\": \"Password must be at least 8 characters.\",",
      "  \"passwordsDoNotMatch\": \"Passwords do not match.\",",
      "  \"inviteAcceptExisting\": \"Sign in with your account, then accept this invite.\",",
      "  \"inviteAcceptedTitle\": \"Invitation Accepted!\",",
      "  \"inviteAcceptedDesc\": \"Your invite is now active. Continue to your dashboard.\",",
      "  \"inviteAcceptFailed\": \"Failed to accept invitation. Please try again.\",",
      "  \"goToDashboard\": \"Go to Dashboard\",",
      "  \"signInRequiredToAcceptInvite\": \"Please sign in to accept this invitation.\",",
      "  \"loadingInvite\": \"Loading invitation data...\",",
      "  \"failedToLoadData\": \"Failed to load invitation.\",",
      "  \"continueLabel\": \"Continue\",",
      "  \"hours\": \"Hours\",",
      "  \"role_hq_owner\": \"HQ Owner\",",
      "  \"emailLabel\": \"Email\",",
      "  \"signInWithEmailButton\": \"Sign in with Email\",",
      "  \"forgotPassword\": \"Forgot password?\",",
      "  \"emailRequired\": \"Please enter your email address.\",",
      "  \"passwordTooShort\": \"Password required (min 6 chars)\",",
      "  \"orDivider\": \"OR\",",
      "  \"inviteMustSignIn\": \"Invite Must Sign In\",",
      "  \"setupBusinessHours\": \"Setup business hours\",",
      "  \"setupBusinessHoursDesc\": \"Your business hours are used for calculating on-duty hours. Business hours are also advertised on your Mobile App and Webpage.\",",
      "  \"openAt\": \"open at\",",
      "  \"closeAt\": \"close at\",",
      "  \"addMore\": \"[+] add more\",",
      "  \"remove\": \"Remove\",",
      "  \"mustSetAtLeastOneInterval\": \"Set at least one business hour.\",",
      "  \"mustSelectDays\": \"Select days for each interval.\",",
      "  \"openMustBeforeClose\": \"Open time must be before close time.\",",
      "  \"daysOverlap\": \"Overlapping days across intervals are not allowed.\",",
      "  \"streetAddress\": \"Street Address\",",
      "  \"zip\": \"ZIP Code\",",
      "  \"businessEmail\": \"Business Email\",",
      "  \"website\": \"Website\",",
      "  \"ownerName\": \"Owner Name\",",
      "  \"taxIdEIN\": \"Tax ID (EIN)\",",
      "  \"businessType\": \"Business Category\",",
      "  \"platformInvoices\": \"Platform Invoices\",",
      "  \"platformPayments\": \"Platform Payments\",",
      "  \"noPaymentsFound\": \"No payments found.\",",
      "  \"addPlatformPayment\": \"Add Payment\",",
      "  \"paymentStatus\": \"Payment Status\",",
      "  \"paymentType\": \"Payment Type\",",
      "  \"scheduledFor\": \"Scheduled For\",",
      "  \"executedAt\": \"Processed At\",",
      "  \"recurringRule\": \"Recurring\",",
      "  \"enterPaymentDetails\": \"Enter payment details\",",
      "  \"confirmPayment\": \"Confirm Payment\",",
      "  \"paymentCompleted\": \"Payment marked as completed\",",
      "  \"developerOnlyFeature\": \"Developer-only feature\",",
      "  \"statusPaid\": \"Paid\",",
      "  \"statusOverdue\": \"Overdue\",",
      "  \"statusSent\": \"Sent\",",
      "  \"statusDraft\": \"Draft\",",
      "  \"statusRefunded\": \"Refunded\",",
      "  \"statusVoided\": \"Voided\",",
      "  \"statusFailed\": \"Failed\",",
      "  \"splitPayment\": \"Split Payment\",",
      "  \"payInvoice\": \"Pay Invoice\",",
      "  \"noteDevOnlyPlaceholder\": \"Placeholder – dev-only payment flow active\",",
      "  \"statusUnpaid\": \"Status Unpaid\",",
      "  \"statusPartial\": \"Status Partial\",",
      "  \"platformPlansTitle\": \"Platform Plans\",",
      "  \"noPlansAvailable\": \"No plans are currently defined.\",",
      "  \"customPlan\": \"Custom\",",
      "  \"inactive\": \"Inactive\",",
      "  \"perMonth\": \"per month\",",
      "  \"featurePlanComingSoon\": \"More plan features coming soon...\",",
      "  \"franchiseSubscriptionsTitle\": \"Franchise Subscriptions\",",
      "  \"noSubscriptionsFound\": \"No subscriptions were found.\",",
      "  \"franchiseIdLabel\": \"Franchise ID\",",
      "  \"planIdLabel\": \"Plan\",",
      "  \"trialEndsLabel\": \"Trial ends\",",
      "  \"nextBillingLabel\": \"Next Billing Date\",",
      "  \"discountLabel\": \"Discount\",",
      "  \"addSubscription\": \"Add Subscription\",",
      "  \"editSubscription\": \"Edit Subscription\",",
      "  \"plan\": \"Plan\",",
      "  \"pleaseSelectAPlan\": \"Please select a plan\",",
      "  \"subscriptionStatus_active\": \"Active\",",
      "  \"subscriptionStatus_paused\": \"Paused\",",
      "  \"subscriptionStatus_trialing\": \"Trialing\",",
      "  \"subscriptionStatus_canceled\": \"Canceled\",",
      "  \"confirmDeleteTitle\": \"Delete Subscription?\",",
      "  \"confirmDeleteDescription\": \"This will permanently remove the subscription from Firestore.\",",
      "  \"deleteSubscription\": \"Delete\",",
      "  \"bulkDeleteSuccess\": \"Successfully deleted {count} subscriptions.\",",
      "  \"enableBulkSelect\": \"Enable Bulk Select\",",
      "  \"translateStatus\": \"{status, select, active{Active} paused{Paused} trialing{Trialing} canceled{Canceled} other{Unknown}}\",",
      "  \"editPlan\": \"Edit Plan\",",
      "  \"deletePlan\": \"Delete Plan\",",
      "  \"quickLinksLabel\": \"Quick Links\",",
      "  \"currentPlan\": \"Current Plan\",",
      "  \"subscribe\": \"Subscribe\",",
      "  \"confirmPlanSubscriptionTitle\": \"Subscribe to Plan\",",
      "  \"confirmPlanSubscriptionPrompt\": \"Do you want to subscribe to this plan?\",",
      "  \"subscriptionSuccessMessage\": \"Successfully subscribed to plan.\",",
      "  \"billingIntervalLabel\": \"Billing Interval\",",
      "  \"priceLabel\": \"Price\",",
      "  \"selectThisPlan\": \"Select This Plan\",",
      "  \"onboardingRequiredBody\": \"You must complete onboarding to access this screen.\",",
      "  \"viewPlatformPlans\": \"View Platform Plans\",",
      "  \"noActiveSubscription\": \"No Active Subscription\",",
      "  \"activePlanLabel\": \"Active Plan\",",
      "  \"subscriptionLoadError\": \"Error Loading Subscription\",",
      "  \"priceAtSubscription\": \"Price Of Subscription\",",
      "  \"subscriptionsListTitle\": \"Franchise Subscriptions\",",
      "  \"planDetails\": \"Plan Details\",",
      "  \"statusActive\": \"Active\",",
      "  \"statusInactive\": \"Inactive\",",
      "  \"unknownDate\": \"Unknown Date\",",
      "  \"perLabel\": \"per {interval}\",",
      "  \"@perLabel\": {",
      "    \"description\": \"Used to describe billing interval, e.g., 'per month', 'per year'\",",
      "    \"placeholders\": {",
      "      \"interval\": {}",
      "    }",
      "  },",
      "  \"customQuote\": \"Custom Quote\",",
      "  \"@customQuote\": {",
      "    \"description\": \"Label shown when a subscription is under a custom price quote\"",
      "  },",
      "  \"startDateLabel\": \"Start Date\",",
      "  \"@startDateLabel\": {",
      "    \"description\": \"Label for the subscription start date\"",
      "  },",
      "  \"planCancelsAtPeriodEnd\": \"Plan is set to cancel at the end of this billing cycle.\",",
      "  \"@planCancelsAtPeriodEnd\": {",
      "    \"description\": \"Shown as a warning if cancelAtPeriodEnd is true\"",
      "  },",
      "  \"subscriptionBillingInsights\": \"Billing insights and usage coming soon\",",
      "  \"@subscriptionBillingInsights\": {",
      "    \"description\": \"Future placeholder for billing-related analytics\"",
      "  },",
      "  \"ownerLabel\": \"Owner\",",
      "  \"contactEmailLabel\": \"Contact Email\",",
      "  \"phoneNumberLabel\": \"Phone Number\",",
      "  \"linkedUserIdLabel\": \"Linked User ID\",",
      "  \"statusLabel\": \"Status\",",
      "  \"trialEndLabel\": \"Trial Ends\",",
      "  \"subscriptionCreated\": \"Subscription Created\",",
      "  \"linkedInvoices\": \"Linked Invoices\",",
      "  \"invoiceNumberLabel\": \"Invoice #\",",
      "  \"amountLabel\": \"Amount\",",
      "  \"notAvailable\": \"N/A\",",
      "  \"subscriptionAnalytics\": \"Subscription analytics\",",
      "  \"editSubscriptionFailed\": \"Failed to open subscription editor.\",",
      "  \"showDetailsTooltip\": \"Show details\",",
      "  \"hideDetailsTooltip\": \"Hide details\",",
      "  \"subscriptionInsights\": \"Insights\",",
      "  \"cancelAtPeriodEndToggle\": \"Cancel at End of Billing Cycle\",",
      "  \"cancelAtPeriodEndDescription\": \"Plan will auto-cancel after the current billing cycle completes.\",",
      "  \"toggleLockedDueToStatus\": \"Disabled due to current subscription status\",",
      "  \"paymentOverdueWarning\": \"⚠️ Payment Overdue\",",
      "  \"invoiceStatusLabel\": \"Invoice Status\",",
      "  \"partial\": \"Partial\",",
      "  \"unpaid\": \"Unpaid\",",
      "  \"overdueBadge\": \"Overdue\",",
      "  \"currentPlatformPlan\": \"Your Current Platform Plan\",",
      "  \"noActivePlatformPlan\": \"You're not subscribed to a platform plan.\",",
      "  \"nextBillingDate\": \"Next billing date: {date}\",",
      "  \"errorLoadingPlan\": \"Error loading current plan.\",",
      "  \"mockPaymentHeader\": \"Mock Payment Details\",",
      "  \"mockPaymentDisclaimer\": \"This is a test-only input form. No real charges will be made.\",",
      "  \"nameOnCard\": \"Name on Card\",",
      "  \"cardNumber\": \"Card Number\",",
      "  \"invalidCardNumber\": \"Please enter a valid card number\",",
      "  \"expiryDate\": \"Expiry Date (MM/YY)\",",
      "  \"invalidExpiryDate\": \"Enter a valid expiry date\",",
      "  \"cvv\": \"CVV\",",
      "  \"invalidCvv\": \"Enter a 3-digit CVV\",",
      "  \"validatePayment\": \"Validate Payment\",",
      "  \"mockPaymentValidated\": \"Mock payment validated successfully.\",",
      "  \"hideDetails\": \"Hide Details\",",
      "  \"priceWithInterval\": \"{price} / {interval}\",",
      "  \"billingInterval\": \"Billing Interval\",",
      "  \"monthly\": \"Monthly\",",
      "  \"yearly\": \"Yearly\",",
      "  \"selectPlan\": \"Select This Plan\",",
      "  \"subscriptionUpdated\": \"Subscription updated successfully!\",",
      "  \"cardType\": \"Card Type\",",
      "  \"paymentValidated\": \"Payment Validated\",",
      "  \"completePaymentToContinue\": \"Complete payment to continue\",",
      "  \"selectBillingIntervalFirst\": \"Please select a billing interval first\",",
      "  \"unnamedPlan\": \"Unnamed Plan\",",
      "  \"subscriptionStartDate\": \"Start Date: {date}\",",
      "  \"autoRenewLabel\": \"Auto-Renew\",",
      "  \"cancelAtPeriodEndLabel\": \"Cancel at Period End\",",
      "  \"overduePaymentWarning\": \"⚠️ Your subscription has an overdue invoice.\",",
      "  \"unknownPlan\": \"Unknown Plan\",",
      "  \"paymentStatusLabel\": \"Payment Status\",",
      "  \"cardOnFileLabel\": \"Card on File\",",
      "  \"viewLastReceipt\": \"View Last Receipt\",",
      "  \"gracePeriodEndsAtLabel\": \"Grace Period Ends\",",
      "  \"billingEmail\": \"Billing Email\",",
      "  \"gracePeriodWarning\": \"Payment overdue. Grace period ends on {date}.\",",
      "  \"gracePeriodExpired\": \"Payment overdue. Your access may be limited until resolved.\",",
      "  \"manageSubscription\": \"Manage Subscription\",",
      "  \"noMatchingInvoices\": \"No matching invoices found.\",",
      "  \"downloadPdf\": \"Download PDF\",",
      "  \"receipt\": \"Receipt\",",
      "  \"paymentMethod\": \"Payment Method\",",
      "  \"manualSubscriptionInjectorTitle\": \"Manual Subscription Injector\",",
      "  \"selectFranchise\": \"Select Franchise\",",
      "  \"selectStatus\": \"Select Status\",",
      "  \"injectSubscription\": \"Inject Subscription\",",
      "  \"subscriptionInjectionSuccess\": \"Subscription injected successfully\",",
      "  \"subscriptionInjectionFailed\": \"Failed to inject subscription\",",
      "  \"pleaseSelectFranchiseAndPlan\": \"Please select both a franchise and a plan\",",
      "  \"genericSavedSuccess\": \"Changes saved successfully\",",
      "  \"nextBillingDateLabel\": \"Next Billing Date\",",
      "  \"swap\": \"Swap\",",
      "  \"toggleSubscriptionTitle\": \"Toggle Subscription Status\",",
      "  \"planSwapperTitle\": \"Swap Franchise Plan\",",
      "  \"onboardingMenuTitle\": \"Franchise Onboarding\",",
      "  \"onboardingFor\": \"Onboarding for\",",
      "  \"stepIngredients\": \"Step 3: Ingredients\",",
      "  \"stepIngredientsDesc\": \"Define all ingredients like toppings, sauces, and sides.\",",
      "  \"stepCategories\": \"Step 4: Categories\",",
      "  \"stepCategoriesDesc\": \"Organize your menu into logical sections (e.g. Pizzas, Drinks).\",",
      "  \"stepMenuItems\": \"Step 5: Menu Items\",",
      "  \"stepMenuItemsDesc\": \"Create actual items customers can order, using ingredients and categories.\",",
      "  \"stepReview\": \"Step 6: Final Review\",",
      "  \"stepReviewDesc\": \"Validate all required data before going live.\",",
      "  \"progressComingSoon\": \"Progress tracking and automation coming soon.\",",
      "  \"stepMarkedComplete\": \"Step marked complete!\",",
      "  \"onboardingIngredients\": \"Ingredients\",",
      "  \"noIngredientsFound\": \"No ingredients found\",",
      "  \"noIngredientsMessage\": \"You have not added any ingredients yet. Start by tapping the add button.\",",
      "  \"ingredientName\": \"Name\",",
      "  \"ingredientDescription\": \"Description\",",
      "  \"errorSavingIngredient\": \"Error saving ingredient\",",
      "  \"ingredientType\": \"Ingredient Type\",",
      "  \"removable\": \"Removable\",",
      "  \"supportsExtra\": \"Supports Extra\",",
      "  \"sidesAllowed\": \"Sides Allowed\",",
      "  \"saveIngredient\": \"Save Ingredient\",",
      "  \"allergenTags\": \"Allergen Tags\",",
      "  \"deleteIngredient\": \"Delete Ingredient\",",
      "  \"confirmDeleteIngredient\": \"Are you sure you want to delete this ingredient?\",",
      "  \"errorDeletingIngredient\": \"Error deleting ingredient\",",
      "  \"addIngredient\": \"Add Ingredient\",",
      "  \"selectAFranchiseFirst\": \"Please select a franchise first.\",",
      "  \"ingredientTypes\": \"Ingredient Types\",",
      "  \"addIngredientType\": \"Add Ingredient Type\",",
      "  \"editIngredientType\": \"Edit Ingredient Type\",",
      "  \"noIngredientTypesFound\": \"No ingredient types found.\",",
      "  \"noDescription\": \"No description provided.\",",
      "  \"ingredientTypeDeleted\": \"Ingredient type deleted\",",
      "  \"systemTag\": \"System Tag\",",
      "  \"sortOrder\": \"Sort Order\",",
      "  \"manageIngredientTypes\": \"Manage Ingredient Types\",",
      "  \"pleaseAddIngredientTypesFirst\": \"Please add at least one ingredient with a type before marking this step complete.\",",
      "  \"stepIngredientTypes\": \"Step 2: Ingredient Types\",",
      "  \"stepIngredientTypesDesc\": \"Create logical ingredient type tags like toppings, sauces, and sides.\",",
      "  \"errorGeneric\": \"Something went wrong. Please try again.\",",
      "  \"selectIngredientTypeTemplate\": \"Select a Starter Template\",",
      "  \"templateLoadedSuccessfully\": \"Template loaded successfully!\",",
      "  \"pizzaShopTemplateLabel\": \"Pizza Shop Starter\",",
      "  \"pizzaShopTemplateSubtitle\": \"Includes cheeses, meats, sauces, and more\",",
      "  \"wingBarTemplateLabel\": \"Wing Bar Starter (Coming Soon)\",",
      "  \"wingBarTemplateSubtitle\": \"Includes dips, sauces, and portion logic\",",
      "  \"loadDefaultTypes\": \"Select Ingredient Type Template\",",
      "  \"deletionBlocked\": \"Deletion Blocked\",",
      "  \"ingredientTypeInUseError\": \"This ingredient type is currently used by one or more ingredients and cannot be deleted.\",",
      "  \"ingredientTypeName\": \"Name\",",
      "  \"ingredientTypeNameHint\": \"e.g. Toppings\",",
      "  \"ingredientTypeAdded\": \"Ingredient type added\",",
      "  \"ingredientTypeNameRequired\": \"Name is required.\",",
      "  \"ingredientTypeUpdated\": \"Ingredient Type Updated.\",",
      "  \"saveChanges\": \"Save Changes\",",
      "  \"revertChanges\": \"Revert Changes\",",
      "  \"invalidJsonFormat\": \"Invalid JSON format. Please ensure the input is a valid list of ingredient types.\",",
      "  \"jsonParseError\": \"Unable to parse JSON preview.\",",
      "  \"noPreviewData\": \"No preview data available.\",",
      "  \"visibleInApp\": \"Visible in App\",",
      "  \"importExportIngredientTypes\": \"Import / Export Ingredient Types\",",
      "  \"editJsonBelow\": \"Edit the JSON below to import or adjust ingredient types.\",",
      "  \"jsonInput\": \"JSON Input\",",
      "  \"preview\": \"Preview\",",
      "  \"importExport\": \"Import / Export\",",
      "  \"selectIngredientTemplate\": \"Select Ingredient Template\",",
      "  \"loadDefaultIngredients\": \"Load Default Ingredients\",",
      "  \"confirmLoadTemplate\": \"Confirm Template Load\",",
      "  \"overwriteWarning\": \"This will overwrite existing ingredients. Continue?\",",
      "  \"templateLoaded\": \"Template loaded successfully!\",",
      "  \"changesSaved\": \"Changes Saved\",",
      "  \"noDataToPreview\": \"No Data To Preview\",",
      "  \"none\": \"None\",",
      "  \"importExportIngredientMetadata\": \"Import / Export Ingredient Metadata\",",
      "  \"importChanges\": \"Import\",",
      "  \"groupBy\": \"Group By\",",
      "  \"typeId\": \"Type ID\",",
      "  \"ascending\": \"Ascending\",",
      "  \"descending\": \"Descending\",",
      "  \"ungrouped\": \"Ungrouped\",",
      "  \"confirmDeletion\": \"Confirm Deletion\",",
      "  \"bulkDeleteConfirmation\": \"Are you sure you want to delete {count} selected ingredients? This action cannot be undone.\",",
      "  \"@bulkDeleteConfirmation\": {",
      "    \"placeholders\": {",
      "      \"count\": {}",
      "    }",
      "  },",
      "  \"bulkDeleteIngredientsSuccess\": \"Bulk Delete Ingredients Success\",",
      "  \"stepMarkedIncomplete\": \"Step marked as incomplete.\",",
      "  \"saveSuccessful\": \"Save Successful\",",
      "  \"invalidTypeIdError\": \"Invalid typeId found for ingredients\",",
      "  \"confirmDeleteCategory\": \"Are you sure you want to delete this category?\",",
      "  \"onboardingCategories\": \"Categories\",",
      "  \"addCategoryTitle\": \"Add Category\",",
      "  \"editCategoryTitle\": \"Edit Category\",",
      "  \"categoryNameLabel\": \"Category Name\",",
      "  \"categoryDescriptionLabel\": \"Category Description\",",
      "  \"importSuccess\": \"Import successful!\",",
      "  \"importError\": \"Failed to import data.\",",
      "  \"importExportCategories\": \"Import/Export Categories\",",
      "  \"importExportInstruction\": \"Paste JSON data to import or edit it before saving.\",",
      "  \"jsonData\": \"JSON Data\",",
      "  \"import\": \"Import\",",
      "  \"selectCategoryTemplate\": \"Select a category template\",",
      "  \"categoryMarkedAsComplete\": \"Category step marked as complete.\",",
      "  \"sizes\": \"Sizes\",",
      "  \"deleteMenuItemConfirm\": \"Are you sure you want to delete {itemName}?\",",
      "  \"menuItemDeleted\": \"Menu item deleted successfully.\",",
      "  \"menuItemMarkedAsComplete\": \"Menu items step marked as complete.\",",
      "  \"onboardingMenuItems\": \"Onboarding: Menu Items\",",
      "  \"loadDefaultTemplates\": \"Load Default Templates\",",
      "  \"noMenuItemsFound\": \"No menu items found.\",",
      "  \"noMenuItemsMessage\": \"Start by adding at least one menu item.\",",
      "  \"editMenuItem\": \"Edit {itemName}\",",
      "  \"basePrice\": \"Base Price\",",
      "  \"importExportJson\": \"Import / Export JSON\",",
      "  \"pasteOrEditJson\": \"Paste or edit JSON for your menu items below.\",",
      "  \"noTemplatesFound\": \"No Templates Found\",",
      "  \"toggleFeatureError\": \"Failed to update feature toggle. Please try again.\",",
      "  \"featureSetupTitle\": \"Select Enabled Features\",",
      "  \"featureSetupDescription\": \"Choose which optional features this franchise should have access to. These are constrained by their current platform plan.\",",
      "  \"featureSetupToggleSection\": \"Available Features\",",
      "  \"saving\": \"Saving...\",",
      "  \"saveSuccess\": \"Features saved successfully.\",",
      "  \"saveErrorTitle\": \"Save Failed\",",
      "  \"saveErrorBody\": \"Unable to save your feature selections. Please try again.\",",
      "  \"stepFeatureSetup\": \"Step 1: Feature Setup\",",
      "  \"stepFeatureSetupDesc\": \"Choose which modules and features this franchise will use.\",",
      "  \"seedPlatformFeaturesTitle\": \"Seed Platform Features\",",
      "  \"seedPlatformFeaturesDescription\": \"Paste a JSON array of feature objects below to overwrite or create entries in the /platform_features collection.\",",
      "  \"jsonInputLabel\": \"Feature JSON Array\",",
      "  \"submitSeedData\": \"Submit Seed Data\",",
      "  \"submitting\": \"Submitting...\",",
      "  \"seedSuccess\": \"✅ Successfully seeded platform features.\",",
      "  \"seedFailure\": \"❌ Failed to seed features. Please check your JSON and try again.\",",
      "  \"devtoolsSeedPlatformPlansTitle\": \"Seed Platform Plans\",",
      "  \"devtoolsSeedPlatformPlansDescription\": \"Input a list of plan objects to store in the /platform_plans collection. Each plan must include a unique 'id' field. Existing entries will be overwritten.\",",
      "  \"devtoolsJsonInputLabel\": \"JSON Input\",",
      "  \"devtoolsJsonValidationEmpty\": \"Input cannot be empty\",",
      "  \"devtoolsSeedSuccess\": \"Seeded successfully!\",",
      "  \"devtoolsSeedError\": \"Failed to seed. Check error logs.\",",
      "  \"seed\": \"Seed\",",
      "  \"copySampleJson\": \"Copy Sample JSON\",",
      "  \"sampleJsonCopied\": \"Sample JSON copied to clipboard!\",",
      "  \"deleting\": \"Deleting...\",",
      "  \"devtoolsDeletePlatformPlansTitle\": \"Delete Platform Plan\",",
      "  \"devtoolsSelectPlan\": \"Select Plan ID\",",
      "  \"devtoolsDeleteSuccess\": \"Plan deleted successfully.\",",
      "  \"devtoolsDeleteError\": \"Failed to delete the plan.\",",
      "  \"platformFeaturePlanTools\": \"Platform Feature + Plan Tools\",",
      "  \"subscriptionTools\": \"Subscription Tools\",",
      "  \"billingTools\": \"Billing Tools\",",
      "  \"devtoolsFieldKey\": \"Key\",",
      "  \"devtoolsFieldName\": \"Name\",",
      "  \"devtoolsFieldModule\": \"Module\",",
      "  \"devtoolsFieldDeprecated\": \"Deprecated\",",
      "  \"devtoolsFieldDeveloperOnly\": \"Developer Only\",",
      "  \"devtoolsFieldDescription\": \"Description\",",
      "  \"devtoolsAddFeature\": \"Add Feature\",",
      "  \"devtoolsFeaturesToSeed\": \"Features to Seed\",",
      "  \"devtoolsValidationEmptyFeatureList\": \"No features to submit.\",",
      "  \"devtoolsValidationMissingFields\": \"Key and Name are required.\",",
      "  \"uploadViaJson\": \"Upload via JSON\",",
      "  \"devtoolsDeletePlatformFeaturesTitle\": \"Delete Platform Feature\",",
      "  \"devtoolsSelectFeature\": \"Select a feature to delete\",",
      "  \"noIngredientsConfigured\": \"No ingredients have been configured yet. Please add or import ingredients to continue.\",",
      "  \"customizationGroupLabel\": \"Group Label\",",
      "  \"selectionLimit\": \"Selection Limit\",",
      "  \"removeGroup\": \"Remove Group\",",
      "  \"addCustomizationGroup\": \"Add Customization Group\",",
      "  \"editNutrition\": \"Edit Nutrition Info\",",
      "  \"calories\": \"Calories\",",
      "  \"fat\": \"Fat\",",
      "  \"carbohydrates\": \"Carbohydrates\",",
      "  \"protein\": \"Protein\",",
      "  \"chooseTemplate\": \"Choose Template\",",
      "  \"template\": \"Template\",",
      "  \"noChatsTitle\": \"No Chats\",",
      "  \"noChatsMessage\": \"No support chats yet.\",",
      "  \"unknownUser\": \"Unknown User\",",
      "  \"deleteChatTitle\": \"Delete Chat\",",
      "  \"deleteChatConfirmMessage\": \"Are you sure you want to delete this chat thread?\",",
      "  \"deleteChatTooltip\": \"Delete this chat\",",
      "  \"deleteButton\": \"Delete\",",
      "  \"genericErrorMessage\": \"Something went wrong. Please try again.\",",
      "  \"createNewIngredient\": \"Create New Ingredient\",",
      "  \"e_g_anchovies\": \"e.g. Anchovies\",",
      "  \"upchargeOptional\": \"Upcharge (optional)\",",
      "  \"selectIngredient\": \"Select Ingredient\",",
      "  \"ingredientCreatedSuccessfully\": \"{ingredientName} created successfully.\",",
      "  \"ingredientCreatedSuccessfullyTooltip\": \"Confirm ingredient creation\",",
      "  \"ingredientStagedSuccessfully\": \"Ingredient \\\"{name}\\\" staged successfully.\",",
      "  \"ingredientStagedSuccessfullyTooltip\": \"This ingredient has been added temporarily. Remember to save changes to finalize it.\",",
      "  \"createNewIngredientType\": \"Create New Ingredient Type\",",
      "  \"typeName\": \"Type Name\",",
      "  \"systemTagOptional\": \"System Tag (optional)\",",
      "  \"ingredientTypeStagedSuccessfully\": \"Ingredient type \\\"{name}\\\" staged successfully.\",",
      "  \"createNewIngredientType\": \"Create New Ingredient Type\",",
      "  \"selectIngredientType\": \"Select Ingredient Type\",",
      "  \"createNewCategory\": \"Create New Category\",",
      "  \"descriptionOptional\": \"Description (optional)\",",
      "  \"selectCategory\": \"Select Category\",",
      "  \"categoryStagedSuccessfully\": \"Category \\\"{categoryName}\\\" staged successfully.\",",
      "  \"toDelete\": \"to delete\",",
      "  \"selectAllPrompt\": \"Select all ingredient types for delete?\",",
      "  \"selectAll\": \"Select All\",",
      "  \"missingMenuItemPrereqs\": \"Menu Item Step Blocked\",",
      "  \"menuItemsMissingPrerequisites\": \"You must complete the following steps before adding menu items: {steps}\",",
      "  \"goToStep\": \"Go to {step}\",",
      "  \"stepIngredientTypes\": \"Ingredient Types\",",
      "  \"stepIngredients\": \"Ingredients\",",
      "  \"stepCategories\": \"Categories\",",
      "  \"ingredientsImported\": \"Imported {count} ingredients.\",",
      "  \"onboardingReviewPublishTitle\": \"Review & Publish\",",
      "  \"onboardingReviewPublishDesc\": \"Check for any missing information or schema issues before going live. All critical issues must be resolved.\",",
      "  \"onboardingReviewFailed\": \"Review Failed\",",
      "  \"onboardingReviewReadyToPublish\": \"All required information is complete. Ready to publish.\",",
      "  \"onboardingReviewFixErrors\": \"Resolve all blocking issues before you can publish.\",",
      "  \"onboardingStepLabel\": \"Step {step} of {total}\",",
      "    \"tagDairyDescription\": \"Contains dairy products such as milk, cheese, or butter.\",",
      "  \"@tagDairyDescription\": {",
      "    \"description\": \"Tooltip description for dairy allergen tag.\"",
      "  },",
      "  \"tagGlutenDescription\": \"Contains gluten from wheat, barley, rye, or related grains.\",",
      "  \"@tagGlutenDescription\": {",
      "    \"description\": \"Tooltip description for gluten allergen tag.\"",
      "  },",
      "  \"tagNutsDescription\": \"Contains tree nuts or peanuts.\",",
      "  \"@tagNutsDescription\": {",
      "    \"description\": \"Tooltip description for nuts allergen tag.\"",
      "  },",
      "  \"tagSoyDescription\": \"Contains soy or soy-based products.\",",
      "  \"@tagSoyDescription\": {",
      "    \"description\": \"Tooltip description for soy allergen tag.\"",
      "  },",
      "  \"tagEggsDescription\": \"Contains eggs or egg-based ingredients.\",",
      "  \"@tagEggsDescription\": {",
      "    \"description\": \"Tooltip description for eggs allergen tag.\"",
      "  },",
      "  \"tagFishDescription\": \"Contains fish or fish-derived ingredients.\",",
      "  \"@tagFishDescription\": {",
      "    \"description\": \"Tooltip description for fish allergen tag.\"",
      "  },",
      "  \"tagShellfishDescription\": \"Contains shellfish such as crab, shrimp, or lobster.\",",
      "  \"@tagShellfishDescription\": {",
      "    \"description\": \"Tooltip description for shellfish allergen tag.\"",
      "  },",
      "  \"tagVeganDescription\": \"Suitable for a vegan diet; contains no animal products.\",",
      "  \"@tagVeganDescription\": {",
      "    \"description\": \"Tooltip description for vegan dietary tag.\"",
      "  },",
      "  \"tagVegetarianDescription\": \"Suitable for a vegetarian diet; contains no meat or fish.\",",
      "  \"@tagVegetarianDescription\": {",
      "    \"description\": \"Tooltip description for vegetarian dietary tag.\"",
      "  },",
      "  \"tagHalalDescription\": \"Prepared according to Halal dietary guidelines.\",",
      "  \"@tagHalalDescription\": {",
      "    \"description\": \"Tooltip description for halal dietary tag.\"",
      "  },",
      "  \"tagKosherDescription\": \"Prepared according to Kosher dietary guidelines.\",",
      "  \"@tagKosherDescription\": {",
      "    \"description\": \"Tooltip description for kosher dietary tag.\"",
      "  },",
      "  \"tagSugarFreeDescription\": \"Contains no added sugars.\",",
      "  \"@tagSugarFreeDescription\": {",
      "    \"description\": \"Tooltip description for sugar-free dietary tag.\"",
      "  },",
      "  \"tagLowSodiumDescription\": \"Low in sodium content.\",",
      "  \"@tagLowSodiumDescription\": {",
      "    \"description\": \"Tooltip description for low sodium dietary tag.\"",
      "  },",
      "  \"tagSpicyDescription\": \"May be spicy or contain hot peppers.\",",
      "  \"@tagSpicyDescription\": {",
      "    \"description\": \"Tooltip description for spicy food tag.\"",
      "  },",
      "  \"tagOrganicDescription\": \"Made with organic ingredients.\",",
      "  \"@tagOrganicDescription\": {",
      "    \"description\": \"Tooltip description for organic dietary tag.\"",
      "  }",
      "",
      "",
      "",
      "",
      "",
      "  }"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 1975,
      "file_size": 91886,
      "file_type": ".arb",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\add_to_cart_button.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "",
      "/// Button for adding an item directly to the cart (no customization flow).",
      "/// Accepts loading state and a callback for tap.",
      "class AddToCartButton extends StatelessWidget {",
      "  final bool isProcessing;",
      "  final VoidCallback? onPressed;",
      "  final String? label;",
      "",
      "  const AddToCartButton({",
      "    super.key,",
      "    required this.isProcessing,",
      "    required this.onPressed,",
      "    this.label,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return ElevatedButton(",
      "      style: ElevatedButton.styleFrom(",
      "        backgroundColor: DesignTokens.primaryColor,",
      "        foregroundColor: DesignTokens.foregroundColor,",
      "        padding: DesignTokens.buttonPadding,",
      "        shape: RoundedRectangleBorder(",
      "          borderRadius: BorderRadius.circular(DesignTokens.buttonRadius),",
      "        ),",
      "        elevation: DesignTokens.buttonElevation,",
      "        textStyle: const TextStyle(",
      "          fontSize: DesignTokens.bodyFontSize,",
      "          fontWeight: DesignTokens.titleFontWeight,",
      "          fontFamily: DesignTokens.fontFamily,",
      "        ),",
      "      ),",
      "      onPressed: isProcessing ? null : onPressed,",
      "      child: isProcessing",
      "          ? const SizedBox(",
      "              width: 22,",
      "              height: 22,",
      "              child: CircularProgressIndicator(strokeWidth: 2),",
      "            )",
      "          : Text(label ?? 'Add to Cart'),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 45,
      "file_size": 1468,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\auth_profile_listener.dart",
    "content": [
      "import 'package:flutter/widgets.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:firebase_auth/firebase_auth.dart' as fb_auth;",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/user_profile_notifier.dart';",
      "import 'package:franchise_admin_portal/core/models/user.dart' as admin_user;",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class AuthProfileListener extends StatefulWidget {",
      "  final Widget child;",
      "",
      "  const AuthProfileListener({",
      "    required this.child,",
      "    super.key,",
      "  });",
      "",
      "  @override",
      "  State<AuthProfileListener> createState() => _AuthProfileListenerState();",
      "}",
      "",
      "class _AuthProfileListenerState extends State<AuthProfileListener> {",
      "  Object? _lastLoggedError;",
      "  bool _navigated = false;",
      "  bool _subscribed = false;",
      "",
      "  @override",
      "  void didChangeDependencies() {",
      "    super.didChangeDependencies();",
      "    final firebaseUser = Provider.of<fb_auth.User?>(context);",
      "    final firestoreService =",
      "        Provider.of<FirestoreService>(context, listen: false);",
      "    final notifier = Provider.of<UserProfileNotifier>(context, listen: false);",
      "    final franchiseProvider =",
      "        Provider.of<FranchiseProvider>(context, listen: false);",
      "",
      "    // Attach listener only if not already attached",
      "    if (!_subscribed) {",
      "      _subscribed = true;",
      "",
      "      // ✅ Listen for user changes and rerun routing when ready",
      "      notifier.addListener(() {",
      "        final user = notifier.user;",
      "        final loading = notifier.loading;",
      "        if (user != null) {",
      "          // ✅ Inject into AdminUserProvider",
      "          Provider.of<AdminUserProvider>(context, listen: false).user = user;",
      "        }",
      "",
      "        if (!_navigated && !loading && firebaseUser != null && user != null) {",
      "          _maybeLogProfileError(notifier, firebaseUser, firestoreService);",
      "          _handleRouting(notifier, firebaseUser, franchiseProvider);",
      "        }",
      "      });",
      "    }",
      "",
      "    // Franchise-agnostic: only pass uid!",
      "    notifier.listenToUser(firestoreService, firebaseUser?.uid);",
      "  }",
      "",
      "  @override",
      "  void didUpdateWidget(AuthProfileListener oldWidget) {",
      "    super.didUpdateWidget(oldWidget);",
      "    final firebaseUser = Provider.of<fb_auth.User?>(context, listen: false);",
      "    final firestoreService =",
      "        Provider.of<FirestoreService>(context, listen: false);",
      "    final notifier = Provider.of<UserProfileNotifier>(context, listen: false);",
      "",
      "    _maybeLogProfileError(notifier, firebaseUser, firestoreService);",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final firebaseUser = Provider.of<fb_auth.User?>(context);",
      "    final firestoreService =",
      "        Provider.of<FirestoreService>(context, listen: false);",
      "    final notifier = Provider.of<UserProfileNotifier>(context, listen: false);",
      "",
      "    _maybeLogProfileError(notifier, firebaseUser, firestoreService);",
      "    return widget.child;",
      "  }",
      "",
      "  void _handleRouting(",
      "    UserProfileNotifier notifier,",
      "    fb_auth.User? firebaseUser,",
      "    FranchiseProvider franchiseProvider,",
      "  ) {",
      "    final user = notifier.user;",
      "    if (_navigated || firebaseUser == null || user == null || notifier.loading)",
      "      return;",
      "",
      "    // If user account is not active",
      "    if (user.status.toLowerCase() != 'active') {",
      "      _navigated = true;",
      "      print(",
      "          '[DEBUG-NAV] Attempting to navigate to /developer/select-franchise from <filename>:<linenumber>');",
      "      Navigator.of(context).pushReplacementNamed('/unauthorized');",
      "      return;",
      "    }",
      "",
      "    // HQ Owner/Manager: go to HQ dashboard",
      "    if (user.isHqOwner || user.isHqManager) {",
      "      _navigated = true;",
      "      print(",
      "          '[DEBUG-NAV] Attempting to navigate to /developer/select-franchise from <filename>:<linenumber>');",
      "      Navigator.of(context).pushReplacementNamed('/hq-owner/dashboard');",
      "      return;",
      "    }",
      "",
      "    // Developer: go to dev dashboard or franchise selector",
      "    if (user.isDeveloper) {",
      "      final selected = franchiseProvider.isFranchiseSelected;",
      "      _navigated = true;",
      "      print(",
      "          '[DEBUG-NAV] AUTH PROFILE LISTENER Routing to dev dashboard or franchise selector screen');",
      "      print(",
      "          '[DEBUG-NAV] Attempting to navigate to /developer/select-franchise from <filename>:<linenumber>');",
      "",
      "      Navigator.of(context).pushReplacementNamed(",
      "        selected ? '/developer/dashboard' : '/developer/select-franchise',",
      "      );",
      "      return;",
      "    }",
      "",
      "    // Owner/Manager: only set franchise and route if defaultFranchise is available",
      "    if (user.isOwner || user.isManager) {",
      "      final lockedId = user.defaultFranchise;",
      "      if (lockedId == null || lockedId.isEmpty) {",
      "        // Optionally, route to an error page or franchise selector if needed",
      "        _navigated = true;",
      "        print(",
      "            '[DEBUG-NAV] Attempting to navigate to /developer/select-franchise from <filename>:<linenumber>');",
      "",
      "        Navigator.of(context).pushReplacementNamed('/unauthorized');",
      "        return;",
      "      }",
      "      if (franchiseProvider.franchiseId != lockedId) {",
      "        franchiseProvider.setFranchiseId(lockedId);",
      "      }",
      "      _navigated = true;",
      "      print(",
      "          '[DEBUG-NAV] Attempting to navigate to /developer/select-franchise from <filename>:<linenumber>');",
      "",
      "      Navigator.of(context).pushReplacementNamed('/admin/dashboard');",
      "      return;",
      "    }",
      "",
      "    // All other users: implement routing as needed",
      "    // e.g. if customer, show a customer homepage, etc.",
      "    // For now, do nothing; you may want to add additional cases",
      "  }",
      "",
      "  void _maybeLogProfileError(",
      "    UserProfileNotifier notifier,",
      "    fb_auth.User? user,",
      "    FirestoreService firestoreService,",
      "  ) {",
      "    if (notifier.lastError != null && notifier.lastError != _lastLoggedError) {",
      "      _lastLoggedError = notifier.lastError;",
      "      WidgetsBinding.instance.addPostFrameCallback((_) async {",
      "        try {",
      "          await ErrorLogger.log(",
      "            message: 'UserProfileNotifier error: ${notifier.lastError}',",
      "            source: 'AuthProfileListener',",
      "            screen: 'AuthProfileListener',",
      "            stack: notifier.lastError is Error",
      "                ? (notifier.lastError as Error).stackTrace?.toString()",
      "                : null,",
      "            contextData: {",
      "              'userId': user?.uid,",
      "              'email': user?.email,",
      "              'profileLoading': notifier.loading,",
      "            },",
      "          );",
      "        } catch (e, stack) {",
      "          // Logging error; just print for dev, skip for prod",
      "        }",
      "      });",
      "    }",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 182,
      "file_size": 6743,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\branded_loading_screen.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "",
      "/// A branded loading screen used across the app during initialization,",
      "/// user/profile loading, or route transitions.",
      "class BrandedLoadingScreen extends StatelessWidget {",
      "  const BrandedLoadingScreen({super.key});",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "",
      "    return Scaffold(",
      "      backgroundColor: Theme.of(context).scaffoldBackgroundColor,",
      "      body: Center(",
      "        child: Column(",
      "          mainAxisSize: MainAxisSize.min,",
      "          children: [",
      "            // Optional: adjust path or use AssetImage if needed",
      "            Image.asset(",
      "              'assets/logo.png',",
      "              height: 100,",
      "              fit: BoxFit.contain,",
      "            ),",
      "            const SizedBox(height: 24),",
      "            const CircularProgressIndicator(),",
      "            const SizedBox(height: 24),",
      "            if (loc != null)",
      "              Text(",
      "                loc.loadingPleaseWait,",
      "                style: TextStyle(",
      "                  fontSize: 16,",
      "                  color: Theme.of(context).colorScheme.onBackground,",
      "                  fontWeight: FontWeight.w500,",
      "                ),",
      "              ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 43,
      "file_size": 1401,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\clear_filters_button.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "",
      "class ClearFiltersButton extends StatelessWidget {",
      "  final VoidCallback onClear;",
      "  final bool enabled;",
      "",
      "  const ClearFiltersButton({",
      "    super.key,",
      "    required this.onClear,",
      "    this.enabled = true,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return OutlinedButton.icon(",
      "      icon: const Icon(Icons.filter_alt_off),",
      "      label: const Text(\"Clear All Filters\"),",
      "      style: OutlinedButton.styleFrom(",
      "        foregroundColor: enabled",
      "            ? Theme.of(context).colorScheme.primary",
      "            : Theme.of(context).disabledColor,",
      "        side: BorderSide(",
      "          color: enabled",
      "              ? Theme.of(context).colorScheme.primary.withOpacity(0.6)",
      "              : Theme.of(context).disabledColor.withOpacity(0.3),",
      "        ),",
      "      ),",
      "      onPressed: enabled ? onClear : null,",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 32,
      "file_size": 957,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\collapsible_panel.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "",
      "class CollapsiblePanel extends StatefulWidget {",
      "  final String title;",
      "  final Widget child;",
      "  final bool initiallyExpanded;",
      "",
      "  const CollapsiblePanel({",
      "    super.key,",
      "    required this.title,",
      "    required this.child,",
      "    this.initiallyExpanded = false,",
      "  });",
      "",
      "  @override",
      "  State<CollapsiblePanel> createState() => _CollapsiblePanelState();",
      "}",
      "",
      "class _CollapsiblePanelState extends State<CollapsiblePanel> {",
      "  late bool _expanded;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _expanded = widget.initiallyExpanded;",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    return Card(",
      "      margin: const EdgeInsets.symmetric(vertical: 8),",
      "      elevation: 0,",
      "      color: colorScheme.surfaceVariant,",
      "      shape: RoundedRectangleBorder(",
      "        borderRadius: BorderRadius.circular(DesignTokens.adminCardRadius),",
      "      ),",
      "      child: Column(",
      "        crossAxisAlignment: CrossAxisAlignment.stretch,",
      "        children: [",
      "          InkWell(",
      "            onTap: () => setState(() => _expanded = !_expanded),",
      "            borderRadius: BorderRadius.circular(DesignTokens.adminCardRadius),",
      "            child: Padding(",
      "              padding: const EdgeInsets.symmetric(vertical: 10, horizontal: 16),",
      "              child: Row(",
      "                children: [",
      "                  Icon(",
      "                    _expanded ? Icons.expand_less : Icons.expand_more,",
      "                    color: colorScheme.primary,",
      "                  ),",
      "                  const SizedBox(width: 8),",
      "                  Expanded(",
      "                    child: Text(",
      "                      widget.title,",
      "                      style: Theme.of(context).textTheme.titleMedium?.copyWith(",
      "                            color: colorScheme.primary,",
      "                            fontWeight: FontWeight.bold,",
      "                          ),",
      "                    ),",
      "                  ),",
      "                ],",
      "              ),",
      "            ),",
      "          ),",
      "          AnimatedCrossFade(",
      "            crossFadeState: _expanded",
      "                ? CrossFadeState.showFirst",
      "                : CrossFadeState.showSecond,",
      "            duration: const Duration(milliseconds: 200),",
      "            firstChild: Padding(",
      "              padding: const EdgeInsets.fromLTRB(16, 0, 16, 16),",
      "              child: widget.child,",
      "            ),",
      "            secondChild: const SizedBox.shrink(),",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 82,
      "file_size": 2598,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\confirmation_dialog.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "",
      "class ConfirmationDialog extends StatelessWidget {",
      "  final String title;",
      "  final String message;",
      "  final String confirmLabel;",
      "  final String cancelLabel;",
      "  final VoidCallback onConfirm;",
      "  final VoidCallback? onCancel;",
      "  final IconData? icon;",
      "  final Color? confirmColor;",
      "  final Color? cancelColor;",
      "  final bool showCancel;",
      "",
      "  const ConfirmationDialog({",
      "    Key? key,",
      "    required this.title,",
      "    required this.message,",
      "    required this.onConfirm,",
      "    this.confirmLabel = 'Confirm',",
      "    this.cancelLabel = 'Cancel',",
      "    this.onCancel,",
      "    this.icon,",
      "    this.confirmColor,",
      "    this.cancelColor,",
      "    this.showCancel = true,",
      "  }) : super(key: key);",
      "",
      "  static Future<bool?> show(",
      "    BuildContext context, {",
      "    required String title,",
      "    required String message,",
      "    required VoidCallback onConfirm,",
      "    String confirmLabel = 'Confirm',",
      "    String cancelLabel = 'Cancel',",
      "    VoidCallback? onCancel,",
      "    IconData? icon,",
      "    Color? confirmColor,",
      "    Color? cancelColor,",
      "    bool showCancel = true,",
      "  }) {",
      "    return showDialog<bool>(",
      "      context: context,",
      "      builder: (_) => ConfirmationDialog(",
      "        title: title,",
      "        message: message,",
      "        onConfirm: onConfirm,",
      "        confirmLabel: confirmLabel,",
      "        cancelLabel: cancelLabel,",
      "        onCancel: onCancel,",
      "        icon: icon,",
      "        confirmColor: confirmColor,",
      "        cancelColor: cancelColor,",
      "        showCancel: showCancel,",
      "      ),",
      "    );",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return AlertDialog(",
      "      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),",
      "      title: Row(",
      "        children: [",
      "          if (icon != null)",
      "            Padding(",
      "              padding: const EdgeInsets.only(right: 8.0),",
      "              child: Icon(icon,",
      "                  color: confirmColor ?? Theme.of(context).primaryColor),",
      "            ),",
      "          Expanded(child: Text(title)),",
      "        ],",
      "      ),",
      "      content: Text(message),",
      "      actions: [",
      "        if (showCancel)",
      "          TextButton(",
      "            onPressed: () {",
      "              Navigator.of(context).pop(false);",
      "              if (onCancel != null) onCancel!();",
      "            },",
      "            style: TextButton.styleFrom(",
      "              foregroundColor:",
      "                  cancelColor ?? Theme.of(context).colorScheme.secondary,",
      "            ),",
      "            child: Text(cancelLabel),",
      "          ),",
      "        ElevatedButton(",
      "          onPressed: () {",
      "            Navigator.of(context).pop(true);",
      "            onConfirm();",
      "          },",
      "          style: ElevatedButton.styleFrom(",
      "            backgroundColor: confirmColor ?? Theme.of(context).primaryColor,",
      "            foregroundColor: Colors.white,",
      "          ),",
      "          child: Text(confirmLabel),",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 102,
      "file_size": 2863,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\customize_and_add_to_cart_button.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "",
      "/// Button for launching customization modal before adding to cart.",
      "/// Accepts loading state and a callback for tap.",
      "class CustomizeAndAddToCartButton extends StatelessWidget {",
      "  final bool isProcessing;",
      "  final VoidCallback? onPressed;",
      "  final String? label;",
      "",
      "  const CustomizeAndAddToCartButton({",
      "    super.key,",
      "    required this.isProcessing,",
      "    required this.onPressed,",
      "    this.label,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return ElevatedButton(",
      "      style: ElevatedButton.styleFrom(",
      "        backgroundColor: DesignTokens.secondaryColor,",
      "        foregroundColor: DesignTokens.foregroundColor,",
      "        padding: DesignTokens.buttonPadding,",
      "        shape: RoundedRectangleBorder(",
      "          borderRadius: BorderRadius.circular(DesignTokens.buttonRadius),",
      "        ),",
      "        elevation: DesignTokens.buttonElevation,",
      "        textStyle: const TextStyle(",
      "          fontSize: DesignTokens.bodyFontSize,",
      "          fontWeight: DesignTokens.titleFontWeight,",
      "          fontFamily: DesignTokens.fontFamily,",
      "        ),",
      "      ),",
      "      onPressed: isProcessing ? null : onPressed,",
      "      child: isProcessing",
      "          ? const SizedBox(",
      "              width: 22,",
      "              height: 22,",
      "              child: CircularProgressIndicator(strokeWidth: 2),",
      "            )",
      "          : Text(label ?? 'Customize'),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 45,
      "file_size": 1484,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\data_export_button.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "",
      "/// Button to trigger data export (CSV/PDF).",
      "/// Accepts export type(s), callback, and optional icon.",
      "enum ExportType { csv, pdf, xlsx }",
      "",
      "class DataExportButton extends StatelessWidget {",
      "  final void Function(ExportType) onExport;",
      "  final List<ExportType> exportTypes;",
      "  final String? label;",
      "",
      "  const DataExportButton({",
      "    Key? key,",
      "    required this.onExport,",
      "    this.exportTypes = const [ExportType.csv],",
      "    this.label,",
      "  }) : super(key: key);",
      "",
      "  String _typeLabel(ExportType type) {",
      "    switch (type) {",
      "      case ExportType.csv:",
      "        return 'CSV';",
      "      case ExportType.pdf:",
      "        return 'PDF';",
      "      case ExportType.xlsx:",
      "        return 'Excel';",
      "    }",
      "  }",
      "",
      "  IconData _typeIcon(ExportType type) {",
      "    switch (type) {",
      "      case ExportType.csv:",
      "        return Icons.table_view;",
      "      case ExportType.pdf:",
      "        return Icons.picture_as_pdf;",
      "      case ExportType.xlsx:",
      "        return Icons.grid_on;",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    if (exportTypes.length == 1) {",
      "      final type = exportTypes.first;",
      "      return ElevatedButton.icon(",
      "        onPressed: () => onExport(type),",
      "        icon: Icon(_typeIcon(type)),",
      "        label: Text(label ?? 'Export ${_typeLabel(type)}'),",
      "        style: ElevatedButton.styleFrom(",
      "          backgroundColor: Theme.of(context).colorScheme.primary,",
      "        ),",
      "      );",
      "    } else {",
      "      return PopupMenuButton<ExportType>(",
      "        icon: const Icon(Icons.file_download),",
      "        tooltip: 'Export data',",
      "        itemBuilder: (context) => exportTypes",
      "            .map((type) => PopupMenuItem(",
      "                  value: type,",
      "                  child: Row(",
      "                    children: [",
      "                      Icon(_typeIcon(type), size: 20),",
      "                      const SizedBox(width: 8),",
      "                      Text(_typeLabel(type)),",
      "                    ],",
      "                  ),",
      "                ))",
      "            .toList(),",
      "        onSelected: onExport,",
      "      );",
      "    }",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 73,
      "file_size": 2061,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\debug_admin_dashboard_screen.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "",
      "class DebugAdminDashboardScreen extends StatelessWidget {",
      "  const DebugAdminDashboardScreen({super.key});",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    print('DebugAdminDashboardScreen build called!');",
      "    return Scaffold(",
      "      appBar: AppBar(title: Text('Debug Admin Dashboard Screen')),",
      "      body: Center(",
      "        child: Text(",
      "          'If you see this, the dashboard widget tree is working.',",
      "          style: TextStyle(fontSize: 24, color: Colors.blue),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 19,
      "file_size": 564,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\delayed_loading_shimmer.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'loading_shimmer_widget.dart';",
      "",
      "class DelayedLoadingShimmer extends StatefulWidget {",
      "  final bool loading;",
      "  final Widget child;",
      "  final Duration delay;",
      "",
      "  const DelayedLoadingShimmer({",
      "    Key? key,",
      "    required this.loading,",
      "    required this.child,",
      "    this.delay = const Duration(milliseconds: 200),",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  State<DelayedLoadingShimmer> createState() => _DelayedLoadingShimmerState();",
      "}",
      "",
      "class _DelayedLoadingShimmerState extends State<DelayedLoadingShimmer> {",
      "  bool _showShimmer = false;",
      "  Future<void>? _timerFuture;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _handleLoading();",
      "  }",
      "",
      "  @override",
      "  void didUpdateWidget(covariant DelayedLoadingShimmer oldWidget) {",
      "    super.didUpdateWidget(oldWidget);",
      "    if (widget.loading != oldWidget.loading) {",
      "      _handleLoading();",
      "    }",
      "  }",
      "",
      "  void _handleLoading() {",
      "    if (widget.loading) {",
      "      _showShimmer = false;",
      "      _timerFuture = Future.delayed(widget.delay, () {",
      "        if (mounted && widget.loading) {",
      "          setState(() {",
      "            _showShimmer = true;",
      "          });",
      "        }",
      "      });",
      "    } else {",
      "      setState(() {",
      "        _showShimmer = false;",
      "      });",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    if (widget.loading && _showShimmer) {",
      "      return const LoadingShimmerWidget();",
      "    }",
      "    return widget.child;",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 62,
      "file_size": 1472,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\dietary_allergen_chips_row.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "",
      "/// Reusable row for displaying dietary tags and allergens as chips.",
      "/// Hides itself if both lists are empty.",
      "class DietaryAllergenChipsRow extends StatelessWidget {",
      "  final List<String> dietaryTags;",
      "  final List<String> allergens;",
      "",
      "  const DietaryAllergenChipsRow({",
      "    Key? key,",
      "    required this.dietaryTags,",
      "    required this.allergens,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    if (dietaryTags.isEmpty && allergens.isEmpty)",
      "      return const SizedBox.shrink();",
      "",
      "    return Padding(",
      "      padding: const EdgeInsets.only(bottom: DesignTokens.gridSpacing * 1.5),",
      "      child: Row(",
      "        children: [",
      "          ...dietaryTags.map(",
      "            (tag) => Container(",
      "              margin: const EdgeInsets.only(right: 8),",
      "              padding: const EdgeInsets.symmetric(vertical: 2, horizontal: 8),",
      "              decoration: BoxDecoration(",
      "                color: DesignTokens.successColor.withAlpha(24),",
      "                borderRadius: BorderRadius.circular(12),",
      "              ),",
      "              child: Text(",
      "                tag,",
      "                style: const TextStyle(",
      "                  fontSize: 12,",
      "                  color: DesignTokens.successColor,",
      "                  fontWeight: FontWeight.bold,",
      "                ),",
      "              ),",
      "            ),",
      "          ),",
      "          ...allergens.map(",
      "            (allergen) => Container(",
      "              margin: const EdgeInsets.only(right: 8),",
      "              padding: const EdgeInsets.symmetric(vertical: 2, horizontal: 8),",
      "              decoration: BoxDecoration(",
      "                color: DesignTokens.warningColor.withAlpha(24),",
      "                borderRadius: BorderRadius.circular(12),",
      "              ),",
      "              child: Text(",
      "                allergen,",
      "                style: const TextStyle(",
      "                  fontSize: 12,",
      "                  color: DesignTokens.warningColor,",
      "                  fontWeight: FontWeight.bold,",
      "                ),",
      "              ),",
      "            ),",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 65,
      "file_size": 2173,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\empty_state_widget.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/config/branding_config.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "",
      "class EmptyStateWidget extends StatelessWidget {",
      "  final String title;",
      "  final String? message;",
      "  final String? imageAsset;",
      "  final IconData? iconData;",
      "  final VoidCallback? onRetry;",
      "  final String? buttonText;",
      "  final bool isAdmin;",
      "",
      "  const EmptyStateWidget({",
      "    super.key,",
      "    required this.title,",
      "    this.message,",
      "    this.imageAsset,",
      "    this.iconData,",
      "    this.onRetry,",
      "    this.buttonText,",
      "    this.isAdmin = false,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "",
      "    final img = imageAsset ??",
      "        (isAdmin",
      "            ? BrandingConfig.adminEmptyStateImage",
      "            : BrandingConfig.bannerPlaceholder);",
      "",
      "    return Semantics(",
      "      label: title,",
      "      header: true,",
      "      child: Center(",
      "        child: Padding(",
      "          padding: DesignTokens.gridPadding",
      "              .add(const EdgeInsets.symmetric(vertical: 32)),",
      "          child: Column(",
      "            mainAxisAlignment: MainAxisAlignment.center,",
      "            children: [",
      "              if (iconData != null)",
      "                Icon(",
      "                  iconData,",
      "                  size: 80,",
      "                  color: colorScheme.primary,",
      "                )",
      "              else if (img != null && img.isNotEmpty)",
      "                Image.asset(",
      "                  img,",
      "                  width: 120,",
      "                  height: 120,",
      "                  fit: BoxFit.contain,",
      "                  semanticLabel: title,",
      "                )",
      "              else",
      "                Icon(",
      "                  Icons.info_outline,",
      "                  size: 80,",
      "                  color: colorScheme.primary,",
      "                ),",
      "              const SizedBox(height: 24),",
      "              Text(",
      "                title,",
      "                style: TextStyle(",
      "                  fontSize: DesignTokens.titleFontSize,",
      "                  fontWeight: DesignTokens.titleFontWeight,",
      "                  color: colorScheme.primary,",
      "                ),",
      "                textAlign: TextAlign.center,",
      "              ),",
      "              if (message != null && message!.isNotEmpty)",
      "                Padding(",
      "                  padding: const EdgeInsets.only(top: 8),",
      "                  child: Text(",
      "                    message!,",
      "                    style: TextStyle(",
      "                      fontSize: DesignTokens.bodyFontSize,",
      "                      color: colorScheme.onSurface.withOpacity(0.7),",
      "                    ),",
      "                    textAlign: TextAlign.center,",
      "                  ),",
      "                ),",
      "              if (onRetry != null)",
      "                Padding(",
      "                  padding: const EdgeInsets.only(top: 20),",
      "                  child: ElevatedButton(",
      "                    onPressed: onRetry,",
      "                    style: ElevatedButton.styleFrom(",
      "                      backgroundColor: colorScheme.secondary,",
      "                      foregroundColor: colorScheme.onSecondary,",
      "                      shape: RoundedRectangleBorder(",
      "                        borderRadius: BorderRadius.circular(24),",
      "                      ),",
      "                    ),",
      "                    child: Text(",
      "                      buttonText ?? (isAdmin ? loc.reload : loc.tryAgain),",
      "                    ),",
      "                  ),",
      "                ),",
      "            ],",
      "          ),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 118,
      "file_size": 3871,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\feature_toggle_list.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/widgets/loading_shimmer_widget.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/models/user.dart' as admin_user;",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "",
      "class FeatureToggleList extends StatelessWidget {",
      "  final String franchiseId;",
      "  final admin_user.User user;",
      "  final Future<void> Function(",
      "    String,",
      "    bool,",
      "    admin_user.User,",
      "    Map<String, dynamic>,",
      "  ) onUpdateFeature;",
      "",
      "  const FeatureToggleList({",
      "    super.key,",
      "    required this.franchiseId,",
      "    required this.user,",
      "    required this.onUpdateFeature,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    return StreamBuilder<Map<String, dynamic>>(",
      "      stream: Provider.of<FirestoreService>(context, listen: false)",
      "          .streamFranchiseFeatureToggles(franchiseId),",
      "      builder: (context, snapshot) {",
      "        if (snapshot.connectionState == ConnectionState.waiting) {",
      "          return const LoadingShimmerWidget();",
      "        }",
      "        if (snapshot.hasError) {",
      "          return Center(",
      "            child: Column(",
      "              mainAxisAlignment: MainAxisAlignment.center,",
      "              children: [",
      "                Icon(Icons.error_outline, color: Colors.redAccent, size: 48),",
      "                const SizedBox(height: 16),",
      "                Text(loc.featureToggleLoadError),",
      "                const SizedBox(height: 10),",
      "                ElevatedButton(",
      "                  onPressed: () => (context as Element).reassemble(),",
      "                  child: Text(loc.retryButton),",
      "                )",
      "              ],",
      "            ),",
      "          );",
      "        }",
      "        final toggles = snapshot.data ?? {};",
      "        final meta = toggles['_meta'] as Map<String, dynamic>? ?? {};",
      "",
      "        // Use stable sorted order",
      "        final ownerToggleableKeys = meta.entries",
      "            .where((entry) => entry.value['owner_togglable'] == true)",
      "            .map((entry) => entry.key)",
      "            .toList()",
      "          ..sort();",
      "        final devOnlyKeys = meta.entries",
      "            .where((entry) => entry.value['owner_togglable'] != true)",
      "            .map((entry) => entry.key)",
      "            .toList()",
      "          ..sort();",
      "",
      "        List<Widget> tileWidgets(List<String> keys) => keys.map((key) {",
      "              final featureMeta = meta[key] as Map<String, dynamic>? ?? {};",
      "              final value = toggles[key] ?? false;",
      "              return FeatureToggleTile(",
      "                key: ValueKey(key),",
      "                toggleKey: key,",
      "                label: loc.featureDisplayName(key),",
      "                description: featureMeta['description'],",
      "                value: value,",
      "                meta: featureMeta,",
      "                user: user,",
      "                onUpdate: (val) => onUpdateFeature(",
      "                  key,",
      "                  val,",
      "                  user,",
      "                  featureMeta,",
      "                ),",
      "              );",
      "            }).toList();",
      "",
      "        if (ownerToggleableKeys.isEmpty &&",
      "            (!user.isDeveloper || devOnlyKeys.isEmpty)) {",
      "          return Center(child: Text(loc.noFeaturesFound));",
      "        }",
      "",
      "        return ListView(",
      "          children: [",
      "            if (ownerToggleableKeys.isNotEmpty)",
      "              Padding(",
      "                padding: const EdgeInsets.symmetric(vertical: 8.0),",
      "                child: Text(",
      "                  loc.ownerTogglesSection,",
      "                  style: const TextStyle(",
      "                    fontWeight: FontWeight.w600,",
      "                    fontSize: 16,",
      "                  ),",
      "                ),",
      "              ),",
      "            ...tileWidgets(ownerToggleableKeys),",
      "            if (user.isDeveloper && devOnlyKeys.isNotEmpty)",
      "              Padding(",
      "                padding: const EdgeInsets.only(top: 32.0, bottom: 8.0),",
      "                child: Text(",
      "                  loc.devOnlyTogglesSection,",
      "                  style: const TextStyle(",
      "                    fontWeight: FontWeight.w600,",
      "                    fontSize: 16,",
      "                    color: Colors.blueGrey,",
      "                  ),",
      "                ),",
      "              ),",
      "            if (user.isDeveloper) ...tileWidgets(devOnlyKeys),",
      "            const SizedBox(height: 12),",
      "          ],",
      "        );",
      "      },",
      "    );",
      "  }",
      "}",
      "",
      "class FeatureToggleTile extends StatefulWidget {",
      "  final String toggleKey;",
      "  final String label;",
      "  final String? description;",
      "  final bool value;",
      "  final Map<String, dynamic> meta;",
      "  final admin_user.User user;",
      "  final Future<void> Function(bool) onUpdate;",
      "",
      "  const FeatureToggleTile({",
      "    super.key,",
      "    required this.toggleKey,",
      "    required this.label,",
      "    this.description,",
      "    required this.value,",
      "    required this.meta,",
      "    required this.user,",
      "    required this.onUpdate,",
      "  });",
      "",
      "  @override",
      "  State<FeatureToggleTile> createState() => _FeatureToggleTileState();",
      "}",
      "",
      "class _FeatureToggleTileState extends State<FeatureToggleTile> {",
      "  bool? _optimisticValue;",
      "  bool _loading = false;",
      "",
      "  @override",
      "  void didUpdateWidget(covariant FeatureToggleTile oldWidget) {",
      "    super.didUpdateWidget(oldWidget);",
      "    // Firestore confirms, clear local optimistic value",
      "    if (_optimisticValue != null && widget.value == _optimisticValue) {",
      "      setState(() => _optimisticValue = null);",
      "    }",
      "    if (_loading && widget.value == _optimisticValue) {",
      "      setState(() => _loading = false);",
      "    }",
      "  }",
      "",
      "  Future<void> _onChanged(bool newValue) async {",
      "    if (_loading) return;",
      "    setState(() {",
      "      _optimisticValue = newValue;",
      "      _loading = true;",
      "    });",
      "    try {",
      "      await widget.onUpdate(newValue);",
      "    } catch (e) {",
      "      setState(() => _optimisticValue = null); // Roll back",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(content: Text('Failed to update toggle.')),",
      "      );",
      "    } finally {",
      "      setState(() => _loading = false);",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final isPaid = widget.meta['paid_service'] == true;",
      "    final isLocked = widget.meta['locked'] == true;",
      "    final shouldDisable =",
      "        _loading || (!widget.user.isDeveloper && isPaid) || isLocked;",
      "    final value = _optimisticValue ?? widget.value;",
      "",
      "    return ListTile(",
      "      key: widget.key,",
      "      contentPadding: const EdgeInsets.symmetric(vertical: 0, horizontal: 8),",
      "      title: Text(",
      "        widget.label,",
      "        style: TextStyle(",
      "          fontWeight: FontWeight.bold,",
      "          color: shouldDisable ? Colors.grey : Colors.black,",
      "        ),",
      "      ),",
      "      subtitle: widget.description != null",
      "          ? Text(",
      "              widget.description!,",
      "              style: const TextStyle(fontSize: 12),",
      "            )",
      "          : null,",
      "      trailing: _loading",
      "          ? const SizedBox(",
      "              width: 32,",
      "              height: 32,",
      "              child: CircularProgressIndicator(strokeWidth: 2),",
      "            )",
      "          : Switch(",
      "              value: value,",
      "              onChanged: shouldDisable ? null : _onChanged,",
      "              activeColor: DesignTokens.primaryColor,",
      "              inactiveThumbColor: Colors.grey,",
      "            ),",
      "      enabled: !shouldDisable,",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 232,
      "file_size": 7657,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\filter_dropdown.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "",
      "/// A dropdown filter for admin tables/lists.",
      "/// Generic for any type T (e.g., String for status, category, etc.).",
      "class FilterDropdown<T> extends StatelessWidget {",
      "  final String label;",
      "  final List<T> options;",
      "  final T? value;",
      "  final ValueChanged<T?> onChanged;",
      "  final String Function(T)? getLabel;",
      "",
      "  const FilterDropdown({",
      "    Key? key,",
      "    required this.label,",
      "    required this.options,",
      "    required this.value,",
      "    required this.onChanged,",
      "    this.getLabel,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Row(",
      "      children: [",
      "        Text('$label: ', style: const TextStyle(fontWeight: FontWeight.w600)),",
      "        const SizedBox(width: 6),",
      "        DropdownButton<T>(",
      "          value: value,",
      "          items: options",
      "              .map((option) => DropdownMenuItem<T>(",
      "                    value: option,",
      "                    child: Text(getLabel != null",
      "                        ? getLabel!(option)",
      "                        : option.toString()),",
      "                  ))",
      "              .toList(),",
      "          onChanged: onChanged,",
      "          underline:",
      "              Container(height: 2, color: Theme.of(context).primaryColorLight),",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 44,
      "file_size": 1292,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\import_csv_file_button.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:file_picker/file_picker.dart';",
      "import 'dart:convert';",
      "",
      "/// Callback with the file's contents (as String) if successful, null if canceled.",
      "typedef CsvFilePickedCallback = void Function(String? csvContent);",
      "",
      "class ImportCsvFileButton extends StatefulWidget {",
      "  /// Display label for the button (should be localized).",
      "  final String label;",
      "",
      "  /// Called with the CSV file's text contents if picked, or null if canceled.",
      "  final CsvFilePickedCallback onCsvPicked;",
      "",
      "  /// Optional icon for the button.",
      "  final IconData icon;",
      "",
      "  /// Can disable the button.",
      "  final bool enabled;",
      "",
      "  const ImportCsvFileButton({",
      "    Key? key,",
      "    required this.label,",
      "    required this.onCsvPicked,",
      "    this.icon = Icons.file_upload,",
      "    this.enabled = true,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  State<ImportCsvFileButton> createState() => _ImportCsvFileButtonState();",
      "}",
      "",
      "class _ImportCsvFileButtonState extends State<ImportCsvFileButton> {",
      "  bool _loading = false;",
      "",
      "  Future<void> _pickCsvFile() async {",
      "    setState(() => _loading = true);",
      "    try {",
      "      final result = await FilePicker.platform.pickFiles(",
      "        type: FileType.custom,",
      "        allowedExtensions: ['csv'],",
      "        withData: true, // Ensures we get file content as bytes",
      "      );",
      "      if (result != null && result.files.single.bytes != null) {",
      "        // Try reading as UTF-8. Fallback to Latin1 if necessary.",
      "        String content;",
      "        try {",
      "          content = String.fromCharCodes(result.files.single.bytes!);",
      "        } catch (e) {",
      "          // If weird encoding, fallback to Latin1.",
      "          content = const Latin1Decoder().convert(result.files.single.bytes!);",
      "        }",
      "        widget.onCsvPicked(content);",
      "      } else {",
      "        // User canceled",
      "        widget.onCsvPicked(null);",
      "      }",
      "    } catch (e) {",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(content: Text('Failed to import file: $e')),",
      "      );",
      "      widget.onCsvPicked(null);",
      "    } finally {",
      "      if (mounted) setState(() => _loading = false);",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return ElevatedButton.icon(",
      "      icon: _loading",
      "          ? const SizedBox(",
      "              width: 18,",
      "              height: 18,",
      "              child: CircularProgressIndicator(",
      "                  strokeWidth: 2, color: Colors.white))",
      "          : Icon(widget.icon, size: 20),",
      "      label: Text(widget.label, style: const TextStyle(fontSize: 15)),",
      "      onPressed: (!widget.enabled || _loading) ? null : _pickCsvFile,",
      "      style: ElevatedButton.styleFrom(",
      "        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),",
      "        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),",
      "        elevation: 0,",
      "        backgroundColor: widget.enabled",
      "            ? Theme.of(context).colorScheme.primary",
      "            : Theme.of(context).disabledColor,",
      "        foregroundColor: widget.enabled ? Colors.white : Colors.black45,",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 91,
      "file_size": 3064,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\included_ingredients_preview.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "",
      "/// Displays a list of included ingredients for a menu item as labeled chips.",
      "/// If the list is empty or null, shows nothing.",
      "/// This widget is fully localizable.",
      "class IncludedIngredientsPreview extends StatelessWidget {",
      "  /// The included ingredients as a list of maps (matching Firestore structure).",
      "  final List<dynamic>? includedIngredients;",
      "",
      "  /// Optionally override the label (otherwise uses localization).",
      "  final String? label;",
      "",
      "  const IncludedIngredientsPreview({",
      "    super.key,",
      "    required this.includedIngredients,",
      "    this.label,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    if (includedIngredients == null || includedIngredients!.isEmpty) {",
      "      return const SizedBox.shrink();",
      "    }",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    return Padding(",
      "      padding: const EdgeInsets.only(bottom: DesignTokens.gridSpacing),",
      "      child: Column(",
      "        crossAxisAlignment: CrossAxisAlignment.start,",
      "        children: [",
      "          Text(",
      "            label ?? loc.includedIngredientsLabel,",
      "            style: TextStyle(",
      "              fontSize: DesignTokens.captionFontSize,",
      "              fontWeight: FontWeight.bold,",
      "              color: DesignTokens.secondaryTextColor,",
      "              fontFamily: DesignTokens.fontFamily,",
      "            ),",
      "          ),",
      "          const SizedBox(height: 4),",
      "          Wrap(",
      "            spacing: 8,",
      "            children: includedIngredients!",
      "                .map((i) => Chip(",
      "                      label: Text(",
      "                        (i is Map && i['name'] != null)",
      "                            ? i['name'].toString()",
      "                            : '',",
      "                        style: const TextStyle(fontSize: 13),",
      "                      ),",
      "                      backgroundColor: DesignTokens.surfaceColor,",
      "                    ))",
      "                .toList(),",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 67,
      "file_size": 2328,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\info_tile.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "",
      "/// Robust, reusable info tile for profile and other label/value displays.",
      "/// Handles null/empty values gracefully.",
      "class InfoTile extends StatelessWidget {",
      "  final String label;",
      "  final String? value;",
      "  final IconData? leadingIcon;",
      "  final Widget? trailing;",
      "",
      "  const InfoTile({",
      "    Key? key,",
      "    required this.label,",
      "    this.value,",
      "    this.leadingIcon,",
      "    this.trailing,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return ListTile(",
      "      leading: leadingIcon != null",
      "          ? Icon(leadingIcon, color: DesignTokens.primaryColor)",
      "          : null,",
      "      title: Text(",
      "        label,",
      "        style: const TextStyle(",
      "          fontSize: DesignTokens.bodyFontSize,",
      "          color: DesignTokens.textColor,",
      "          fontWeight: DesignTokens.titleFontWeight,",
      "          fontFamily: DesignTokens.fontFamily,",
      "        ),",
      "      ),",
      "      subtitle: Text(",
      "        (value == null || value!.trim().isEmpty) ? '—' : value!,",
      "        style: const TextStyle(",
      "          fontSize: DesignTokens.captionFontSize,",
      "          color: DesignTokens.secondaryTextColor,",
      "          fontFamily: DesignTokens.fontFamily,",
      "          fontWeight: DesignTokens.bodyFontWeight,",
      "        ),",
      "      ),",
      "      trailing: trailing,",
      "      contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 0),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 48,
      "file_size": 1476,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\loading_shimmer_widget.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:shimmer/shimmer.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "",
      "class LoadingShimmerWidget extends StatelessWidget {",
      "  final int itemCount;",
      "  final double cardHeight;",
      "  final double cardWidth;",
      "  final Axis direction;",
      "",
      "  // Admin grid support",
      "  final bool isAdminGrid;",
      "  final int gridColumns;",
      "",
      "  const LoadingShimmerWidget({",
      "    Key? key,",
      "    this.itemCount = 4,",
      "    this.cardHeight = 160.0,",
      "    this.cardWidth = double.infinity,",
      "    this.direction = Axis.vertical,",
      "    this.isAdminGrid = false,",
      "    this.gridColumns = 2,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    if (isAdminGrid) {",
      "      return Shimmer.fromColors(",
      "        baseColor: DesignTokens.shimmerBaseColor,",
      "        highlightColor: DesignTokens.shimmerHighlightColor,",
      "        child: GridView.count(",
      "          physics: const NeverScrollableScrollPhysics(),",
      "          shrinkWrap: true,",
      "          crossAxisCount: gridColumns,",
      "          children: List.generate(",
      "            itemCount,",
      "            (index) => Padding(",
      "              padding: const EdgeInsets.all(12),",
      "              child: Container(",
      "                height: cardHeight,",
      "                width: cardWidth,",
      "                decoration: BoxDecoration(",
      "                  color: Colors.white,",
      "                  borderRadius: BorderRadius.circular(DesignTokens.cardRadius),",
      "                ),",
      "              ),",
      "            ),",
      "          ),",
      "        ),",
      "      );",
      "    }",
      "",
      "    return Shimmer.fromColors(",
      "      baseColor: DesignTokens.shimmerBaseColor,",
      "      highlightColor: DesignTokens.shimmerHighlightColor,",
      "      child: GridView.count(",
      "        crossAxisCount: 2, // or 3 for tablet",
      "        shrinkWrap: true,",
      "        physics: const NeverScrollableScrollPhysics(),",
      "        childAspectRatio: 1,",
      "        padding: const EdgeInsets.all(12),",
      "        children: List.generate(",
      "          itemCount,",
      "          (index) => Container(",
      "            margin: const EdgeInsets.all(8),",
      "            decoration: BoxDecoration(",
      "              color: Colors.white,",
      "              borderRadius: BorderRadius.circular(DesignTokens.cardRadius),",
      "            ),",
      "          ),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 75,
      "file_size": 2278,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\menu_item_card.dart",
    "content": [
      "// lib/widgets/menu_item_card.dart",
      "",
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/config/branding_config.dart';",
      "import 'package:franchise_admin_portal/core/models/menu_item.dart';",
      "import 'package:franchise_admin_portal/core/models/ingredient_metadata.dart';",
      "import 'package:franchise_admin_portal/widgets/customization/customization_modal.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:firebase_auth/firebase_auth.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "",
      "typedef AddToCartCallback = void Function(",
      "  MenuItem menuItem,",
      "  Map<String, dynamic> customizations,",
      "  int quantity,",
      "  double totalPrice,",
      ");",
      "",
      "class MenuItemCard extends StatefulWidget {",
      "  final MenuItem menuItem;",
      "  final AddToCartCallback? onAddToCart;",
      "  final bool showDescription;",
      "  final bool expanded;",
      "  final EdgeInsets? margin;",
      "  final String franchiseId;",
      "",
      "  const MenuItemCard({",
      "    super.key,",
      "    required this.menuItem,",
      "    required this.franchiseId,",
      "    this.onAddToCart,",
      "    this.showDescription = true,",
      "    this.expanded = false,",
      "    this.margin,",
      "  });",
      "",
      "  @override",
      "  State<MenuItemCard> createState() => _MenuItemCardState();",
      "}",
      "",
      "class _MenuItemCardState extends State<MenuItemCard> {",
      "  int _quantity = 1;",
      "  String? _userId;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    final user = FirebaseAuth.instance.currentUser;",
      "    _userId = user?.uid;",
      "  }",
      "",
      "  Widget _favoriteHeart(bool isFavorited, bool enabled, AppLocalizations loc) {",
      "    final firestoreService =",
      "        Provider.of<FirestoreService>(context, listen: false);",
      "    return IconButton(",
      "      icon: Icon(",
      "        isFavorited ? Icons.favorite : Icons.favorite_border,",
      "        color:",
      "            isFavorited ? DesignTokens.accentColor : DesignTokens.hintTextColor,",
      "      ),",
      "      tooltip: enabled",
      "          ? (isFavorited",
      "              ? loc.removeFromFavoritesTooltip",
      "              : loc.addToFavoritesTooltip)",
      "          : loc.signInToFavoriteTooltip,",
      "      onPressed: enabled",
      "          ? () async {",
      "              if (isFavorited) {",
      "                await firestoreService.removeFavoriteMenuItem(",
      "                  _userId!,",
      "                  widget.franchiseId,",
      "                  widget.menuItem.id,",
      "                );",
      "              } else {",
      "                await firestoreService.addFavoriteMenuItem(",
      "                  _userId!,",
      "                  widget.franchiseId,",
      "                  widget.menuItem.id,",
      "                );",
      "              }",
      "              setState(() {});",
      "            }",
      "          : null,",
      "    );",
      "  }",
      "",
      "  Future<void> _handleCustomizeAndAdd(AppLocalizations loc) async {",
      "    // Get ingredientMetadata from Provider (required for CustomizationModal)",
      "    final ingredientMetadata =",
      "        Provider.of<Map<String, IngredientMetadata>>(context, listen: false);",
      "",
      "    await showDialog(",
      "      context: context,",
      "      builder: (context) => CustomizationModal(",
      "        menuItem: widget.menuItem,",
      "        ingredientMetadata: ingredientMetadata,",
      "        initialQuantity: _quantity,",
      "        onConfirm: (customizations, quantity, totalPrice) {",
      "          widget.onAddToCart",
      "              ?.call(widget.menuItem, customizations, quantity, totalPrice);",
      "          setState(() => _quantity = 1);",
      "          ScaffoldMessenger.of(context).showSnackBar(",
      "            SnackBar(content: Text(loc.addedToCartMessage)),",
      "          );",
      "        },",
      "      ),",
      "    );",
      "  }",
      "",
      "  void _handleAddToCart(AppLocalizations loc) {",
      "    widget.onAddToCart?.call(",
      "        widget.menuItem, {}, _quantity, widget.menuItem.price * _quantity);",
      "    setState(() => _quantity = 1);",
      "    ScaffoldMessenger.of(context).showSnackBar(",
      "      SnackBar(content: Text(loc.addedToCartMessage)),",
      "    );",
      "  }",
      "",
      "  bool get _hasCustomizations =>",
      "      (widget.menuItem.includedIngredients?.isNotEmpty ?? false) ||",
      "      (widget.menuItem.customizationGroups?.isNotEmpty ?? false) ||",
      "      (widget.menuItem.optionalAddOns?.isNotEmpty ?? false);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    final firestoreService =",
      "        Provider.of<FirestoreService>(context, listen: false);",
      "    final isWide = MediaQuery.of(context).size.width > 600;",
      "",
      "    // *** PULL INGREDIENT METADATA HERE ***",
      "    final ingredientMetadata =",
      "        Provider.of<Map<String, IngredientMetadata>>(context);",
      "",
      "    return Card(",
      "      margin: widget.margin ??",
      "          const EdgeInsets.symmetric(vertical: 6, horizontal: 6),",
      "      elevation: 2,",
      "      shape: RoundedRectangleBorder(",
      "        borderRadius: BorderRadius.circular(DesignTokens.cardRadius),",
      "        side: const BorderSide(color: DesignTokens.cardBorderColor, width: 1),",
      "      ),",
      "      child: Padding(",
      "        padding: isWide",
      "            ? const EdgeInsets.all(20)",
      "            : const EdgeInsets.symmetric(horizontal: 12, vertical: 10),",
      "        child: Row(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            // --- ITEM IMAGE + QUANTITY ---",
      "            Column(",
      "              children: [",
      "                ClipRRect(",
      "                  borderRadius: BorderRadius.circular(DesignTokens.cardRadius),",
      "                  child: widget.menuItem.image != null &&",
      "                          widget.menuItem.image!.isNotEmpty",
      "                      ? SizedBox(",
      "                          width: DesignTokens.menuItemImageWidth,",
      "                          height: DesignTokens.menuItemImageHeight,",
      "                          child: Image.network(",
      "                            widget.menuItem.image!,",
      "                            fit: BoxFit.cover,",
      "                            errorBuilder: (context, error, stackTrace) =>",
      "                                Image.asset(",
      "                              BrandingConfig.defaultPizzaIcon,",
      "                              fit: BoxFit.cover,",
      "                            ),",
      "                          ),",
      "                        )",
      "                      : Image.asset(",
      "                          BrandingConfig.defaultPizzaIcon,",
      "                          width: DesignTokens.menuItemImageWidth,",
      "                          height: DesignTokens.menuItemImageHeight,",
      "                        ),",
      "                ),",
      "                const SizedBox(height: 8),",
      "                // Quantity Selector under Image",
      "                Row(",
      "                  mainAxisAlignment: MainAxisAlignment.center,",
      "                  children: [",
      "                    IconButton(",
      "                      icon: const Icon(Icons.remove),",
      "                      visualDensity: VisualDensity.compact,",
      "                      onPressed: _quantity > 1",
      "                          ? () => setState(() => _quantity--)",
      "                          : null,",
      "                    ),",
      "                    Text(",
      "                      '$_quantity',",
      "                      style: const TextStyle(",
      "                        fontWeight: FontWeight.bold,",
      "                        fontSize: DesignTokens.bodyFontSize,",
      "                      ),",
      "                    ),",
      "                    IconButton(",
      "                      icon: const Icon(Icons.add),",
      "                      visualDensity: VisualDensity.compact,",
      "                      onPressed: () => setState(() => _quantity++),",
      "                    ),",
      "                  ],",
      "                ),",
      "              ],",
      "            ),",
      "            const SizedBox(width: 14),",
      "            // --- DETAILS + ACTIONS ---",
      "            Expanded(",
      "              child: Column(",
      "                crossAxisAlignment: CrossAxisAlignment.start,",
      "                children: [",
      "                  // NAME",
      "                  Text(",
      "                    widget.menuItem.name,",
      "                    style: const TextStyle(",
      "                      fontSize: DesignTokens.titleFontSize,",
      "                      fontWeight: FontWeight.bold,",
      "                      color: DesignTokens.textColor,",
      "                    ),",
      "                    maxLines: 2,",
      "                    overflow: TextOverflow.ellipsis,",
      "                  ),",
      "                  // PRICE",
      "                  Text(",
      "                    '\\$${widget.menuItem.price.toStringAsFixed(2)}',",
      "                    style: const TextStyle(",
      "                      fontSize: DesignTokens.bodyFontSize,",
      "                      fontWeight: FontWeight.w600,",
      "                      color: DesignTokens.textColor,",
      "                    ),",
      "                  ),",
      "                  // DESCRIPTION",
      "                  if (widget.showDescription &&",
      "                      widget.menuItem.description.isNotEmpty)",
      "                    Padding(",
      "                      padding: const EdgeInsets.only(top: 4.0),",
      "                      child: Text(",
      "                        widget.menuItem.description,",
      "                        style: const TextStyle(",
      "                          fontSize: DesignTokens.captionFontSize,",
      "                          color: DesignTokens.secondaryTextColor,",
      "                        ),",
      "                        maxLines: widget.expanded ? 4 : 2,",
      "                        overflow: TextOverflow.ellipsis,",
      "                      ),",
      "                    ),",
      "                  const SizedBox(height: 10),",
      "                  // --- BUTTONS & HEART ROW ---",
      "                  Row(",
      "                    crossAxisAlignment: CrossAxisAlignment.start,",
      "                    children: [",
      "                      // Customize button",
      "                      if (_hasCustomizations)",
      "                        Expanded(",
      "                          child: SizedBox(",
      "                            height: 36,",
      "                            child: ElevatedButton(",
      "                              style: ElevatedButton.styleFrom(",
      "                                backgroundColor: DesignTokens.secondaryColor,",
      "                                foregroundColor: DesignTokens.foregroundColor,",
      "                                shape: RoundedRectangleBorder(",
      "                                  borderRadius: BorderRadius.circular(18),",
      "                                ),",
      "                                padding: EdgeInsets.zero,",
      "                                elevation: DesignTokens.buttonElevation,",
      "                              ),",
      "                              onPressed: () => _handleCustomizeAndAdd(loc),",
      "                              child: Padding(",
      "                                padding: const EdgeInsets.symmetric(",
      "                                    horizontal: 5, vertical: 4),",
      "                                child: FittedBox(",
      "                                  fit: BoxFit.scaleDown,",
      "                                  child: Text(",
      "                                    loc.customize,",
      "                                    textAlign: TextAlign.center,",
      "                                    style: const TextStyle(",
      "                                      fontWeight: FontWeight.w500,",
      "                                      fontSize: 13,",
      "                                    ),",
      "                                  ),",
      "                                ),",
      "                              ),",
      "                            ),",
      "                          ),",
      "                        ),",
      "                      if (_hasCustomizations) const SizedBox(width: 8),",
      "                      // Plain add to cart if NO customizations",
      "                      if (!_hasCustomizations)",
      "                        Expanded(",
      "                          child: SizedBox(",
      "                            height: 36,",
      "                            child: ElevatedButton(",
      "                              style: ElevatedButton.styleFrom(",
      "                                backgroundColor: DesignTokens.primaryColor,",
      "                                foregroundColor: DesignTokens.foregroundColor,",
      "                                shape: RoundedRectangleBorder(",
      "                                  borderRadius: BorderRadius.circular(18),",
      "                                ),",
      "                                padding: EdgeInsets.zero,",
      "                                elevation: DesignTokens.buttonElevation,",
      "                              ),",
      "                              onPressed: () => _handleAddToCart(loc),",
      "                              child: Padding(",
      "                                padding: const EdgeInsets.symmetric(",
      "                                    horizontal: 5, vertical: 4),",
      "                                child: FittedBox(",
      "                                  fit: BoxFit.scaleDown,",
      "                                  child: Text(",
      "                                    loc.addToCart,",
      "                                    textAlign: TextAlign.center,",
      "                                    style: const TextStyle(",
      "                                      fontWeight: FontWeight.w500,",
      "                                      fontSize: 13,",
      "                                    ),",
      "                                  ),",
      "                                ),",
      "                              ),",
      "                            ),",
      "                          ),",
      "                        ),",
      "                      if (_hasCustomizations) ...[",
      "                        Expanded(",
      "                          child: SizedBox(",
      "                            height: 36,",
      "                            child: ElevatedButton(",
      "                              style: ElevatedButton.styleFrom(",
      "                                backgroundColor: DesignTokens.primaryColor,",
      "                                foregroundColor: DesignTokens.foregroundColor,",
      "                                shape: RoundedRectangleBorder(",
      "                                  borderRadius: BorderRadius.circular(18),",
      "                                ),",
      "                                padding: EdgeInsets.zero,",
      "                                elevation: DesignTokens.buttonElevation,",
      "                              ),",
      "                              onPressed: () => _handleAddToCart(loc),",
      "                              child: Padding(",
      "                                padding: const EdgeInsets.symmetric(",
      "                                    horizontal: 5, vertical: 4),",
      "                                child: FittedBox(",
      "                                  fit: BoxFit.scaleDown,",
      "                                  child: Text(",
      "                                    loc.addToCart,",
      "                                    textAlign: TextAlign.center,",
      "                                    style: const TextStyle(",
      "                                      fontWeight: FontWeight.w500,",
      "                                      fontSize: 13,",
      "                                    ),",
      "                                  ),",
      "                                ),",
      "                              ),",
      "                            ),",
      "                          ),",
      "                        ),",
      "                      ],",
      "                      const SizedBox(width: 8),",
      "                      // Heart/favorite",
      "                      _userId == null",
      "                          ? _favoriteHeart(false, false, loc)",
      "                          : StreamBuilder<List<String>>(",
      "                              stream:",
      "                                  firestoreService.favoritesMenuItemIdsStream(",
      "                                      _userId!, widget.franchiseId),",
      "                              builder: (context, idSnapshot) {",
      "                                if (!idSnapshot.hasData)",
      "                                  return _favoriteHeart(false, false, loc);",
      "                                final ids = idSnapshot.data!;",
      "                                return StreamBuilder<List<MenuItem>>(",
      "                                  stream: firestoreService.getMenuItemsByIds(",
      "                                      widget.franchiseId, ids),",
      "                                  builder: (context, itemSnapshot) {",
      "                                    if (itemSnapshot.connectionState ==",
      "                                        ConnectionState.waiting) {",
      "                                      return _favoriteHeart(false, false, loc);",
      "                                    }",
      "                                    if (itemSnapshot.hasError) {",
      "                                      return _favoriteHeart(false, true, loc);",
      "                                    }",
      "                                    final isFavorited = itemSnapshot.data?.any(",
      "                                          (mi) => mi.id == widget.menuItem.id,",
      "                                        ) ??",
      "                                        false;",
      "                                    return _favoriteHeart(",
      "                                        isFavorited, true, loc);",
      "                                  },",
      "                                );",
      "                              },",
      "                            )",
      "                    ],",
      "                  ),",
      "                  // -- EXAMPLE: Show allergen tags from metadata (optional) --",
      "                  if (_hasCustomizations &&",
      "                      widget.menuItem.includedIngredients != null)",
      "                    Padding(",
      "                      padding: const EdgeInsets.only(top: 8.0),",
      "                      child: Wrap(",
      "                        spacing: 6,",
      "                        children: widget.menuItem.includedIngredients!",
      "                            .map((ingredientId) {",
      "                          final meta = ingredientMetadata[ingredientId];",
      "                          if (meta == null || meta.allergens.isEmpty)",
      "                            return const SizedBox();",
      "                          return Chip(",
      "                            label: Text(meta.allergens.join(', ')),",
      "                            backgroundColor: Colors.orange.shade100,",
      "                          );",
      "                        }).toList(),",
      "                      ),",
      "                    ),",
      "                ],",
      "              ),",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 424,
      "file_size": 18267,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\menu_item_image.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/config/branding_config.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "",
      "/// A reusable menu item image widget with fallback to the default pizza icon.",
      "/// Accepts network or asset image URLs, with sizing consistent across the app.",
      "class MenuItemImage extends StatelessWidget {",
      "  final String? imageUrl;",
      "  final double? width;",
      "  final double? height;",
      "  final BoxFit fit;",
      "  final BorderRadiusGeometry? borderRadius;",
      "",
      "  const MenuItemImage({",
      "    super.key,",
      "    this.imageUrl,",
      "    this.width,",
      "    this.height,",
      "    this.fit = BoxFit.cover,",
      "    this.borderRadius,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final double w = width ?? DesignTokens.menuItemImageWidth;",
      "    final double h = height ?? DesignTokens.menuItemImageHeight;",
      "    final BoxFit boxFit = fit ?? BoxFit.cover;",
      "",
      "    final image = (imageUrl != null && imageUrl!.isNotEmpty)",
      "        ? Image.network(",
      "            imageUrl!,",
      "            width: w,",
      "            height: h,",
      "            fit: boxFit,",
      "            errorBuilder: (context, error, stackTrace) => Image.asset(",
      "              BrandingConfig.defaultPizzaIcon,",
      "              width: w,",
      "              height: h,",
      "              fit: boxFit,",
      "            ),",
      "          )",
      "        : Image.asset(",
      "            BrandingConfig.defaultPizzaIcon,",
      "            width: w,",
      "            height: h,",
      "            fit: boxFit,",
      "          );",
      "",
      "    if (borderRadius != null) {",
      "      return ClipRRect(",
      "        borderRadius: borderRadius!,",
      "        child: image,",
      "      );",
      "    }",
      "    return image;",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 57,
      "file_size": 1660,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\menu_item_validator.dart",
    "content": [
      "/// Utility class to validate menu item customization groups",
      "class MenuItemValidator {",
      "  /// Returns a list of required customization groups that are missing from the current item.",
      "  static List<String> getMissingRequiredGroups({",
      "    required List<Map<String, dynamic>> customizations,",
      "    required List requiredGroups,",
      "  }) {",
      "    final Set<String> present = customizations",
      "        .map((g) {",
      "          final label = g['label'];",
      "          if (label is String) return label.toLowerCase().trim();",
      "          if (label is Map && label.containsKey('en'))",
      "            return label['en'].toLowerCase().trim();",
      "          return null;",
      "        })",
      "        .whereType<String>()",
      "        .toSet();",
      "",
      "    return requiredGroups",
      "        .map((r) => r.toString().toLowerCase().trim())",
      "        .where((r) => !present.contains(r))",
      "        .toList();",
      "  }",
      "",
      "  static List<String> getMissingRequiredFields({",
      "    required List<Map<String, dynamic>> includedIngredients,",
      "    required List<Map<String, dynamic>> optionalAddOns,",
      "    required List fieldKeys,",
      "  }) {",
      "    final List<String> missing = [];",
      "",
      "    if (fieldKeys.contains('includedIngredients') &&",
      "        includedIngredients.isEmpty) {",
      "      missing.add('includedIngredients');",
      "    }",
      "",
      "    if (fieldKeys.contains('optionalAddOns') && optionalAddOns.isEmpty) {",
      "      missing.add('optionalAddOns');",
      "    }",
      "",
      "    return missing;",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 43,
      "file_size": 1402,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\network_image_widget.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:cached_network_image/cached_network_image.dart';",
      "",
      "/// A reusable widget that loads & caches a network image,",
      "/// shows a progress indicator while loading, and falls back",
      "/// to a local asset if the URL is empty or the load fails.",
      "/// Optionally applies rounded corners.",
      "class NetworkImageWidget extends StatelessWidget {",
      "  /// The remote image URL. If null/empty, [fallbackAsset] is shown.",
      "  final String? imageUrl;",
      "",
      "  /// Path to the local asset to use as a placeholder or on error.",
      "  final String fallbackAsset;",
      "",
      "  /// Desired display width.",
      "  final double width;",
      "",
      "  /// Desired display height.",
      "  final double height;",
      "",
      "  /// How to inscribe the image into the space.",
      "  final BoxFit fit;",
      "",
      "  /// Optional corner radius.",
      "  final BorderRadius? borderRadius;",
      "",
      "  const NetworkImageWidget({",
      "    Key? key,",
      "    required this.imageUrl,",
      "    required this.fallbackAsset,",
      "    required this.width,",
      "    required this.height,",
      "    this.fit = BoxFit.cover,",
      "    this.borderRadius,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    Widget img;",
      "",
      "    // 1) If no URL provided, immediately show fallback asset.",
      "    if (imageUrl == null || imageUrl!.trim().isEmpty) {",
      "      img = Image.asset(",
      "        fallbackAsset,",
      "        width: width,",
      "        height: height,",
      "        fit: fit,",
      "      );",
      "    } else {",
      "      // 2) Otherwise attempt to load via CachedNetworkImage.",
      "      img = CachedNetworkImage(",
      "        imageUrl: imageUrl!,",
      "        width: width,",
      "        height: height,",
      "        fit: fit,",
      "        placeholder: (ctx, url) => const Center(",
      "          child: CircularProgressIndicator(),",
      "        ),",
      "        errorWidget: (ctx, url, error) => Image.asset(",
      "          fallbackAsset,",
      "          width: width,",
      "          height: height,",
      "          fit: fit,",
      "        ),",
      "      );",
      "    }",
      "",
      "    // 3) If a borderRadius is provided, wrap in ClipRRect.",
      "    if (borderRadius != null) {",
      "      return ClipRRect(",
      "        borderRadius: borderRadius!,",
      "        child: img,",
      "      );",
      "    }",
      "",
      "    // 4) Otherwise return the image as-is.",
      "    return img;",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 79,
      "file_size": 2170,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\pagination_controls.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "",
      "/// Pagination controls for admin tables/lists.",
      "/// Supports \"Previous\" and \"Next\" buttons, with page display.",
      "class PaginationControls extends StatelessWidget {",
      "  final int currentPage;",
      "  final int totalPages;",
      "  final VoidCallback? onPrevious;",
      "  final VoidCallback? onNext;",
      "",
      "  const PaginationControls({",
      "    Key? key,",
      "    required this.currentPage,",
      "    required this.totalPages,",
      "    this.onPrevious,",
      "    this.onNext,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final canGoBack = currentPage > 1;",
      "    final canGoForward = currentPage < totalPages;",
      "",
      "    return Row(",
      "      mainAxisAlignment: MainAxisAlignment.center,",
      "      children: [",
      "        IconButton(",
      "          icon: const Icon(Icons.arrow_back_ios_new),",
      "          onPressed: canGoBack ? onPrevious : null,",
      "          tooltip: 'Previous page',",
      "        ),",
      "        Padding(",
      "          padding: const EdgeInsets.symmetric(horizontal: 12),",
      "          child: Text(",
      "            'Page $currentPage of $totalPages',",
      "            style: const TextStyle(fontWeight: FontWeight.bold),",
      "          ),",
      "        ),",
      "        IconButton(",
      "          icon: const Icon(Icons.arrow_forward_ios),",
      "          onPressed: canGoForward ? onNext : null,",
      "          tooltip: 'Next page',",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 47,
      "file_size": 1360,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\portion_selector.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "",
      "enum Portion { left, whole, right }",
      "",
      "class PortionSelector extends StatelessWidget {",
      "  final Portion value;",
      "  final void Function(Portion) onChanged;",
      "  final double size;",
      "",
      "  /// New: Map<Portion, bool> disables. If null, all enabled. Example: {Portion.left: true}",
      "  final Map<Portion, bool>? disables;",
      "",
      "  const PortionSelector({",
      "    Key? key,",
      "    required this.value,",
      "    required this.onChanged,",
      "    this.size = 24,",
      "    this.disables, // <-- Optional: not required for existing usage!",
      "  }) : super(key: key);",
      "",
      "  Color get _activeColor => Colors.teal.shade700;",
      "  Color get _inactiveColor => Colors.grey.shade400;",
      "  Color get _disabledColor => Colors.grey.shade300;",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final disables = this.disables ?? {};",
      "    return Row(",
      "      mainAxisAlignment: MainAxisAlignment.center,",
      "      children: [",
      "        _PortionCircle(",
      "          portion: Portion.left,",
      "          isSelected: value == Portion.left,",
      "          onTap: disables[Portion.left] == true",
      "              ? null",
      "              : () => onChanged(Portion.left),",
      "          activeColor: _activeColor,",
      "          inactiveColor: _inactiveColor,",
      "          disabledColor: _disabledColor,",
      "          disabled: disables[Portion.left] == true,",
      "          size: size,",
      "        ),",
      "        SizedBox(width: size * 0.2),",
      "        _PortionCircle(",
      "          portion: Portion.whole,",
      "          isSelected: value == Portion.whole,",
      "          onTap: disables[Portion.whole] == true",
      "              ? null",
      "              : () => onChanged(Portion.whole),",
      "          activeColor: _activeColor,",
      "          inactiveColor: _inactiveColor,",
      "          disabledColor: _disabledColor,",
      "          disabled: disables[Portion.whole] == true,",
      "          size: size,",
      "        ),",
      "        SizedBox(width: size * 0.2),",
      "        _PortionCircle(",
      "          portion: Portion.right,",
      "          isSelected: value == Portion.right,",
      "          onTap: disables[Portion.right] == true",
      "              ? null",
      "              : () => onChanged(Portion.right),",
      "          activeColor: _activeColor,",
      "          inactiveColor: _inactiveColor,",
      "          disabledColor: _disabledColor,",
      "          disabled: disables[Portion.right] == true,",
      "          size: size,",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}",
      "",
      "class _PortionCircle extends StatelessWidget {",
      "  final Portion portion;",
      "  final bool isSelected;",
      "  final VoidCallback? onTap;",
      "  final Color activeColor;",
      "  final Color inactiveColor;",
      "  final Color disabledColor;",
      "  final bool disabled;",
      "  final double size;",
      "",
      "  const _PortionCircle({",
      "    required this.portion,",
      "    required this.isSelected,",
      "    required this.onTap,",
      "    required this.activeColor,",
      "    required this.inactiveColor,",
      "    required this.disabledColor,",
      "    required this.disabled,",
      "    required this.size,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return SizedBox(",
      "      width: size,",
      "      height: size,",
      "      child: GestureDetector(",
      "        onTap: disabled ? null : onTap,",
      "        child: CustomPaint(",
      "          size: Size(size, size),",
      "          painter: _PortionPainter(",
      "            portion: portion,",
      "            isSelected: isSelected,",
      "            activeColor: activeColor,",
      "            inactiveColor: inactiveColor,",
      "            disabledColor: disabledColor,",
      "            disabled: disabled,",
      "          ),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "class _PortionPainter extends CustomPainter {",
      "  final Portion portion;",
      "  final bool isSelected;",
      "  final Color activeColor;",
      "  final Color inactiveColor;",
      "  final Color disabledColor;",
      "  final bool disabled;",
      "",
      "  _PortionPainter({",
      "    required this.portion,",
      "    required this.isSelected,",
      "    required this.activeColor,",
      "    required this.inactiveColor,",
      "    required this.disabledColor,",
      "    required this.disabled,",
      "  });",
      "",
      "  @override",
      "  void paint(Canvas canvas, Size size) {",
      "    final color =",
      "        disabled ? disabledColor : (isSelected ? activeColor : inactiveColor);",
      "",
      "    final fillPaint = Paint()",
      "      ..color = color.withOpacity(isSelected && !disabled ? 1.0 : 0.35)",
      "      ..style = PaintingStyle.fill;",
      "",
      "    final outerPaint = Paint()",
      "      ..color = color",
      "      ..style = PaintingStyle.stroke",
      "      ..strokeWidth = size.width * 0.12;",
      "",
      "    final center = Offset(size.width / 2, size.height / 2);",
      "    final radius = size.width / 2 - size.width * 0.13;",
      "",
      "    // Draw outer circle",
      "    canvas.drawCircle(center, radius, outerPaint);",
      "",
      "    // Draw inside (based on portion)",
      "    switch (portion) {",
      "      case Portion.left:",
      "        final rect = Rect.fromCircle(center: center, radius: radius - 1.2);",
      "        canvas.drawArc(rect, 3.14 / 2, 3.14, true, fillPaint);",
      "        break;",
      "      case Portion.whole:",
      "        canvas.drawCircle(center, radius - 1.2, fillPaint);",
      "        break;",
      "      case Portion.right:",
      "        final rect = Rect.fromCircle(center: center, radius: radius - 1.2);",
      "        canvas.drawArc(rect, -3.14 / 2, 3.14, true, fillPaint);",
      "        break;",
      "    }",
      "  }",
      "",
      "  @override",
      "  bool shouldRepaint(covariant CustomPainter oldDelegate) => true;",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 173,
      "file_size": 5139,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\profile_gate_screen.dart",
    "content": [
      "// File: lib/widgets/profile_gate_screen.dart",
      "import 'dart:async';",
      "import 'dart:html' as html; // Web reload",
      "import 'package:flutter/foundation.dart' show kIsWeb;",
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:firebase_auth/firebase_auth.dart' as fb_auth;",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/models/user.dart' as admin_user;",
      "import '../core/services/firestore_service.dart';",
      "import '../core/providers/admin_user_provider.dart';",
      "import '../core/providers/user_profile_notifier.dart';",
      "import '../config/design_tokens.dart';",
      "import '../config/branding_config.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class ProfileGateScreen extends StatefulWidget {",
      "  const ProfileGateScreen({Key? key}) : super(key: key);",
      "",
      "  @override",
      "  State<ProfileGateScreen> createState() => _ProfileGateScreenState();",
      "}",
      "",
      "class _ProfileGateScreenState extends State<ProfileGateScreen> {",
      "  Timer? _timer;",
      "  bool _timedOut = false;",
      "  bool _claimsRefreshed = false;",
      "  bool _retrying = false;",
      "  static const _timeoutSeconds = 10;",
      "  late FirestoreService _firestoreService;",
      "  late UserProfileNotifier _profileNotifier;",
      "  admin_user.User? _lastSetUser;",
      "",
      "  String? _getInviteToken() {",
      "    // If you save the invite token in localStorage after invite-accept",
      "    try {",
      "      return html.window.localStorage['invite_token'];",
      "    } catch (_) {",
      "      return null;",
      "    }",
      "  }",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "",
      "    WidgetsBinding.instance.addPostFrameCallback((_) async {",
      "      _profileNotifier =",
      "          Provider.of<UserProfileNotifier>(context, listen: false);",
      "      _firestoreService = Provider.of<FirestoreService>(context, listen: false);",
      "      final fbUser = fb_auth.FirebaseAuth.instance.currentUser;",
      "",
      "      print('[ProfileGateScreen] initState START');",
      "      print('[ProfileGateScreen] Firebase user: $fbUser');",
      "      print('[ProfileGateScreen] Current profile: ${_profileNotifier.user}');",
      "      print('[ProfileGateScreen] Is loading: ${_profileNotifier.loading}');",
      "",
      "      // Defensive: Avoid triggering reload if already loading or loaded",
      "      if (fbUser != null) {",
      "        if (_profileNotifier.user == null && !_profileNotifier.loading) {",
      "          print(",
      "              '[ProfileGateScreen] ⏳ No user loaded, starting listenToUser...');",
      "          _profileNotifier.listenToUser(_firestoreService, fbUser.uid);",
      "          _startTimeout();",
      "        } else if (_profileNotifier.user != null) {",
      "          print(",
      "              '[ProfileGateScreen] ✅ User already loaded. No need to reload.');",
      "        } else if (_profileNotifier.loading) {",
      "          print('[ProfileGateScreen] ⏳ Already loading. No action taken.');",
      "        }",
      "      } else {",
      "        print(",
      "            '[ProfileGateScreen] ⚠️ Firebase user is null. Cannot load profile.');",
      "      }",
      "    });",
      "  }",
      "",
      "  void _startTimeout() {",
      "    _timer?.cancel();",
      "    print(",
      "        '[ProfileGateScreen] Starting profile load timeout ($_timeoutSeconds seconds)');",
      "    _timer = Timer(Duration(seconds: _timeoutSeconds), () async {",
      "      setState(() => _timedOut = true);",
      "      print(",
      "          '[ProfileGateScreen] Profile load timed out after $_timeoutSeconds seconds');",
      "      await _logError('Profile load timed out after $_timeoutSeconds seconds');",
      "    });",
      "  }",
      "",
      "  Future<void> _logError(String message,",
      "      {Object? error, StackTrace? stack}) async {",
      "    try {",
      "      await ErrorLogger.log(",
      "        message: message,",
      "        source: 'profile_gate_screen',",
      "        stack: stack?.toString(),",
      "        severity: 'error',",
      "        screen: 'ProfileGateScreen',",
      "        contextData: {",
      "          if (error != null) 'error': error.toString(),",
      "        },",
      "      );",
      "    } catch (_) {}",
      "  }",
      "",
      "  @override",
      "  void dispose() {",
      "    _timer?.cancel();",
      "    super.dispose();",
      "  }",
      "",
      "  void _retry() {",
      "    print('[ProfileGateScreen] Retry pressed. Restarting load and timeout.');",
      "    setState(() {",
      "      _timedOut = false;",
      "      _claimsRefreshed = false;",
      "      _retrying = true;",
      "    });",
      "    _profileNotifier.reload();",
      "    _startTimeout();",
      "    setState(() {",
      "      _retrying = false;",
      "    });",
      "  }",
      "",
      "  // Modular dashboard section handler",
      "  Future<void> _navigateToDashboard(",
      "      admin_user.User user, AppLocalizations loc) async {",
      "    print(",
      "        '[ProfileGateScreen] Navigating with user: ${user.email} -> ${user.roles}');",
      "    final roles = user.roles ?? <String>[];",
      "    print(",
      "        '[ProfileGateScreen] _navigateToDashboard: roles=$roles, status=${user.status}');",
      "    if (user.status != 'active') {",
      "      print(",
      "          '[ProfileGateScreen] Navigating to /unauthorized (status: ${user.status})');",
      "      Navigator.of(context).pushReplacementNamed('/unauthorized');",
      "      return;",
      "    }",
      "    // HQ roles are handled in build(), so no need to check here!",
      "    if (roles.contains(admin_user.User.roleDeveloper)) {",
      "      print('[ProfileGateScreen] Navigating to /developer/dashboard');",
      "      Navigator.of(context).pushReplacementNamed('/developer/dashboard');",
      "    } else if (roles.contains(admin_user.User.roleOwner) ||",
      "        roles.contains(admin_user.User.roleManager)) {",
      "      print('[ProfileGateScreen] Navigating to /admin/dashboard');",
      "      Navigator.of(context).pushReplacementNamed('/admin/dashboard');",
      "    } else {",
      "      print('[ProfileGateScreen] No recognized role. roles=$roles');",
      "      await _logError('User has no recognized role', error: roles);",
      "      _showErrorSnack(loc.noValidRoleFound, Theme.of(context));",
      "    }",
      "  }",
      "",
      "  void _showErrorSnack(String msg, ThemeData theme) {",
      "    ScaffoldMessenger.of(context).showSnackBar(",
      "      SnackBar(content: Text(msg), backgroundColor: theme.colorScheme.error),",
      "    );",
      "  }",
      "",
      "  Future<void> _forceClaimsAndReload(AppLocalizations loc) async {",
      "    try {",
      "      final user = fb_auth.FirebaseAuth.instance.currentUser;",
      "      if (user != null) {",
      "        await user.getIdToken(true); // Force refresh",
      "      }",
      "      if (kIsWeb) {",
      "        html.window.location.reload();",
      "      }",
      "    } catch (e, stack) {",
      "      await _logError('Failed to refresh claims/token', error: e, stack: stack);",
      "      _showErrorSnack(loc.claimsRefreshFailed, Theme.of(context));",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "",
      "    if (loc == null) {",
      "      return _loadingScreen(\"Loading localization...\", theme, colorScheme,",
      "          showSpinner: true);",
      "    }",
      "",
      "    final notifier = Provider.of<UserProfileNotifier>(context);",
      "    final user = notifier.user;",
      "    final error = notifier.lastError;",
      "    final isLoading = notifier.loading && !_timedOut;",
      "",
      "    print('[ProfileGateScreen] DEBUG TRACE: user=${user?.toString()}');",
      "    print('[ProfileGateScreen] User profile loaded: '",
      "        'email=${user?.email}, '",
      "        'isActive=${user?.isActive}, '",
      "        'roles=${user?.roles}, '",
      "        'franchiseIds=${user?.franchiseIds}, '",
      "        'defaultFranchise=${user?.defaultFranchise}');",
      "",
      "    // === Onboarding: Detect incomplete profile ===",
      "    if (user != null &&",
      "        (user.completeProfile == null || user.completeProfile == false)) {",
      "      print(",
      "          '[ProfileGateScreen] User profile incomplete, redirecting to onboarding.');",
      "      WidgetsBinding.instance.addPostFrameCallback((_) {",
      "        Navigator.of(context).pushReplacementNamed(",
      "          '/franchise-onboarding',",
      "          arguments: {'token': _getInviteToken()},",
      "        );",
      "      });",
      "      return _loadingScreen(",
      "          \"Redirecting to franchise onboarding...\", theme, colorScheme,",
      "          showSpinner: true);",
      "    }",
      "",
      "    // === Defensive Fix: Wait for roles if user is active but claims not yet applied ===",
      "    final roles = user?.roles ?? [];",
      "    final currentRoute = ModalRoute.of(context)?.settings.name ?? '';",
      "    final isAlreadyAtDashboard = [",
      "      '/admin/dashboard',",
      "      '/platform-owner/dashboard',",
      "      '/hq-owner/dashboard',",
      "      '/developer/dashboard',",
      "    ].any((r) => currentRoute.startsWith(r));",
      "",
      "    print('[ProfileGateScreen] Current route: $currentRoute');",
      "    print('[ProfileGateScreen] isAlreadyAtDashboard: $isAlreadyAtDashboard');",
      "    final hasRoles = roles.isNotEmpty;",
      "",
      "    if (user != null && user.status == 'active') {",
      "      if (!hasRoles) {",
      "        print(",
      "            '[ProfileGateScreen] ⚠️ User is active, but roles are missing. Will wait for claim sync.');",
      "        if (!_claimsRefreshed) {",
      "          setState(() => _claimsRefreshed = true);",
      "          _forceClaimsAndReload(loc);",
      "        }",
      "        return _loadingScreen(loc.syncingRolesPleaseWait, theme, colorScheme,",
      "            showSpinner: true);",
      "      }",
      "",
      "      if (_lastSetUser != user) {",
      "        _lastSetUser = user;",
      "        WidgetsBinding.instance.addPostFrameCallback((_) {",
      "          Provider.of<AdminUserProvider>(context, listen: false).user = user;",
      "        });",
      "      }",
      "",
      "      print(",
      "          '[ProfileGateScreen] User loaded: email=${user.email}, roles=$roles, isActive=${user.isActive}');",
      "",
      "      if (roles.contains('platform_owner')) {",
      "        final route = ModalRoute.of(context)?.settings.name;",
      "        final isOnCorrectDashboard =",
      "            route != null && route.startsWith('/platform-owner/dashboard');",
      "",
      "        print('[ProfileGateScreen] Detected platform_owner. '",
      "            'currentRoute=$route, isOnCorrectDashboard=$isOnCorrectDashboard');",
      "",
      "        if (!isOnCorrectDashboard) {",
      "          WidgetsBinding.instance.addPostFrameCallback((_) {",
      "            Navigator.of(context)",
      "                .pushReplacementNamed('/platform-owner/dashboard');",
      "          });",
      "          return _loadingScreen(",
      "              loc.redirectingToPlatformOwnerDashboard ?? \"Redirecting...\",",
      "              theme,",
      "              colorScheme,",
      "              showSpinner: true);",
      "        }",
      "      } else if (roles.contains('hq_owner') || roles.contains('hq_manager')) {",
      "        print(",
      "            '[ProfileGateScreen] Detected hq_owner/hq_manager role, routing to /hq-owner/dashboard');",
      "        WidgetsBinding.instance.addPostFrameCallback((_) {",
      "          Navigator.of(context).pushReplacementNamed('/hq-owner/dashboard');",
      "        });",
      "        return _loadingScreen(",
      "            loc.redirectingToOwnerHQDashboard ??",
      "                \"Redirecting to HQ Dashboard...\",",
      "            theme,",
      "            colorScheme,",
      "            showSpinner: true);",
      "      } else if (roles.contains('developer')) {",
      "        print(",
      "            '[ProfileGateScreen] === Developer detected, redirecting to /developer/dashboard ===');",
      "        WidgetsBinding.instance.addPostFrameCallback((_) {",
      "          Navigator.of(context).pushReplacementNamed('/developer/dashboard');",
      "        });",
      "        return _loadingScreen(",
      "            loc.redirectingToDeveloperDashboard ??",
      "                \"Redirecting to Developer Dashboard...\",",
      "            theme,",
      "            colorScheme,",
      "            showSpinner: true);",
      "      } else if (roles.contains('owner') || roles.contains('manager')) {",
      "        final franchiseIds = user.franchiseIds ?? [];",
      "        print('[ProfileGateScreen] OWNER/MANAGER: franchiseIds=$franchiseIds');",
      "",
      "        if (franchiseIds.length > 1) {",
      "          print(",
      "              '[ProfileGateScreen] Franchise selection required, showing FranchiseSelectorScreen. '",
      "              'franchiseIds=$franchiseIds, '",
      "              'selectedFranchiseId=${Provider.of<FranchiseProvider>(context, listen: false).franchiseId}');",
      "          WidgetsBinding.instance.addPostFrameCallback((_) {",
      "            Navigator.of(context)",
      "                .pushReplacementNamed('/developer/select-franchise');",
      "          });",
      "          return _loadingScreen(",
      "              loc.selectFranchiseToManage ?? \"Select a franchise to manage...\",",
      "              theme,",
      "              colorScheme,",
      "              showSpinner: true);",
      "        } else if (franchiseIds.length == 1) {",
      "          print(",
      "              '[ProfileGateScreen] Admin/manager role detected, routing to AdminDashboardScreen. '",
      "              'selectedFranchiseId=${Provider.of<FranchiseProvider>(context, listen: false).franchiseId}');",
      "          Provider.of<FranchiseProvider>(context, listen: false)",
      "              .setFranchiseId(franchiseIds.first);",
      "          WidgetsBinding.instance.addPostFrameCallback((_) {",
      "            Navigator.of(context).pushReplacementNamed('/admin/dashboard');",
      "          });",
      "          return _loadingScreen(",
      "              loc.redirecting ?? \"Redirecting...\", theme, colorScheme,",
      "              showSpinner: true);",
      "        } else {",
      "          print('[ProfileGateScreen] No franchises found for owner/manager');",
      "          _showErrorSnack(\"No franchises found in your profile.\", theme);",
      "          return _errorScreen(",
      "            msg: \"No franchises found in your profile.\",",
      "            details: \"\",",
      "            onRetry: _retry,",
      "            theme: theme,",
      "            colorScheme: colorScheme,",
      "            loc: loc,",
      "            icon: Icons.error_outline,",
      "          );",
      "        }",
      "      } else {",
      "        print('[ProfileGateScreen] No valid role found, showing error');",
      "        _showErrorSnack(loc.noValidRoleFound, theme);",
      "        return _errorScreen(",
      "          msg: loc.noValidRoleFound,",
      "          details: \"\",",
      "          onRetry: _retry,",
      "          theme: theme,",
      "          colorScheme: colorScheme,",
      "          loc: loc,",
      "          icon: Icons.error_outline,",
      "        );",
      "      }",
      "    }",
      "",
      "    if (_timedOut && user == null) {",
      "      print('[ProfileGateScreen] State: Timed out, user is null.');",
      "      return _errorScreen(",
      "        msg: loc.profileLoadTimeout,",
      "        details: loc.tryAgainOrContactSupport,",
      "        onRetry: _retry,",
      "        theme: theme,",
      "        colorScheme: colorScheme,",
      "        loc: loc,",
      "        icon: Icons.timer_off,",
      "      );",
      "    }",
      "",
      "    if (error != null) {",
      "      print('[ProfileGateScreen] State: Error detected - $error');",
      "      return _errorScreen(",
      "        msg: loc.profileLoadFailed,",
      "        details: error.toString(),",
      "        onRetry: _retry,",
      "        theme: theme,",
      "        colorScheme: colorScheme,",
      "        loc: loc,",
      "        icon: Icons.error_outline,",
      "      );",
      "    }",
      "",
      "    if (user != null && (user.roles == null || user.roles!.isEmpty)) {",
      "      print('[ProfileGateScreen] Profile loaded, roles is null or empty! '",
      "          'User: ${user.email}, roles: ${user.roles}, status: ${user.status}');",
      "      if (!_claimsRefreshed) {",
      "        setState(() => _claimsRefreshed = true);",
      "        _forceClaimsAndReload(loc);",
      "      }",
      "      return _loadingScreen(loc.syncingRolesPleaseWait, theme, colorScheme,",
      "          showSpinner: true);",
      "    }",
      "",
      "    print('[ProfileGateScreen] Default: show loading with branding');",
      "    return _loadingScreen(loc.loadingProfileAndPermissions, theme, colorScheme,",
      "        showSpinner: true);",
      "  }",
      "",
      "  // === Loading State UI ===",
      "  Widget _loadingScreen(String msg, ThemeData theme, ColorScheme colorScheme,",
      "      {bool showSpinner = false}) {",
      "    return Scaffold(",
      "      backgroundColor: colorScheme.background,",
      "      body: Center(",
      "        child: Column(",
      "          mainAxisAlignment: MainAxisAlignment.center,",
      "          children: [",
      "            if (BrandingConfig.logoUrl.isNotEmpty)",
      "              Padding(",
      "                padding: const EdgeInsets.only(bottom: 28),",
      "                child: Image.network(",
      "                  BrandingConfig.logoUrl,",
      "                  height: 78,",
      "                  fit: BoxFit.contain,",
      "                  errorBuilder: (context, error, stackTrace) => Image.asset(",
      "                    BrandingConfig.logoMain,",
      "                    height: 78,",
      "                    fit: BoxFit.contain,",
      "                  ),",
      "                ),",
      "              ),",
      "            if (showSpinner) const CircularProgressIndicator(),",
      "            if (showSpinner) const SizedBox(height: 24),",
      "            Text(",
      "              msg,",
      "              style: theme.textTheme.titleLarge,",
      "              textAlign: TextAlign.center,",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  // === Error State UI ===",
      "  Widget _errorScreen({",
      "    required String msg,",
      "    required String details,",
      "    required VoidCallback onRetry,",
      "    required ThemeData theme,",
      "    required ColorScheme colorScheme,",
      "    required AppLocalizations loc,",
      "    IconData? icon,",
      "  }) {",
      "    return Scaffold(",
      "      backgroundColor: colorScheme.background,",
      "      body: Center(",
      "        child: ConstrainedBox(",
      "          constraints: const BoxConstraints(maxWidth: 480),",
      "          child: Card(",
      "            shape: RoundedRectangleBorder(",
      "              borderRadius: BorderRadius.circular(DesignTokens.adminCardRadius),",
      "            ),",
      "            margin: const EdgeInsets.symmetric(vertical: 32, horizontal: 16),",
      "            elevation: DesignTokens.adminCardElevation,",
      "            color: colorScheme.errorContainer.withOpacity(0.9),",
      "            child: Padding(",
      "              padding: const EdgeInsets.all(32),",
      "              child: Column(",
      "                mainAxisSize: MainAxisSize.min,",
      "                children: [",
      "                  Icon(icon ?? Icons.error_outline,",
      "                      size: 48, color: colorScheme.error),",
      "                  const SizedBox(height: 24),",
      "                  Text(msg,",
      "                      style: theme.textTheme.titleLarge",
      "                          ?.copyWith(color: colorScheme.error),",
      "                      textAlign: TextAlign.center),",
      "                  const SizedBox(height: 12),",
      "                  Text(details,",
      "                      style: theme.textTheme.bodyMedium,",
      "                      textAlign: TextAlign.center),",
      "                  const SizedBox(height: 30),",
      "                  ElevatedButton.icon(",
      "                    icon: const Icon(Icons.refresh),",
      "                    label: Text(loc.tryAgain),",
      "                    onPressed: onRetry,",
      "                  ),",
      "                ],",
      "              ),",
      "            ),",
      "          ),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  // === Future Feature Placeholder Section ===",
      "  Widget _futureFeatureSection(BuildContext context) {",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "    final loc = AppLocalizations.of(context)!;",
      "    return Column(",
      "      children: [",
      "        Icon(Icons.lightbulb_outline, color: colorScheme.secondary, size: 26),",
      "        const SizedBox(height: 8),",
      "        Text(",
      "          loc.futureFeaturesTitle,",
      "          style: theme.textTheme.titleMedium?.copyWith(",
      "            color: colorScheme.secondary,",
      "            fontWeight: FontWeight.bold,",
      "          ),",
      "        ),",
      "        const SizedBox(height: 4),",
      "        Text(loc.futureFeaturesBody,",
      "            style: theme.textTheme.bodySmall, textAlign: TextAlign.center),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 507,
      "file_size": 19021,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\profile_nav_tile.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "",
      "/// A reusable navigation tile for profile/account menus.",
      "/// Handles optional icons and highlight states.",
      "class ProfileNavTile extends StatelessWidget {",
      "  final String label;",
      "  final Widget destination;",
      "  final IconData? icon;",
      "  final bool highlight;",
      "",
      "  const ProfileNavTile({",
      "    Key? key,",
      "    required this.label,",
      "    required this.destination,",
      "    this.icon,",
      "    this.highlight = false,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return ListTile(",
      "      leading: icon != null",
      "          ? Icon(",
      "              icon,",
      "              color: highlight",
      "                  ? DesignTokens.adminPrimaryColor",
      "                  : DesignTokens.primaryColor,",
      "            )",
      "          : null,",
      "      title: Text(",
      "        label,",
      "        style: TextStyle(",
      "          fontSize: DesignTokens.bodyFontSize,",
      "          color: highlight",
      "              ? DesignTokens.adminPrimaryColor",
      "              : DesignTokens.textColor,",
      "          fontFamily: DesignTokens.fontFamily,",
      "          fontWeight: DesignTokens.bodyFontWeight,",
      "        ),",
      "      ),",
      "      trailing: const Icon(",
      "        Icons.arrow_forward,",
      "        color: DesignTokens.primaryColor,",
      "      ),",
      "      onTap: () => Navigator.of(context).push(",
      "        MaterialPageRoute(builder: (_) => destination),",
      "      ),",
      "      contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 0),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 52,
      "file_size": 1526,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\quantity_stepper.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "",
      "/// A universal, reusable quantity stepper widget.",
      "/// Accepts a value, increment/decrement callbacks, and an optional minimum/maximum.",
      "class QuantityStepper extends StatelessWidget {",
      "  final int value;",
      "  final VoidCallback onIncrement;",
      "  final VoidCallback onDecrement;",
      "  final int min;",
      "  final int? max;",
      "  final double fontSize;",
      "  final double iconSize;",
      "",
      "  const QuantityStepper({",
      "    super.key,",
      "    required this.value,",
      "    required this.onIncrement,",
      "    required this.onDecrement,",
      "    this.min = 1,",
      "    this.max,",
      "    this.fontSize = 16.0,",
      "    this.iconSize = 24.0,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final bool canDecrement = value > min;",
      "    final bool canIncrement = max == null ? true : value < max!;",
      "",
      "    return Row(",
      "      mainAxisSize: MainAxisSize.min,",
      "      children: [",
      "        IconButton(",
      "          icon: const Icon(Icons.remove),",
      "          iconSize: iconSize,",
      "          onPressed: canDecrement ? onDecrement : null,",
      "          color: canDecrement",
      "              ? DesignTokens.primaryColor",
      "              : DesignTokens.disabledTextColor,",
      "          splashRadius: 20,",
      "        ),",
      "        Container(",
      "          width: 32,",
      "          alignment: Alignment.center,",
      "          child: Text(",
      "            '$value',",
      "            style: TextStyle(",
      "              fontSize: fontSize,",
      "              fontWeight: FontWeight.bold,",
      "              fontFamily: DesignTokens.fontFamily,",
      "            ),",
      "          ),",
      "        ),",
      "        IconButton(",
      "          icon: const Icon(Icons.add),",
      "          iconSize: iconSize,",
      "          onPressed: canIncrement ? onIncrement : null,",
      "          color: canIncrement",
      "              ? DesignTokens.primaryColor",
      "              : DesignTokens.disabledTextColor,",
      "          splashRadius: 20,",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 67,
      "file_size": 1937,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\safe_logo_image.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import '../config/branding_config.dart';",
      "",
      "class SafeLogoImage extends StatelessWidget {",
      "  final double? height;",
      "  final BoxFit fit;",
      "  const SafeLogoImage({this.height, this.fit = BoxFit.contain, super.key});",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Image.network(",
      "      BrandingConfig.logoUrl,",
      "      height: height,",
      "      fit: fit,",
      "      errorBuilder: (context, error, stackTrace) =>",
      "          Image.asset(BrandingConfig.logoMain, height: height, fit: fit),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 19,
      "file_size": 552,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\scrolling_json_editor.dart",
    "content": [
      "import 'dart:convert';",
      "import 'package:flutter/material.dart';",
      "import 'package:flutter/services.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class ScrollingJsonEditor extends StatefulWidget {",
      "  final String? initialJson;",
      "  final void Function(String json) onChanged;",
      "  final double height;",
      "  final bool readOnly;",
      "  final AppLocalizations loc;",
      "",
      "  const ScrollingJsonEditor({",
      "    Key? key,",
      "    required this.onChanged,",
      "    this.initialJson,",
      "    this.height = 455,",
      "    this.readOnly = false,",
      "    required this.loc,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  State<ScrollingJsonEditor> createState() => _ScrollingJsonEditorState();",
      "}",
      "",
      "class _ScrollingJsonEditorState extends State<ScrollingJsonEditor> {",
      "  late final TextEditingController _controller;",
      "  late final ScrollController _scrollController;",
      "  String? _error;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _controller = TextEditingController(text: widget.initialJson ?? '');",
      "    _scrollController = ScrollController();",
      "    _controller.addListener(_handleChange);",
      "  }",
      "",
      "  void _handleChange() {",
      "    try {",
      "      final text = _controller.text.trim();",
      "      if (text.isEmpty) {",
      "        setState(() => _error = null);",
      "        widget.onChanged(text);",
      "        return;",
      "      }",
      "",
      "      final parsed = json.decode(text);",
      "      if (parsed is! Map && parsed is! List) {",
      "        throw const FormatException('Invalid JSON structure');",
      "      }",
      "",
      "      setState(() => _error = null);",
      "      widget.onChanged(text);",
      "    } catch (e, stack) {",
      "      setState(() => _error = widget.loc.invalidJsonFormat ?? 'Invalid JSON');",
      "      ErrorLogger.log(",
      "        message: 'Invalid JSON in ScrollingJsonEditor',",
      "        source: 'scrolling_json_editor.dart',",
      "        screen: 'ingredient_type_management_screen',",
      "        severity: 'warning',",
      "        stack: stack.toString(),",
      "        contextData: {",
      "          'input': _controller.text,",
      "          'errorType': e.runtimeType.toString(),",
      "        },",
      "      );",
      "    }",
      "  }",
      "",
      "  @override",
      "  void dispose() {",
      "    _controller.removeListener(_handleChange);",
      "    _controller.dispose();",
      "    _scrollController.dispose();",
      "    super.dispose();",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "",
      "    // Measure if scrolling is necessary",
      "    return LayoutBuilder(",
      "      builder: (context, constraints) {",
      "        // Create a dummy text painter to estimate overflow",
      "        final span = TextSpan(",
      "          text: _controller.text,",
      "          style: theme.textTheme.bodyMedium,",
      "        );",
      "        final tp = TextPainter(",
      "          text: span,",
      "          textDirection: TextDirection.ltr,",
      "          maxLines: null,",
      "        );",
      "        tp.layout(maxWidth: constraints.maxWidth - 24); // padding fudge factor",
      "",
      "        final estimatedHeight = tp.size.height;",
      "        final scrollable = estimatedHeight > (widget.height - 24);",
      "",
      "        final editor = TextField(",
      "          controller: _controller,",
      "          scrollController: _scrollController,",
      "          maxLines: null,",
      "          readOnly: widget.readOnly,",
      "          style: theme.textTheme.bodyMedium,",
      "          decoration: const InputDecoration.collapsed(",
      "            hintText: '{ \"key\": \"value\" }',",
      "          ),",
      "          keyboardType: TextInputType.multiline,",
      "          inputFormatters: [",
      "            FilteringTextInputFormatter.deny(RegExp(r'[\\u0000]')),",
      "          ],",
      "        );",
      "",
      "        return Column(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            Container(",
      "              height: widget.height,",
      "              decoration: BoxDecoration(",
      "                color: DesignTokens.surfaceColor,",
      "                border: Border.all(",
      "                  color: _error != null",
      "                      ? colorScheme.error",
      "                      : DesignTokens.cardBorderColor,",
      "                ),",
      "                borderRadius: BorderRadius.circular(DesignTokens.cardRadius),",
      "              ),",
      "              padding: const EdgeInsets.all(12),",
      "              child: scrollable",
      "                  ? Scrollbar(",
      "                      controller: _scrollController,",
      "                      thumbVisibility: true,",
      "                      child: editor,",
      "                    )",
      "                  : editor,",
      "            ),",
      "            if (_error != null) ...[",
      "              const SizedBox(height: 6),",
      "              Text(",
      "                _error!,",
      "                style: theme.textTheme.bodySmall?.copyWith(",
      "                  color: colorScheme.error,",
      "                ),",
      "              ),",
      "            ],",
      "          ],",
      "        );",
      "      },",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 156,
      "file_size": 4859,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\sign_out_button.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/widgets/confirmation_dialog.dart';",
      "",
      "/// A reusable sign out button with built-in confirmation dialog.",
      "/// Use in any screen where sign-out is needed for consistent UX.",
      "class SignOutButton extends StatelessWidget {",
      "  final String signOutLabel;",
      "  final String confirmationTitle;",
      "  final String confirmationMessage;",
      "  final String confirmLabel;",
      "  final String cancelLabel;",
      "  final VoidCallback onSignOut;",
      "",
      "  const SignOutButton({",
      "    Key? key,",
      "    required this.signOutLabel,",
      "    required this.confirmationTitle,",
      "    required this.confirmationMessage,",
      "    required this.confirmLabel,",
      "    required this.cancelLabel,",
      "    required this.onSignOut,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return ElevatedButton(",
      "      style: ElevatedButton.styleFrom(",
      "        backgroundColor: DesignTokens.errorColor,",
      "        foregroundColor: DesignTokens.foregroundColor,",
      "        padding: DesignTokens.buttonPadding,",
      "        shape: RoundedRectangleBorder(",
      "          borderRadius: BorderRadius.circular(DesignTokens.buttonRadius),",
      "        ),",
      "        elevation: DesignTokens.buttonElevation,",
      "      ),",
      "      onPressed: () async {",
      "        final shouldSignOut = await ConfirmationDialog.show(",
      "          context,",
      "          title: confirmationTitle,",
      "          message: confirmationMessage,",
      "          icon: Icons.logout,",
      "          confirmLabel: confirmLabel,",
      "          cancelLabel: cancelLabel,",
      "          confirmColor: DesignTokens.errorColor,",
      "          onConfirm: () {}, // ConfirmationDialog requires onConfirm",
      "        );",
      "        if (shouldSignOut == true) {",
      "          onSignOut();",
      "        }",
      "      },",
      "      child: Text(",
      "        signOutLabel,",
      "        style: const TextStyle(",
      "          fontSize: DesignTokens.bodyFontSize,",
      "          fontFamily: DesignTokens.fontFamily,",
      "          fontWeight: DesignTokens.bodyFontWeight,",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 62,
      "file_size": 2070,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\social_sign_in_buttons.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:firebase_auth/firebase_auth.dart';",
      "import 'package:franchise_admin_portal/core/services/auth_service.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/models/user.dart' as admin_user;",
      "import 'package:franchise_admin_portal/core/providers/user_profile_notifier.dart';",
      "",
      "/// SocialSignInButtons (ADMIN VERSION)",
      "/// Only allows Google and Phone sign-in (no guest or demo modes).",
      "class SocialSignInButtons extends StatefulWidget {",
      "  final void Function(User? user)? onSuccess;",
      "  final void Function(String error)? onError;",
      "  final void Function(bool)? setLoading;",
      "",
      "  final bool showGoogle;",
      "  final bool showPhone;",
      "  final bool isLoading;",
      "",
      "  final Color? googleButtonColor;",
      "  final Color? phoneButtonColor;",
      "",
      "  final Future<void> Function(User user)? ensureUserProfile;",
      "",
      "  const SocialSignInButtons({",
      "    super.key,",
      "    this.onSuccess,",
      "    this.onError,",
      "    this.setLoading,",
      "    this.showGoogle = true,",
      "    this.showPhone = true,",
      "    this.isLoading = false,",
      "    this.googleButtonColor,",
      "    this.phoneButtonColor,",
      "    this.ensureUserProfile,",
      "  });",
      "",
      "  @override",
      "  State<SocialSignInButtons> createState() => _SocialSignInButtonsState();",
      "}",
      "",
      "class _SocialSignInButtonsState extends State<SocialSignInButtons> {",
      "  bool _loading = false;",
      "",
      "  void _setLoading(bool value) {",
      "    setState(() => _loading = value);",
      "    widget.setLoading?.call(value);",
      "  }",
      "",
      "  Future<void> _defaultEnsureUserProfile(",
      "      BuildContext context, User user) async {",
      "    final firestoreService =",
      "        Provider.of<FirestoreService>(context, listen: false);",
      "    final existing = await firestoreService.getUser(user.uid);",
      "    if (existing == null) {",
      "      final newUser = admin_user.User(",
      "        id: user.uid,",
      "        name: user.displayName ?? \"\",",
      "        email: user.email ?? \"\",",
      "        phoneNumber: user.phoneNumber,",
      "        addresses: [],",
      "        language: \"en\",",
      "        roles: [admin_user.User.roleAdmin],",
      "        status: \"active\",",
      "      );",
      "      await firestoreService.addUser(newUser);",
      "    }",
      "  }",
      "",
      "  Future<void> _handleSignIn(",
      "      BuildContext context, Future<User?> Function() signInMethod) async {",
      "    _setLoading(true);",
      "    try {",
      "      final user = await signInMethod();",
      "      if (!mounted) return;",
      "      if (user != null) {",
      "        if (widget.ensureUserProfile != null) {",
      "          await widget.ensureUserProfile!(user);",
      "        } else {",
      "          await _defaultEnsureUserProfile(context, user);",
      "        }",
      "        if (!mounted) return;",
      "        // --- ADD THIS BLOCK ---",
      "        final firestoreService =",
      "            Provider.of<FirestoreService>(context, listen: false);",
      "        Provider.of<UserProfileNotifier>(context, listen: false)",
      "            .listenToUser(firestoreService, user.uid);",
      "        // --- END BLOCK ---",
      "        widget.onSuccess?.call(user);",
      "      } else {",
      "        if (!mounted) return;",
      "        widget.onError?.call(\"Sign-in failed. Please try again.\");",
      "      }",
      "    } catch (e) {",
      "      if (!mounted) return;",
      "      widget.onError?.call(e.toString());",
      "    }",
      "    if (!mounted) return;",
      "    _setLoading(false);",
      "  }",
      "",
      "  Future<void> _handlePhoneSignIn(BuildContext context) async {",
      "    String phone = '';",
      "    String? verificationId;",
      "    bool smsSent = false;",
      "    String smsCode = '';",
      "    String? error;",
      "",
      "    await showDialog(",
      "      context: context,",
      "      builder: (dialogContext) {",
      "        return StatefulBuilder(builder: (context, setDialogState) {",
      "          return AlertDialog(",
      "            title: Text(smsSent ? 'Enter SMS Code' : 'Sign in with Phone'),",
      "            content: Column(",
      "              mainAxisSize: MainAxisSize.min,",
      "              children: [",
      "                if (!smsSent)",
      "                  TextField(",
      "                    keyboardType: TextInputType.phone,",
      "                    decoration: const InputDecoration(",
      "                      labelText: 'Phone Number',",
      "                      hintText: '+1XXXXXXXXXX',",
      "                    ),",
      "                    onChanged: (v) => phone = v,",
      "                  ),",
      "                if (smsSent)",
      "                  TextField(",
      "                    keyboardType: TextInputType.number,",
      "                    decoration: const InputDecoration(",
      "                      labelText: 'SMS Code',",
      "                    ),",
      "                    onChanged: (v) => smsCode = v,",
      "                  ),",
      "                if (error != null)",
      "                  Padding(",
      "                    padding: const EdgeInsets.only(top: 8.0),",
      "                    child: Text(error!,",
      "                        style:",
      "                            const TextStyle(color: Colors.red, fontSize: 12)),",
      "                  ),",
      "              ],",
      "            ),",
      "            actions: [",
      "              TextButton(",
      "                onPressed: () => Navigator.of(dialogContext).pop(),",
      "                child: const Text('Cancel'),",
      "              ),",
      "              if (!smsSent)",
      "                TextButton(",
      "                  onPressed: () async {",
      "                    _setLoading(true);",
      "                    try {",
      "                      final authService =",
      "                          Provider.of<AuthService>(context, listen: false);",
      "                      await authService.signInWithPhone(",
      "                        phone,",
      "                        (vid, _) {",
      "                          setDialogState(() {",
      "                            smsSent = true;",
      "                            verificationId = vid;",
      "                          });",
      "                        },",
      "                        onError: (err) {",
      "                          setDialogState(() {",
      "                            error = err.toString();",
      "                          });",
      "                        },",
      "                      );",
      "                    } catch (e) {",
      "                      setDialogState(() {",
      "                        error = e.toString();",
      "                      });",
      "                    }",
      "                    if (!mounted) return;",
      "                    _setLoading(false);",
      "                  },",
      "                  child: const Text('Send Code'),",
      "                ),",
      "              if (smsSent)",
      "                TextButton(",
      "                  onPressed: () async {",
      "                    _setLoading(true);",
      "                    try {",
      "                      final authService =",
      "                          Provider.of<AuthService>(context, listen: false);",
      "                      final user = await authService.verifySmsCode(",
      "                          verificationId!, smsCode);",
      "                      if (!mounted) return;",
      "                      if (user != null) {",
      "                        if (widget.ensureUserProfile != null) {",
      "                          await widget.ensureUserProfile!(user);",
      "                        } else {",
      "                          await _defaultEnsureUserProfile(context, user);",
      "                        }",
      "                        if (!mounted) return;",
      "                        widget.onSuccess?.call(user);",
      "                        Navigator.of(dialogContext).pop();",
      "                      } else {",
      "                        setDialogState(() {",
      "                          error = \"Incorrect code.\";",
      "                        });",
      "                      }",
      "                    } catch (e) {",
      "                      setDialogState(() {",
      "                        error = e.toString();",
      "                      });",
      "                    }",
      "                    if (!mounted) return;",
      "                    _setLoading(false);",
      "                  },",
      "                  child: const Text('Verify'),",
      "                ),",
      "            ],",
      "          );",
      "        });",
      "      },",
      "    );",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final authService = Provider.of<AuthService>(context, listen: false);",
      "    final isBusy = widget.isLoading || _loading;",
      "",
      "    return Column(",
      "      children: [",
      "        if (widget.showGoogle)",
      "          SizedBox(",
      "            width: double.infinity,",
      "            child: ElevatedButton.icon(",
      "              icon: const Icon(Icons.g_mobiledata, color: Colors.red, size: 24),",
      "              label: const Text('Sign in with Google'),",
      "              onPressed: isBusy",
      "                  ? null",
      "                  : () => _handleSignIn(",
      "                        context,",
      "                        () => authService.signInWithGoogle(),",
      "                      ),",
      "              style: ElevatedButton.styleFrom(",
      "                backgroundColor: widget.googleButtonColor ?? Colors.white,",
      "                foregroundColor: Colors.black,",
      "              ),",
      "            ),",
      "          ),",
      "        if (widget.showGoogle) const SizedBox(height: 8),",
      "        if (widget.showPhone)",
      "          SizedBox(",
      "            width: double.infinity,",
      "            child: ElevatedButton.icon(",
      "              icon: const Icon(Icons.phone, color: Colors.green, size: 22),",
      "              label: const Text('Sign in with Phone'),",
      "              onPressed: isBusy ? null : () => _handlePhoneSignIn(context),",
      "              style: ElevatedButton.styleFrom(",
      "                backgroundColor: widget.phoneButtonColor ?? Colors.green[50],",
      "                foregroundColor: Colors.green[900],",
      "              ),",
      "            ),",
      "          ),",
      "        if (widget.showPhone) const SizedBox(height: 8),",
      "        if (isBusy) ...[",
      "          const SizedBox(height: 12),",
      "          const CircularProgressIndicator(),",
      "        ],",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 268,
      "file_size": 9525,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\status_chip.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "",
      "/// A versatile chip for displaying status values (order, inventory, user, etc.).",
      "class StatusChip extends StatelessWidget {",
      "  final String status;",
      "  final Map<String, Color>? statusColorMap;",
      "  final bool useIcon;",
      "",
      "  const StatusChip({",
      "    Key? key,",
      "    required this.status,",
      "    this.statusColorMap,",
      "    this.useIcon = false,",
      "  }) : super(key: key);",
      "",
      "  Color _getStatusColor() {",
      "    final normalized = status.toLowerCase();",
      "    if (statusColorMap != null && statusColorMap!.containsKey(normalized)) {",
      "      return statusColorMap![normalized]!;",
      "    }",
      "    // Fallback defaults",
      "    switch (normalized) {",
      "      case 'pending':",
      "        return Colors.orange;",
      "      case 'in progress':",
      "      case 'processing':",
      "        return Colors.blue;",
      "      case 'delivered':",
      "      case 'complete':",
      "        return Colors.green;",
      "      case 'cancelled':",
      "      case 'canceled':",
      "        return Colors.red;",
      "      case 'failed':",
      "        return Colors.redAccent;",
      "      case 'out of stock':",
      "        return Colors.grey;",
      "      default:",
      "        return Colors.grey.shade400;",
      "    }",
      "  }",
      "",
      "  IconData? _getStatusIcon() {",
      "    final normalized = status.toLowerCase();",
      "    switch (normalized) {",
      "      case 'pending':",
      "        return Icons.hourglass_empty;",
      "      case 'in progress':",
      "      case 'processing':",
      "        return Icons.sync;",
      "      case 'delivered':",
      "      case 'complete':",
      "        return Icons.check_circle;",
      "      case 'cancelled':",
      "      case 'canceled':",
      "        return Icons.cancel;",
      "      case 'failed':",
      "        return Icons.warning;",
      "      case 'out of stock':",
      "        return Icons.remove_shopping_cart;",
      "      default:",
      "        return null;",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final color = _getStatusColor();",
      "    final icon = useIcon ? _getStatusIcon() : null;",
      "",
      "    return Chip(",
      "      label: Text(",
      "        status,",
      "        style: TextStyle(",
      "          color: color.computeLuminance() > 0.5 ? Colors.black : Colors.white,",
      "          fontWeight: FontWeight.bold,",
      "        ),",
      "      ),",
      "      backgroundColor: color,",
      "      avatar: icon != null ? Icon(icon, size: 18, color: Colors.white) : null,",
      "      padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 2),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 84,
      "file_size": 2297,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\subscription_access_guard.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_subscription_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/user_profile_notifier.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "",
      "class SubscriptionAccessGuard extends StatelessWidget {",
      "  final Widget child;",
      "",
      "  const SubscriptionAccessGuard({super.key, required this.child});",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final user = context.read<AdminUserProvider>().user;",
      "",
      "    // Bypass check for privileged roles",
      "    final roles = user?.roles ?? [];",
      "    final isBypass =",
      "        roles.contains('platform_owner') || roles.contains('developer');",
      "    debugPrint('[SubscriptionAccessGuard] User roles: ${user?.roles}');",
      "    debugPrint('[SubscriptionAccessGuard] isBypass: $isBypass');",
      "    if (isBypass) return child;",
      "",
      "    final sub =",
      "        context.watch<FranchiseSubscriptionNotifier>().currentSubscription;",
      "",
      "    if (sub == null || sub.status != 'active') {",
      "      return const Center(child: Text('No active subscription.'));",
      "    }",
      "",
      "    final now = DateTime.now();",
      "    final isBlocked = sub.hasOverdueInvoice &&",
      "        (sub.gracePeriodEndsAt != null && now.isAfter(sub.gracePeriodEndsAt!));",
      "",
      "    if (isBlocked) {",
      "      return const Center(",
      "        child: Padding(",
      "          padding: EdgeInsets.all(24),",
      "          child: Column(",
      "            mainAxisSize: MainAxisSize.min,",
      "            children: [",
      "              Icon(Icons.warning_rounded, color: Colors.red, size: 64),",
      "              SizedBox(height: 16),",
      "              Text(",
      "                'Your subscription is overdue and past the grace period.',",
      "                style: TextStyle(fontSize: 16),",
      "                textAlign: TextAlign.center,",
      "              ),",
      "              SizedBox(height: 8),",
      "              Text(",
      "                'Please update your billing info or contact support to regain access.',",
      "                textAlign: TextAlign.center,",
      "              ),",
      "            ],",
      "          ),",
      "        ),",
      "      );",
      "    }",
      "",
      "    return child;",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 62,
      "file_size": 2176,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\Address\\address_form.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/models/address.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "",
      "typedef FieldValidator = String? Function(String?);",
      "",
      "class AddressForm extends StatefulWidget {",
      "  final GlobalKey<FormState> formKey;",
      "  final void Function(Address address) onSubmit;",
      "  final Address? initialValue;",
      "  final String? submitLabel;",
      "  final Map<String, FieldValidator>? fieldValidators;",
      "",
      "  const AddressForm({",
      "    super.key,",
      "    required this.formKey,",
      "    required this.onSubmit,",
      "    this.initialValue,",
      "    this.submitLabel,",
      "    this.fieldValidators,",
      "  });",
      "",
      "  @override",
      "  State<AddressForm> createState() => _AddressFormState();",
      "}",
      "",
      "class _AddressFormState extends State<AddressForm> {",
      "  late String? _label;",
      "  late String? _street;",
      "  late String? _city;",
      "  late String? _state;",
      "  late String? _zip;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _label = widget.initialValue?.label;",
      "    _street = widget.initialValue?.street;",
      "    _city = widget.initialValue?.city;",
      "    _state = widget.initialValue?.state;",
      "    _zip = widget.initialValue?.zip;",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "",
      "    // Default US validation logic",
      "    String? defaultLabelValidator(String? value) =>",
      "        value == null || value.isEmpty ? loc.labelRequired : null;",
      "    String? defaultStreetValidator(String? value) =>",
      "        value == null || value.isEmpty ? loc.streetRequired : null;",
      "    String? defaultCityValidator(String? value) =>",
      "        value == null || value.isEmpty ? loc.cityRequired : null;",
      "    String? defaultStateValidator(String? value) =>",
      "        value == null || value.isEmpty ? loc.stateRequired : null;",
      "    String? defaultZipValidator(String? value) {",
      "      if (value == null || value.isEmpty) return loc.zipRequired;",
      "      if (!RegExp(r'^\\d{5}$').hasMatch(value)) return loc.invalidZip;",
      "      return null;",
      "    }",
      "",
      "    return Form(",
      "      key: widget.formKey,",
      "      child: Column(",
      "        children: [",
      "          TextFormField(",
      "            initialValue: _label,",
      "            decoration: InputDecoration(",
      "              labelText: loc.labelExample,",
      "              border: OutlineInputBorder(",
      "                borderRadius:",
      "                    BorderRadius.circular(DesignTokens.formFieldRadius),",
      "              ),",
      "              hintStyle: const TextStyle(",
      "                color: DesignTokens.hintTextColor,",
      "              ),",
      "            ),",
      "            validator:",
      "                widget.fieldValidators?['label'] ?? defaultLabelValidator,",
      "            onSaved: (value) => _label = value,",
      "            style: const TextStyle(",
      "              color: DesignTokens.textColor,",
      "              fontFamily: DesignTokens.fontFamily,",
      "              fontWeight: DesignTokens.bodyFontWeight,",
      "            ),",
      "          ),",
      "          const SizedBox(height: DesignTokens.gridSpacing),",
      "          TextFormField(",
      "            initialValue: _street,",
      "            decoration: InputDecoration(",
      "              labelText: loc.street,",
      "              border: OutlineInputBorder(",
      "                borderRadius:",
      "                    BorderRadius.circular(DesignTokens.formFieldRadius),",
      "              ),",
      "              hintStyle: const TextStyle(",
      "                color: DesignTokens.hintTextColor,",
      "              ),",
      "            ),",
      "            validator:",
      "                widget.fieldValidators?['street'] ?? defaultStreetValidator,",
      "            onSaved: (value) => _street = value,",
      "            style: const TextStyle(",
      "              color: DesignTokens.textColor,",
      "              fontFamily: DesignTokens.fontFamily,",
      "              fontWeight: DesignTokens.bodyFontWeight,",
      "            ),",
      "          ),",
      "          const SizedBox(height: DesignTokens.gridSpacing),",
      "          TextFormField(",
      "            initialValue: _city,",
      "            decoration: InputDecoration(",
      "              labelText: loc.city,",
      "              border: OutlineInputBorder(",
      "                borderRadius:",
      "                    BorderRadius.circular(DesignTokens.formFieldRadius),",
      "              ),",
      "              hintStyle: const TextStyle(",
      "                color: DesignTokens.hintTextColor,",
      "              ),",
      "            ),",
      "            validator: widget.fieldValidators?['city'] ?? defaultCityValidator,",
      "            onSaved: (value) => _city = value,",
      "            style: const TextStyle(",
      "              color: DesignTokens.textColor,",
      "              fontFamily: DesignTokens.fontFamily,",
      "              fontWeight: DesignTokens.bodyFontWeight,",
      "            ),",
      "          ),",
      "          const SizedBox(height: DesignTokens.gridSpacing),",
      "          TextFormField(",
      "            initialValue: _state,",
      "            decoration: InputDecoration(",
      "              labelText: loc.state,",
      "              border: OutlineInputBorder(",
      "                borderRadius:",
      "                    BorderRadius.circular(DesignTokens.formFieldRadius),",
      "              ),",
      "              hintStyle: const TextStyle(",
      "                color: DesignTokens.hintTextColor,",
      "              ),",
      "            ),",
      "            validator:",
      "                widget.fieldValidators?['state'] ?? defaultStateValidator,",
      "            onSaved: (value) => _state = value,",
      "            style: const TextStyle(",
      "              color: DesignTokens.textColor,",
      "              fontFamily: DesignTokens.fontFamily,",
      "              fontWeight: DesignTokens.bodyFontWeight,",
      "            ),",
      "          ),",
      "          const SizedBox(height: DesignTokens.gridSpacing),",
      "          TextFormField(",
      "            initialValue: _zip,",
      "            decoration: InputDecoration(",
      "              labelText: loc.zipCode,",
      "              border: OutlineInputBorder(",
      "                borderRadius:",
      "                    BorderRadius.circular(DesignTokens.formFieldRadius),",
      "              ),",
      "              hintStyle: const TextStyle(",
      "                color: DesignTokens.hintTextColor,",
      "              ),",
      "            ),",
      "            validator: widget.fieldValidators?['zip'] ?? defaultZipValidator,",
      "            onSaved: (value) => _zip = value,",
      "            style: const TextStyle(",
      "              color: DesignTokens.textColor,",
      "              fontFamily: DesignTokens.fontFamily,",
      "              fontWeight: DesignTokens.bodyFontWeight,",
      "            ),",
      "          ),",
      "          const SizedBox(height: DesignTokens.gridSpacing * 2),",
      "          ElevatedButton(",
      "            style: ElevatedButton.styleFrom(",
      "              backgroundColor: DesignTokens.primaryColor,",
      "              foregroundColor: DesignTokens.foregroundColor,",
      "              padding: DesignTokens.buttonPadding,",
      "              shape: RoundedRectangleBorder(",
      "                borderRadius: BorderRadius.circular(DesignTokens.buttonRadius),",
      "              ),",
      "              elevation: DesignTokens.buttonElevation,",
      "            ),",
      "            onPressed: () {",
      "              if (widget.formKey.currentState!.validate()) {",
      "                widget.formKey.currentState!.save();",
      "                final address = Address(",
      "                  id: UniqueKey().toString(),",
      "                  label: _label!,",
      "                  street: _street!,",
      "                  city: _city!,",
      "                  state: _state!,",
      "                  zip: _zip!,",
      "                );",
      "",
      "                widget.onSubmit(address);",
      "                widget.formKey.currentState!.reset();",
      "                FocusScope.of(context).unfocus();",
      "              }",
      "            },",
      "            child: Text(widget.submitLabel ?? loc.addAddress),",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 216,
      "file_size": 7906,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\Address\\address_list_view.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/core/models/address.dart';",
      "import 'package:franchise_admin_portal/widgets/Address/delivery_address_tile.dart';",
      "",
      "class AddressListView extends StatelessWidget {",
      "  final List<Address> addresses;",
      "  final Future<void> Function(Address address) onDelete;",
      "",
      "  const AddressListView({",
      "    super.key,",
      "    required this.addresses,",
      "    required this.onDelete,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return ListView.builder(",
      "      shrinkWrap: true,",
      "      physics: const NeverScrollableScrollPhysics(),",
      "      itemCount: addresses.length,",
      "      itemBuilder: (context, index) {",
      "        final address = addresses[index];",
      "        return DeliveryAddressTile(",
      "          address: address,",
      "          onDelete: () => onDelete(address),",
      "        );",
      "      },",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 30,
      "file_size": 879,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\Address\\delivery_addresses_body.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/core/models/address.dart';",
      "import 'package:franchise_admin_portal/widgets/Address/address_list_view.dart';",
      "import 'package:franchise_admin_portal/widgets/Address/address_form.dart';",
      "import 'package:franchise_admin_portal/widgets/empty_state_widget.dart';",
      "import 'package:franchise_admin_portal/widgets/confirmation_dialog.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:firebase_auth/firebase_auth.dart';",
      "",
      "class DeliveryAddressesBody extends StatefulWidget {",
      "  final List<Address> addresses;",
      "  final FirestoreService firestoreService;",
      "  final User user;",
      "  final GlobalKey<FormState> formKey;",
      "  final String franchiseId;",
      "",
      "  const DeliveryAddressesBody({",
      "    super.key,",
      "    required this.addresses,",
      "    required this.firestoreService,",
      "    required this.user,",
      "    required this.formKey,",
      "    required this.franchiseId,",
      "  });",
      "",
      "  @override",
      "  State<DeliveryAddressesBody> createState() => _DeliveryAddressesBodyState();",
      "}",
      "",
      "class _DeliveryAddressesBodyState extends State<DeliveryAddressesBody> {",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final localizations = AppLocalizations.of(context)!;",
      "    final addresses = widget.addresses;",
      "    final firestoreService = widget.firestoreService;",
      "    final user = widget.user;",
      "    final formKey = widget.formKey;",
      "",
      "    return Padding(",
      "      padding: DesignTokens.cardPadding,",
      "      child: SingleChildScrollView(",
      "        padding: EdgeInsets.only(",
      "          bottom: MediaQuery.of(context).viewInsets.bottom +",
      "              MediaQuery.of(context).viewPadding.bottom +",
      "              16,",
      "        ),",
      "        child: Column(",
      "          mainAxisSize: MainAxisSize.min,",
      "          children: [",
      "            if (addresses.isEmpty)",
      "              EmptyStateWidget(",
      "                title: localizations.noAddressesSaved,",
      "                iconData: Icons.home_outlined,",
      "              )",
      "            else",
      "              AddressListView(",
      "                addresses: addresses,",
      "                onDelete: (address) async {",
      "                  final shouldDelete = await ConfirmationDialog.show(",
      "                    context,",
      "                    title: localizations.areYouSure,",
      "                    message: localizations.deleteAddress,",
      "                    onConfirm: () {},",
      "                    confirmLabel: localizations.confirm,",
      "                    cancelLabel: localizations.cancel,",
      "                    icon: Icons.delete,",
      "                    confirmColor: DesignTokens.errorColor,",
      "                  );",
      "                  if (shouldDelete == true) {",
      "                    await firestoreService.removeAddressForUser(",
      "                        user.uid, address.id);",
      "                    if (!mounted) return;",
      "                    ScaffoldMessenger.of(context).showSnackBar(",
      "                      SnackBar(",
      "                        content: Text(",
      "                          localizations.addressRemoved,",
      "                          style: const TextStyle(",
      "                            color: DesignTokens.textColor,",
      "                            fontFamily: DesignTokens.fontFamily,",
      "                            fontWeight: DesignTokens.bodyFontWeight,",
      "                          ),",
      "                        ),",
      "                        backgroundColor: DesignTokens.surfaceColor,",
      "                        duration: DesignTokens.toastDuration,",
      "                      ),",
      "                    );",
      "                  }",
      "                },",
      "              ),",
      "            if (addresses.length < 5)",
      "              AddressForm(",
      "                formKey: formKey,",
      "                submitLabel: localizations.addAddress,",
      "                // You can inject validation logic here if needed for franchise/international",
      "                onSubmit: (newAddress) async {",
      "                  final shouldAdd = await ConfirmationDialog.show(",
      "                    context,",
      "                    title: localizations.areYouSure,",
      "                    message: localizations.addAddress,",
      "                    onConfirm: () {},",
      "                    confirmLabel: localizations.confirm,",
      "                    cancelLabel: localizations.cancel,",
      "                    icon: Icons.add_location_alt,",
      "                    confirmColor: DesignTokens.primaryColor,",
      "                  );",
      "                  if (shouldAdd == true) {",
      "                    await firestoreService.addAddressForUser(",
      "                        user.uid, newAddress);",
      "",
      "                    if (!mounted) return;",
      "                    ScaffoldMessenger.of(context).showSnackBar(",
      "                      SnackBar(",
      "                        content: Text(",
      "                          localizations.addressAdded,",
      "                          style: const TextStyle(",
      "                            color: DesignTokens.textColor,",
      "                            fontFamily: DesignTokens.fontFamily,",
      "                            fontWeight: DesignTokens.bodyFontWeight,",
      "                          ),",
      "                        ),",
      "                        backgroundColor: DesignTokens.surfaceColor,",
      "                        duration: DesignTokens.toastDuration,",
      "                      ),",
      "                    );",
      "                  }",
      "                },",
      "              ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 135,
      "file_size": 5483,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\Address\\delivery_address_tile.dart",
    "content": [
      "import 'package:provider/provider.dart';",
      "import 'package:flutter/material.dart';",
      "import 'package:firebase_auth/firebase_auth.dart';",
      "import 'package:franchise_admin_portal/core/models/address.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/widgets/Address/edit_address_dialog.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "",
      "class DeliveryAddressTile extends StatelessWidget {",
      "  final Address address;",
      "  final VoidCallback onDelete;",
      "",
      "  const DeliveryAddressTile({",
      "    super.key,",
      "    required this.address,",
      "    required this.onDelete,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Card(",
      "      elevation: DesignTokens.cardElevation,",
      "      margin: const EdgeInsets.symmetric(",
      "        vertical: DesignTokens.gridSpacing / 2,",
      "      ),",
      "      shape: RoundedRectangleBorder(",
      "        borderRadius: BorderRadius.circular(DesignTokens.cardRadius),",
      "      ),",
      "      color: DesignTokens.surfaceColor,",
      "      child: ListTile(",
      "        title: Text(",
      "          address.label,",
      "          style: const TextStyle(",
      "            fontSize: DesignTokens.bodyFontSize,",
      "            color: DesignTokens.textColor,",
      "            fontWeight: DesignTokens.titleFontWeight,",
      "            fontFamily: DesignTokens.fontFamily,",
      "          ),",
      "        ),",
      "        subtitle: Text(",
      "          '${address.street}, ${address.city}, ${address.state} ${address.zip}',",
      "          style: const TextStyle(",
      "            fontSize: DesignTokens.captionFontSize,",
      "            color: DesignTokens.secondaryTextColor,",
      "            fontFamily: DesignTokens.fontFamily,",
      "            fontWeight: DesignTokens.bodyFontWeight,",
      "          ),",
      "        ),",
      "        trailing: Row(",
      "          mainAxisSize: MainAxisSize.min,",
      "          children: [",
      "            IconButton(",
      "              icon: const Icon(Icons.edit, color: DesignTokens.primaryColor),",
      "              onPressed: () async {",
      "                final firestoreService =",
      "                    FirestoreService(); // Or use Provider if that's your pattern",
      "                final user = FirebaseAuth.instance.currentUser;",
      "                final localizations = AppLocalizations.of(context)!;",
      "                if (user == null) return;",
      "                await EditAddressDialog.show(",
      "                  context,",
      "                  initialValue: address,",
      "                  onSave: (updatedAddress) async {",
      "                    final franchiseId =",
      "                        Provider.of<FranchiseProvider>(context, listen: false)",
      "                            .franchiseId;",
      "                    await firestoreService.updateAddressForUser(",
      "                      user.uid,",
      "                      updatedAddress,",
      "                    );",
      "                    if (!context.mounted) return;",
      "                    ScaffoldMessenger.of(context).showSnackBar(",
      "                      SnackBar(",
      "                        content: Text(",
      "                          localizations.addressUpdated ?? 'Address updated',",
      "                          style: const TextStyle(",
      "                            color: DesignTokens.textColor,",
      "                            fontFamily: DesignTokens.fontFamily,",
      "                            fontWeight: DesignTokens.bodyFontWeight,",
      "                          ),",
      "                        ),",
      "                        backgroundColor: DesignTokens.surfaceColor,",
      "                        duration: DesignTokens.toastDuration,",
      "                      ),",
      "                    );",
      "                  },",
      "                );",
      "              },",
      "            ),",
      "            IconButton(",
      "              icon: const Icon(Icons.delete, color: DesignTokens.errorColor),",
      "              onPressed: onDelete,",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 101,
      "file_size": 3960,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\Address\\edit_address_dialog.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/models/address.dart';",
      "import 'package:franchise_admin_portal/widgets/Address/address_form.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "",
      "class EditAddressDialog extends StatefulWidget {",
      "  final Address initialValue;",
      "  final Future<void> Function(Address updatedAddress) onSave;",
      "",
      "  const EditAddressDialog({",
      "    super.key,",
      "    required this.initialValue,",
      "    required this.onSave,",
      "  });",
      "",
      "  static Future<void> show(",
      "    BuildContext context, {",
      "    required Address initialValue,",
      "    required Future<void> Function(Address updatedAddress) onSave,",
      "  }) {",
      "    return showDialog(",
      "      context: context,",
      "      builder: (context) => Dialog(",
      "        insetPadding: const EdgeInsets.symmetric(horizontal: 24, vertical: 24),",
      "        child: EditAddressDialog(",
      "          initialValue: initialValue,",
      "          onSave: onSave,",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  @override",
      "  State<EditAddressDialog> createState() => _EditAddressDialogState();",
      "}",
      "",
      "class _EditAddressDialogState extends State<EditAddressDialog> {",
      "  final GlobalKey<FormState> _formKey = GlobalKey<FormState>();",
      "  late Address _editedAddress;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _editedAddress = widget.initialValue;",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    return Padding(",
      "      padding: const EdgeInsets.all(24.0),",
      "      child: SingleChildScrollView(",
      "        child: Column(",
      "          mainAxisSize: MainAxisSize.min,",
      "          children: [",
      "            Text(",
      "              loc.editAddress,",
      "              style: Theme.of(context).textTheme.titleLarge?.copyWith(",
      "                    color: DesignTokens.primaryColor,",
      "                    fontWeight: FontWeight.bold,",
      "                  ),",
      "            ),",
      "            const SizedBox(height: 20),",
      "            AddressForm(",
      "              formKey: _formKey,",
      "              initialValue: _editedAddress,",
      "              submitLabel: loc.save,",
      "              onSubmit: (updated) async {",
      "                Navigator.of(context).pop(); // Close dialog",
      "                await widget.onSave(updated);",
      "              },",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 86,
      "file_size": 2634,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\admin\\admin_bottom_nav_bar.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/core/models/dashboard_section.dart';",
      "",
      "class AdminBottomNavBar extends StatelessWidget {",
      "  final List<DashboardSection> sections;",
      "  final int selectedIndex;",
      "  final void Function(int index) onTap;",
      "",
      "  const AdminBottomNavBar({",
      "    Key? key,",
      "    required this.sections,",
      "    required this.selectedIndex,",
      "    required this.onTap,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return BottomNavigationBar(",
      "      type: BottomNavigationBarType.fixed,",
      "      currentIndex: selectedIndex,",
      "      onTap: onTap,",
      "      selectedItemColor: Theme.of(context).colorScheme.primary,",
      "      unselectedItemColor: Theme.of(context).iconTheme.color?.withOpacity(0.6),",
      "      showUnselectedLabels: true,",
      "      items: sections.map((section) {",
      "        return BottomNavigationBarItem(",
      "          icon: Icon(section.icon),",
      "          label: section.title,",
      "        );",
      "      }).toList(),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 33,
      "file_size": 1010,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\admin\\admin_bulk_selection_toolbar.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "",
      "class AdminBulkSelectionToolbar extends StatelessWidget {",
      "  final int selectedCount;",
      "  final VoidCallback onDelete;",
      "  final VoidCallback onClearSelection;",
      "  final String deleteLabel;",
      "  final String clearSelectionTooltip;",
      "  final String selectedLabel;",
      "",
      "  const AdminBulkSelectionToolbar({",
      "    Key? key,",
      "    required this.selectedCount,",
      "    required this.onDelete,",
      "    required this.onClearSelection,",
      "    required this.deleteLabel,",
      "    required this.clearSelectionTooltip,",
      "    required this.selectedLabel,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Padding(",
      "      padding: const EdgeInsets.all(8.0),",
      "      child: Row(",
      "        children: [",
      "          Text(",
      "            selectedLabel,",
      "            style: const TextStyle(fontWeight: FontWeight.bold),",
      "          ),",
      "          const SizedBox(width: 8),",
      "          ElevatedButton.icon(",
      "            icon: const Icon(Icons.delete),",
      "            label: Text(deleteLabel),",
      "            onPressed: onDelete,",
      "          ),",
      "          const Spacer(),",
      "          IconButton(",
      "            icon: const Icon(Icons.clear),",
      "            tooltip: clearSelectionTooltip,",
      "            onPressed: onClearSelection,",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 47,
      "file_size": 1306,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\admin\\admin_delete_confirm_dialog.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "",
      "class AdminDeleteConfirmDialog extends StatelessWidget {",
      "  /// Number of items to delete, for localization prompt.",
      "  final int itemCount;",
      "",
      "  /// Optionally override title/content if needed.",
      "  final String? titleOverride;",
      "  final String? contentOverride;",
      "",
      "  const AdminDeleteConfirmDialog({",
      "    Key? key,",
      "    required this.itemCount,",
      "    this.titleOverride,",
      "    this.contentOverride,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    return AlertDialog(",
      "      title: Text(titleOverride ?? loc.deleteItemsTitle),",
      "      content: Text(",
      "        contentOverride ?? loc.deleteItemsPrompt(itemCount),",
      "      ),",
      "      actions: [",
      "        TextButton(",
      "          onPressed: () => Navigator.of(context).pop(false),",
      "          child: Text(loc.cancel),",
      "        ),",
      "        ElevatedButton(",
      "          onPressed: () => Navigator.of(context).pop(true),",
      "          child: Text(loc.delete),",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 46,
      "file_size": 1354,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\admin\\admin_empty_state_widget.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/config/branding_config.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "",
      "class AdminEmptyStateWidget extends StatelessWidget {",
      "  final String title;",
      "  final String message;",
      "  final String? imageAsset;",
      "  final String? actionLabel;",
      "  final VoidCallback? onAction;",
      "  final IconData? icon;",
      "",
      "  const AdminEmptyStateWidget({",
      "    super.key,",
      "    required this.title,",
      "    required this.message,",
      "    this.imageAsset,",
      "    this.actionLabel,",
      "    this.onAction,",
      "    this.icon,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    return Center(",
      "      child: Padding(",
      "        padding: const EdgeInsets.symmetric(vertical: 44, horizontal: 24),",
      "        child: Column(",
      "          mainAxisAlignment: MainAxisAlignment.center,",
      "          children: [",
      "            if (imageAsset != null && imageAsset!.isNotEmpty)",
      "              Image.asset(",
      "                imageAsset!,",
      "                width: 140,",
      "                fit: BoxFit.contain,",
      "              )",
      "            else if (icon != null)",
      "              Icon(icon, size: 72, color: colorScheme.secondary),",
      "            const SizedBox(height: 24),",
      "            Text(",
      "              title,",
      "              style: Theme.of(context).textTheme.titleLarge?.copyWith(",
      "                    color: colorScheme.onSurface,",
      "                    fontWeight: FontWeight.bold,",
      "                  ),",
      "              textAlign: TextAlign.center,",
      "            ),",
      "            const SizedBox(height: 8),",
      "            Text(",
      "              message,",
      "              style: Theme.of(context).textTheme.bodyMedium?.copyWith(",
      "                    color: colorScheme.onSurfaceVariant,",
      "                  ),",
      "              textAlign: TextAlign.center,",
      "            ),",
      "            if (actionLabel != null && onAction != null)",
      "              Padding(",
      "                padding: const EdgeInsets.only(top: 32),",
      "                child: ElevatedButton.icon(",
      "                  icon: const Icon(Icons.arrow_forward),",
      "                  label: Text(actionLabel!),",
      "                  style: ElevatedButton.styleFrom(",
      "                    backgroundColor: colorScheme.primary,",
      "                    foregroundColor: colorScheme.onPrimary,",
      "                    elevation: 1,",
      "                    shape: RoundedRectangleBorder(",
      "                      borderRadius:",
      "                          BorderRadius.circular(DesignTokens.adminButtonRadius),",
      "                    ),",
      "                  ),",
      "                  onPressed: onAction,",
      "                ),",
      "              ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 80,
      "file_size": 2710,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\admin\\admin_menu_editor_popup_menu.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "",
      "class AdminMenuEditorPopupMenu extends StatelessWidget {",
      "  final bool showDeleted;",
      "  final bool canDeleteOrExport;",
      "  final VoidCallback onShowColumns;",
      "  final VoidCallback onBulkUpload;",
      "  final VoidCallback onToggleShowDeleted;",
      "  final VoidCallback onExportCSV;",
      "  final String columnsLabel;",
      "  final String importCSVLabel;",
      "  final String showDeletedLabel;",
      "  final String exportCSVLabel;",
      "",
      "  const AdminMenuEditorPopupMenu({",
      "    Key? key,",
      "    required this.showDeleted,",
      "    required this.canDeleteOrExport,",
      "    required this.onShowColumns,",
      "    required this.onBulkUpload,",
      "    required this.onToggleShowDeleted,",
      "    required this.onExportCSV,",
      "    required this.columnsLabel,",
      "    required this.importCSVLabel,",
      "    required this.showDeletedLabel,",
      "    required this.exportCSVLabel,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return PopupMenuButton<int>(",
      "      constraints: const BoxConstraints(",
      "        minWidth: 0,",
      "        maxWidth: 180,",
      "      ),",
      "      icon: const Icon(Icons.more_vert),",
      "      onSelected: (value) async {",
      "        if (value == 0) {",
      "          onShowColumns();",
      "        } else if (value == 1) {",
      "          onBulkUpload();",
      "        } else if (value == 2) {",
      "          onToggleShowDeleted();",
      "        } else if (value == 3) {",
      "          if (!canDeleteOrExport) return;",
      "          onExportCSV();",
      "        }",
      "      },",
      "      itemBuilder: (context) => [",
      "        PopupMenuItem<int>(",
      "          value: 0,",
      "          child: Padding(",
      "            padding:",
      "                const EdgeInsets.symmetric(horizontal: 14.0, vertical: 4.0),",
      "            child: Row(",
      "              mainAxisSize: MainAxisSize.min,",
      "              children: [",
      "                const Icon(Icons.view_column, size: 18),",
      "                const SizedBox(width: 8),",
      "                Text(",
      "                  columnsLabel,",
      "                  style: const TextStyle(",
      "                    fontWeight: FontWeight.bold,",
      "                    color: Colors.black87,",
      "                    fontSize: 16,",
      "                  ),",
      "                ),",
      "              ],",
      "            ),",
      "          ),",
      "        ),",
      "        PopupMenuItem<int>(",
      "          value: 1,",
      "          enabled: canDeleteOrExport,",
      "          child: Padding(",
      "            padding:",
      "                const EdgeInsets.symmetric(horizontal: 14.0, vertical: 4.0),",
      "            child: Row(",
      "              mainAxisSize: MainAxisSize.min,",
      "              children: [",
      "                const Icon(Icons.upload_file, size: 18),",
      "                const SizedBox(width: 8),",
      "                Text(",
      "                  importCSVLabel,",
      "                  style: const TextStyle(",
      "                    fontWeight: FontWeight.bold,",
      "                    color: Colors.black87,",
      "                    fontSize: 16,",
      "                  ),",
      "                ),",
      "              ],",
      "            ),",
      "          ),",
      "        ),",
      "        PopupMenuItem<int>(",
      "          value: 2,",
      "          child: Padding(",
      "            padding:",
      "                const EdgeInsets.symmetric(horizontal: 14.0, vertical: 4.0),",
      "            child: Row(",
      "              mainAxisSize: MainAxisSize.min,",
      "              children: [",
      "                Icon(Icons.delete_outline,",
      "                    size: 18,",
      "                    color: showDeleted",
      "                        ? Theme.of(context).colorScheme.primary",
      "                        : Colors.black54),",
      "                const SizedBox(width: 8),",
      "                Text(",
      "                  showDeletedLabel,",
      "                  style: TextStyle(",
      "                    fontWeight: FontWeight.bold,",
      "                    color: showDeleted",
      "                        ? Theme.of(context).colorScheme.primary",
      "                        : Colors.black87,",
      "                    fontSize: 16,",
      "                  ),",
      "                ),",
      "              ],",
      "            ),",
      "          ),",
      "        ),",
      "        PopupMenuItem<int>(",
      "          value: 3,",
      "          enabled: canDeleteOrExport,",
      "          child: Padding(",
      "            padding:",
      "                const EdgeInsets.symmetric(horizontal: 14.0, vertical: 4.0),",
      "            child: Row(",
      "              mainAxisSize: MainAxisSize.min,",
      "              children: [",
      "                const Icon(Icons.download, size: 18),",
      "                const SizedBox(width: 8),",
      "                Text(",
      "                  exportCSVLabel,",
      "                  style: const TextStyle(",
      "                    fontWeight: FontWeight.bold,",
      "                    color: Colors.black87,",
      "                    fontSize: 16,",
      "                  ),",
      "                ),",
      "              ],",
      "            ),",
      "          ),",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 149,
      "file_size": 4675,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\admin\\admin_menu_item_actions_row.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "",
      "class AdminMenuItemActionsRow extends StatelessWidget {",
      "  final bool canEdit;",
      "  final bool canDeleteOrExport;",
      "  final VoidCallback onEdit;",
      "  final VoidCallback onCustomize;",
      "  final VoidCallback onDelete;",
      "",
      "  const AdminMenuItemActionsRow({",
      "    Key? key,",
      "    required this.canEdit,",
      "    required this.canDeleteOrExport,",
      "    required this.onEdit,",
      "    required this.onCustomize,",
      "    required this.onDelete,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Row(",
      "      mainAxisSize: MainAxisSize.min,",
      "      children: [",
      "        IconButton(",
      "          icon: const Icon(Icons.edit),",
      "          tooltip: 'Edit',",
      "          onPressed: canEdit ? onEdit : null,",
      "        ),",
      "        IconButton(",
      "          icon: const Icon(Icons.list_alt),",
      "          tooltip: 'Customize',",
      "          onPressed: canEdit ? onCustomize : null,",
      "        ),",
      "        IconButton(",
      "          icon: const Icon(Icons.delete, color: Colors.red),",
      "          tooltip: 'Delete',",
      "          onPressed: canDeleteOrExport ? onDelete : null,",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 42,
      "file_size": 1136,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\admin\\admin_menu_item_row.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/widgets/admin/admin_menu_item_actions_row.dart';",
      "import 'package:franchise_admin_portal/core/models/menu_item.dart';",
      "import 'package:franchise_admin_portal/core/models/category.dart';",
      "import 'package:franchise_admin_portal/core/models/user.dart' as admin_user;",
      "import 'package:franchise_admin_portal/config/branding_config.dart';",
      "import 'package:franchise_admin_portal/widgets/network_image_widget.dart';",
      "import 'package:franchise_admin_portal/widgets/dietary_allergen_chips_row.dart';",
      "import 'package:franchise_admin_portal/widgets/status_chip.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "",
      "class AdminMenuItemRow extends StatelessWidget {",
      "  final MenuItem item;",
      "  final bool isSelected;",
      "  final List<Category> categories;",
      "  final admin_user.User user;",
      "  final bool canEdit;",
      "  final bool canDeleteOrExport;",
      "  final VoidCallback onSelect;",
      "  final VoidCallback onEdit;",
      "  final VoidCallback onCustomize;",
      "  final VoidCallback onDelete;",
      "  final List<String> visibleColumns;",
      "",
      "  const AdminMenuItemRow({",
      "    Key? key,",
      "    required this.item,",
      "    required this.isSelected,",
      "    required this.categories,",
      "    required this.user,",
      "    required this.canEdit,",
      "    required this.canDeleteOrExport,",
      "    required this.onSelect,",
      "    required this.onEdit,",
      "    required this.onCustomize,",
      "    required this.onDelete,",
      "    required this.visibleColumns,",
      "  }) : super(key: key);",
      "",
      "  Widget _buildCellMobile(String key, MenuItem item, String categoryName) {",
      "    switch (key) {",
      "      case 'image':",
      "        return Padding(",
      "          padding: const EdgeInsets.only(right: 8),",
      "          child: SizedBox(",
      "            width: 48,",
      "            height: 48,",
      "            child: NetworkImageWidget(",
      "              imageUrl: item.image,",
      "              fallbackAsset: BrandingConfig.defaultPizzaIcon,",
      "              width: 48,",
      "              height: 48,",
      "              borderRadius: BorderRadius.circular(8),",
      "            ),",
      "          ),",
      "        );",
      "      case 'available':",
      "        return Padding(",
      "          padding: const EdgeInsets.only(right: 8),",
      "          child: Container(",
      "            width: 10,",
      "            height: 10,",
      "            margin: const EdgeInsets.only(top: 4),",
      "            decoration: BoxDecoration(",
      "              color: item.availability ? Colors.green : Colors.red,",
      "              shape: BoxShape.circle,",
      "            ),",
      "          ),",
      "        );",
      "      case 'name':",
      "        return Expanded(",
      "          child: Padding(",
      "            padding: const EdgeInsets.only(right: 8),",
      "            child: Text(",
      "              item.name,",
      "              style: const TextStyle(fontWeight: FontWeight.bold),",
      "              overflow: TextOverflow.ellipsis,",
      "            ),",
      "          ),",
      "        );",
      "      case 'category':",
      "        return Padding(",
      "          padding: const EdgeInsets.only(right: 8),",
      "          child: SizedBox(",
      "            width: 90,",
      "            child: Text(",
      "              categoryName,",
      "              overflow: TextOverflow.ellipsis,",
      "              style: const TextStyle(fontSize: 14, color: Colors.black87),",
      "            ),",
      "          ),",
      "        );",
      "      case 'price':",
      "        return Padding(",
      "          padding: const EdgeInsets.only(right: 8),",
      "          child: Text(",
      "            '\\$${item.price.toStringAsFixed(2)}',",
      "            style: const TextStyle(fontWeight: FontWeight.w600),",
      "          ),",
      "        );",
      "      case 'sku':",
      "        return Padding(",
      "          padding: const EdgeInsets.only(right: 8),",
      "          child: SizedBox(",
      "            width: 90,",
      "            child: Text(",
      "              item.sku ?? '',",
      "              overflow: TextOverflow.ellipsis,",
      "              style: const TextStyle(fontSize: 14, color: Colors.black87),",
      "            ),",
      "          ),",
      "        );",
      "      case 'dietary':",
      "        return Padding(",
      "          padding: const EdgeInsets.only(right: 8),",
      "          child: SizedBox(",
      "            width: 180,",
      "            child: DietaryAllergenChipsRow(",
      "              dietaryTags: item.dietaryTags,",
      "              allergens: item.allergens,",
      "            ),",
      "          ),",
      "        );",
      "      default:",
      "        return const SizedBox.shrink();",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final bool isMobile = MediaQuery.of(context).size.width < 600;",
      "    final categoryName = item.category;",
      "",
      "    if (isMobile) {",
      "      return Card(",
      "        color: isSelected ? Colors.grey.shade400 : DesignTokens.surfaceColor,",
      "        child: InkWell(",
      "          onTap: onSelect,",
      "          child: Padding(",
      "            padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),",
      "            child: Row(",
      "              children: [",
      "                for (final col in visibleColumns)",
      "                  _buildCellMobile(col, item, categoryName),",
      "                const SizedBox(width: 8),",
      "                PopupMenuButton<String>(",
      "                  icon: const Icon(Icons.more_vert),",
      "                  itemBuilder: (context) => [",
      "                    if (canEdit)",
      "                      PopupMenuItem(",
      "                        value: 'edit',",
      "                        child: Row(",
      "                          children: const [",
      "                            Icon(Icons.edit, size: 18),",
      "                            SizedBox(width: 8),",
      "                            Text('Edit'),",
      "                          ],",
      "                        ),",
      "                      ),",
      "                    if (canEdit)",
      "                      PopupMenuItem(",
      "                        value: 'customize',",
      "                        child: Row(",
      "                          children: const [",
      "                            Icon(Icons.tune, size: 18),",
      "                            SizedBox(width: 8),",
      "                            Text('Customize'),",
      "                          ],",
      "                        ),",
      "                      ),",
      "                    if (canDeleteOrExport)",
      "                      PopupMenuItem(",
      "                        value: 'delete',",
      "                        child: Row(",
      "                          children: const [",
      "                            Icon(Icons.delete,",
      "                                size: 18, color: Colors.redAccent),",
      "                            SizedBox(width: 8),",
      "                            Text('Delete',",
      "                                style: TextStyle(color: Colors.redAccent)),",
      "                          ],",
      "                        ),",
      "                      ),",
      "                  ],",
      "                  onSelected: (value) {",
      "                    switch (value) {",
      "                      case 'edit':",
      "                        onEdit();",
      "                        break;",
      "                      case 'customize':",
      "                        onCustomize();",
      "                        break;",
      "                      case 'delete':",
      "                        onDelete();",
      "                        break;",
      "                    }",
      "                  },",
      "                ),",
      "              ],",
      "            ),",
      "          ),",
      "        ),",
      "      );",
      "    } else {",
      "      Widget _buildCell(String key) {",
      "        switch (key) {",
      "          case 'image':",
      "            return SizedBox(",
      "              width: 60,",
      "              height: 48,",
      "              child: NetworkImageWidget(",
      "                imageUrl: item.image,",
      "                fallbackAsset: BrandingConfig.defaultPizzaIcon,",
      "                width: 48,",
      "                height: 48,",
      "                borderRadius: BorderRadius.circular(8),",
      "              ),",
      "            );",
      "          case 'name':",
      "            return SizedBox(",
      "              width: 120,",
      "              child: Text(item.name, overflow: TextOverflow.ellipsis),",
      "            );",
      "          case 'category':",
      "            return SizedBox(",
      "              width: 90,",
      "              child: Text(categoryName, overflow: TextOverflow.ellipsis),",
      "            );",
      "          case 'price':",
      "            return SizedBox(",
      "              width: 60,",
      "              child: Text('\\$${item.price.toStringAsFixed(2)}'),",
      "            );",
      "          case 'available':",
      "            return SizedBox(",
      "              width: 90,",
      "              child: Row(",
      "                children: [",
      "                  Container(",
      "                    width: 12,",
      "                    height: 12,",
      "                    decoration: BoxDecoration(",
      "                      color: item.availability ? Colors.green : Colors.red,",
      "                      shape: BoxShape.circle,",
      "                    ),",
      "                  ),",
      "                  const SizedBox(width: 6),",
      "                  Text(",
      "                    item.availability ? \"Available\" : \"Unavailable\",",
      "                    style: TextStyle(",
      "                      color: item.availability ? Colors.green : Colors.red,",
      "                      fontWeight: FontWeight.w500,",
      "                      fontSize: 14,",
      "                    ),",
      "                  ),",
      "                ],",
      "              ),",
      "            );",
      "          case 'sku':",
      "            return SizedBox(",
      "              width: 90,",
      "              child: Text(item.sku ?? '', overflow: TextOverflow.ellipsis),",
      "            );",
      "          case 'dietary':",
      "            return SizedBox(",
      "              width: 180,",
      "              child: DietaryAllergenChipsRow(",
      "                dietaryTags: item.dietaryTags,",
      "                allergens: item.allergens,",
      "              ),",
      "            );",
      "          default:",
      "            return const SizedBox.shrink();",
      "        }",
      "      }",
      "",
      "      return Card(",
      "        color: isSelected ? Colors.grey.shade400 : DesignTokens.surfaceColor,",
      "        child: InkWell(",
      "          onTap: onSelect,",
      "          child: Padding(",
      "            padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),",
      "            child: SingleChildScrollView(",
      "              scrollDirection: Axis.horizontal,",
      "              child: Row(",
      "                children: [",
      "                  ...visibleColumns.map(_buildCell).toList(),",
      "                  const SizedBox(width: 8),",
      "                  PopupMenuButton<String>(",
      "                    icon: const Icon(Icons.more_vert),",
      "                    itemBuilder: (context) => [",
      "                      if (canEdit)",
      "                        PopupMenuItem(",
      "                          value: 'edit',",
      "                          child: Row(",
      "                            children: const [",
      "                              Icon(Icons.edit, size: 18),",
      "                              SizedBox(width: 8),",
      "                              Text('Edit'),",
      "                            ],",
      "                          ),",
      "                        ),",
      "                      if (canEdit)",
      "                        PopupMenuItem(",
      "                          value: 'customize',",
      "                          child: Row(",
      "                            children: const [",
      "                              Icon(Icons.tune, size: 18),",
      "                              SizedBox(width: 8),",
      "                              Text('Customize'),",
      "                            ],",
      "                          ),",
      "                        ),",
      "                      if (canDeleteOrExport)",
      "                        PopupMenuItem(",
      "                          value: 'delete',",
      "                          child: Row(",
      "                            children: const [",
      "                              Icon(Icons.delete,",
      "                                  size: 18, color: Colors.redAccent),",
      "                              SizedBox(width: 8),",
      "                              Text('Delete',",
      "                                  style: TextStyle(color: Colors.redAccent)),",
      "                            ],",
      "                          ),",
      "                        ),",
      "                    ],",
      "                    onSelected: (value) {",
      "                      switch (value) {",
      "                        case 'edit':",
      "                          onEdit();",
      "                          break;",
      "                        case 'customize':",
      "                          onCustomize();",
      "                          break;",
      "                        case 'delete':",
      "                          onDelete();",
      "                          break;",
      "                      }",
      "                    },",
      "                  )",
      "                ],",
      "              ),",
      "            ),",
      "          ),",
      "        ),",
      "      );",
      "    }",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 350,
      "file_size": 12229,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\admin\\admin_search_bar.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "",
      "typedef AdminSearchCallback = void Function(String query);",
      "",
      "class AdminSearchBar extends StatelessWidget {",
      "  final String? hintText;",
      "  final TextEditingController controller;",
      "  final AdminSearchCallback? onChanged;",
      "  final AdminSearchCallback? onSubmitted;",
      "  final VoidCallback? onClear;",
      "",
      "  const AdminSearchBar({",
      "    super.key,",
      "    this.hintText,",
      "    required this.controller,",
      "    this.onChanged,",
      "    this.onSubmitted,",
      "    this.onClear,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    return Padding(",
      "      padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 6),",
      "      child: TextField(",
      "        controller: controller,",
      "        decoration: InputDecoration(",
      "          hintText: hintText ?? loc.adminSearchHint,",
      "          prefixIcon: const Icon(Icons.search),",
      "          suffixIcon: controller.text.isEmpty",
      "              ? null",
      "              : IconButton(",
      "                  icon: const Icon(Icons.clear),",
      "                  onPressed: () {",
      "                    controller.clear();",
      "                    if (onChanged != null) onChanged!('');",
      "                    if (onClear != null) onClear!();",
      "                  },",
      "                  tooltip: loc.clear,",
      "                ),",
      "          border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),",
      "          isDense: true,",
      "        ),",
      "        onChanged: (val) => onChanged?.call(val),",
      "        onSubmitted: onSubmitted,",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 58,
      "file_size": 1851,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\admin\\admin_sidebar.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/core/models/dashboard_section.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "",
      "class AdminSidebar extends StatelessWidget {",
      "  final List<DashboardSection> sections;",
      "  final int selectedIndex;",
      "  final void Function(int index) onSelect;",
      "  final List<Widget>? extraWidgets;",
      "",
      "  const AdminSidebar({",
      "    Key? key,",
      "    required this.sections,",
      "    required this.selectedIndex,",
      "    required this.onSelect,",
      "    this.extraWidgets,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "",
      "    return Container(",
      "      decoration: BoxDecoration(",
      "        border: Border(",
      "          right: BorderSide(color: theme.dividerColor.withOpacity(0.1)),",
      "        ),",
      "        color: colorScheme.surface,",
      "      ),",
      "      child: ListView(",
      "        padding: EdgeInsets.zero,",
      "        children: [",
      "          ...List.generate(sections.length, (index) {",
      "            final section = sections[index];",
      "            final isSelected = selectedIndex == index;",
      "",
      "            return Material(",
      "              color: isSelected",
      "                  ? colorScheme.primary.withOpacity(0.08)",
      "                  : Colors.transparent,",
      "              child: ListTile(",
      "                leading: Icon(",
      "                  section.icon,",
      "                  color:",
      "                      isSelected ? colorScheme.primary : theme.iconTheme.color,",
      "                ),",
      "                title: Text(",
      "                  section.title,",
      "                  style: theme.textTheme.bodyLarge?.copyWith(",
      "                    fontWeight: isSelected ? FontWeight.w600 : FontWeight.w400,",
      "                    color: isSelected",
      "                        ? colorScheme.primary",
      "                        : theme.textTheme.bodyLarge?.color,",
      "                  ),",
      "                ),",
      "                onTap: () => onSelect(index),",
      "                selected: isSelected,",
      "                selectedTileColor: colorScheme.primary.withOpacity(0.1),",
      "              ),",
      "            );",
      "          }),",
      "          if (extraWidgets != null && extraWidgets!.isNotEmpty) ...[",
      "            const Divider(height: 24, thickness: 1),",
      "            ...extraWidgets!,",
      "          ],",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 71,
      "file_size": 2360,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\admin\\admin_sortable_grid.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "",
      "typedef AdminGridSortCallback = void Function(String sortKey, bool ascending);",
      "",
      "class AdminSortableGrid<T> extends StatefulWidget {",
      "  final List<T> items;",
      "  final List<String> columns;",
      "  final List<String> sortKeys;",
      "  final List<String> columnKeys;",
      "  final Widget Function(BuildContext, T) itemBuilder;",
      "  final String? sortKey;",
      "  final bool ascending;",
      "  final AdminGridSortCallback? onSort;",
      "",
      "  const AdminSortableGrid({",
      "    super.key,",
      "    required this.items,",
      "    required this.columns,",
      "    required this.sortKeys,",
      "    required this.columnKeys,",
      "    required this.itemBuilder,",
      "    this.sortKey,",
      "    this.ascending = true,",
      "    this.onSort,",
      "  });",
      "",
      "  @override",
      "  State<AdminSortableGrid<T>> createState() => _AdminSortableGridState<T>();",
      "}",
      "",
      "class _AdminSortableGridState<T> extends State<AdminSortableGrid<T>> {",
      "  late String? _sortKey;",
      "  late bool _ascending;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _sortKey = widget.sortKey ??",
      "        (widget.sortKeys.isNotEmpty ? widget.sortKeys.first : null);",
      "    _ascending = widget.ascending;",
      "  }",
      "",
      "  void _handleSort(String key) {",
      "    setState(() {",
      "      if (_sortKey == key) {",
      "        _ascending = !_ascending;",
      "      } else {",
      "        _sortKey = key;",
      "        _ascending = true;",
      "      }",
      "    });",
      "    if (widget.onSort != null && _sortKey != null) {",
      "      widget.onSort!(_sortKey!, _ascending);",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final bool isMobile = MediaQuery.of(context).size.width < 600;",
      "",
      "    if (isMobile) {",
      "      // Mobile: List-based, columns stack vertically.",
      "      return Column(",
      "        children: [",
      "          Row(",
      "            children: List.generate(widget.columns.length, (idx) {",
      "              final colKey = widget.columnKeys[idx];",
      "              final isActive = widget.sortKeys[idx] == _sortKey;",
      "              return Expanded(",
      "                child: InkWell(",
      "                  onTap: widget.sortKeys[idx].isNotEmpty",
      "                      ? () => _handleSort(widget.sortKeys[idx])",
      "                      : null,",
      "                  child: Row(",
      "                    mainAxisAlignment: MainAxisAlignment.center,",
      "                    children: [",
      "                      Text(",
      "                        widget.columns[idx],",
      "                        style: TextStyle(",
      "                          fontWeight:",
      "                              isActive ? FontWeight.bold : FontWeight.normal,",
      "                          color: isActive",
      "                              ? Theme.of(context).primaryColor",
      "                              : Colors.black87,",
      "                        ),",
      "                      ),",
      "                      if (isActive)",
      "                        Icon(",
      "                          _ascending",
      "                              ? Icons.arrow_upward",
      "                              : Icons.arrow_downward,",
      "                          size: 16,",
      "                        ),",
      "                    ],",
      "                  ),",
      "                ),",
      "              );",
      "            }),",
      "          ),",
      "          const Divider(height: 1),",
      "          Expanded(",
      "            child: widget.items.isEmpty",
      "                ? Center(",
      "                    child: Text(",
      "                      \"No items found.\",",
      "                      style: TextStyle(color: Colors.grey),",
      "                    ),",
      "                  )",
      "                : ListView.builder(",
      "                    itemCount: widget.items.length,",
      "                    itemBuilder: (ctx, idx) =>",
      "                        widget.itemBuilder(ctx, widget.items[idx]),",
      "                  ),",
      "          ),",
      "        ],",
      "      );",
      "    } else {",
      "      // Tablet/Desktop: grid row/column, no overflow, always readable.",
      "      // By default, all columns except the last are Expanded; last is for actions and can be SizedBox.",
      "      return Column(",
      "        children: [",
      "          Padding(",
      "            padding: const EdgeInsets.symmetric(vertical: 8.0),",
      "            child: Row(",
      "              children: [",
      "                for (int idx = 0; idx < widget.columns.length; idx++)",
      "                  if (idx == widget.columns.length - 1)",
      "                    SizedBox(",
      "                      width: 100,",
      "                      child: Center(",
      "                        child: Text(widget.columns[idx],",
      "                            style:",
      "                                const TextStyle(fontWeight: FontWeight.bold)),",
      "                      ),",
      "                    )",
      "                  else",
      "                    Expanded(",
      "                      flex: 3,",
      "                      child: InkWell(",
      "                        onTap: widget.sortKeys[idx].isNotEmpty",
      "                            ? () => _handleSort(widget.sortKeys[idx])",
      "                            : null,",
      "                        child: Row(",
      "                          mainAxisAlignment: MainAxisAlignment.center,",
      "                          children: [",
      "                            Text(",
      "                              widget.columns[idx],",
      "                              style: TextStyle(",
      "                                fontWeight: widget.sortKeys[idx] == _sortKey",
      "                                    ? FontWeight.bold",
      "                                    : FontWeight.normal,",
      "                                color: widget.sortKeys[idx] == _sortKey",
      "                                    ? Theme.of(context).primaryColor",
      "                                    : Colors.black87,",
      "                              ),",
      "                            ),",
      "                            if (widget.sortKeys[idx] == _sortKey)",
      "                              Icon(",
      "                                _ascending",
      "                                    ? Icons.arrow_upward",
      "                                    : Icons.arrow_downward,",
      "                                size: 16,",
      "                              ),",
      "                          ],",
      "                        ),",
      "                      ),",
      "                    ),",
      "              ],",
      "            ),",
      "          ),",
      "          const Divider(height: 1),",
      "          Expanded(",
      "            child: widget.items.isEmpty",
      "                ? Center(",
      "                    child: Text(",
      "                      \"No items found.\",",
      "                      style: TextStyle(color: Colors.grey),",
      "                    ),",
      "                  )",
      "                : ListView.builder(",
      "                    itemCount: widget.items.length,",
      "                    itemBuilder: (ctx, idx) =>",
      "                        widget.itemBuilder(ctx, widget.items[idx]),",
      "                  ),",
      "          ),",
      "        ],",
      "      );",
      "    }",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 190,
      "file_size": 6618,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\admin\\admin_unauthorized_dialog.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "",
      "class AdminUnauthorizedDialog extends StatelessWidget {",
      "  const AdminUnauthorizedDialog({Key? key}) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    return AlertDialog(",
      "      title: Text(loc.unauthorizedTitle),",
      "      content: Text(loc.unauthorizedDialogMessage),",
      "      actions: [",
      "        TextButton(",
      "          onPressed: () => Navigator.of(context).pop(),",
      "          child: Text(loc.ok),",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 28,
      "file_size": 854,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\admin\\admin_unauthorized_widget.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "",
      "class AdminUnauthorizedWidget extends StatelessWidget {",
      "  final String? title;",
      "  final String? message;",
      "  final String? buttonText;",
      "  final VoidCallback? onReturnHome;",
      "",
      "  const AdminUnauthorizedWidget({",
      "    Key? key,",
      "    this.title,",
      "    this.message,",
      "    this.buttonText,",
      "    this.onReturnHome,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Scaffold(",
      "      appBar: AppBar(",
      "        title: Text(title ?? \"Menu Editor\"),",
      "      ),",
      "      body: Center(",
      "        child: Column(",
      "          mainAxisAlignment: MainAxisAlignment.center,",
      "          children: [",
      "            const Icon(Icons.lock_outline, size: 54, color: Colors.redAccent),",
      "            const SizedBox(height: 16),",
      "            Text(",
      "              message ??",
      "                  \"Unauthorized — You do not have permission to access this page.\",",
      "              style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 18),",
      "              textAlign: TextAlign.center,",
      "            ),",
      "            const SizedBox(height: 18),",
      "            ElevatedButton.icon(",
      "              icon: const Icon(Icons.home),",
      "              label: Text(buttonText ?? \"Return to Home\"),",
      "              onPressed: onReturnHome ??",
      "                  () {",
      "                    Navigator.of(context).popUntil((route) => route.isFirst);",
      "                  },",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 49,
      "file_size": 1465,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\admin\\chart_widgets.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:fl_chart/fl_chart.dart';",
      "",
      "/// Modular bar chart widget for admin analytics.",
      "class BarChartWidget extends StatelessWidget {",
      "  final List<BarChartGroupData> barGroups;",
      "  final List<String> xLabels;",
      "  final String? title;",
      "  final double maxY;",
      "",
      "  const BarChartWidget({",
      "    Key? key,",
      "    required this.barGroups,",
      "    required this.xLabels,",
      "    this.title,",
      "    required this.maxY,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Card(",
      "      margin: const EdgeInsets.symmetric(vertical: 12),",
      "      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),",
      "      child: Padding(",
      "        padding: const EdgeInsets.all(16),",
      "        child: Column(",
      "          children: [",
      "            if (title != null)",
      "              Padding(",
      "                padding: const EdgeInsets.only(bottom: 8),",
      "                child:",
      "                    Text(title!, style: Theme.of(context).textTheme.titleLarge),",
      "              ),",
      "            SizedBox(",
      "              height: 220,",
      "              child: BarChart(",
      "                BarChartData(",
      "                  maxY: maxY,",
      "                  borderData: FlBorderData(show: false),",
      "                  titlesData: FlTitlesData(",
      "                    bottomTitles: AxisTitles(",
      "                      sideTitles: SideTitles(",
      "                        showTitles: true,",
      "                        getTitlesWidget: (double value, _) {",
      "                          final idx = value.toInt();",
      "                          return Text(idx < xLabels.length ? xLabels[idx] : '');",
      "                        },",
      "                      ),",
      "                    ),",
      "                    leftTitles: AxisTitles(",
      "                      sideTitles: SideTitles(showTitles: true),",
      "                    ),",
      "                  ),",
      "                  barGroups: barGroups,",
      "                ),",
      "              ),",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "/// Modular line chart widget for admin analytics.",
      "class LineChartWidget extends StatelessWidget {",
      "  final List<FlSpot> spots;",
      "  final List<String> xLabels;",
      "  final String? title;",
      "  final double maxY;",
      "",
      "  const LineChartWidget({",
      "    Key? key,",
      "    required this.spots,",
      "    required this.xLabels,",
      "    this.title,",
      "    required this.maxY,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Card(",
      "      margin: const EdgeInsets.symmetric(vertical: 12),",
      "      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),",
      "      child: Padding(",
      "        padding: const EdgeInsets.all(16),",
      "        child: Column(",
      "          children: [",
      "            if (title != null)",
      "              Padding(",
      "                padding: const EdgeInsets.only(bottom: 8),",
      "                child:",
      "                    Text(title!, style: Theme.of(context).textTheme.titleLarge),",
      "              ),",
      "            SizedBox(",
      "              height: 220,",
      "              child: LineChart(",
      "                LineChartData(",
      "                  maxY: maxY,",
      "                  borderData: FlBorderData(show: false),",
      "                  titlesData: FlTitlesData(",
      "                    bottomTitles: AxisTitles(",
      "                      sideTitles: SideTitles(",
      "                        showTitles: true,",
      "                        getTitlesWidget: (double value, _) {",
      "                          final idx = value.toInt();",
      "                          return Text(idx < xLabels.length ? xLabels[idx] : '');",
      "                        },",
      "                      ),",
      "                    ),",
      "                    leftTitles: AxisTitles(",
      "                      sideTitles: SideTitles(showTitles: true),",
      "                    ),",
      "                  ),",
      "                  lineBarsData: [",
      "                    LineChartBarData(",
      "                      spots: spots,",
      "                      isCurved: true,",
      "                      barWidth: 3,",
      "                      color: Theme.of(context).primaryColor,",
      "                      dotData: FlDotData(show: false),",
      "                    ),",
      "                  ],",
      "                ),",
      "              ),",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 132,
      "file_size": 4212,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\admin\\franchise_selector.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/core/models/franchise_info.dart';",
      "",
      "class FranchiseSelector extends StatelessWidget {",
      "  final List<FranchiseInfo> items;",
      "  final String? selectedFranchiseId;",
      "  final void Function(String franchiseId) onSelected;",
      "",
      "  const FranchiseSelector({",
      "    super.key,",
      "    required this.items,",
      "    required this.selectedFranchiseId,",
      "    required this.onSelected,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return ListView.separated(",
      "      padding: const EdgeInsets.symmetric(vertical: 28, horizontal: 16),",
      "      itemCount: items.length,",
      "      separatorBuilder: (_, __) => const Divider(),",
      "      itemBuilder: (context, idx) {",
      "        final f = items[idx];",
      "        final isSelected = f.id == selectedFranchiseId;",
      "",
      "        return ListTile(",
      "          leading: f.logoUrl != null",
      "              ? CircleAvatar(backgroundImage: NetworkImage(f.logoUrl!))",
      "              : const CircleAvatar(child: Icon(Icons.storefront)),",
      "          title: Text(f.name),",
      "          subtitle: Text(f.id),",
      "          onTap: () {",
      "            print('[FranchiseSelector] Franchise tapped: ${f.id}');",
      "            this.onSelected(f.id);",
      "          },",
      "          trailing: isSelected",
      "              ? const Icon(Icons.check_circle, color: Colors.green)",
      "              : const Icon(Icons.chevron_right),",
      "          shape: RoundedRectangleBorder(",
      "            borderRadius: BorderRadius.circular(12),",
      "          ),",
      "        );",
      "      },",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 46,
      "file_size": 1532,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\admin\\onboarding_tracker_widget.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "",
      "class OnboardingTrackerWidget extends StatelessWidget {",
      "  final Map<String, bool> checklist;",
      "  final void Function()? onCompletePressed;",
      "",
      "  const OnboardingTrackerWidget({",
      "    Key? key,",
      "    required this.checklist,",
      "    this.onCompletePressed,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    final theme = Theme.of(context);",
      "    final completed = checklist.entries.where((e) => e.value).length;",
      "    final total = checklist.length;",
      "    final progress = total > 0 ? completed / total : 0.0;",
      "",
      "    return Card(",
      "      elevation: 1,",
      "      shape: RoundedRectangleBorder(",
      "          borderRadius: BorderRadius.circular(DesignTokens.radiusLg)),",
      "      child: Padding(",
      "        padding: const EdgeInsets.all(16.0),",
      "        child: Column(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            Text(",
      "              loc.onboardingChecklist,",
      "              style: theme.textTheme.titleMedium",
      "                  ?.copyWith(fontWeight: FontWeight.bold),",
      "            ),",
      "            const SizedBox(height: 8),",
      "            LinearProgressIndicator(",
      "              value: progress,",
      "              minHeight: 8,",
      "              backgroundColor: theme.colorScheme.surfaceVariant,",
      "              color: theme.colorScheme.primary,",
      "              semanticsLabel: loc.onboardingChecklist,",
      "            ),",
      "            const SizedBox(height: 16),",
      "            ...checklist.entries.map((entry) => ListTile(",
      "                  dense: true,",
      "                  contentPadding: EdgeInsets.zero,",
      "                  leading: Icon(",
      "                    entry.value",
      "                        ? Icons.check_circle",
      "                        : Icons.radio_button_unchecked,",
      "                    color: entry.value",
      "                        ? theme.colorScheme.primary",
      "                        : theme.disabledColor,",
      "                  ),",
      "                  title: Text(",
      "                    _labelForKey(entry.key, loc),",
      "                    style: theme.textTheme.bodyLarge,",
      "                  ),",
      "                )),",
      "            const SizedBox(height: 12),",
      "            if (progress == 1.0 && onCompletePressed != null)",
      "              Align(",
      "                alignment: Alignment.centerRight,",
      "                child: ElevatedButton.icon(",
      "                  icon: const Icon(Icons.check),",
      "                  label: Text(loc.markAsComplete),",
      "                  onPressed: onCompletePressed,",
      "                ),",
      "              ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  String _labelForKey(String key, AppLocalizations loc) {",
      "    switch (key) {",
      "      case 'profileCompleted':",
      "        return loc.profileCompleted;",
      "      case 'menuUploaded':",
      "        return loc.menuUploaded;",
      "      case 'inventoryLoaded':",
      "        return loc.inventoryLoaded;",
      "      case 'staffInvited':",
      "        return loc.staffInvited;",
      "      case 'testOrderPlaced':",
      "        return loc.testOrderPlaced;",
      "      default:",
      "        return key;",
      "    }",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 101,
      "file_size": 3451,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\banner\\banner_action_handler.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/core/models/banner.dart' as model;",
      "import 'package:franchise_admin_portal/core/models/category.dart';",
      "import 'package:franchise_admin_portal/core/services/analytics_service.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "",
      "// You may inject analytics or other services here as needed.",
      "",
      "class BannerActionHandler {",
      "  /// Handles what happens when a banner or its CTA is tapped.",
      "  static Future<void> handle(",
      "    BuildContext context,",
      "    model.Banner banner, {",
      "    AnalyticsService? analyticsService,",
      "    AppLocalizations? loc,",
      "    List<Category>? categories,",
      "  }) async {",
      "    // Fallback for localization and analytics.",
      "    loc ??= AppLocalizations.of(context)!;",
      "",
      "    if (analyticsService != null) {",
      "      void logBannerTap(String bannerId) {",
      "        // Implement logging logic",
      "      }",
      "    }",
      "",
      "    switch (banner.action.type) {",
      "      case 'linkCategory':",
      "        if (banner.action.value != null && categories != null) {",
      "          final matchedCat = categories.firstWhere(",
      "            (cat) => cat.id == banner.action.value,",
      "            orElse: () => Category(",
      "              id: banner.action.value!,",
      "              name: banner.action.value!,",
      "              description: '',",
      "              image: '',",
      "            ),",
      "          );",
      "          ScaffoldMessenger.of(context).showSnackBar(",
      "            SnackBar(",
      "              content: Text(",
      "                '${loc.categorySelected}: ${matchedCat.name}',",
      "                style: const TextStyle(color: Colors.white),",
      "              ),",
      "              backgroundColor: Colors.green[700],",
      "            ),",
      "          );",
      "        } else {",
      "          ScaffoldMessenger.of(context).showSnackBar(",
      "            SnackBar(",
      "              content: Text(",
      "                loc.noCategoriesAvailable,",
      "                style: const TextStyle(color: Colors.white),",
      "              ),",
      "              backgroundColor: Colors.red,",
      "            ),",
      "          );",
      "        }",
      "        break;",
      "",
      "      case 'promo':",
      "        if (banner.action.value != null) {",
      "          ScaffoldMessenger.of(context).showSnackBar(",
      "            SnackBar(",
      "              content: Text(",
      "                '${loc.applyPromo}: ${banner.action.value}',",
      "                style: const TextStyle(color: Colors.black),",
      "              ),",
      "              backgroundColor: Colors.yellow[200],",
      "            ),",
      "          );",
      "        } else {",
      "          ScaffoldMessenger.of(context).showSnackBar(",
      "            SnackBar(",
      "              content: Text(",
      "                loc.invalidPromo,",
      "                style: const TextStyle(color: Colors.white),",
      "              ),",
      "              backgroundColor: Colors.red,",
      "            ),",
      "          );",
      "        }",
      "        break;",
      "",
      "      case 'linkItem':",
      "        // You can add item-specific navigation logic here if needed.",
      "        // Example: push item details screen.",
      "        ScaffoldMessenger.of(context).showSnackBar(",
      "          SnackBar(",
      "            content: Text(",
      "              loc.notImplemented,",
      "              style: const TextStyle(color: Colors.white),",
      "            ),",
      "            backgroundColor: Colors.grey[800],",
      "          ),",
      "        );",
      "        break;",
      "",
      "      default:",
      "        // For any other action or 'none', do nothing.",
      "        break;",
      "    }",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 104,
      "file_size": 3339,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\banner\\banner_carousel.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:carousel_slider/carousel_slider.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/config/branding_config.dart';",
      "import 'package:franchise_admin_portal/core/models/banner.dart' as model;",
      "import 'package:franchise_admin_portal/widgets/network_image_widget.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/widgets/banner/promo_banner_card.dart';",
      "",
      "typedef BannerTapCallback = void Function(model.Banner banner);",
      "",
      "class BannerCarousel extends StatelessWidget {",
      "  final List<model.Banner> banners;",
      "  final BannerTapCallback? onBannerTap;",
      "",
      "  const BannerCarousel({",
      "    super.key,",
      "    required this.banners,",
      "    this.onBannerTap,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    if (banners.isEmpty) {",
      "      // For visual consistency, you could show a placeholder or SizedBox.shrink().",
      "      return const SizedBox.shrink();",
      "    }",
      "    return Padding(",
      "      padding: DesignTokens.gridPadding,",
      "      child: CarouselSlider.builder(",
      "        itemCount: banners.length,",
      "        itemBuilder: (context, index, realIdx) {",
      "          final banner = banners[index];",
      "          return PromoBannerCard(",
      "            banner: banner,",
      "            onTap: () => onBannerTap?.call(banner),",
      "            onCTAPressed: () => onBannerTap?.call(banner),",
      "          );",
      "        },",
      "        options: CarouselOptions(",
      "          height: DesignTokens.bannerHeight,",
      "          autoPlay: true,",
      "          autoPlayInterval: DesignTokens.bannerAutoPlayInterval,",
      "          enlargeCenterPage: true,",
      "          viewportFraction: 1.0,",
      "          enableInfiniteScroll: banners.length > 1,",
      "          pauseAutoPlayOnTouch: true,",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  String _getCTAForAction(BuildContext context, String type) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[YourWidget] loc is null! Localization not available for this context.');",
      "      return 'Localization missing! [debug]';",
      "    }",
      "    switch (type) {",
      "      case 'linkCategory':",
      "        return loc.browseCategoryCta;",
      "      case 'linkItem':",
      "        return loc.orderNowCta;",
      "      case 'promo':",
      "        return loc.applyPromoCta;",
      "      default:",
      "        return loc.defaultBannerCta;",
      "    }",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 71,
      "file_size": 2404,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\banner\\promo_banner_card.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/config/branding_config.dart';",
      "import 'package:franchise_admin_portal/core/models/banner.dart' as model;",
      "import 'package:franchise_admin_portal/widgets/network_image_widget.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "",
      "class PromoBannerCard extends StatelessWidget {",
      "  final model.Banner banner;",
      "  final VoidCallback? onTap;",
      "  final VoidCallback? onCTAPressed;",
      "",
      "  const PromoBannerCard({",
      "    Key? key,",
      "    required this.banner,",
      "    this.onTap,",
      "    this.onCTAPressed,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final theme = Theme.of(context);",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "",
      "    return GestureDetector(",
      "      onTap: onTap,",
      "      child: Stack(",
      "        fit: StackFit.expand,",
      "        children: [",
      "          ClipRRect(",
      "            borderRadius:",
      "                BorderRadius.circular(DesignTokens.bannerBorderRadius),",
      "            child: NetworkImageWidget(",
      "              imageUrl: banner.image,",
      "              fallbackAsset: BrandingConfig.bannerPlaceholder,",
      "              width: double.infinity,",
      "              height: DesignTokens.bannerHeight,",
      "              fit: BoxFit.cover,",
      "              borderRadius:",
      "                  BorderRadius.circular(DesignTokens.bannerBorderRadius),",
      "            ),",
      "          ),",
      "          Container(",
      "            decoration: BoxDecoration(",
      "              borderRadius:",
      "                  BorderRadius.circular(DesignTokens.bannerBorderRadius),",
      "              color: DesignTokens.bannerOverlayColor",
      "                  .withAlpha(DesignTokens.bannerOverlayAlpha),",
      "            ),",
      "          ),",
      "          Positioned(",
      "            left: 16,",
      "            right: 16,",
      "            bottom: 16,",
      "            child: Column(",
      "              crossAxisAlignment: CrossAxisAlignment.start,",
      "              children: [",
      "                if (banner.title.isNotEmpty)",
      "                  Text(",
      "                    banner.title,",
      "                    style: TextStyle(",
      "                      fontSize: DesignTokens.titleFontSize,",
      "                      color: DesignTokens.foregroundColor,",
      "                      fontWeight: DesignTokens.titleFontWeight,",
      "                      shadows: const [",
      "                        Shadow(color: Colors.black54, blurRadius: 4),",
      "                      ],",
      "                    ),",
      "                    maxLines: 1,",
      "                    overflow: TextOverflow.ellipsis,",
      "                  ),",
      "                if (banner.subtitle.isNotEmpty)",
      "                  Padding(",
      "                    padding: const EdgeInsets.only(top: 2),",
      "                    child: Text(",
      "                      banner.subtitle,",
      "                      style: TextStyle(",
      "                        fontSize: DesignTokens.captionFontSize,",
      "                        color: DesignTokens.foregroundColor,",
      "                        fontWeight: FontWeight.w400,",
      "                        shadows: const [",
      "                          Shadow(color: Colors.black54, blurRadius: 4),",
      "                        ],",
      "                      ),",
      "                      maxLines: 2,",
      "                      overflow: TextOverflow.ellipsis,",
      "                    ),",
      "                  ),",
      "                if (banner.action.type != 'none')",
      "                  Padding(",
      "                    padding: const EdgeInsets.only(top: 8),",
      "                    child: ElevatedButton(",
      "                      style: ElevatedButton.styleFrom(",
      "                        backgroundColor: DesignTokens.secondaryColor,",
      "                        foregroundColor: DesignTokens.foregroundColor,",
      "                        shape: RoundedRectangleBorder(",
      "                          borderRadius: BorderRadius.circular(24),",
      "                        ),",
      "                      ),",
      "                      onPressed: onCTAPressed ?? onTap,",
      "                      child: Text(",
      "                        (banner.action.ctaText != null &&",
      "                                banner.action.ctaText!.isNotEmpty)",
      "                            ? banner.action.ctaText!",
      "                            : _getCTAForAction(loc, banner.action.type),",
      "                      ),",
      "                    ),",
      "                  ),",
      "              ],",
      "            ),",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "",
      "  String _getCTAForAction(AppLocalizations loc, String type) {",
      "    switch (type) {",
      "      case 'linkCategory':",
      "        return loc.browseCategoryCta;",
      "      case 'linkItem':",
      "        return loc.orderNowCta;",
      "      case 'promo':",
      "        return loc.applyPromoCta;",
      "      default:",
      "        return loc.defaultBannerCta;",
      "    }",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 136,
      "file_size": 4971,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\business\\business_hours_editor.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "",
      "const _DAYS = [",
      "  'sun',",
      "  'mon',",
      "  'tue',",
      "  'wed',",
      "  'thu',",
      "  'fri',",
      "  'sat',",
      "];",
      "",
      "const _DAY_LABELS = {",
      "  'sun': 'Sun',",
      "  'mon': 'Mon',",
      "  'tue': 'Tue',",
      "  'wed': 'Wed',",
      "  'thu': 'Thu',",
      "  'fri': 'Fri',",
      "  'sat': 'Sat',",
      "};",
      "",
      "class BusinessHourInterval {",
      "  List<String> days;",
      "  TimeOfDay open;",
      "  TimeOfDay close;",
      "",
      "  BusinessHourInterval({",
      "    required this.days,",
      "    required this.open,",
      "    required this.close,",
      "  });",
      "",
      "  Map<String, dynamic> toJson() => {",
      "        'days': days,",
      "        'open': '${open.hour.toString().padLeft(2, '0')}:'",
      "            '${open.minute.toString().padLeft(2, '0')}',",
      "        'close': '${close.hour.toString().padLeft(2, '0')}:'",
      "            '${close.minute.toString().padLeft(2, '0')}',",
      "      };",
      "",
      "  static BusinessHourInterval fromJson(Map<String, dynamic> json) {",
      "    final openParts = (json['open'] as String).split(':');",
      "    final closeParts = (json['close'] as String).split(':');",
      "    return BusinessHourInterval(",
      "      days: List<String>.from(json['days'] ?? []),",
      "      open: TimeOfDay(",
      "        hour: int.parse(openParts[0]),",
      "        minute: int.parse(openParts[1]),",
      "      ),",
      "      close: TimeOfDay(",
      "        hour: int.parse(closeParts[0]),",
      "        minute: int.parse(closeParts[1]),",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "class BusinessHoursEditor extends StatefulWidget {",
      "  final List<Map<String, dynamic>> initialHours;",
      "  final void Function(List<Map<String, dynamic>>)? onChanged;",
      "  final bool enabled;",
      "",
      "  const BusinessHoursEditor({",
      "    Key? key,",
      "    this.initialHours = const [],",
      "    this.onChanged,",
      "    this.enabled = true,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  State<BusinessHoursEditor> createState() => _BusinessHoursEditorState();",
      "}",
      "",
      "class _BusinessHoursEditorState extends State<BusinessHoursEditor> {",
      "  late List<BusinessHourInterval> _intervals;",
      "  String? _validationError;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _intervals = widget.initialHours.isNotEmpty",
      "        ? widget.initialHours",
      "            .map((e) => BusinessHourInterval.fromJson(e))",
      "            .toList()",
      "        : [",
      "            BusinessHourInterval(",
      "              days: ['mon', 'tue', 'wed', 'thu', 'fri'],",
      "              open: const TimeOfDay(hour: 9, minute: 0),",
      "              close: const TimeOfDay(hour: 17, minute: 0),",
      "            ),",
      "          ];",
      "  }",
      "",
      "  void _addInterval() {",
      "    setState(() {",
      "      _intervals.add(",
      "        BusinessHourInterval(",
      "          days: [],",
      "          open: const TimeOfDay(hour: 9, minute: 0),",
      "          close: const TimeOfDay(hour: 17, minute: 0),",
      "        ),",
      "      );",
      "      _validationError = null;",
      "    });",
      "    _notifyChange();",
      "  }",
      "",
      "  void _removeInterval(int index) {",
      "    setState(() {",
      "      _intervals.removeAt(index);",
      "      _validationError = null;",
      "    });",
      "    _notifyChange();",
      "  }",
      "",
      "  void _updateInterval(",
      "      int index, List<String> days, TimeOfDay open, TimeOfDay close) {",
      "    setState(() {",
      "      _intervals[index] = BusinessHourInterval(",
      "        days: days,",
      "        open: open,",
      "        close: close,",
      "      );",
      "      _validationError = null;",
      "    });",
      "    _notifyChange();",
      "  }",
      "",
      "  void _notifyChange() {",
      "    widget.onChanged?.call(_intervals.map((e) => e.toJson()).toList());",
      "  }",
      "",
      "  String? _validateIntervals(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (_intervals.isEmpty) {",
      "      return loc?.mustSetAtLeastOneInterval ??",
      "          'Set at least one business hour.';",
      "    }",
      "    final coveredDays = <String>{};",
      "    for (final interval in _intervals) {",
      "      if (interval.days.isEmpty) {",
      "        return loc?.mustSelectDays ?? 'Select days for each interval.';",
      "      }",
      "      if (interval.open.hour > interval.close.hour ||",
      "          (interval.open.hour == interval.close.hour &&",
      "              interval.open.minute >= interval.close.minute)) {",
      "        return loc?.openMustBeforeClose ??",
      "            'Open time must be before close time.';",
      "      }",
      "      for (final day in interval.days) {",
      "        if (coveredDays.contains(day)) {",
      "          return loc?.daysOverlap ??",
      "              'Overlapping days across intervals are not allowed.';",
      "        }",
      "        coveredDays.add(day);",
      "      }",
      "    }",
      "    if (coveredDays.isEmpty) {",
      "      return loc?.mustSelectDays ?? 'Select days for each interval.';",
      "    }",
      "    return null;",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    final enabled = widget.enabled;",
      "",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        Text(",
      "          loc?.setupBusinessHours ?? \"Setup business hours\",",
      "          style: Theme.of(context).textTheme.titleMedium,",
      "        ),",
      "        const SizedBox(height: 8),",
      "        Text(",
      "          loc?.setupBusinessHoursDesc ??",
      "              \"Your business hours are used for on-duty calculation, \"",
      "                  \"and shown on your restaurant page.\",",
      "          style: Theme.of(context).textTheme.bodySmall,",
      "        ),",
      "        const SizedBox(height: 14),",
      "        ..._intervals",
      "            .asMap()",
      "            .entries",
      "            .map((entry) => _buildInterval(context, entry.key, entry.value))",
      "            .toList(),",
      "        const SizedBox(height: 10),",
      "        SizedBox(",
      "          width: double.infinity,",
      "          child: OutlinedButton.icon(",
      "            icon: const Icon(Icons.add),",
      "            label: Text(loc?.addMore ?? \"[+] add more\"),",
      "            onPressed: enabled ? _addInterval : null,",
      "          ),",
      "        ),",
      "        if (_validationError != null)",
      "          Padding(",
      "            padding: const EdgeInsets.only(top: 8),",
      "            child: Text(",
      "              _validationError!,",
      "              style: TextStyle(color: colorScheme.error, fontSize: 13),",
      "            ),",
      "          ),",
      "        const SizedBox(height: 4),",
      "      ],",
      "    );",
      "  }",
      "",
      "  Widget _buildInterval(",
      "      BuildContext context, int index, BusinessHourInterval interval) {",
      "    final enabled = widget.enabled;",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "",
      "    return Card(",
      "      margin: const EdgeInsets.symmetric(vertical: 7),",
      "      color: enabled ? colorScheme.surface : colorScheme.surfaceVariant,",
      "      child: Padding(",
      "        padding: const EdgeInsets.all(12),",
      "        child: Column(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            Row(",
      "              children: [",
      "                Flexible(",
      "                  child: _TimePickerField(",
      "                    label: AppLocalizations.of(context)?.openAt ?? 'open at',",
      "                    time: interval.open,",
      "                    enabled: enabled,",
      "                    onChanged: (t) {",
      "                      final days = List<String>.from(interval.days);",
      "                      _updateInterval(index, days, t, interval.close);",
      "                    },",
      "                  ),",
      "                ),",
      "                const SizedBox(width: 12),",
      "                Flexible(",
      "                  child: _TimePickerField(",
      "                    label: AppLocalizations.of(context)?.closeAt ?? 'close at',",
      "                    time: interval.close,",
      "                    enabled: enabled,",
      "                    onChanged: (t) {",
      "                      final days = List<String>.from(interval.days);",
      "                      _updateInterval(index, days, interval.open, t);",
      "                    },",
      "                  ),",
      "                ),",
      "                if (enabled)",
      "                  IconButton(",
      "                    icon: const Icon(Icons.remove_circle_outline),",
      "                    onPressed: () => _removeInterval(index),",
      "                    tooltip: AppLocalizations.of(context)?.remove ?? 'Remove',",
      "                  ),",
      "              ],",
      "            ),",
      "            const SizedBox(height: 7),",
      "            Wrap(",
      "              spacing: 9,",
      "              children: _DAYS",
      "                  .map((d) => FilterChip(",
      "                        selected: interval.days.contains(d),",
      "                        label: Text(_DAY_LABELS[d]!),",
      "                        onSelected: enabled",
      "                            ? (selected) {",
      "                                final days = List<String>.from(interval.days);",
      "                                if (selected) {",
      "                                  days.add(d);",
      "                                } else {",
      "                                  days.remove(d);",
      "                                }",
      "                                _updateInterval(",
      "                                  index,",
      "                                  days,",
      "                                  interval.open,",
      "                                  interval.close,",
      "                                );",
      "                              }",
      "                            : null,",
      "                      ))",
      "                  .toList(),",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  // Validate and expose to parent",
      "  bool validate(BuildContext context) {",
      "    final error = _validateIntervals(context);",
      "    setState(() => _validationError = error);",
      "    return error == null;",
      "  }",
      "",
      "  // Expose current value as List<Map<String, dynamic>>",
      "  List<Map<String, dynamic>> get value =>",
      "      _intervals.map((e) => e.toJson()).toList();",
      "}",
      "",
      "/// Helper time picker for hour/min selection",
      "class _TimePickerField extends StatelessWidget {",
      "  final String label;",
      "  final TimeOfDay time;",
      "  final bool enabled;",
      "  final void Function(TimeOfDay) onChanged;",
      "",
      "  const _TimePickerField({",
      "    required this.label,",
      "    required this.time,",
      "    required this.onChanged,",
      "    this.enabled = true,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return GestureDetector(",
      "      onTap: enabled",
      "          ? () async {",
      "              final picked = await showTimePicker(",
      "                context: context,",
      "                initialTime: time,",
      "              );",
      "              if (picked != null) onChanged(picked);",
      "            }",
      "          : null,",
      "      child: InputDecorator(",
      "        decoration: InputDecoration(",
      "          labelText: label,",
      "          border: const OutlineInputBorder(),",
      "          enabled: enabled,",
      "          isDense: true,",
      "        ),",
      "        child: Text(",
      "          time.format(context),",
      "          style: TextStyle(",
      "            color: enabled",
      "                ? Theme.of(context).textTheme.bodyLarge?.color",
      "                : Colors.grey,",
      "            fontWeight: FontWeight.w600,",
      "          ),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 350,
      "file_size": 10714,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\categories\\category_card.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/config/branding_config.dart';",
      "import 'package:franchise_admin_portal/core/models/category.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "",
      "typedef CategoryTapCallback = void Function(Category category);",
      "",
      "class CategoryCard extends StatelessWidget {",
      "  final Category category;",
      "  final CategoryTapCallback? onTap;",
      "",
      "  const CategoryCard({",
      "    Key? key,",
      "    required this.category,",
      "    this.onTap,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    final String imagePath =",
      "        (category.image != null && category.image!.isNotEmpty)",
      "            ? category.image!",
      "            : BrandingConfig.defaultCategoryIcon;",
      "",
      "    return Semantics(",
      "      label: loc.menuCategoryLabel(category.name),",
      "      button: true,",
      "      child: Material(",
      "        color: Colors.transparent,",
      "        borderRadius: BorderRadius.circular(DesignTokens.cardRadius),",
      "        elevation: DesignTokens.cardElevation,",
      "        child: InkWell(",
      "          borderRadius: BorderRadius.circular(DesignTokens.cardRadius),",
      "          onTap: () => onTap?.call(category),",
      "          child: Ink(",
      "            decoration: BoxDecoration(",
      "              border: Border.all(",
      "                color: DesignTokens.primaryColor,",
      "                width: DesignTokens.categoryCardBorderWidth,",
      "              ),",
      "              borderRadius: BorderRadius.circular(DesignTokens.cardRadius),",
      "              color: Colors.transparent,",
      "              boxShadow: const [",
      "                BoxShadow(",
      "                  color: Colors.black12,",
      "                  blurRadius: 4,",
      "                  offset: Offset(0, 2),",
      "                ),",
      "              ],",
      "            ),",
      "            child: Stack(",
      "              children: [",
      "                // Background image fills the card.",
      "                ClipRRect(",
      "                  borderRadius: BorderRadius.circular(DesignTokens.cardRadius),",
      "                  child: imagePath.startsWith('http')",
      "                      ? Image.network(",
      "                          imagePath,",
      "                          width: double.infinity,",
      "                          height: double.infinity,",
      "                          fit: BoxFit.cover,",
      "                          errorBuilder: (_, __, ___) => Positioned.fill(",
      "                            child: Image.asset(",
      "                              BrandingConfig.defaultCategoryIcon,",
      "                              fit: BoxFit.cover,",
      "                            ),",
      "                          ),",
      "                        )",
      "                      : Image.asset(",
      "                          imagePath,",
      "                          width: double.infinity,",
      "                          height: double.infinity,",
      "                          fit: BoxFit.cover,",
      "                        ),",
      "                ),",
      "                // Overlay gradient for text readability.",
      "                Positioned.fill(",
      "                  child: Container(",
      "                    decoration: BoxDecoration(",
      "                      borderRadius:",
      "                          BorderRadius.circular(DesignTokens.cardRadius),",
      "                      gradient: LinearGradient(",
      "                        begin: Alignment.topCenter,",
      "                        end: Alignment.bottomCenter,",
      "                        colors: [",
      "                          Colors.transparent,",
      "                          Colors.black.withOpacity(0.55),",
      "                        ],",
      "                        stops: const [0.5, 1.0],",
      "                      ),",
      "                    ),",
      "                  ),",
      "                ),",
      "                // Text (name & optional description) at the bottom.",
      "                Positioned(",
      "                  left: 0,",
      "                  right: 0,",
      "                  bottom: 0,",
      "                  child: Padding(",
      "                    padding: const EdgeInsets.all(14.0),",
      "                    child: Column(",
      "                      crossAxisAlignment: CrossAxisAlignment.start,",
      "                      mainAxisSize: MainAxisSize.min,",
      "                      children: [",
      "                        Text(",
      "                          category.name,",
      "                          style: const TextStyle(",
      "                            fontSize: DesignTokens.titleFontSize,",
      "                            fontWeight: DesignTokens.titleFontWeight,",
      "                            color: Colors.white,",
      "                            fontFamily: DesignTokens.fontFamily,",
      "                            shadows: [",
      "                              Shadow(color: Colors.black54, blurRadius: 4),",
      "                            ],",
      "                          ),",
      "                          maxLines: 2,",
      "                          overflow: TextOverflow.ellipsis,",
      "                        ),",
      "                        if (category.description != null &&",
      "                            category.description!.isNotEmpty)",
      "                          Padding(",
      "                            padding: const EdgeInsets.only(top: 4.0),",
      "                            child: Text(",
      "                              category.description!,",
      "                              style: const TextStyle(",
      "                                fontSize: DesignTokens.captionFontSize,",
      "                                color: Colors.white70,",
      "                                fontFamily: DesignTokens.fontFamily,",
      "                                fontWeight: DesignTokens.bodyFontWeight,",
      "                                shadows: [",
      "                                  Shadow(color: Colors.black26, blurRadius: 2),",
      "                                ],",
      "                              ),",
      "                              maxLines: 2,",
      "                              overflow: TextOverflow.ellipsis,",
      "                            ),",
      "                          ),",
      "                      ],",
      "                    ),",
      "                  ),",
      "                ),",
      "              ],",
      "            ),",
      "          ),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 158,
      "file_size": 6335,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\categories\\category_grid.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/models/category.dart';",
      "import 'package:franchise_admin_portal/widgets/categories/category_card.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "",
      "typedef CategoryTapCallback = void Function(Category category);",
      "",
      "class CategoryGrid extends StatelessWidget {",
      "  final List<Category> categories;",
      "  final CategoryTapCallback? onCategoryTap;",
      "  final int? crossAxisCount;",
      "  final double? childAspectRatio;",
      "  final EdgeInsetsGeometry? padding;",
      "  final Widget? emptyWidget;",
      "  final Widget? loadingWidget;",
      "",
      "  const CategoryGrid({",
      "    Key? key,",
      "    required this.categories,",
      "    this.onCategoryTap,",
      "    this.crossAxisCount,",
      "    this.childAspectRatio,",
      "    this.padding,",
      "    this.emptyWidget,",
      "    this.loadingWidget,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "",
      "    if (categories.isEmpty) {",
      "      // Show provided emptyWidget, or a default empty state",
      "      return emptyWidget ??",
      "          Center(",
      "            child: Text(",
      "              loc.noCategoriesAvailable,",
      "              style: const TextStyle(",
      "                color: DesignTokens.secondaryTextColor,",
      "                fontSize: DesignTokens.bodyFontSize,",
      "                fontWeight: DesignTokens.bodyFontWeight,",
      "                fontFamily: DesignTokens.fontFamily,",
      "              ),",
      "              textAlign: TextAlign.center,",
      "              semanticsLabel: loc.noCategoriesAvailable,",
      "            ),",
      "          );",
      "    }",
      "",
      "    // Responsive grid columns: default 2 (mobile), 3 (tablet+)",
      "    final int gridCount =",
      "        crossAxisCount ?? (MediaQuery.of(context).size.width > 600 ? 3 : 2);",
      "",
      "    return GridView.builder(",
      "      padding: padding ?? DesignTokens.gridPadding,",
      "      itemCount: categories.length,",
      "      gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(",
      "        crossAxisCount: gridCount,",
      "        childAspectRatio: childAspectRatio ?? DesignTokens.gridCardAspectRatio,",
      "        crossAxisSpacing: DesignTokens.gridSpacing,",
      "        mainAxisSpacing: DesignTokens.gridSpacing,",
      "      ),",
      "      itemBuilder: (context, index) {",
      "        final category = categories[index];",
      "        return CategoryCard(",
      "          category: category,",
      "          onTap: onCategoryTap,",
      "        );",
      "      },",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 80,
      "file_size": 2700,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\customization\\bottom_bar.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/models/menu_item.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/utils/formatting.dart';",
      "",
      "typedef ConfirmCallback = void Function(",
      "  Map<String, dynamic> customizations,",
      "  int quantity,",
      "  double totalPrice,",
      ");",
      "",
      "class CustomizationBottomBar extends StatelessWidget {",
      "  final MenuItem menuItem;",
      "  final ThemeData theme;",
      "  final AppLocalizations loc;",
      "  final double totalPrice;",
      "  final String? error;",
      "  final VoidCallback onCancel;",
      "  final VoidCallback onSubmit;",
      "  final ConfirmCallback onConfirm;",
      "  final Map<String, int> drinkFlavorCounts;",
      "  final Map<String, num>? sizePrices;",
      "  final List<String>? sizes;",
      "  final double? menuItemPrice;",
      "  final int drinkMaxPerFlavor;",
      "",
      "  const CustomizationBottomBar({",
      "    Key? key,",
      "    required this.menuItem,",
      "    required this.theme,",
      "    required this.loc,",
      "    required this.totalPrice,",
      "    required this.error,",
      "    required this.onCancel,",
      "    required this.onSubmit,",
      "    required this.onConfirm,",
      "    required this.drinkFlavorCounts,",
      "    required this.sizePrices,",
      "    required this.sizes,",
      "    required this.menuItemPrice,",
      "    required this.drinkMaxPerFlavor,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final isDrinks = menuItem.category.toLowerCase() == 'drinks';",
      "",
      "    // DRINKS-SPECIFIC: Calculate price and display total based on flavor counts.",
      "    final drinkPrice = (sizePrices != null && sizes?.isNotEmpty == true)",
      "        ? (sizePrices![sizes!.first] as num).toDouble()",
      "        : (menuItemPrice as num?)?.toDouble() ?? 0.0;",
      "    final drinkTotalCount = isDrinks",
      "        ? (drinkFlavorCounts.values.fold(0, (sum, v) => sum + (v ?? 0)))",
      "        : 0;",
      "    final total = isDrinks ? (drinkTotalCount * drinkPrice) : totalPrice;",
      "",
      "    return Column(",
      "      children: [",
      "        Row(",
      "          mainAxisAlignment: MainAxisAlignment.spaceBetween,",
      "          children: [",
      "            Text(",
      "              loc.total,",
      "              style: theme.textTheme.titleLarge?.copyWith(",
      "                fontWeight: FontWeight.bold,",
      "                fontFamily: DesignTokens.fontFamily,",
      "              ),",
      "            ),",
      "            Text(",
      "              // You must import your currencyFormat function!",
      "              currencyFormat(context, total),",
      "              style: theme.textTheme.titleLarge?.copyWith(",
      "                color: DesignTokens.primaryColor,",
      "                fontWeight: FontWeight.bold,",
      "                fontFamily: DesignTokens.fontFamily,",
      "              ),",
      "            ),",
      "          ],",
      "        ),",
      "        if (error != null)",
      "          Padding(",
      "            padding: const EdgeInsets.only(top: 8.0),",
      "            child: Text(",
      "              error!,",
      "              style: theme.textTheme.bodySmall?.copyWith(",
      "                color: DesignTokens.errorTextColor,",
      "                fontFamily: DesignTokens.fontFamily,",
      "              ),",
      "            ),",
      "          ),",
      "        Row(",
      "          mainAxisAlignment: MainAxisAlignment.end,",
      "          children: [",
      "            TextButton(",
      "              style: TextButton.styleFrom(",
      "                foregroundColor: DesignTokens.secondaryColor,",
      "              ),",
      "              onPressed: onCancel,",
      "              child: Text(",
      "                loc.cancel,",
      "                style: TextStyle(",
      "                  fontFamily: DesignTokens.fontFamily,",
      "                ),",
      "              ),",
      "            ),",
      "            SizedBox(width: DesignTokens.gridSpacing),",
      "            ElevatedButton(",
      "              style: ElevatedButton.styleFrom(",
      "                backgroundColor: DesignTokens.primaryColor,",
      "                foregroundColor: Colors.white,",
      "                shape: RoundedRectangleBorder(",
      "                  borderRadius:",
      "                      BorderRadius.circular(DesignTokens.buttonRadius),",
      "                ),",
      "              ),",
      "              onPressed: isDrinks",
      "                  ? () {",
      "                      // Only proceed if at least one drink selected",
      "                      if (drinkTotalCount == 0) {",
      "                        // This assumes parent will handle error state!",
      "                        // (You could also pass a setError callback)",
      "                        return;",
      "                      }",
      "                      // For each flavor with count > 0, call onConfirm once per drink",
      "                      drinkFlavorCounts.forEach((ingId, count) {",
      "                        for (var i = 0; i < count; i++) {",
      "                          onConfirm({",
      "                            'flavor': ingId,",
      "                            'size': sizes?.first,",
      "                          }, 1, drinkPrice);",
      "                        }",
      "                      });",
      "                      onCancel(); // close dialog",
      "                    }",
      "                  : onSubmit,",
      "              child: Text(",
      "                loc.addToCart,",
      "                style: TextStyle(",
      "                  fontFamily: DesignTokens.fontFamily,",
      "                ),",
      "              ),",
      "            ),",
      "          ],",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 149,
      "file_size": 5223,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\customization\\checkbox_customization_group.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/models/ingredient_metadata.dart';",
      "import 'package:franchise_admin_portal/core/utils/formatting.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "",
      "class CheckboxCustomizationGroup extends StatelessWidget {",
      "  final Map<String, dynamic> group;",
      "  final ThemeData theme;",
      "  final AppLocalizations loc;",
      "  final String category;",
      "  final List<dynamic>? includedIngredients;",
      "  final Map<String, IngredientMetadata> ingredientMetadata;",
      "  final Set<String> currentIngredients;",
      "  final bool usesDynamicToppingPricing;",
      "  final bool Function(String groupLabel) showPortionToggle;",
      "  final double Function() getToppingUpcharge;",
      "  final double Function(IngredientMetadata? meta) getIngredientUpcharge;",
      "  final void Function(String ingId, String groupLabel) toggleIngredient;",
      "  final Widget Function(String ingId) buildPortionPillToggle;",
      "",
      "  const CheckboxCustomizationGroup({",
      "    Key? key,",
      "    required this.group,",
      "    required this.theme,",
      "    required this.loc,",
      "    required this.category,",
      "    required this.includedIngredients,",
      "    required this.ingredientMetadata,",
      "    required this.currentIngredients,",
      "    required this.usesDynamicToppingPricing,",
      "    required this.showPortionToggle,",
      "    required this.getToppingUpcharge,",
      "    required this.getIngredientUpcharge,",
      "    required this.toggleIngredient,",
      "    required this.buildPortionPillToggle,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final String groupLabel = group['label'] ?? '';",
      "    final List<String> ingredientIds =",
      "        (group['ingredientIds'] as List<dynamic>? ?? [])",
      "            .map((e) => e.toString())",
      "            .toList();",
      "",
      "    final bool isSalad = category.toLowerCase().contains('salad');",
      "",
      "    final List<String> unselectedIds = ingredientIds",
      "        .where((ingId) => !currentIngredients.contains(ingId))",
      "        .toList();",
      "",
      "    return Padding(",
      "      padding: const EdgeInsets.symmetric(vertical: 6.0),",
      "      child: Column(",
      "        crossAxisAlignment: CrossAxisAlignment.start,",
      "        children: [",
      "          Text(",
      "            groupLabel,",
      "            style: theme.textTheme.titleMedium?.copyWith(",
      "              color: DesignTokens.secondaryColor,",
      "              fontWeight: FontWeight.bold,",
      "              fontFamily: DesignTokens.fontFamily,",
      "            ),",
      "          ),",
      "          ...unselectedIds.map((ingId) {",
      "            final meta = ingredientMetadata[ingId];",
      "            final bool checked = currentIngredients.contains(ingId);",
      "            final double upcharge = usesDynamicToppingPricing",
      "                ? getToppingUpcharge()",
      "                : getIngredientUpcharge(meta);",
      "",
      "            final bool wasIncluded = (includedIngredients?.any(",
      "                  (e) => (e['ingredientId'] ?? e['id']) == ingId,",
      "                ) ??",
      "                false);",
      "",
      "            final bool showUpcharge = isSalad ? !wasIncluded : (upcharge > 0);",
      "",
      "            return Row(",
      "              children: [",
      "                Expanded(",
      "                  child: CheckboxListTile(",
      "                    dense: true,",
      "                    value: checked,",
      "                    onChanged: meta?.outOfStock == true",
      "                        ? null",
      "                        : (v) => toggleIngredient(ingId, groupLabel),",
      "                    title: Text(",
      "                      meta?.name ?? ingId,",
      "                      style: theme.textTheme.bodyLarge?.copyWith(",
      "                        color: DesignTokens.textColor,",
      "                        fontFamily: DesignTokens.fontFamily,",
      "                      ),",
      "                      overflow: TextOverflow.ellipsis,",
      "                    ),",
      "                    secondary: showUpcharge",
      "                        ? Text(",
      "                            '+${currencyFormat(context, upcharge)}',",
      "                            style: theme.textTheme.bodyMedium?.copyWith(",
      "                              color: DesignTokens.secondaryColor,",
      "                              fontWeight: FontWeight.bold,",
      "                              fontFamily: DesignTokens.fontFamily,",
      "                            ),",
      "                          )",
      "                        : null,",
      "                    controlAffinity: ListTileControlAffinity.leading,",
      "                  ),",
      "                ),",
      "                if (showPortionToggle(groupLabel))",
      "                  Padding(",
      "                    padding: const EdgeInsets.only(right: 8.0),",
      "                    child: checked",
      "                        ? buildPortionPillToggle(ingId)",
      "                        : SizedBox.shrink(),",
      "                  ),",
      "              ],",
      "            );",
      "          }).toList(),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 124,
      "file_size": 4824,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\customization\\current_ingredients.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/core/models/menu_item.dart';",
      "import 'package:franchise_admin_portal/core/models/ingredient_metadata.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/widgets/portion_selector.dart';",
      "import 'package:franchise_admin_portal/widgets/customization/portion_pill_toggle.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "",
      "typedef CurrencyFormat = String Function(BuildContext context, num value);",
      "typedef GetSaladToppingUpcharge = double Function();",
      "typedef ToggleIngredient = void Function(String, String);",
      "typedef CanDoubleCurrentIngredient = bool Function(String? groupLabel);",
      "typedef IsDoughIngredient = bool Function(String);",
      "typedef IsRadioGroup = bool Function(String);",
      "typedef GetPortion = Portion Function(String);",
      "",
      "class CurrentIngredients extends StatelessWidget {",
      "  final List<String> currentIngredients;",
      "  final MenuItem menuItem;",
      "  final Map<String, IngredientMetadata> ingredientMetadata;",
      "  final Map<String, int> selectedSauceCounts;",
      "  final Map<String, int> selectedDressingCounts;",
      "  final Map<String, String> radioSelections;",
      "  final Map<String, Portion> ingredientPortions;",
      "  final Map<String, bool> doubleToppings;",
      "  final Map<String, double> ingredientAmounts;",
      "  final int doublesCount;",
      "  final int maxDoubles;",
      "  final bool Function(String? groupLabel) canDoubleCurrentIngredient;",
      "  final bool Function(String) isDoughIngredient;",
      "  final bool Function(String) isRadioGroup;",
      "  final double Function() getSaladToppingUpcharge;",
      "  final CurrencyFormat currencyFormat;",
      "  final void Function(void Function()) setState;",
      "  final ToggleIngredient toggleIngredient;",
      "",
      "  const CurrentIngredients({",
      "    Key? key,",
      "    required this.currentIngredients,",
      "    required this.menuItem,",
      "    required this.ingredientMetadata,",
      "    required this.selectedSauceCounts,",
      "    required this.selectedDressingCounts,",
      "    required this.radioSelections,",
      "    required this.ingredientPortions,",
      "    required this.doubleToppings,",
      "    required this.ingredientAmounts,",
      "    required this.doublesCount,",
      "    required this.maxDoubles,",
      "    required this.canDoubleCurrentIngredient,",
      "    required this.isDoughIngredient,",
      "    required this.isRadioGroup,",
      "    required this.getSaladToppingUpcharge,",
      "    required this.currencyFormat,",
      "    required this.setState,",
      "    required this.toggleIngredient,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final theme = Theme.of(context);",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    if (currentIngredients.isEmpty) return const SizedBox.shrink();",
      "",
      "    final isDinner = menuItem.category.toLowerCase().contains('dinner');",
      "    final isSalad = menuItem.category.toLowerCase().contains('salad');",
      "",
      "    // Salad upcharge annotation (always visible for salads)",
      "    final upchargeAnnotation = isSalad",
      "        ? Padding(",
      "            padding: const EdgeInsets.only(bottom: 4.0),",
      "            child: Text(",
      "              'Add extra toppings or double any ingredient for just +${currencyFormat(context, getSaladToppingUpcharge())}.',",
      "              style: theme.textTheme.bodySmall?.copyWith(",
      "                color: DesignTokens.secondaryTextColor,",
      "                fontStyle: FontStyle.italic,",
      "                fontFamily: DesignTokens.fontFamily,",
      "              ),",
      "            ),",
      "          )",
      "        : const SizedBox.shrink();",
      "",
      "    final showIngIds = currentIngredients.where((id) {",
      "      final meta = ingredientMetadata[id];",
      "      if (isDinner) {",
      "        if (meta?.type?.toLowerCase() == 'sauces' &&",
      "            (meta?.amountSelectable ?? false)) {",
      "          return true;",
      "        }",
      "        return (meta?.removable ?? false);",
      "      }",
      "      if (isDoughIngredient(id)) return false;",
      "      if (selectedSauceCounts.containsKey(id)) return false;",
      "      if (selectedDressingCounts.containsKey(id)) return false;",
      "      if (menuItem.customizationGroups != null) {",
      "        for (final group in menuItem.customizationGroups!) {",
      "          if ((group['ingredientIds'] as List).contains(id)) {",
      "            final groupLabel = group['label'] as String;",
      "            if (isRadioGroup(groupLabel)) {",
      "              if (radioSelections[groupLabel] == id) return false;",
      "            }",
      "          }",
      "        }",
      "      }",
      "      return true;",
      "    }).toList();",
      "",
      "    if (showIngIds.isEmpty) return const SizedBox.shrink();",
      "",
      "    return Padding(",
      "      padding: const EdgeInsets.symmetric(vertical: 6.0),",
      "      child: Column(",
      "        crossAxisAlignment: CrossAxisAlignment.start,",
      "        children: [",
      "          if (isSalad) upchargeAnnotation,",
      "          Text(",
      "            loc.currentIngredientsLabel,",
      "            style: theme.textTheme.titleMedium?.copyWith(",
      "              color: DesignTokens.primaryColor,",
      "              fontWeight: FontWeight.bold,",
      "              fontFamily: DesignTokens.fontFamily,",
      "            ),",
      "          ),",
      "          ...showIngIds.map((ingId) {",
      "            final meta = ingredientMetadata[ingId];",
      "            String? groupLabel;",
      "            if (menuItem.customizationGroups != null) {",
      "              for (final group in menuItem.customizationGroups!) {",
      "                if ((group['ingredientIds'] as List).contains(ingId)) {",
      "                  groupLabel = group['label'];",
      "                  break;",
      "                }",
      "              }",
      "            }",
      "            final removable = meta?.removable ?? true;",
      "            final outOfStock = meta?.outOfStock == true;",
      "            final cat = menuItem.category.toLowerCase();",
      "            final isPizza = cat.contains('pizza');",
      "            final showPortionSelector = isPizza &&",
      "                groupLabel != null &&",
      "                (groupLabel == \"Meats\" ||",
      "                    groupLabel == \"Veggies\" ||",
      "                    groupLabel == \"Cheeses\");",
      "            final canDouble = canDoubleCurrentIngredient(groupLabel);",
      "            final isSauceWithDropdown = isDinner &&",
      "                (meta?.type?.toLowerCase() == 'sauces' &&",
      "                    (meta?.amountSelectable ?? false));",
      "            final isRemoved = removable && !currentIngredients.contains(ingId);",
      "",
      "            return Column(",
      "              crossAxisAlignment: CrossAxisAlignment.start,",
      "              children: [",
      "                Row(",
      "                  crossAxisAlignment: CrossAxisAlignment.center,",
      "                  children: [",
      "                    if (isDinner && isSauceWithDropdown)",
      "                      const SizedBox(width: 18),",
      "                    if (isDinner && !isSauceWithDropdown && removable)",
      "                      Checkbox(",
      "                        value: !isRemoved,",
      "                        onChanged: outOfStock",
      "                            ? null",
      "                            : (val) {",
      "                                setState(() {",
      "                                  if (val == true) {",
      "                                    currentIngredients.add(ingId);",
      "                                  } else {",
      "                                    currentIngredients.remove(ingId);",
      "                                  }",
      "                                });",
      "                              },",
      "                      ),",
      "                    if (!isDinner)",
      "                      Checkbox(",
      "                        value: true,",
      "                        onChanged: removable &&",
      "                                groupLabel != null &&",
      "                                !isRadioGroup(groupLabel) &&",
      "                                groupLabel.toLowerCase() != 'sauces' &&",
      "                                groupLabel.toLowerCase() != 'dressings'",
      "                            ? (val) => toggleIngredient(ingId, groupLabel!)",
      "                            : null,",
      "                      ),",
      "                    Expanded(",
      "                      child: Row(",
      "                        children: [",
      "                          Expanded(",
      "                            child: Text(",
      "                              meta?.name ?? ingId,",
      "                              style: TextStyle(",
      "                                fontWeight: removable",
      "                                    ? FontWeight.normal",
      "                                    : FontWeight.bold,",
      "                                color: outOfStock",
      "                                    ? DesignTokens.secondaryTextColor",
      "                                    : DesignTokens.textColor,",
      "                              ),",
      "                            ),",
      "                          ),",
      "                          if (isSauceWithDropdown)",
      "                            Padding(",
      "                              padding: const EdgeInsets.only(left: 8.0),",
      "                              child: DropdownButton<String>(",
      "                                value: ingredientAmounts[ingId] != null",
      "                                    ? ingredientAmounts[ingId].toString()",
      "                                    : meta?.amountOptions?.first,",
      "                                items: List<String>.from(",
      "                                  meta?.amountOptions ?? [],",
      "                                )",
      "                                    .map((opt) => DropdownMenuItem<String>(",
      "                                          value: opt,",
      "                                          child: Text(opt),",
      "                                        ))",
      "                                    .toList(),",
      "                                onChanged: outOfStock",
      "                                    ? null",
      "                                    : (val) {",
      "                                        setState(() {",
      "                                          ingredientAmounts[ingId] =",
      "                                              double.parse(val!);",
      "                                        });",
      "                                      },",
      "                              ),",
      "                            ),",
      "                        ],",
      "                      ),",
      "                    ),",
      "                    if (isDinner && !isSauceWithDropdown && isRemoved)",
      "                      Padding(",
      "                        padding: const EdgeInsets.only(left: 8.0),",
      "                        child: Text(",
      "                          loc.ingredientRemovedLabel,",
      "                          style: TextStyle(",
      "                            color: DesignTokens.primaryColor,",
      "                            fontStyle: FontStyle.italic,",
      "                            fontWeight: FontWeight.w600,",
      "                          ),",
      "                        ),",
      "                      ),",
      "                    if (!isDinner && !showPortionSelector && canDouble) ...[",
      "                      Padding(",
      "                        padding: const EdgeInsets.only(right: 8.0),",
      "                        child: Text(",
      "                          \"Amount\",",
      "                          style: const TextStyle(",
      "                            fontSize: 13,",
      "                            color: DesignTokens.secondaryColor,",
      "                            fontFamily: DesignTokens.fontFamily,",
      "                            fontWeight: FontWeight.bold,",
      "                          ),",
      "                        ),",
      "                      ),",
      "                      PortionPillToggle(",
      "                        isDouble: doubleToppings[ingId] == true,",
      "                        onTap: () {",
      "                          setState(() {",
      "                            if (doubleToppings[ingId] == true) {",
      "                              doubleToppings[ingId] = false;",
      "                            } else {",
      "                              if (doublesCount < maxDoubles)",
      "                                doubleToppings[ingId] = true;",
      "                            }",
      "                          });",
      "                        },",
      "                      ),",
      "                    ],",
      "                  ],",
      "                ),",
      "                if (!isDinner && showPortionSelector)",
      "                  Padding(",
      "                    padding: const EdgeInsets.only(bottom: 6.0),",
      "                    child: Row(",
      "                      crossAxisAlignment: CrossAxisAlignment.center,",
      "                      children: [",
      "                        const SizedBox(width: 40),",
      "                        PortionSelector(",
      "                          value: ingredientPortions[ingId] ?? Portion.whole,",
      "                          onChanged: (portion) {",
      "                            setState(() {",
      "                              ingredientPortions[ingId] = portion;",
      "                            });",
      "                          },",
      "                          size: 22,",
      "                        ),",
      "                        const Spacer(),",
      "                        PortionPillToggle(",
      "                          isDouble: doubleToppings[ingId] == true,",
      "                          onTap: () {",
      "                            setState(() {",
      "                              if (doubleToppings[ingId] == true) {",
      "                                doubleToppings[ingId] = false;",
      "                              } else {",
      "                                if (doublesCount < maxDoubles)",
      "                                  doubleToppings[ingId] = true;",
      "                              }",
      "                            });",
      "                          },",
      "                        ),",
      "                      ],",
      "                    ),",
      "                  ),",
      "                if (!removable && !isDinner)",
      "                  Padding(",
      "                    padding: const EdgeInsets.only(left: 44.0, top: 2),",
      "                    child: Text(",
      "                      loc.cannotBeRemoved,",
      "                      style: const TextStyle(",
      "                        color: DesignTokens.hintTextColor,",
      "                        fontStyle: FontStyle.italic,",
      "                      ),",
      "                    ),",
      "                  ),",
      "                if (showIngIds.last != ingId)",
      "                  Padding(",
      "                    padding: const EdgeInsets.symmetric(vertical: 6.0),",
      "                    child: Divider(",
      "                      thickness: 1.0,",
      "                      color: Colors.grey[300],",
      "                      height: 1,",
      "                    ),",
      "                  ),",
      "              ],",
      "            );",
      "          }).toList(),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 336,
      "file_size": 14474,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\customization\\customization_modal.dart",
    "content": [
      "// ignore_for_file: prefer_const_constructors",
      "import 'package:franchise_admin_portal/widgets/customization/pizza_sauce_selector_tab.dart';",
      "import 'package:collection/collection.dart';",
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:intl/intl.dart';",
      "import 'package:franchise_admin_portal/core/utils/formatting.dart';",
      "import 'package:franchise_admin_portal/core/models/menu_item.dart';",
      "import 'package:franchise_admin_portal/core/models/ingredient_metadata.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/widgets/portion_selector.dart';",
      "import 'package:franchise_admin_portal/widgets/customization/dressing_selector_group.dart';",
      "import 'package:franchise_admin_portal/widgets/customization/sauce_selector_group.dart';",
      "import 'package:franchise_admin_portal/widgets/customization/checkbox_customization_group.dart';",
      "import 'package:franchise_admin_portal/widgets/customization/dinner_included_ingredients.dart';",
      "import 'package:franchise_admin_portal/widgets/customization/radio_customization_group.dart';",
      "import 'package:franchise_admin_portal/widgets/customization/drinks_flavor_selector.dart';",
      "import 'package:franchise_admin_portal/widgets/customization/portion_pill_toggle.dart';",
      "import 'package:franchise_admin_portal/widgets/customization/optional_addons_group.dart';",
      "import 'package:franchise_admin_portal/widgets/customization/wings_optional_addons_group.dart';",
      "import 'package:franchise_admin_portal/widgets/customization/wings_dip_sauce_selector.dart';",
      "import 'package:franchise_admin_portal/widgets/customization/wings_portion_selector.dart';",
      "import 'package:franchise_admin_portal/widgets/customization/size_dropdown.dart';",
      "import 'package:franchise_admin_portal/widgets/customization/topping_cost_label.dart';",
      "import 'package:franchise_admin_portal/widgets/customization/current_ingredients.dart';",
      "import 'package:franchise_admin_portal/widgets/customization/header.dart';",
      "import 'package:franchise_admin_portal/widgets/customization/bottom_bar.dart';",
      "import 'package:franchise_admin_portal/core/models/size_template.dart';",
      "",
      "const MAX_DOUBLES = 4;",
      "const DOUGH_IDS = {'dough_calzone', 'dough_pizza', 'dough'};",
      "int _wingsDipSauceTabIndex = 0;",
      "const portionNames = {",
      "  Portion.whole: \"Whole\",",
      "  Portion.left: \"Left\",",
      "  Portion.right: \"Right\"",
      "};",
      "",
      "extension StringCasingExtension on String {",
      "  String capitalize() =>",
      "      this.isNotEmpty ? '${this[0].toUpperCase()}${substring(1)}' : '';",
      "}",
      "",
      "class PizzaSauceSelection {",
      "  final String id;",
      "  final String name;",
      "  bool selected;",
      "  Portion portion;",
      "  String amount;",
      "",
      "  PizzaSauceSelection({",
      "    required this.id,",
      "    required this.name,",
      "    this.selected = false,",
      "    this.portion = Portion.whole,",
      "    this.amount = 'regular',",
      "  });",
      "",
      "  PizzaSauceSelection copyWith({",
      "    bool? selected,",
      "    Portion? portion,",
      "    String? amount,",
      "  }) {",
      "    return PizzaSauceSelection(",
      "      id: id,",
      "      name: name,",
      "      selected: selected ?? this.selected,",
      "      portion: portion ?? this.portion,",
      "      amount: amount ?? this.amount,",
      "    );",
      "  }",
      "}",
      "",
      "class CustomizationModal extends StatefulWidget {",
      "  final MenuItem menuItem;",
      "  final int initialQuantity;",
      "  final Map<String, dynamic>? initialCustomizations;",
      "  final void Function(",
      "    Map<String, dynamic> customizations,",
      "    int quantity,",
      "    double totalPrice,",
      "  ) onConfirm;",
      "  final Map<String, IngredientMetadata>? ingredientMetadata;",
      "",
      "  const CustomizationModal({",
      "    super.key,",
      "    required this.menuItem,",
      "    this.ingredientMetadata,",
      "    this.initialQuantity = 1,",
      "    this.initialCustomizations,",
      "    required this.onConfirm,",
      "  });",
      "",
      "  @override",
      "  State<CustomizationModal> createState() => _CustomizationModalState();",
      "}",
      "",
      "class _CustomizationModalState extends State<CustomizationModal> {",
      "  late int _quantity;",
      "  late Set<String> _currentIngredients;",
      "  late Map<String, Set<String>> _groupSelections;",
      "  late Set<String> _selectedAddOns;",
      "  late Map<String, String?> _radioSelections;",
      "  SizeData? _selectedSize;",
      "  String? _error;",
      "  late Map<String, IngredientMetadata> _ingredientMetadata;",
      "",
      "  late List<Map<String, dynamic>> _checkboxGroups;",
      "  late List<Map<String, dynamic>> _radioGroups;",
      "  String? _selectedSauceId;",
      "",
      "  final Map<String, bool> _doubleToppings = {};",
      "  final Map<String, Portion> _ingredientPortions = {};",
      "  final Map<String, bool> _doubleAddOns = {};",
      "  final Map<String, int> _selectedSauceCounts = {};",
      "  final Map<String, int> _selectedDressingCounts = {};",
      "",
      "  final Map<String, String> _ingredientAmounts =",
      "      {}; // ingredientId -> \"Light\"/\"Regular\"/\"Extra\"",
      "",
      "  // --- Cheeses-specific fields ---",
      "  late Set<String> _selectedCheeses;",
      "  late Map<String, Portion> _cheesePortions;",
      "  late Map<String, bool> _cheeseIsDouble;",
      "",
      "  // --- Wings-specific fields ---",
      "  late Map<String, String?> _selectedDippedSauces; // For split dipped choices",
      "  late bool _isAnyDipped; // True if any part is dipped",
      "  late Map<String, int> _sideDipCounts; // For extra dip cups per flavor",
      "",
      "  // Drinks state",
      "  late Map<String, int> _drinkFlavorCounts; // ingredientId -> count",
      "  int _drinkTotalCount = 0;",
      "  int _drinkMaxPerFlavor = 10; // Default, overwritten by Firestore value",
      "",
      "  // --- Pizza Sauce State ---",
      "  String? _selectedPizzaSauceId;",
      "  String _selectedSaucePortion = 'whole'; // 'whole', 'left', 'right'",
      "  String _selectedSauceAmount = 'regular'; // 'light', 'regular', 'extra'",
      "",
      "  List<PizzaSauceSelection> _pizzaSauceSelections = [];",
      "  bool _sauceSplitValidationError = false;",
      "",
      "  // --- grouped tabs for meats and veggies for pizzas / calzones ---",
      "  late List<String>",
      "      _toppingTabLabels; // Will be [\"Meats\", \"Veggies\"] if present",
      "  String _selectedToppingTab = '';",
      "  late List<Map<String, dynamic>> _toppingTabGroups;",
      "",
      "  void _handleSauceTap(int index) {",
      "    setState(() {",
      "      final selectedCount =",
      "          _pizzaSauceSelections.where((s) => s.selected).length;",
      "      final current = _pizzaSauceSelections[index];",
      "",
      "      // If currently not selected and already two other sauces are selected, block",
      "      if (!current.selected && selectedCount >= 2) {",
      "        return; // Only allow two",
      "      }",
      "",
      "      // Toggling selection",
      "      _pizzaSauceSelections[index] =",
      "          current.copyWith(selected: !current.selected);",
      "",
      "      // Always keep at least one sauce selected",
      "      if (_pizzaSauceSelections.where((s) => s.selected).isEmpty) {",
      "        _pizzaSauceSelections[index] = current.copyWith(selected: true);",
      "      }",
      "",
      "      // If toggled to selected, set to default portion if not set",
      "      if (_pizzaSauceSelections[index].selected) {",
      "        // Set default to 'whole', unless already split",
      "        _pizzaSauceSelections[index] =",
      "            _pizzaSauceSelections[index].copyWith(portion: Portion.whole);",
      "      }",
      "",
      "      // If toggling off in a split, clear validation error",
      "      _sauceSplitValidationError = false;",
      "    });",
      "  }",
      "",
      "// This function ensures only valid splits",
      "  void _handleSaucePortionChange(int index, Portion portion) {",
      "    setState(() {",
      "      _pizzaSauceSelections[index] = _pizzaSauceSelections[index]",
      "          .copyWith(portion: portion, selected: true);",
      "",
      "      // If setting to 'whole', clear all other sauce selections except this one",
      "      if (portion == Portion.whole) {",
      "        for (int i = 0; i < _pizzaSauceSelections.length; i++) {",
      "          if (i != index) {",
      "            _pizzaSauceSelections[i] = _pizzaSauceSelections[i]",
      "                .copyWith(selected: false, portion: Portion.whole);",
      "          }",
      "        }",
      "      } else {",
      "        // If now split, allow one more 'half' selection only",
      "        int halfCount = _pizzaSauceSelections",
      "            .where((s) => s.selected && s.portion != Portion.whole)",
      "            .length;",
      "        if (halfCount == 2) {",
      "          // Lock out any other selections",
      "          for (int i = 0; i < _pizzaSauceSelections.length; i++) {",
      "            if (i != index &&",
      "                _pizzaSauceSelections[i].selected &&",
      "                _pizzaSauceSelections[i].portion == portion) {",
      "              // Prevent both selected sauces from being on the same side",
      "              _pizzaSauceSelections[i] = _pizzaSauceSelections[i]",
      "                  .copyWith(selected: false, portion: Portion.whole);",
      "            }",
      "          }",
      "        }",
      "      }",
      "      _sauceSplitValidationError = false;",
      "    });",
      "  }",
      "",
      "  void _resetPizzaSauceSelections() {",
      "    setState(() {",
      "      for (var s in _pizzaSauceSelections) {",
      "        s.selected = false;",
      "        s.portion = Portion.whole;",
      "        s.amount = 'regular';",
      "      }",
      "      if (_pizzaSauceSelections.isNotEmpty) {",
      "        _pizzaSauceSelections[0].selected = true;",
      "        _pizzaSauceSelections[0].portion = Portion.whole;",
      "        _pizzaSauceSelections[0].amount = 'regular';",
      "      }",
      "      _sauceSplitValidationError = false;",
      "    });",
      "  }",
      "",
      "  // Helper to map UI size to Firestore key for upcharges",
      "  String _normalizeSizeKey(String? uiSize) {",
      "    if (uiSize == null) return '';",
      "    final toppingPrices = widget.menuItem.additionalToppingPrices;",
      "    if (toppingPrices != null && toppingPrices.containsKey(uiSize)) {",
      "      return uiSize;",
      "    }",
      "    final pizzaSizeMap = <String, String>{",
      "      \"Small 10\\\"\": \"Small 10\\\"\",",
      "      \"Medium 12\\\"\": \"Medium 12\\\"\",",
      "      \"Large 14\\\"\": \"Large 14\\\"\",",
      "      \"XL 16\\\"\": \"XL 16\\\"\",",
      "      \"Small\": \"Small 10\\\"\",",
      "      \"Medium\": \"Medium 12\\\"\",",
      "      \"Large\": \"Large 14\\\"\",",
      "      \"XL\": \"XL 16\\\"\",",
      "    };",
      "    if (_isPizzaOrCalzone()) {",
      "      if (pizzaSizeMap.containsKey(uiSize)) return pizzaSizeMap[uiSize]!;",
      "      final lowerUi = uiSize.toLowerCase();",
      "      for (final key in pizzaSizeMap.keys) {",
      "        if (key.toLowerCase() == lowerUi ||",
      "            key.toLowerCase().contains(lowerUi)) {",
      "          return pizzaSizeMap[key]!;",
      "        }",
      "      }",
      "    }",
      "    return uiSize; // guaranteed not null by above",
      "  }",
      "",
      "  bool _showsCurrentIngredients() {",
      "    final cat = widget.menuItem.category.toLowerCase();",
      "    final catId = (widget.menuItem.categoryId ?? '').toLowerCase();",
      "    return [cat, catId].any((c) =>",
      "        c.contains('pizza') ||",
      "        c.contains('calzone') ||",
      "        c.contains('salad') ||",
      "        c.contains('sub'));",
      "  }",
      "",
      "  bool _isPizzaOrCalzone() {",
      "    final cat = widget.menuItem.category.toLowerCase();",
      "    return cat.contains('pizza') || cat.contains('calzone');",
      "  }",
      "",
      "  bool _isCalzone() {",
      "    return widget.menuItem.category.toLowerCase().contains('calzone');",
      "  }",
      "",
      "  bool _isWings() {",
      "    final name = widget.menuItem.name.toLowerCase();",
      "    return name.contains('wings');",
      "  }",
      "",
      "  bool _showPortionToggle(String groupLabel) {",
      "    if (!_isPizzaOrCalzone()) return false;",
      "    return groupLabel == \"Meats\" ||",
      "        groupLabel == \"Veggies\" ||",
      "        groupLabel == \"Cheeses\";",
      "  }",
      "",
      "  @override",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    //print('[DEBUG] MenuItem for customization: ${widget.menuItem.toMap()}');",
      "",
      "    // --- Initialize cheeses state (self-contained) ---",
      "    final cheeseGroup = widget.menuItem.customizationGroups?.firstWhereOrNull(",
      "        (g) => (g['label'] as String).toLowerCase() == 'cheeses');",
      "    final cheeseIds =",
      "        (cheeseGroup?['ingredientIds'] as List?)?.cast<String>() ?? [];",
      "    _selectedCheeses = {",
      "      ...?widget.menuItem.includedIngredients",
      "          ?.where((i) => cheeseIds.contains(i['ingredientId'] ?? i['id']))",
      "          .map((i) => i['ingredientId'] ?? i['id'])",
      "    };",
      "    _cheesePortions = {};",
      "    _cheeseIsDouble = {};",
      "    for (final id in _selectedCheeses) {",
      "      _cheesePortions[id] = Portion.whole;",
      "      _cheeseIsDouble[id] = false;",
      "    }",
      "",
      "    _quantity = widget.initialQuantity;",
      "    _ingredientMetadata = widget.ingredientMetadata ??",
      "        Provider.of<Map<String, IngredientMetadata>>(context, listen: false);",
      "    final sizes = widget.menuItem.sizes;",
      "    _selectedSize = (sizes != null && sizes.isNotEmpty) ? sizes.first : null;",
      "    _drinkFlavorCounts = {};",
      "    if (_isPizza()) {",
      "      final saucesGroup = widget.menuItem.customizationGroups?.firstWhereOrNull(",
      "          (g) => (g['label'] as String).toLowerCase() == 'sauces');",
      "      final sauceIds =",
      "          (saucesGroup?['ingredientIds'] as List?)?.cast<String>() ?? [];",
      "      _pizzaSauceSelections = sauceIds.map((id) {",
      "        final meta = _ingredientMetadata[id];",
      "        return PizzaSauceSelection(",
      "          id: id,",
      "          name: meta?.name ?? id,",
      "          selected: false,",
      "          portion: Portion.whole,",
      "          amount: 'regular',",
      "        );",
      "      }).toList();",
      "",
      "      // Default to first available sauce, 'whole'",
      "      if (_pizzaSauceSelections.isNotEmpty) {",
      "        _pizzaSauceSelections[0].selected = true;",
      "        _pizzaSauceSelections[0].portion = Portion.whole;",
      "      }",
      "    }",
      "    _initializeSelections();",
      "    if (_isPizza()) {",
      "      // Find default sauce (first from sauces group, fallback to included ingredient, fallback to null)",
      "      final saucesGroup = widget.menuItem.customizationGroups?.firstWhereOrNull(",
      "          (g) => (g['label'] as String).toLowerCase() == 'sauces');",
      "      final sauceIds =",
      "          (saucesGroup?['ingredientIds'] as List?)?.cast<String>() ?? [];",
      "      // Default: included sauce or first from group, or 'sauce_none'",
      "      final includedSauceId =",
      "          widget.menuItem.includedIngredients?.firstWhereOrNull(",
      "        (ing) => (ing['type']?.toString()?.toLowerCase() == 'sauces'),",
      "      )?['ingredientId'];",
      "      _selectedPizzaSauceId = includedSauceId ??",
      "          (sauceIds.isNotEmpty ? sauceIds.first : 'sauce_none');",
      "      _selectedSaucePortion = 'whole';",
      "      _selectedSauceAmount = 'regular';",
      "    }",
      "    _sortCustomizationGroups();",
      "    // Setup pizza/calzone topping tabs for \"Meats\" and \"Veggies\" ONLY",
      "    if (_isPizzaOrCalzone() && widget.menuItem.customizationGroups != null) {",
      "      _toppingTabGroups = widget.menuItem.customizationGroups!",
      "          .where((g) => (g['label']?.toString().toLowerCase() == 'meats' ||",
      "              g['label']?.toString().toLowerCase() == 'veggies'))",
      "          .toList();",
      "      _toppingTabLabels =",
      "          _toppingTabGroups.map((g) => g['label'].toString()).toList();",
      "      _selectedToppingTab =",
      "          _toppingTabLabels.isNotEmpty ? _toppingTabLabels.first : '';",
      "    } else {",
      "      _toppingTabLabels = [];",
      "      _selectedToppingTab = '';",
      "      _toppingTabGroups = [];",
      "    }",
      "",
      "    _initializeSauceCounts();",
      "    _initializeDressingCounts();",
      "",
      "    // --- Wings initialization ---",
      "    if (_isWings()) {",
      "      final sizes = widget.menuItem.sizes ?? [];",
      "      _selectedSize ??= sizes.isNotEmpty ? sizes.first : null;",
      "      final splitCount = widget.menuItem.dippingSplits?[_selectedSize] ?? 2;",
      "      _selectedDippedSauces = {};",
      "      final sauceOptions = widget.menuItem.dippingSauceOptions ?? [];",
      "      for (var i = 0; i < splitCount; i++) {",
      "        _selectedDippedSauces['split_$i'] = \"plain\";",
      "      }",
      "",
      "      _isAnyDipped = false;",
      "      _sideDipCounts = {};",
      "      final sideOptions = widget.menuItem.sideDipSauceOptions ?? [];",
      "      for (final id in sideOptions) {",
      "        _sideDipCounts[id] = 0;",
      "      }",
      "    }",
      "",
      "    // --- Initialize ingredientAmounts for amountSelectable included ingredients ---",
      "    if (widget.menuItem.includedIngredients != null) {",
      "      for (final ing in widget.menuItem.includedIngredients!) {",
      "        // First: check if present in ingredient_metadata, else fallback to map",
      "        final ingId = ing['ingredientId'] ?? ing['id'];",
      "        final meta = _ingredientMetadata[ingId];",
      "        final List<String>? options = meta?.amountOptions ??",
      "            (ing['amountOptions'] is List",
      "                ? List<String>.from(ing['amountOptions'])",
      "                : null);",
      "        final bool selectable = meta?.amountSelectable ??",
      "            (ing['amountSelectable'] == true && options != null);",
      "",
      "        if (selectable && options != null && options.isNotEmpty) {",
      "          // Prefer 'Regular' as default, fallback to first option",
      "          _ingredientAmounts[ingId] = options.firstWhere(",
      "            (opt) => opt.toLowerCase() == 'regular',",
      "            orElse: () => options.first,",
      "          );",
      "        }",
      "      }",
      "    }",
      "    if (widget.menuItem.category.toLowerCase() == 'drinks') {",
      "      _drinkFlavorCounts = {};",
      "      _drinkTotalCount = 0;",
      "      // Try to get maxPerFlavor from Firestore field, else fallback",
      "      _drinkMaxPerFlavor =",
      "          (widget.menuItem.toMap()['maxPerFlavor'] as int?) ?? 10;",
      "      for (final ing in widget.menuItem.includedIngredients ?? []) {",
      "        final ingId = ing['ingredientId'] ?? ing['id'];",
      "        _drinkFlavorCounts[ingId] = 0;",
      "      }",
      "    }",
      "  }",
      "",
      "  void _initializeSelections() {",
      "    _currentIngredients = {};",
      "    if (widget.menuItem.includedIngredients != null) {",
      "      for (final ing in widget.menuItem.includedIngredients!) {",
      "        final ingId = ing['ingredientId'] ?? ing['id'];",
      "        _currentIngredients.add(ingId);",
      "      }",
      "    }",
      "    _groupSelections = {};",
      "    _radioSelections = {};",
      "    if (widget.menuItem.customizationGroups != null) {",
      "      for (final group in widget.menuItem.customizationGroups!) {",
      "        final groupLabel = group['label'];",
      "        final ids = (group['ingredientIds'] as List<dynamic>? ?? [])",
      "            .map((e) => e.toString())",
      "            .toList();",
      "",
      "        // --- Default Cook to Regular for Calzones ---",
      "        if (groupLabel.toLowerCase() == 'cook' &&",
      "            widget.menuItem.category.toLowerCase().contains('calzone')) {",
      "          _radioSelections[groupLabel] =",
      "              ids.contains('cook_regular') ? 'cook_regular' : ids.first;",
      "          _currentIngredients.add(_radioSelections[groupLabel]!);",
      "          continue;",
      "        }",
      "",
      "        if (_isRadioGroup(groupLabel)) {",
      "          final included = ids.firstWhere(",
      "            (id) => _currentIngredients.contains(id),",
      "            orElse: () => ids.isNotEmpty ? ids.first : '',",
      "          );",
      "          _radioSelections[groupLabel] = included;",
      "        } else {",
      "          _groupSelections[groupLabel] = <String>{};",
      "        }",
      "      }",
      "    }",
      "",
      "    _selectedAddOns = {};",
      "  }",
      "",
      "  void _initializeSauceCounts() {",
      "    if (widget.menuItem.customizationGroups != null) {",
      "      for (final group in widget.menuItem.customizationGroups!) {",
      "        final label = (group['label'] as String?)?.toLowerCase();",
      "        if (label == 'sauces') {",
      "          final ids = (group['ingredientIds'] as List<dynamic>? ?? [])",
      "              .map((e) => e.toString())",
      "              .toList();",
      "          for (final id in ids) {",
      "            _selectedSauceCounts[id] = 0;",
      "          }",
      "        }",
      "      }",
      "    }",
      "    // Also init for optionalAddOns that are sauces (for appetizers, etc)",
      "    if (widget.menuItem.optionalAddOns != null) {",
      "      for (final addOn in widget.menuItem.optionalAddOns!) {",
      "        final ingId = addOn['ingredientId'] ?? addOn['id'];",
      "        final meta = _ingredientMetadata[ingId];",
      "        if (meta?.type?.toLowerCase() == \"sauces\" ||",
      "            addOn['type']?.toString()?.toLowerCase() == \"sauces\") {",
      "          _selectedSauceCounts[ingId] = 0;",
      "        }",
      "      }",
      "    }",
      "  }",
      "",
      "  void _initializeDressingCounts() {",
      "    if (widget.menuItem.customizationGroups != null) {",
      "      for (final group in widget.menuItem.customizationGroups!) {",
      "        final label = (group['label'] as String?)?.toLowerCase();",
      "        if (label == 'dressings') {",
      "          final ids = (group['ingredientIds'] as List<dynamic>? ?? [])",
      "              .map((e) => e.toString())",
      "              .toList();",
      "          for (final id in ids) {",
      "            _selectedDressingCounts[id] = 0;",
      "          }",
      "        }",
      "      }",
      "    }",
      "  }",
      "",
      "  void _sortCustomizationGroups() {",
      "    _checkboxGroups = [];",
      "    _radioGroups = [];",
      "    if (widget.menuItem.customizationGroups != null) {",
      "      for (final group in widget.menuItem.customizationGroups!) {",
      "        final groupLabel = (group['label'] ?? '').toString();",
      "        final isSauceGroup = groupLabel.toLowerCase() == 'sauces';",
      "        final isDressingGroup = groupLabel.toLowerCase() == 'dressings';",
      "        if (_isRadioGroup(groupLabel) || isSauceGroup || isDressingGroup) {",
      "          _radioGroups.add(group);",
      "        } else {",
      "          // Exclude \"Meats\" and \"Veggies\" for pizza/calzone, they'll be handled as tabs",
      "          if (!_isPizzaOrCalzone() ||",
      "              (groupLabel.toLowerCase() != 'meats' &&",
      "                  groupLabel.toLowerCase() != 'veggies')) {",
      "            _checkboxGroups.add(group);",
      "          }",
      "        }",
      "      }",
      "    }",
      "  }",
      "",
      "  bool _isRadioGroup(String label) {",
      "    final lower = label.toLowerCase();",
      "    return lower == 'crust' || lower == 'cook' || lower == 'cut';",
      "  }",
      "",
      "  bool _isDoughIngredient(String? ingId) =>",
      "      ingId != null && DOUGH_IDS.contains(ingId.toLowerCase());",
      "",
      "  bool _canDoubleCurrentIngredient(String? groupLabel) {",
      "    final cat = widget.menuItem.category.toLowerCase();",
      "    if (cat.contains('pizza') || cat.contains('calzone')) {",
      "      return groupLabel != null &&",
      "          (groupLabel == \"Meats\" ||",
      "              groupLabel == \"Veggies\" ||",
      "              groupLabel == \"Cheeses\");",
      "    }",
      "    if (cat.contains('sub') || cat.contains('salad')) {",
      "      return true;",
      "    }",
      "    return false;",
      "  }",
      "",
      "  bool _isPizza() {",
      "    final cat = widget.menuItem.category.toLowerCase();",
      "    return cat.contains('pizza');",
      "  }",
      "",
      "  Map<String, bool> _getPizzaSaucePortionDisables(int sauceIdx) {",
      "    if (!_isPizza()) return {};",
      "    final selected = _pizzaSauceSelections;",
      "    // Find which sides (left/right/whole) are already used",
      "    int leftIdx = -1, rightIdx = -1, wholeIdx = -1;",
      "    for (int i = 0; i < selected.length; i++) {",
      "      if (!selected[i].selected) continue;",
      "      if (selected[i].portion == Portion.whole) wholeIdx = i;",
      "      if (selected[i].portion == Portion.left) leftIdx = i;",
      "      if (selected[i].portion == Portion.right) rightIdx = i;",
      "    }",
      "",
      "    // Default: nothing disabled",
      "    bool disableLeft = false, disableRight = false, disableWhole = false;",
      "",
      "    // If another sauce is selected as whole, only allow this to be whole if this is that sauce, otherwise disable all toggles",
      "    if (wholeIdx != -1 && wholeIdx != sauceIdx) {",
      "      disableLeft = true;",
      "      disableRight = true;",
      "      disableWhole = true;",
      "    } else if ((leftIdx != -1 && leftIdx != sauceIdx) &&",
      "        (rightIdx != -1 && rightIdx != sauceIdx)) {",
      "      // If both halves are taken and this isn't one of them, everything disabled",
      "      disableLeft = true;",
      "      disableRight = true;",
      "      disableWhole = true;",
      "    } else if (leftIdx != -1 && leftIdx != sauceIdx) {",
      "      // If Left is taken elsewhere, only Right is allowed here",
      "      disableLeft = true;",
      "      disableWhole = true;",
      "    } else if (rightIdx != -1 && rightIdx != sauceIdx) {",
      "      // If Right is taken elsewhere, only Left is allowed here",
      "      disableRight = true;",
      "      disableWhole = true;",
      "    }",
      "    // If this sauce isn't selected, and 2 sauces are already selected, don't allow selecting more",
      "    if (!selected[sauceIdx].selected &&",
      "        selected.where((s) => s.selected).length >= 2) {",
      "      disableLeft = true;",
      "      disableRight = true;",
      "      disableWhole = true;",
      "    }",
      "",
      "    return {",
      "      'left': disableLeft,",
      "      'right': disableRight,",
      "      'whole': disableWhole,",
      "    };",
      "  }",
      "",
      "  double _getToppingUpcharge() {",
      "    final prices = widget.menuItem.additionalToppingPrices;",
      "    final key = _normalizeSizeKey(_selectedSize?.label);",
      "    if (prices != null && key != null && prices[key] != null) {",
      "      return (prices[key] as num).toDouble();",
      "    }",
      "    return 0.0;",
      "  }",
      "",
      "  double _getIngredientUpcharge(IngredientMetadata? meta) {",
      "    if (meta == null) return 0.0;",
      "    if (meta.upcharge != null && meta.upcharge!.isNotEmpty) {",
      "      return meta.upcharge!.values.first;",
      "    }",
      "    return 0.0;",
      "  }",
      "",
      "  int _getFreeSauceCount() {",
      "    // Use freeSauceCount for sauces, and fallback to 2 if missing",
      "    final value = widget.menuItem.freeSauceCount;",
      "    if (value is Map) {",
      "      final key = _normalizeSizeKey(_selectedSize?.label);",
      "",
      "      return (key != null && value[key] != null) ? value[key] as int : 0;",
      "    }",
      "    if (value is int) return value;",
      "    return 0;",
      "  }",
      "",
      "  double _getExtraSauceUpcharge() {",
      "    // Use extraSauceUpcharge if present, fallback to 0.95",
      "    return (widget.menuItem.extraSauceUpcharge as num?)?.toDouble() ?? 0.95;",
      "  }",
      "",
      "  int _getFreeDressingCount() {",
      "    final value =",
      "        widget.menuItem.freeDressingCount ?? widget.menuItem.freeSauceCount;",
      "    if (value is Map) {",
      "      final key = _normalizeSizeKey(_selectedSize?.label);",
      "",
      "      return (key != null && value[key] != null) ? value[key] as int : 0;",
      "    }",
      "    if (value is int) return value;",
      "    return 0;",
      "  }",
      "",
      "  double _getExtraDressingUpcharge() {",
      "    return (widget.menuItem.extraDressingUpcharge as num?)?.toDouble() ??",
      "        (widget.menuItem.extraSauceUpcharge as num?)?.toDouble() ??",
      "        0.50;",
      "  }",
      "",
      "  double _getSaladToppingUpcharge() {",
      "    final prices = widget.menuItem.additionalToppingPrices;",
      "    final key = _normalizeSizeKey(_selectedSize?.label);",
      "",
      "    if (prices != null && key != null && prices[key] != null) {",
      "      return (prices[key] as num).toDouble();",
      "    }",
      "    return 0.80;",
      "  }",
      "",
      "  double get _customizationsTotal {",
      "    double total = 0.0;",
      "    final usesDynamicToppingPricing =",
      "        widget.menuItem.additionalToppingPrices != null &&",
      "            _selectedSize != null;",
      "",
      "    // 1. Add-ons",
      "    if (widget.menuItem.optionalAddOns != null) {",
      "      for (final addOn in widget.menuItem.optionalAddOns!) {",
      "        final ingId = addOn['ingredientId'] ?? addOn['id'];",
      "        if (_selectedAddOns.contains(ingId)) {",
      "          final meta = _ingredientMetadata[ingId];",
      "          double upcharge = usesDynamicToppingPricing",
      "              ? _getToppingUpcharge()",
      "              : (meta != null",
      "                  ? _getIngredientUpcharge(meta)",
      "                  : (addOn['price'] as num?)?.toDouble() ?? 0.0);",
      "          int multiplier = _doubleAddOns[ingId] == true ? 2 : 1;",
      "          total += upcharge * multiplier;",
      "        }",
      "      }",
      "    }",
      "",
      "    // 2. Dressings (stepper logic for salads, etc)",
      "    if (_selectedDressingCounts.isNotEmpty) {",
      "      final int freeDressings = _getFreeDressingCount();",
      "      final double extraDressingUpcharge = _getExtraDressingUpcharge();",
      "      final totalDressings =",
      "          _selectedDressingCounts.values.fold(0, (a, b) => a + b);",
      "      final extraDressings =",
      "          totalDressings > freeDressings ? (totalDressings - freeDressings) : 0;",
      "      total += extraDressings * extraDressingUpcharge;",
      "    }",
      "",
      "    // 3. Sauces (stepper logic for sauces as customization group or add-on)",
      "    if (_selectedSauceCounts.isNotEmpty) {",
      "      final int freeSauces = _getFreeSauceCount();",
      "      final double extraSauceUpcharge = _getExtraSauceUpcharge();",
      "      final totalSauces = _selectedSauceCounts.values.fold(0, (a, b) => a + b);",
      "      final extraSauces =",
      "          totalSauces > freeSauces ? (totalSauces - freeSauces) : 0;",
      "      total += extraSauces * extraSauceUpcharge;",
      "    }",
      "",
      "    // --- Wings Side Dip Pricing ---",
      "    if (_isWings()) {",
      "      final upcharge = widget.menuItem.sideDipUpcharge?[_selectedSize] ?? 0.95;",
      "      final freeDips = widget.menuItem.freeDipCupCount?[_selectedSize] ?? 0;",
      "      // Only dips in dippingSauceOptions are eligible as \"free\"",
      "      final dipIds = widget.menuItem.dippingSauceOptions ?? [];",
      "      final totalDipCups = dipIds.fold<int>(",
      "        0,",
      "        (sum, id) => sum + (_sideDipCounts[id] ?? 0),",
      "      );",
      "      final extraDips = (totalDipCups - freeDips).clamp(0, 1000);",
      "      total += extraDips * upcharge;",
      "",
      "      // Now always upcharge for sauces (add-ons of type \"sauces\")",
      "      final sauceAddOnIds = (widget.menuItem.optionalAddOns ?? [])",
      "          .where((a) => (a['type']?.toString()?.toLowerCase() == 'sauces'))",
      "          .map((a) => a['ingredientId'] ?? a['id'])",
      "          .toList();",
      "      for (final id in sauceAddOnIds) {",
      "        final count = _sideDipCounts[id] ?? 0;",
      "        total += count * upcharge; // No \"free\" sauces—always upcharge",
      "      }",
      "    }",
      "",
      "    // 4. Ingredients (included or not) - handle doubles robustly!",
      "    for (final ingId in _currentIngredients) {",
      "      if (_isDoughIngredient(ingId)) continue;",
      "      if (_selectedSauceCounts.containsKey(ingId)) continue; // skip sauces",
      "      if (_selectedDressingCounts.containsKey(ingId))",
      "        continue; // skip dressings",
      "",
      "      final meta = _ingredientMetadata[ingId];",
      "",
      "      // **NEW: skip Crust type (never charge for crust selection)**",
      "      if (meta?.type?.toLowerCase() == 'crust' ||",
      "          meta?.type?.toLowerCase() == 'cook') continue;",
      "",
      "      final cat = widget.menuItem.category.toLowerCase();",
      "      final isSalad = cat.contains('salad');",
      "      final wasIncluded = (widget.menuItem.includedIngredients?.any(",
      "            (e) => (e['ingredientId'] ?? e['id']) == ingId,",
      "          ) ??",
      "          false);",
      "",
      "      double upcharge = usesDynamicToppingPricing",
      "          ? _getToppingUpcharge()",
      "          : _getIngredientUpcharge(meta);",
      "",
      "      final isDouble = _doubleToppings[ingId] == true;",
      "",
      "      if (isSalad) {",
      "        // SALADS: Only apply upcharge for double, never for simple re-adding",
      "        if (wasIncluded) {",
      "          if (isDouble) total += upcharge;",
      "          // else no upcharge, even if toggled off/on",
      "        } else {",
      "          // Not included: always apply upcharge (regular/double)",
      "          total += upcharge * (isDouble ? 2 : 1);",
      "        }",
      "      } else {",
      "        // All other categories: original logic",
      "        if (wasIncluded) {",
      "          if (isDouble) total += upcharge;",
      "        } else {",
      "          total += upcharge * (isDouble ? 2 : 1);",
      "        }",
      "      }",
      "    }",
      "",
      "    return total;",
      "  }",
      "",
      "  double get _basePrice {",
      "    final key = _normalizeSizeKey(_selectedSize?.label);",
      "",
      "    if (key != null &&",
      "        widget.menuItem.sizePrices != null &&",
      "        widget.menuItem.sizePrices![key] != null) {",
      "      return (widget.menuItem.sizePrices![key] as num).toDouble();",
      "    }",
      "    return widget.menuItem.price;",
      "  }",
      "",
      "  double get _totalPrice => (_basePrice + _customizationsTotal) * _quantity;",
      "",
      "  int get _doublesCount =>",
      "      _doubleToppings.values.where((isDouble) => isDouble).length;",
      "",
      "  void _toggleIngredient(String ingId, String groupLabel) {",
      "    setState(() {",
      "      if (_currentIngredients.contains(ingId)) {",
      "        _currentIngredients.remove(ingId);",
      "        _doubleToppings.remove(ingId);",
      "        _ingredientPortions.remove(ingId);",
      "      } else {",
      "        _currentIngredients.add(ingId);",
      "        if (_isPizzaOrCalzone()) {",
      "          _doubleToppings[ingId] = false;",
      "          _ingredientPortions[ingId] = Portion.whole;",
      "        }",
      "      }",
      "    });",
      "  }",
      "",
      "  void _handleDoubleChanged(String ingId, bool value) {",
      "    if (!value && _doubleToppings[ingId] != true) return;",
      "    setState(() {",
      "      if (value && _doublesCount >= MAX_DOUBLES) return;",
      "      _doubleToppings[ingId] = value;",
      "    });",
      "  }",
      "",
      "  void _handlePortionChanged(String ingId, Portion? portion) {",
      "    if (portion == null) return;",
      "    setState(() {",
      "      _ingredientPortions[ingId] = portion;",
      "    });",
      "  }",
      "",
      "  void _handleRadioSelect(String groupLabel, String? ingId) {",
      "    setState(() {",
      "      _radioSelections[groupLabel] = ingId;",
      "      if (widget.menuItem.customizationGroups != null) {",
      "        final group = widget.menuItem.customizationGroups!.firstWhere(",
      "            (g) => (g['label'] as String) == groupLabel,",
      "            orElse: () => {});",
      "        final ids = (group['ingredientIds'] as List<dynamic>? ?? [])",
      "            .map((e) => e.toString())",
      "            .toList();",
      "        for (final id in ids) {",
      "          _currentIngredients.remove(id);",
      "        }",
      "        if (ingId != null && ingId.isNotEmpty) _currentIngredients.add(ingId);",
      "      }",
      "    });",
      "  }",
      "",
      "  void _submit() {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[YourWidget] loc is null! Localization not available for this context.');",
      "      // Show error to user if needed, e.g. using a SnackBar:",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(content: Text('Localization missing! [debug]')),",
      "      );",
      "      return;",
      "    }",
      "    setState(() => _error = null);",
      "",
      "    // --- RADIO GROUP VALIDATION ---",
      "    if (widget.menuItem.customizationGroups != null) {",
      "      for (final group in widget.menuItem.customizationGroups!) {",
      "        final groupLabel = group['label'];",
      "        if ((_isRadioGroup(groupLabel)) &&",
      "            (_radioSelections[groupLabel] == null ||",
      "                _radioSelections[groupLabel]!.isEmpty)) {",
      "          setState(() => _error =",
      "              loc.pleaseSelectRequired.replaceFirst('{name}', groupLabel));",
      "          return;",
      "        }",
      "      }",
      "    }",
      "",
      "    // --- PIZZA SAUCE SPLIT VALIDATION ---",
      "    if (_isPizza()) {",
      "      final selected = _pizzaSauceSelections.where((s) => s.selected).toList();",
      "",
      "      final halves = selected.where((s) => s.portion != Portion.whole).toList();",
      "      if (halves.length == 1) {",
      "        setState(() => _sauceSplitValidationError = true);",
      "        return; // Must choose both halves or none!",
      "      }",
      "      if (selected.length > 2) {",
      "        setState(() => _sauceSplitValidationError = true);",
      "        return; // No more than 2!",
      "      }",
      "      // Validate no duplicate side selection (can't have two 'lefts' or two 'rights')",
      "      if (halves.length == 2) {",
      "        final sides = halves.map((s) => s.portion).toSet();",
      "        if (sides.length < 2) {",
      "          setState(() => _sauceSplitValidationError = true);",
      "          return;",
      "        }",
      "      }",
      "      setState(() => _sauceSplitValidationError = false);",
      "    }",
      "",
      "    final Map<String, dynamic> ingredientOptions = {};",
      "    if (_isPizzaOrCalzone()) {",
      "      for (final ingId in _currentIngredients) {",
      "        if (_doubleToppings.containsKey(ingId) ||",
      "            _ingredientPortions.containsKey(ingId)) {",
      "          ingredientOptions[ingId] = {",
      "            'double': _doubleToppings[ingId] == true,",
      "            'portion': _ingredientPortions[ingId]?.toString().split('.').last ??",
      "                'whole',",
      "          };",
      "        }",
      "      }",
      "    }",
      "",
      "    // Only include sauces with a count > 0",
      "    final nonZeroSauces = Map.fromEntries(",
      "      _selectedSauceCounts.entries.where((e) => e.value > 0),",
      "    );",
      "    final nonZeroDressings = Map.fromEntries(",
      "      _selectedDressingCounts.entries.where((e) => e.value > 0),",
      "    );",
      "",
      "    // Add cheese selections to submission result",
      "    final Map<String, dynamic> cheeseOptions = {};",
      "    for (final cheeseId in _selectedCheeses) {",
      "      cheeseOptions[cheeseId] = {",
      "        'portion':",
      "            _cheesePortions[cheeseId]?.toString().split('.').last ?? 'whole',",
      "        'double': _cheeseIsDouble[cheeseId] == true,",
      "      };",
      "    }",
      "",
      "    final Map<String, dynamic> result = {",
      "      'currentIngredients': _currentIngredients",
      "          .where((id) => !_selectedDressingCounts.containsKey(id))",
      "          .toList(),",
      "      'groupSelections':",
      "          _groupSelections.map((k, v) => MapEntry(k, v.toList())),",
      "      'selectedAddOns': _selectedAddOns.toList(),",
      "      'size': _selectedSize,",
      "      ..._radioSelections,",
      "      if (ingredientOptions.isNotEmpty) 'ingredientOptions': ingredientOptions,",
      "      if (_selectedCheeses.isNotEmpty) 'cheeses': _selectedCheeses.toList(),",
      "      if (cheeseOptions.isNotEmpty) 'cheeseOptions': cheeseOptions,",
      "      if (nonZeroSauces.isNotEmpty) 'sauces': nonZeroSauces,",
      "      if (nonZeroDressings.isNotEmpty) 'dressings': nonZeroDressings,",
      "    };",
      "",
      "    // --- Wings-specific ---",
      "    if (_isWings()) {",
      "      result['dippedSplits'] = _isAnyDipped",
      "          ? _selectedDippedSauces.values.where((v) => v != null).toList()",
      "          : [];",
      "      result['isAnyDipped'] = _isAnyDipped;",
      "      result['sideDipCups'] = Map<String, int>.from(_sideDipCounts);",
      "    }",
      "",
      "    if (_ingredientAmounts.isNotEmpty) {",
      "      result['ingredientAmounts'] = {..._ingredientAmounts};",
      "    }",
      "",
      "    // --- PIZZA: Capture full split sauce selection ---",
      "    if (_isPizza()) {",
      "      final selected = _pizzaSauceSelections.where((s) => s.selected).toList();",
      "      result['sauce'] = selected",
      "          .map((s) => {",
      "                'id': s.id,",
      "                'portion': s.portion.toString().split('.').last,",
      "                'amount': s.amount,",
      "              })",
      "          .toList();",
      "    }",
      "",
      "    widget.onConfirm(",
      "      result,",
      "      _quantity,",
      "      _totalPrice,",
      "    );",
      "    Navigator.of(context).pop();",
      "  }",
      "",
      "  @override",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final theme = Theme.of(context);",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "",
      "    return Dialog(",
      "      shape: RoundedRectangleBorder(",
      "        borderRadius: BorderRadius.circular(DesignTokens.cardRadius),",
      "      ),",
      "      backgroundColor: DesignTokens.surfaceColor,",
      "      child: ConstrainedBox(",
      "        constraints: BoxConstraints(",
      "          maxHeight: MediaQuery.of(context).size.height * 0.85,",
      "          minWidth: 300,",
      "          maxWidth: 440,",
      "        ),",
      "        child: Padding(",
      "          padding: DesignTokens.cardPadding,",
      "          child: Column(",
      "            mainAxisSize: MainAxisSize.min,",
      "            children: [",
      "              Flexible(",
      "                child: SingleChildScrollView(",
      "                  child: Column(",
      "                    crossAxisAlignment: CrossAxisAlignment.start,",
      "                    children: [",
      "                      CustomizationHeader(",
      "                        menuItem: widget.menuItem,",
      "                        theme: theme,",
      "                        loc: loc,",
      "                      ),",
      "                      SizedBox(height: DesignTokens.gridSpacing),",
      "                      if (widget.menuItem.category.toLowerCase() != 'drinks' &&",
      "                          widget.menuItem.sizes != null &&",
      "                          widget.menuItem.sizes!.isNotEmpty)",
      "                        SizeDropdown(",
      "                          menuItem: widget.menuItem,",
      "                          selectedSize: _selectedSize?.label,",
      "                          onChanged: (String? newLabel) {",
      "                            setState(() {",
      "                              _selectedSize = widget.menuItem.sizes?.firstWhere(",
      "                                (s) => s.label == newLabel,",
      "                                orElse: () => widget.menuItem.sizes!.first,",
      "                              );",
      "                            });",
      "                          },",
      "                          toppingCostLabel: _isPizzaOrCalzone()",
      "                              ? ToppingCostLabel(",
      "                                  theme: theme,",
      "                                  loc: loc,",
      "                                  getToppingUpcharge: _getToppingUpcharge,",
      "                                  currencyFormat: currencyFormat,",
      "                                )",
      "                              : null,",
      "                          normalizeSizeKey: _normalizeSizeKey,",
      "                        ),",
      "",
      "                      if (_isWings()) ...[",
      "                        WingsPortionSelector(",
      "                          menuItem: widget.menuItem,",
      "                          theme: theme,",
      "                          loc: loc,",
      "                          selectedSize: _selectedSize?.label,",
      "                          ingredientMetadata: _ingredientMetadata,",
      "                          selectedDippedSauces: Map.fromEntries(",
      "                            _selectedDippedSauces.entries",
      "                                .where((e) => e.value != null)",
      "                                .map((e) => MapEntry(e.key, e.value!)),",
      "                          ),",
      "                          setState: setState,",
      "                        ),",
      "                        WingsDipSauceSelector(",
      "                          menuItem: widget.menuItem,",
      "                          theme: theme,",
      "                          loc: loc,",
      "                          ingredientMetadata: _ingredientMetadata,",
      "                          sideDipCounts: _sideDipCounts,",
      "                          wingsDipSauceTabIndex: _wingsDipSauceTabIndex,",
      "                          setState: setState,",
      "                          onTabChanged: (newIndex) {",
      "                            setState(() {",
      "                              _wingsDipSauceTabIndex = newIndex;",
      "                            });",
      "                          },",
      "                        ),",
      "                        WingsOptionalAddOnsGroup(",
      "                          menuItem: widget.menuItem,",
      "                          theme: theme,",
      "                          loc: loc,",
      "                          ingredientMetadata: _ingredientMetadata,",
      "                          selectedAddOns: _selectedAddOns,",
      "                          doubleAddOns: _doubleAddOns,",
      "                          setState: setState,",
      "                          onChanged: (ingId, checked) {",
      "                            if (checked) {",
      "                              _selectedAddOns.add(ingId);",
      "                              _doubleAddOns[ingId] = false;",
      "                            } else {",
      "                              _selectedAddOns.remove(ingId);",
      "                              _doubleAddOns.remove(ingId);",
      "                            }",
      "                          },",
      "                        ),",
      "                      ],",
      "                      if (widget.menuItem.category.toLowerCase() == 'drinks')",
      "                        DrinksFlavorSelector(",
      "                          menuItem: widget.menuItem,",
      "                          theme: theme,",
      "                          loc: loc,",
      "                          ingredientMetadata: _ingredientMetadata,",
      "                          selectedSauceCounts: _selectedSauceCounts,",
      "                          setState: setState,",
      "                        )",
      "                      else if (widget.menuItem.category.toLowerCase() ==",
      "                          'dinners')",
      "                        DinnerIncludedIngredients(",
      "                          menuItem: widget.menuItem,",
      "                          theme: theme,",
      "                          loc: loc,",
      "                          ingredientMetadata: _ingredientMetadata,",
      "                          currentIngredients: _currentIngredients,",
      "                          ingredientAmounts: _ingredientAmounts,",
      "                          setState: setState,",
      "                        )",
      "                      else if (_showsCurrentIngredients())",
      "                        Column(",
      "                          crossAxisAlignment: CrossAxisAlignment.start,",
      "                          children: [",
      "                            Padding(",
      "                              padding:",
      "                                  const EdgeInsets.only(top: 10, bottom: 10),",
      "                              child: Container(",
      "                                width: double.infinity,",
      "                                decoration: BoxDecoration(",
      "                                  color: DesignTokens.primaryColor,",
      "                                  borderRadius: BorderRadius.circular(6),",
      "                                ),",
      "                                padding: const EdgeInsets.symmetric(",
      "                                    vertical: 8, horizontal: 14),",
      "                                child: Text(",
      "                                  \"Current Toppings\",",
      "                                  style: theme.textTheme.titleMedium?.copyWith(",
      "                                    color: Colors.white,",
      "                                    fontWeight: FontWeight.bold,",
      "                                  ),",
      "                                ),",
      "                              ),",
      "                            ),",
      "                            ..._currentIngredients.where((id) {",
      "                              final meta = _ingredientMetadata[id];",
      "                              // Exclude dressing, sauce, and crust types from \"Current Toppings\"",
      "                              final type = meta?.type?.toLowerCase() ?? '';",
      "                              return !_selectedDressingCounts.containsKey(id) &&",
      "                                  !_selectedSauceCounts.containsKey(id) &&",
      "                                  type != 'crust' &&",
      "                                  type != 'cheeses';",
      "                            }).map((ingId) {",
      "                              final meta = _ingredientMetadata[ingId];",
      "                              return Card(",
      "                                margin: EdgeInsets.symmetric(",
      "                                    vertical: 2, horizontal: 0),",
      "                                child: Padding(",
      "                                  padding: EdgeInsets.symmetric(",
      "                                      vertical: 8, horizontal: 12),",
      "                                  child: Column(",
      "                                    crossAxisAlignment:",
      "                                        CrossAxisAlignment.start,",
      "                                    children: [",
      "                                      // ...rest of your row/ingredient UI...",
      "                                      Row(",
      "                                        crossAxisAlignment:",
      "                                            CrossAxisAlignment.center,",
      "                                        children: [",
      "                                          Expanded(",
      "                                            child: Text(",
      "                                              meta?.name ?? ingId,",
      "                                              style: theme.textTheme.bodyLarge,",
      "                                              overflow: TextOverflow.ellipsis,",
      "                                            ),",
      "                                          ),",
      "                                          TextButton(",
      "                                            style: TextButton.styleFrom(",
      "                                              foregroundColor:",
      "                                                  theme.colorScheme.error,",
      "                                            ),",
      "                                            onPressed: () {",
      "                                              setState(() {",
      "                                                _currentIngredients",
      "                                                    .remove(ingId);",
      "                                                _doubleToppings.remove(ingId);",
      "                                                _ingredientPortions",
      "                                                    .remove(ingId);",
      "                                              });",
      "                                            },",
      "                                            child: Text(loc.remove),",
      "                                          ),",
      "                                        ],",
      "                                      ),",
      "                                      SizedBox(height: 6),",
      "                                      Row(",
      "                                        children: [",
      "                                          if (!_isCalzone()) ...[",
      "                                            Flexible(",
      "                                              fit: FlexFit.tight,",
      "                                              child: PortionSelector(",
      "                                                value: _ingredientPortions[",
      "                                                        ingId] ??",
      "                                                    Portion.whole,",
      "                                                onChanged: (portion) =>",
      "                                                    _handlePortionChanged(",
      "                                                        ingId, portion),",
      "                                              ),",
      "                                            ),",
      "                                            SizedBox(width: 10),",
      "                                          ],",
      "                                          Flexible(",
      "                                            fit: FlexFit.tight,",
      "                                            child: PortionPillToggle(",
      "                                              isDouble:",
      "                                                  _doubleToppings[ingId] ==",
      "                                                      true,",
      "                                              onTap: () => _handleDoubleChanged(",
      "                                                  ingId,",
      "                                                  !_doubleToppings[ingId]!),",
      "                                            ),",
      "                                          ),",
      "                                        ],",
      "                                      ),",
      "                                    ],",
      "                                  ),",
      "                                ),",
      "                              );",
      "                            }).toList(),",
      "                          ],",
      "                        ),",
      "",
      "                      // --- Begin Pizza/Calzone Topping Tabs UI ---",
      "                      if (_isPizzaOrCalzone() && _toppingTabLabels.isNotEmpty)",
      "                        Padding(",
      "                          padding: const EdgeInsets.only(top: 18, bottom: 4),",
      "                          child: Container(",
      "                            width: double.infinity,",
      "                            decoration: BoxDecoration(",
      "                              color: DesignTokens.primaryColor,",
      "                              borderRadius: BorderRadius.circular(6),",
      "                            ),",
      "                            padding: const EdgeInsets.symmetric(",
      "                                vertical: 8, horizontal: 14),",
      "                            child: Text(",
      "                              \"Additional Toppings\",",
      "                              style: theme.textTheme.titleMedium?.copyWith(",
      "                                color: Colors.white,",
      "                                fontWeight: FontWeight.bold,",
      "                              ),",
      "                            ),",
      "                          ),",
      "                        ),",
      "",
      "                      Padding(",
      "                        padding: const EdgeInsets.symmetric(",
      "                            vertical: 6.0), // Much tighter vertical space",
      "                        child: Container(",
      "                          decoration: BoxDecoration(",
      "                            color: Colors.white,",
      "                            borderRadius: BorderRadius.circular(30),",
      "                            border:",
      "                                Border.all(color: Colors.grey[300]!, width: 1),",
      "                          ),",
      "                          // The Row is now wrapped in a Container, acting like a tab bar.",
      "                          child: Row(",
      "                            children: _toppingTabLabels.map((label) {",
      "                              final bool selected =",
      "                                  _selectedToppingTab == label;",
      "                              return Expanded(",
      "                                child: GestureDetector(",
      "                                  onTap: () => setState(",
      "                                      () => _selectedToppingTab = label),",
      "                                  child: AnimatedContainer(",
      "                                    duration: Duration(milliseconds: 150),",
      "                                    decoration: BoxDecoration(",
      "                                      color: selected",
      "                                          ? DesignTokens.secondaryColor",
      "                                          : Colors.transparent,",
      "                                      borderRadius: BorderRadius.circular(30),",
      "                                    ),",
      "                                    padding: const EdgeInsets.symmetric(",
      "                                        vertical: 12),",
      "                                    alignment: Alignment.center,",
      "                                    child: Text(",
      "                                      label,",
      "                                      style:",
      "                                          theme.textTheme.bodyLarge?.copyWith(",
      "                                        color: selected",
      "                                            ? Colors.white",
      "                                            : DesignTokens.secondaryColor,",
      "                                        fontWeight: selected",
      "                                            ? FontWeight.bold",
      "                                            : FontWeight.normal,",
      "                                      ),",
      "                                    ),",
      "                                  ),",
      "                                ),",
      "                              );",
      "                            }).toList(),",
      "                          ),",
      "                        ),",
      "                      ),",
      "",
      "                      if (_isPizzaOrCalzone() && _selectedToppingTab.isNotEmpty)",
      "                        Builder(",
      "                          builder: (context) {",
      "                            final group = _toppingTabGroups.firstWhereOrNull(",
      "                                (g) => g['label'] == _selectedToppingTab);",
      "                            if (group == null) return SizedBox.shrink();",
      "",
      "                            final ingredientIds =",
      "                                (group['ingredientIds'] as List<dynamic>? ?? [])",
      "                                    .map((e) => e.toString())",
      "                                    .toList();",
      "",
      "                            return Column(",
      "                              crossAxisAlignment: CrossAxisAlignment.stretch,",
      "                              children: [",
      "                                Padding(",
      "                                  padding:",
      "                                      const EdgeInsets.only(top: 4, bottom: 4),",
      "                                  child: Divider(",
      "                                    thickness: 2,",
      "                                    color: Colors.grey[700],",
      "                                  ),",
      "                                ),",
      "                                ...ingredientIds",
      "                                    .where((ingId) =>",
      "                                        !_currentIngredients.contains(ingId))",
      "                                    .map((ingId) {",
      "                                  final meta = _ingredientMetadata[ingId];",
      "                                  return Card(",
      "                                    margin: EdgeInsets.symmetric(",
      "                                        vertical: 2, horizontal: 0),",
      "                                    child: Padding(",
      "                                      padding: EdgeInsets.symmetric(",
      "                                          vertical: 8, horizontal: 12),",
      "                                      child: Row(",
      "                                        crossAxisAlignment:",
      "                                            CrossAxisAlignment.center,",
      "                                        children: [",
      "                                          Expanded(",
      "                                            child: Text(meta?.name ?? ingId,",
      "                                                style:",
      "                                                    theme.textTheme.bodyLarge),",
      "                                          ),",
      "                                          TextButton(",
      "                                            onPressed: () {",
      "                                              setState(() {",
      "                                                _currentIngredients.add(ingId);",
      "                                                _doubleToppings[ingId] = false;",
      "                                                _ingredientPortions[ingId] =",
      "                                                    Portion.whole;",
      "                                              });",
      "                                            },",
      "                                            child: Text('Click to Add',",
      "                                                style: TextStyle(",
      "                                                    color: theme",
      "                                                        .colorScheme.primary)),",
      "                                          ),",
      "                                        ],",
      "                                      ),",
      "                                    ),",
      "                                  );",
      "                                }),",
      "                                Padding(",
      "                                  padding: const EdgeInsets.only(top: 10),",
      "                                  child: Divider(",
      "                                    thickness: 2,",
      "                                    color: Colors.grey[700],",
      "                                  ),",
      "                                ),",
      "                              ],",
      "                            );",
      "                          },",
      "                        ),",
      "",
      "                      // --- End Pizza/Calzone Topping Tabs UI ---",
      "",
      "                      ..._checkboxGroups.map((group) {",
      "                        final label =",
      "                            (group['label'] ?? '').toString().toLowerCase();",
      "                        if (label == 'cheeses') {",
      "                          final cheeseIds =",
      "                              (group['ingredientIds'] as List<dynamic>? ?? [])",
      "                                  .cast<String>();",
      "                          final selectedCheeses = cheeseIds",
      "                              .where((id) => _selectedCheeses.contains(id))",
      "                              .toList();",
      "                          final summary = selectedCheeses.isEmpty",
      "                              ? \"None\"",
      "                              : selectedCheeses.map((id) {",
      "                                  final meta = _ingredientMetadata[id];",
      "                                  final isDouble = _cheeseIsDouble[id] == true;",
      "                                  final portion =",
      "                                      _cheesePortions[id] ?? Portion.whole;",
      "                                  // Only show portion if not calzone and not whole",
      "                                  return \"${meta?.name ?? id}\"",
      "                                      \"${isDouble ? \" (Double)\" : \"\"}\"",
      "                                      \"${(!_isCalzone() && portion != Portion.whole) ? \" (${portionNames[portion]})\" : \"\"}\";",
      "                                }).join(\", \");",
      "                          return Padding(",
      "                            padding: const EdgeInsets.only(bottom: 10.0),",
      "                            child: Column(",
      "                              crossAxisAlignment: CrossAxisAlignment.start,",
      "                              children: [",
      "                                Padding(",
      "                                  padding:",
      "                                      const EdgeInsets.symmetric(horizontal: 0),",
      "                                  child: Container(",
      "                                    width: double.infinity,",
      "                                    decoration: BoxDecoration(",
      "                                      color: DesignTokens.primaryColor,",
      "                                      borderRadius: BorderRadius.circular(6),",
      "                                    ),",
      "                                    padding: const EdgeInsets.symmetric(",
      "                                        vertical: 8, horizontal: 14),",
      "                                    child: Text(",
      "                                      \"Cheeses\",",
      "                                      style:",
      "                                          theme.textTheme.titleMedium?.copyWith(",
      "                                        color: Colors.white,",
      "                                        fontWeight: FontWeight.bold,",
      "                                      ),",
      "                                    ),",
      "                                  ),",
      "                                ),",
      "                                ExpansionTile(",
      "                                  tilePadding:",
      "                                      EdgeInsets.symmetric(horizontal: 0),",
      "                                  title: Text(",
      "                                    summary,",
      "                                    style: theme.textTheme.bodySmall",
      "                                        ?.copyWith(color: Colors.grey[600]),",
      "                                    maxLines: 2,",
      "                                    overflow: TextOverflow.ellipsis,",
      "                                  ),",
      "                                  subtitle: Padding(",
      "                                    padding: const EdgeInsets.only(top: 2.0),",
      "                                    child: Text(",
      "                                      \"Add extra cheeses for an additional charge.\",",
      "                                      style:",
      "                                          theme.textTheme.bodySmall?.copyWith(",
      "                                        color: Colors.grey[500],",
      "                                        fontStyle: FontStyle.italic,",
      "                                      ),",
      "                                    ),",
      "                                  ),",
      "                                  children: cheeseIds.map((cheeseId) {",
      "                                    final meta = _ingredientMetadata[cheeseId];",
      "                                    final selected =",
      "                                        _selectedCheeses.contains(cheeseId);",
      "                                    return Card(",
      "                                      margin: EdgeInsets.symmetric(",
      "                                          vertical: 2, horizontal: 0),",
      "                                      child: Padding(",
      "                                        padding: EdgeInsets.symmetric(",
      "                                            vertical: 8, horizontal: 12),",
      "                                        child: Column(",
      "                                          crossAxisAlignment:",
      "                                              CrossAxisAlignment.start,",
      "                                          children: [",
      "                                            Row(",
      "                                              crossAxisAlignment:",
      "                                                  CrossAxisAlignment.center,",
      "                                              children: [",
      "                                                Expanded(",
      "                                                  child: Text(",
      "                                                    meta?.name ?? cheeseId,",
      "                                                    style: theme",
      "                                                        .textTheme.bodyLarge,",
      "                                                  ),",
      "                                                ),",
      "                                                if (selected)",
      "                                                  TextButton(",
      "                                                    style: TextButton.styleFrom(",
      "                                                      foregroundColor: theme",
      "                                                          .colorScheme.error,",
      "                                                    ),",
      "                                                    onPressed: () {",
      "                                                      setState(() {",
      "                                                        _selectedCheeses",
      "                                                            .remove(cheeseId);",
      "                                                        _cheesePortions",
      "                                                            .remove(cheeseId);",
      "                                                        _cheeseIsDouble",
      "                                                            .remove(cheeseId);",
      "                                                      });",
      "                                                    },",
      "                                                    child: Text('Remove'),",
      "                                                  )",
      "                                                else",
      "                                                  TextButton(",
      "                                                    onPressed: () {",
      "                                                      setState(() {",
      "                                                        _selectedCheeses",
      "                                                            .add(cheeseId);",
      "                                                        _cheesePortions[",
      "                                                                cheeseId] =",
      "                                                            Portion.whole;",
      "                                                        _cheeseIsDouble[",
      "                                                            cheeseId] = false;",
      "                                                      });",
      "                                                    },",
      "                                                    child: Text(",
      "                                                      'Click to Add',",
      "                                                      style: TextStyle(",
      "                                                          color: theme",
      "                                                              .colorScheme",
      "                                                              .primary),",
      "                                                    ),",
      "                                                  ),",
      "                                              ],",
      "                                            ),",
      "                                            if (selected)",
      "                                              Padding(",
      "                                                padding: const EdgeInsets.only(",
      "                                                    top: 6.0),",
      "                                                child: Row(",
      "                                                  children: [",
      "                                                    if (!_isCalzone()) ...[",
      "                                                      Flexible(",
      "                                                        fit: FlexFit.tight,",
      "                                                        child: PortionSelector(",
      "                                                          value: _cheesePortions[",
      "                                                                  cheeseId] ??",
      "                                                              Portion.whole,",
      "                                                          onChanged: (portion) {",
      "                                                            setState(() {",
      "                                                              _cheesePortions[",
      "                                                                      cheeseId] =",
      "                                                                  portion;",
      "                                                            });",
      "                                                          },",
      "                                                        ),",
      "                                                      ),",
      "                                                      SizedBox(width: 10),",
      "                                                    ],",
      "                                                    Flexible(",
      "                                                      fit: FlexFit.tight,",
      "                                                      child: PortionPillToggle(",
      "                                                        isDouble:",
      "                                                            _cheeseIsDouble[",
      "                                                                    cheeseId] ==",
      "                                                                true,",
      "                                                        onTap: () {",
      "                                                          setState(() {",
      "                                                            _cheeseIsDouble[",
      "                                                                    cheeseId] =",
      "                                                                !(_cheeseIsDouble[",
      "                                                                        cheeseId] ??",
      "                                                                    false);",
      "                                                          });",
      "                                                        },",
      "                                                      ),",
      "                                                    ),",
      "                                                  ],",
      "                                                ),",
      "                                              ),",
      "                                          ],",
      "                                        ),",
      "                                      ),",
      "                                    );",
      "                                  }).toList(),",
      "                                ),",
      "                              ],",
      "                            ),",
      "                          );",
      "                        } else {",
      "                          // Non-cheese group: render as before",
      "                          return CheckboxCustomizationGroup(",
      "                            group: group,",
      "                            theme: theme,",
      "                            loc: loc,",
      "                            category: widget.menuItem.category,",
      "                            includedIngredients:",
      "                                widget.menuItem.includedIngredients,",
      "                            ingredientMetadata: _ingredientMetadata,",
      "                            currentIngredients: _currentIngredients,",
      "                            usesDynamicToppingPricing:",
      "                                widget.menuItem.additionalToppingPrices !=",
      "                                        null &&",
      "                                    _selectedSize != null,",
      "                            showPortionToggle: _showPortionToggle,",
      "                            getToppingUpcharge: _getToppingUpcharge,",
      "                            getIngredientUpcharge: _getIngredientUpcharge,",
      "                            toggleIngredient: _toggleIngredient,",
      "                            buildPortionPillToggle: (ingId) =>",
      "                                PortionPillToggle(",
      "                              isDouble: _doubleToppings[ingId] == true,",
      "                              onTap: () {",
      "                                setState(() {",
      "                                  if (_doubleToppings[ingId] == true) {",
      "                                    _doubleToppings[ingId] = false;",
      "                                  } else {",
      "                                    if (_doublesCount < MAX_DOUBLES)",
      "                                      _doubleToppings[ingId] = true;",
      "                                  }",
      "                                });",
      "                              },",
      "                            ),",
      "                          );",
      "                        }",
      "                      }),",
      "",
      "                      ..._radioGroups.map((group) {",
      "                        final label =",
      "                            (group['label'] as String?)?.toLowerCase();",
      "                        if (label == 'sauces') {",
      "                          // --- Unified Sauce Summary Logic (works for both pizza/calzone) ---",
      "                          final saucesGroup = group;",
      "                          final sauceIds =",
      "                              (saucesGroup['ingredientIds'] as List?)",
      "                                      ?.cast<String>() ??",
      "                                  [];",
      "",
      "                          String sauceSummary;",
      "",
      "                          if (_isCalzone()) {",
      "                            // CALZONE: summarize by stepper sauce count",
      "                            final selectedSauceIds = sauceIds",
      "                                .where(",
      "                                    (id) => (_selectedSauceCounts[id] ?? 0) > 0)",
      "                                .toList();",
      "                            if (selectedSauceIds.isEmpty) {",
      "                              sauceSummary = \"None\";",
      "                            } else {",
      "                              sauceSummary = selectedSauceIds.map((id) {",
      "                                final name =",
      "                                    _ingredientMetadata[id]?.name ?? id;",
      "                                final count = _selectedSauceCounts[id] ?? 0;",
      "                                return count > 1 ? \"$name (x$count)\" : \"$name\";",
      "                              }).join(\", \");",
      "                            }",
      "                          } else {",
      "                            // PIZZA: use split/portion/amount summary",
      "                            final selectedSauces = _pizzaSauceSelections",
      "                                .where((s) => s.selected)",
      "                                .toList();",
      "                            if (selectedSauces.isEmpty) {",
      "                              sauceSummary = \"None\";",
      "                            } else {",
      "                              sauceSummary = selectedSauces.map((s) {",
      "                                final name =",
      "                                    _ingredientMetadata[s.id]?.name ?? s.name;",
      "                                final amount = s.amount.capitalize();",
      "                                if (s.portion != Portion.whole) {",
      "                                  final portion = portionNames[s.portion] ?? \"\";",
      "                                  return \"$name ($portion, $amount)\";",
      "                                } else {",
      "                                  return \"$name ($amount)\";",
      "                                }",
      "                              }).join(\", \");",
      "                            }",
      "                          }",
      "                          return Padding(",
      "                            padding: const EdgeInsets.only(bottom: 10.0),",
      "                            child: Column(",
      "                              crossAxisAlignment: CrossAxisAlignment.start,",
      "                              children: [",
      "                                Padding(",
      "                                  padding:",
      "                                      const EdgeInsets.symmetric(horizontal: 0),",
      "                                  child: Container(",
      "                                    width: double.infinity,",
      "                                    decoration: BoxDecoration(",
      "                                      color: DesignTokens.primaryColor,",
      "                                      borderRadius: BorderRadius.circular(6),",
      "                                    ),",
      "                                    padding: const EdgeInsets.symmetric(",
      "                                        vertical: 8, horizontal: 14),",
      "                                    child: Text(",
      "                                      \"Sauces\",",
      "                                      style:",
      "                                          theme.textTheme.titleMedium?.copyWith(",
      "                                        color: Colors.white,",
      "                                        fontWeight: FontWeight.bold,",
      "                                      ),",
      "                                    ),",
      "                                  ),",
      "                                ),",
      "                                ExpansionTile(",
      "                                  tilePadding:",
      "                                      EdgeInsets.symmetric(horizontal: 0),",
      "                                  title: Text(",
      "                                    sauceSummary,",
      "                                    style: theme.textTheme.bodySmall",
      "                                        ?.copyWith(color: Colors.grey[600]),",
      "                                    maxLines: 2,",
      "                                    overflow: TextOverflow.ellipsis,",
      "                                  ),",
      "                                  subtitle: Padding(",
      "                                    padding: const EdgeInsets.only(top: 2.0),",
      "                                    child: Text(",
      "                                      \"Split your sauce or add extra for an additional charge.\",",
      "                                      style:",
      "                                          theme.textTheme.bodySmall?.copyWith(",
      "                                        color: Colors.grey[500],",
      "                                        fontStyle: FontStyle.italic,",
      "                                      ),",
      "                                    ),",
      "                                  ),",
      "                                  children: [",
      "                                    SauceSelectorGroup(",
      "                                      group: group,",
      "                                      theme: theme,",
      "                                      loc: loc,",
      "                                      isPizza: _isPizza,",
      "                                      pizzaSauceSelections:",
      "                                          _pizzaSauceSelections,",
      "                                      ingredientMetadata: _ingredientMetadata,",
      "                                      sauceSplitValidationError:",
      "                                          _sauceSplitValidationError,",
      "                                      resetPizzaSauceSelections:",
      "                                          _resetPizzaSauceSelections,",
      "                                      setState: setState,",
      "                                      selectedSauceCounts: _selectedSauceCounts,",
      "                                      getFreeSauceCount: _getFreeSauceCount,",
      "                                      getExtraSauceUpcharge:",
      "                                          _getExtraSauceUpcharge,",
      "                                    ),",
      "                                  ],",
      "                                ),",
      "                              ],",
      "                            ),",
      "                          );",
      "                        } else if (label == 'dressings') {",
      "                          // --- Dressings logic ---",
      "                          return DressingSelectorGroup(",
      "                            group: group,",
      "                            theme: theme,",
      "                            loc: loc,",
      "                            selectedDressingCounts: _selectedDressingCounts,",
      "                            onCountChanged: (ingId, newCount) {",
      "                              setState(() =>",
      "                                  _selectedDressingCounts[ingId] = newCount);",
      "                            },",
      "                            getFreeDressingCount: _getFreeDressingCount,",
      "                            getExtraDressingUpcharge: _getExtraDressingUpcharge,",
      "                            ingredientMetadata: _ingredientMetadata,",
      "                          );",
      "                        }",
      "                        // DO NOT RENDER crust, cook, cut here",
      "                        return null;",
      "                      }).whereType<Widget>(),",
      "",
      "                      if (!_isWings() &&",
      "                          widget.menuItem.optionalAddOns != null &&",
      "                          widget.menuItem.optionalAddOns!.isNotEmpty)",
      "                        OptionalAddOnsGroup(",
      "                          menuItem: widget.menuItem,",
      "                          theme: theme,",
      "                          loc: loc,",
      "                          ingredientMetadata: _ingredientMetadata,",
      "                          selectedAddOns: _selectedAddOns,",
      "                          doubleAddOns: _doubleAddOns,",
      "                          selectedSauceCounts: _selectedSauceCounts,",
      "                          usesDynamicToppingPricing:",
      "                              widget.menuItem.additionalToppingPrices != null &&",
      "                                  _selectedSize != null,",
      "                          getToppingUpcharge: _getToppingUpcharge,",
      "                          getIngredientUpcharge: _getIngredientUpcharge,",
      "                          onToggleAddOn: (ingId, val) {",
      "                            setState(() {",
      "                              if (val == true) {",
      "                                _selectedAddOns.add(ingId);",
      "                                _doubleAddOns[ingId] = false;",
      "                              } else {",
      "                                _selectedAddOns.remove(ingId);",
      "                                _doubleAddOns.remove(ingId);",
      "                              }",
      "                            });",
      "                          },",
      "                          onChangeSauceCount: (ingId, delta) {",
      "                            setState(() {",
      "                              final count = _selectedSauceCounts[ingId] ?? 0;",
      "                              _selectedSauceCounts[ingId] =",
      "                                  (count + delta).clamp(0, 100);",
      "                            });",
      "                          },",
      "                          buildAddOnDoublePill: (ingId, isDouble, onTap) =>",
      "                              PortionPillToggle(",
      "                            isDouble: isDouble,",
      "                            onTap: onTap,",
      "                          ),",
      "                          maxFreeSauces: _getFreeSauceCount(),",
      "                          extraSauceUpcharge: _getExtraSauceUpcharge(),",
      "                        ),",
      "",
      "                      // --- ORDER DETAILS SECTION: Always at the very end, collapsed by default ---",
      "                      Builder(",
      "                        builder: (context) {",
      "                          // Get all remaining radio groups (crust, cook, cut)",
      "                          final orderDetailGroups = _radioGroups.where((group) {",
      "                            final label =",
      "                                (group['label'] as String?)?.toLowerCase();",
      "                            return label == 'crust' ||",
      "                                label == 'cook' ||",
      "                                label == 'cut';",
      "                          }).toList();",
      "",
      "                          // Compose summary for collapsed state",
      "                          String detailsSummary = orderDetailGroups",
      "                              .map((group) {",
      "                                final label = (group['label'] as String?) ?? '';",
      "                                final selected = _radioSelections[label];",
      "                                if (selected == null) return '';",
      "                                final meta = _ingredientMetadata[selected];",
      "                                return \"${label.capitalize()}: ${meta?.name ?? selected}\";",
      "                              })",
      "                              .where((str) => str.isNotEmpty)",
      "                              .join(\" | \");",
      "",
      "                          return Padding(",
      "                            padding:",
      "                                const EdgeInsets.only(top: 12.0, bottom: 4),",
      "                            child: Column(",
      "                              crossAxisAlignment: CrossAxisAlignment.start,",
      "                              children: [",
      "                                Padding(",
      "                                  padding:",
      "                                      const EdgeInsets.symmetric(horizontal: 0),",
      "                                  child: Container(",
      "                                    width: double.infinity,",
      "                                    decoration: BoxDecoration(",
      "                                      color: DesignTokens.primaryColor,",
      "                                      borderRadius: BorderRadius.circular(6),",
      "                                    ),",
      "                                    padding: const EdgeInsets.symmetric(",
      "                                        vertical: 8, horizontal: 14),",
      "                                    child: Text(",
      "                                      \"Order Details\",",
      "                                      style:",
      "                                          theme.textTheme.titleMedium?.copyWith(",
      "                                        color: Colors.white,",
      "                                        fontWeight: FontWeight.bold,",
      "                                      ),",
      "                                    ),",
      "                                  ),",
      "                                ),",
      "                                ExpansionTile(",
      "                                  tilePadding:",
      "                                      EdgeInsets.symmetric(horizontal: 0),",
      "                                  title: Text(",
      "                                    detailsSummary.isEmpty",
      "                                        ? \"Customize crust, cook, and cut.\"",
      "                                        : detailsSummary,",
      "                                    style: theme.textTheme.bodySmall",
      "                                        ?.copyWith(color: Colors.grey[600]),",
      "                                    maxLines: 2,",
      "                                    overflow: TextOverflow.ellipsis,",
      "                                  ),",
      "                                  subtitle: Padding(",
      "                                    padding: const EdgeInsets.only(top: 2.0),",
      "                                    child: Text(",
      "                                      \"Tap to customize crust, cook, or cut.\",",
      "                                      style:",
      "                                          theme.textTheme.bodySmall?.copyWith(",
      "                                        color: Colors.grey[500],",
      "                                        fontStyle: FontStyle.italic,",
      "                                      ),",
      "                                    ),",
      "                                  ),",
      "                                  children: orderDetailGroups.map((group) {",
      "                                    return RadioCustomizationGroup(",
      "                                      group: group,",
      "                                      theme: theme,",
      "                                      loc: loc,",
      "                                      ingredientMetadata: _ingredientMetadata,",
      "                                      radioSelections: _radioSelections,",
      "                                      getIngredientUpcharge:",
      "                                          _getIngredientUpcharge,",
      "                                      handleRadioSelect: _handleRadioSelect,",
      "                                    );",
      "                                  }).toList(),",
      "                                ),",
      "                              ],",
      "                            ),",
      "                          );",
      "                        },",
      "                      ),",
      "                    ],",
      "                  ),",
      "                ),",
      "              ),",
      "              CustomizationBottomBar(",
      "                menuItem: widget.menuItem,",
      "                theme: theme,",
      "                loc: loc,",
      "                totalPrice: _totalPrice,",
      "                error: _error,",
      "                onCancel: () => Navigator.of(context).pop(),",
      "                onSubmit: _submit,",
      "                onConfirm: widget.onConfirm,",
      "                drinkFlavorCounts: _drinkFlavorCounts,",
      "                sizePrices: widget.menuItem.sizePrices,",
      "                sizes: widget.menuItem.sizes?.map((s) => s.label).toList(),",
      "                menuItemPrice: widget.menuItem.price,",
      "                drinkMaxPerFlavor: _drinkMaxPerFlavor,",
      "              ),",
      "            ],",
      "          ),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 1915,
      "file_size": 87633,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\customization\\dinner_included_ingredients.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/core/models/menu_item.dart';",
      "import 'package:franchise_admin_portal/core/models/ingredient_metadata.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "",
      "class DinnerIncludedIngredients extends StatelessWidget {",
      "  final MenuItem menuItem;",
      "  final ThemeData theme;",
      "  final AppLocalizations loc;",
      "  final Map<String, IngredientMetadata> ingredientMetadata;",
      "  final Set<String> currentIngredients;",
      "  final Map<String, String> ingredientAmounts;",
      "  final void Function(VoidCallback fn) setState;",
      "",
      "  const DinnerIncludedIngredients({",
      "    Key? key,",
      "    required this.menuItem,",
      "    required this.theme,",
      "    required this.loc,",
      "    required this.ingredientMetadata,",
      "    required this.currentIngredients,",
      "    required this.ingredientAmounts,",
      "    required this.setState,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    if ((menuItem.category.toLowerCase() != 'dinners') ||",
      "        menuItem.includedIngredients == null ||",
      "        menuItem.includedIngredients!.isEmpty) {",
      "      return SizedBox.shrink();",
      "    }",
      "",
      "    final visibleIngs = menuItem.includedIngredients!.where((ing) {",
      "      final ingId = ing['ingredientId'] ?? ing['id'];",
      "      final meta = ingredientMetadata[ingId];",
      "      final removable = meta?.removable ?? ing['removable'] ?? false;",
      "      final isSauce = meta?.type?.toLowerCase() == 'sauces';",
      "      final amountSelectable =",
      "          meta?.amountSelectable ?? ing['amountSelectable'] == true;",
      "      // Only show if removable, or if sauce with amountSelectable",
      "      return removable || (isSauce && amountSelectable);",
      "    }).toList();",
      "",
      "    return Padding(",
      "      padding: const EdgeInsets.symmetric(vertical: 6.0),",
      "      child: Column(",
      "        crossAxisAlignment: CrossAxisAlignment.start,",
      "        children: [",
      "          Text(",
      "            loc.currentIngredientsLabel,",
      "            style: theme.textTheme.titleMedium?.copyWith(",
      "              color: DesignTokens.primaryColor,",
      "              fontWeight: FontWeight.bold,",
      "              fontFamily: DesignTokens.fontFamily,",
      "            ),",
      "          ),",
      "          ...visibleIngs.asMap().entries.map((entry) {",
      "            final index = entry.key;",
      "            final ing = entry.value;",
      "            final ingId = ing['ingredientId'] ?? ing['id'];",
      "            final meta = ingredientMetadata[ingId];",
      "            final name = meta?.name ?? ing['name'] ?? ingId;",
      "            final removable = meta?.removable ?? ing['removable'] ?? false;",
      "            final outOfStock = meta?.outOfStock ?? false;",
      "            final isSauce = meta?.type?.toLowerCase() == 'sauces';",
      "            final amountSelectable =",
      "                meta?.amountSelectable ?? ing['amountSelectable'] == true;",
      "            final List<String> amountOptions =",
      "                meta?.amountOptions?.cast<String>() ??",
      "                    (ing['amountOptions'] is List",
      "                        ? List<String>.from(ing['amountOptions'])",
      "                        : []);",
      "            final String? amountValue = ingredientAmounts[ingId] ??",
      "                (amountOptions.isNotEmpty",
      "                    ? amountOptions.firstWhere(",
      "                        (opt) => opt.toLowerCase() == 'regular',",
      "                        orElse: () => amountOptions.first)",
      "                    : null);",
      "",
      "            final isRemoved = removable && !currentIngredients.contains(ingId);",
      "",
      "            return Column(",
      "              crossAxisAlignment: CrossAxisAlignment.start,",
      "              children: [",
      "                Row(",
      "                  crossAxisAlignment: CrossAxisAlignment.center,",
      "                  children: [",
      "                    // Only show checkbox if removable and not amount-selectable sauce",
      "                    if (removable && !(isSauce && amountSelectable))",
      "                      Checkbox(",
      "                        value: !isRemoved,",
      "                        onChanged: outOfStock",
      "                            ? null",
      "                            : (val) {",
      "                                setState(() {",
      "                                  if (val == true) {",
      "                                    currentIngredients.add(ingId);",
      "                                  } else {",
      "                                    currentIngredients.remove(ingId);",
      "                                  }",
      "                                });",
      "                              },",
      "                      ),",
      "                    if (!removable || (isSauce && amountSelectable))",
      "                      SizedBox(width: 18), // align w/ checkbox",
      "",
      "                    Expanded(",
      "                      child: Row(",
      "                        children: [",
      "                          Expanded(",
      "                            child: Text(",
      "                              name,",
      "                              style: theme.textTheme.bodyLarge?.copyWith(",
      "                                color: outOfStock",
      "                                    ? DesignTokens.secondaryTextColor",
      "                                    : DesignTokens.textColor,",
      "                                fontWeight: outOfStock",
      "                                    ? FontWeight.normal",
      "                                    : FontWeight.w500,",
      "                                fontFamily: DesignTokens.fontFamily,",
      "                              ),",
      "                            ),",
      "                          ),",
      "                          // If amount is selectable, always show dropdown",
      "                          if (isSauce &&",
      "                              amountSelectable &&",
      "                              amountOptions.isNotEmpty)",
      "                            Padding(",
      "                              padding: const EdgeInsets.only(left: 8.0),",
      "                              child: DropdownButton<String>(",
      "                                value: amountValue,",
      "                                items: amountOptions.map((opt) {",
      "                                  return DropdownMenuItem<String>(",
      "                                    value: opt,",
      "                                    child: Text(opt),",
      "                                  );",
      "                                }).toList(),",
      "                                onChanged: outOfStock",
      "                                    ? null",
      "                                    : (val) {",
      "                                        setState(() {",
      "                                          ingredientAmounts[ingId] = val!;",
      "                                        });",
      "                                      },",
      "                              ),",
      "                            ),",
      "                        ],",
      "                      ),",
      "                    ),",
      "                    // Out of Stock Annotation",
      "                    if (outOfStock)",
      "                      Padding(",
      "                        padding: const EdgeInsets.only(left: 8.0),",
      "                        child: Text(",
      "                          loc.outOfStockLabel ?? \"Out of Stock\",",
      "                          style: theme.textTheme.bodySmall?.copyWith(",
      "                            color: DesignTokens.errorTextColor,",
      "                            fontStyle: FontStyle.italic,",
      "                            fontWeight: FontWeight.bold,",
      "                          ),",
      "                        ),",
      "                      ),",
      "                    // \"Removed\" annotation for removable non-sauce ingredients",
      "                    if (removable &&",
      "                        !(isSauce && amountSelectable) &&",
      "                        isRemoved)",
      "                      Padding(",
      "                        padding: const EdgeInsets.only(left: 8.0),",
      "                        child: Text(",
      "                          loc.ingredientRemovedLabel ?? \"Removed\",",
      "                          style: TextStyle(",
      "                            color: DesignTokens.primaryColor,",
      "                            fontStyle: FontStyle.italic,",
      "                            fontWeight: FontWeight.w600,",
      "                          ),",
      "                        ),",
      "                      ),",
      "                  ],",
      "                ),",
      "                if (index < visibleIngs.length - 1)",
      "                  Padding(",
      "                    padding: const EdgeInsets.symmetric(vertical: 6.0),",
      "                    child: Divider(",
      "                      thickness: 1.0,",
      "                      color: Colors.grey[300],",
      "                      height: 1,",
      "                    ),",
      "                  ),",
      "              ],",
      "            );",
      "          }).toList(),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 198,
      "file_size": 8622,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\customization\\dressing_selector_group.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/models/ingredient_metadata.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "",
      "class DressingSelectorGroup extends StatelessWidget {",
      "  final Map<String, dynamic> group;",
      "  final ThemeData theme;",
      "  final AppLocalizations loc;",
      "  final Map<String, int> selectedDressingCounts;",
      "  final void Function(String ingId, int newCount) onCountChanged;",
      "  final int Function() getFreeDressingCount;",
      "  final double Function() getExtraDressingUpcharge;",
      "  final Map<String, IngredientMetadata> ingredientMetadata;",
      "",
      "  const DressingSelectorGroup({",
      "    Key? key,",
      "    required this.group,",
      "    required this.theme,",
      "    required this.loc,",
      "    required this.selectedDressingCounts,",
      "    required this.onCountChanged,",
      "    required this.getFreeDressingCount,",
      "    required this.getExtraDressingUpcharge,",
      "    required this.ingredientMetadata,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final groupLabel = group['label'] ?? 'Dressings';",
      "    final ingredientIds = (group['ingredientIds'] as List<dynamic>? ?? [])",
      "        .map((e) => e.toString())",
      "        .toList();",
      "",
      "    final int freeDressings = getFreeDressingCount();",
      "    final double extraDressingUpcharge = getExtraDressingUpcharge();",
      "",
      "    for (final id in ingredientIds) {",
      "      selectedDressingCounts[id] ??= 0;",
      "    }",
      "",
      "    return Padding(",
      "      padding: const EdgeInsets.symmetric(vertical: 6.0),",
      "      child: Column(",
      "        crossAxisAlignment: CrossAxisAlignment.start,",
      "        children: [",
      "          Text(",
      "            \"$groupLabel ($freeDressings free, +${extraDressingUpcharge.toStringAsFixed(2)} each extra)\",",
      "            style: theme.textTheme.titleMedium?.copyWith(",
      "              color: DesignTokens.secondaryColor,",
      "              fontWeight: FontWeight.bold,",
      "              fontFamily: DesignTokens.fontFamily,",
      "            ),",
      "          ),",
      "          ...ingredientIds.map((ingId) {",
      "            final meta = ingredientMetadata[ingId];",
      "            final count = selectedDressingCounts[ingId] ?? 0;",
      "            final outOfStock = meta?.outOfStock == true;",
      "",
      "            return Padding(",
      "              padding: const EdgeInsets.symmetric(vertical: 4.0),",
      "              child: Row(",
      "                children: [",
      "                  IconButton(",
      "                    icon: Icon(Icons.remove, size: 20),",
      "                    onPressed: !outOfStock && count > 0",
      "                        ? () => onCountChanged(ingId, count - 1)",
      "                        : null,",
      "                  ),",
      "                  SizedBox(width: 2),",
      "                  Expanded(",
      "                    child: Text(",
      "                      meta?.name ?? ingId,",
      "                      style: theme.textTheme.bodyLarge?.copyWith(",
      "                        color: DesignTokens.textColor,",
      "                        fontFamily: DesignTokens.fontFamily,",
      "                      ),",
      "                    ),",
      "                  ),",
      "                  SizedBox(width: 8),",
      "                  Container(",
      "                    width: 28,",
      "                    alignment: Alignment.center,",
      "                    child: Text(",
      "                      'x$count',",
      "                      style: theme.textTheme.bodyLarge?.copyWith(",
      "                        fontWeight: FontWeight.bold,",
      "                        color: count > 0",
      "                            ? DesignTokens.primaryColor",
      "                            : DesignTokens.secondaryTextColor,",
      "                        fontFamily: DesignTokens.fontFamily,",
      "                      ),",
      "                    ),",
      "                  ),",
      "                  SizedBox(width: 8),",
      "                  IconButton(",
      "                    icon: Icon(Icons.add, size: 20),",
      "                    onPressed: !outOfStock",
      "                        ? () => onCountChanged(ingId, count + 1)",
      "                        : null,",
      "                  ),",
      "                ],",
      "              ),",
      "            );",
      "          }).toList(),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 110,
      "file_size": 4111,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\customization\\drinks_flavor_selector.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/core/models/menu_item.dart';",
      "import 'package:franchise_admin_portal/core/models/ingredient_metadata.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/utils/formatting.dart';",
      "",
      "class DrinksFlavorSelector extends StatelessWidget {",
      "  final MenuItem menuItem;",
      "  final ThemeData theme;",
      "  final AppLocalizations loc;",
      "  final Map<String, IngredientMetadata> ingredientMetadata;",
      "  final Map<String, int> selectedSauceCounts;",
      "  final void Function(VoidCallback fn) setState;",
      "",
      "  const DrinksFlavorSelector({",
      "    Key? key,",
      "    required this.menuItem,",
      "    required this.theme,",
      "    required this.loc,",
      "    required this.ingredientMetadata,",
      "    required this.selectedSauceCounts,",
      "    required this.setState,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final size = menuItem.sizes?.first.label ?? '';",
      "    final price = menuItem.sizePrices != null &&",
      "            menuItem.sizes != null &&",
      "            menuItem.sizes!.isNotEmpty",
      "        ? (menuItem.sizePrices![menuItem.sizes!.first] as num?)?.toDouble() ??",
      "            menuItem.price",
      "        : menuItem.price;",
      "",
      "    final included = menuItem.includedIngredients ?? [];",
      "    final flavorIds =",
      "        included.map((e) => e['ingredientId'] ?? e['id']).toList();",
      "",
      "    return Padding(",
      "      padding: const EdgeInsets.only(bottom: 12.0),",
      "      child: Column(",
      "        crossAxisAlignment: CrossAxisAlignment.start,",
      "        children: [",
      "          Row(",
      "            children: [",
      "              Text(",
      "                \"Size\",",
      "                style: theme.textTheme.titleMedium?.copyWith(",
      "                  color: DesignTokens.secondaryColor,",
      "                  fontWeight: FontWeight.bold,",
      "                  fontFamily: DesignTokens.fontFamily,",
      "                ),",
      "              ),",
      "              SizedBox(width: 8),",
      "              Text(",
      "                size,",
      "                style: theme.textTheme.titleMedium,",
      "              ),",
      "              SizedBox(width: 16),",
      "              Text(",
      "                currencyFormat(context, price),",
      "                style: theme.textTheme.titleMedium?.copyWith(",
      "                  color: DesignTokens.primaryColor,",
      "                  fontWeight: FontWeight.bold,",
      "                  fontFamily: DesignTokens.fontFamily,",
      "                ),",
      "              ),",
      "            ],",
      "          ),",
      "          SizedBox(height: 12),",
      "          Text(",
      "            \"Choose Flavors\",",
      "            style: theme.textTheme.titleMedium?.copyWith(",
      "              color: DesignTokens.secondaryColor,",
      "              fontWeight: FontWeight.bold,",
      "              fontFamily: DesignTokens.fontFamily,",
      "            ),",
      "          ),",
      "          ...flavorIds.map((id) {",
      "            final meta = ingredientMetadata[id];",
      "            final count = selectedSauceCounts[id] ?? 0;",
      "            final outOfStock = meta?.outOfStock == true;",
      "",
      "            return Padding(",
      "              padding: const EdgeInsets.symmetric(vertical: 4.0),",
      "              child: Row(",
      "                children: [",
      "                  IconButton(",
      "                    icon: Icon(Icons.remove, size: 20),",
      "                    onPressed: !outOfStock && count > 0",
      "                        ? () => setState(() {",
      "                              selectedSauceCounts[id] = count - 1;",
      "                            })",
      "                        : null,",
      "                  ),",
      "                  SizedBox(width: 2),",
      "                  Expanded(",
      "                    child: Text(",
      "                      meta?.name ?? id,",
      "                      style: theme.textTheme.bodyLarge?.copyWith(",
      "                        color: DesignTokens.textColor,",
      "                        fontFamily: DesignTokens.fontFamily,",
      "                      ),",
      "                    ),",
      "                  ),",
      "                  SizedBox(width: 8),",
      "                  Text('x$count', style: theme.textTheme.bodyLarge),",
      "                  SizedBox(width: 8),",
      "                  IconButton(",
      "                    icon: Icon(Icons.add, size: 20),",
      "                    onPressed: !outOfStock && count < 10",
      "                        ? () => setState(() {",
      "                              selectedSauceCounts[id] = count + 1;",
      "                            })",
      "                        : null,",
      "                  ),",
      "                ],",
      "              ),",
      "            );",
      "          }).toList(),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 126,
      "file_size": 4565,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\customization\\header.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/models/menu_item.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/config/branding_config.dart';",
      "",
      "class CustomizationHeader extends StatelessWidget {",
      "  final MenuItem menuItem;",
      "  final ThemeData theme;",
      "  final AppLocalizations loc;",
      "",
      "  const CustomizationHeader({",
      "    Key? key,",
      "    required this.menuItem,",
      "    required this.theme,",
      "    required this.loc,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Row(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        if (menuItem.image != null && menuItem.image!.isNotEmpty)",
      "          ClipRRect(",
      "            borderRadius: BorderRadius.circular(DesignTokens.cardRadius),",
      "            child: Image.network(",
      "              menuItem.image!,",
      "              width: DesignTokens.menuItemImageWidth,",
      "              height: DesignTokens.menuItemImageHeight,",
      "              fit: BoxFit.cover,",
      "              errorBuilder: (_, __, ___) => Image.asset(",
      "                BrandingConfig.defaultPizzaIcon,",
      "                width: DesignTokens.menuItemImageWidth,",
      "                height: DesignTokens.menuItemImageHeight,",
      "                fit: BoxFit.cover,",
      "              ),",
      "            ),",
      "          ),",
      "        SizedBox(width: DesignTokens.gridSpacing),",
      "        Expanded(",
      "          child: Column(",
      "            crossAxisAlignment: CrossAxisAlignment.start,",
      "            children: [",
      "              Text(",
      "                menuItem.name,",
      "                style: theme.textTheme.titleLarge?.copyWith(",
      "                  color: DesignTokens.textColor,",
      "                  fontWeight: FontWeight.bold,",
      "                  fontFamily: DesignTokens.fontFamily,",
      "                ),",
      "              ),",
      "              SizedBox(height: DesignTokens.gridSpacing / 2),",
      "              Text(",
      "                menuItem.description,",
      "                style: theme.textTheme.bodyMedium?.copyWith(",
      "                  color: DesignTokens.secondaryTextColor,",
      "                  fontFamily: DesignTokens.fontFamily,",
      "                ),",
      "                maxLines: 2,",
      "                overflow: TextOverflow.ellipsis,",
      "              ),",
      "            ],",
      "          ),",
      "        )",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 69,
      "file_size": 2405,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\customization\\optional_addons_group.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/models/menu_item.dart';",
      "import 'package:franchise_admin_portal/core/models/ingredient_metadata.dart';",
      "import 'package:franchise_admin_portal/widgets/customization/portion_pill_toggle.dart'; // if you use the pill toggle here",
      "import 'package:franchise_admin_portal/core/utils/formatting.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "",
      "typedef DoubleAddOnCallback = void Function(String ingId, bool value);",
      "",
      "class OptionalAddOnsGroup extends StatelessWidget {",
      "  final MenuItem menuItem;",
      "  final ThemeData theme;",
      "  final AppLocalizations loc;",
      "  final Map<String, IngredientMetadata> ingredientMetadata;",
      "  final Set<String> selectedAddOns;",
      "  final Map<String, bool> doubleAddOns;",
      "  final Map<String, int> selectedSauceCounts;",
      "  final bool usesDynamicToppingPricing;",
      "  final double Function() getToppingUpcharge;",
      "  final double Function(IngredientMetadata? meta) getIngredientUpcharge;",
      "  final void Function(String ingId, bool? value) onToggleAddOn;",
      "  final void Function(String ingId, int delta) onChangeSauceCount;",
      "  final Widget Function(String ingId, bool isDouble, VoidCallback onTap)",
      "      buildAddOnDoublePill;",
      "  final int maxFreeSauces;",
      "  final double extraSauceUpcharge;",
      "",
      "  const OptionalAddOnsGroup({",
      "    super.key,",
      "    required this.menuItem,",
      "    required this.theme,",
      "    required this.loc,",
      "    required this.ingredientMetadata,",
      "    required this.selectedAddOns,",
      "    required this.doubleAddOns,",
      "    required this.selectedSauceCounts,",
      "    required this.usesDynamicToppingPricing,",
      "    required this.getToppingUpcharge,",
      "    required this.getIngredientUpcharge,",
      "    required this.onToggleAddOn,",
      "    required this.onChangeSauceCount,",
      "    required this.buildAddOnDoublePill,",
      "    required this.maxFreeSauces,",
      "    required this.extraSauceUpcharge,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final toppingUpcharge = getToppingUpcharge();",
      "",
      "    return Padding(",
      "      padding: const EdgeInsets.only(bottom: 8.0),",
      "      child: Column(",
      "        crossAxisAlignment: CrossAxisAlignment.start,",
      "        children: [",
      "          Text(",
      "            loc.optionalAddOnsLabel,",
      "            style: theme.textTheme.titleMedium?.copyWith(",
      "              color: DesignTokens.secondaryColor,",
      "              fontWeight: FontWeight.bold,",
      "              fontFamily: DesignTokens.fontFamily,",
      "            ),",
      "          ),",
      "          ...menuItem.optionalAddOns!.map((addOn) {",
      "            final ingId = addOn['ingredientId'] ?? addOn['id'];",
      "            final meta = ingredientMetadata[ingId];",
      "            final isSauce = (meta?.type?.toLowerCase() == \"sauces\") ||",
      "                (addOn['type']?.toString()?.toLowerCase() == \"sauces\");",
      "            final upcharge = usesDynamicToppingPricing",
      "                ? toppingUpcharge",
      "                : (meta != null &&",
      "                        meta.upcharge != null &&",
      "                        meta.upcharge!.isNotEmpty)",
      "                    ? getIngredientUpcharge(meta)",
      "                    : (addOn['price'] as num?)?.toDouble() ?? 0.0;",
      "",
      "            if (isSauce) {",
      "              final count = selectedSauceCounts[ingId] ?? 0;",
      "              return Padding(",
      "                padding: const EdgeInsets.symmetric(vertical: 4.0),",
      "                child: Row(",
      "                  children: [",
      "                    IconButton(",
      "                      icon: Icon(Icons.remove, size: 20),",
      "                      onPressed: count > 0",
      "                          ? () => onChangeSauceCount(ingId, -1)",
      "                          : null,",
      "                    ),",
      "                    const SizedBox(width: 2),",
      "                    Expanded(",
      "                      child: Text(",
      "                        meta?.name ?? addOn['name'] ?? ingId,",
      "                        style: theme.textTheme.bodyLarge?.copyWith(",
      "                          color: DesignTokens.textColor,",
      "                          fontFamily: DesignTokens.fontFamily,",
      "                        ),",
      "                        overflow: TextOverflow.ellipsis,",
      "                      ),",
      "                    ),",
      "                    const SizedBox(width: 8),",
      "                    Container(",
      "                      width: 28,",
      "                      alignment: Alignment.center,",
      "                      child: Text(",
      "                        'x$count',",
      "                        style: theme.textTheme.bodyLarge?.copyWith(",
      "                          fontWeight: FontWeight.bold,",
      "                          color: count > 0",
      "                              ? DesignTokens.primaryColor",
      "                              : DesignTokens.secondaryTextColor,",
      "                          fontFamily: DesignTokens.fontFamily,",
      "                        ),",
      "                      ),",
      "                    ),",
      "                    const SizedBox(width: 8),",
      "                    IconButton(",
      "                      icon: Icon(Icons.add, size: 20),",
      "                      onPressed: () => onChangeSauceCount(ingId, 1),",
      "                    ),",
      "                  ],",
      "                ),",
      "              );",
      "            } else {",
      "              final checked = selectedAddOns.contains(ingId);",
      "              final isDouble = doubleAddOns[ingId] == true;",
      "              final priceDisplay = upcharge > 0",
      "                  ? '+${currencyFormat(context, upcharge * (isDouble ? 2 : 1))}'",
      "                  : '';",
      "              return Row(",
      "                children: [",
      "                  Checkbox(",
      "                    value: checked,",
      "                    onChanged: meta?.outOfStock == true",
      "                        ? null",
      "                        : (val) => onToggleAddOn(ingId, val),",
      "                  ),",
      "                  Expanded(",
      "                    child: Text(",
      "                      meta?.name ?? addOn['name'] ?? ingId,",
      "                      style: theme.textTheme.bodyLarge?.copyWith(",
      "                        color: DesignTokens.textColor,",
      "                        fontFamily: DesignTokens.fontFamily,",
      "                      ),",
      "                      overflow: TextOverflow.ellipsis,",
      "                    ),",
      "                  ),",
      "                  if (checked && upcharge > 0)",
      "                    Padding(",
      "                      padding: const EdgeInsets.only(left: 4.0),",
      "                      child: Text(",
      "                        priceDisplay,",
      "                        style: theme.textTheme.bodyMedium?.copyWith(",
      "                          color: DesignTokens.secondaryColor,",
      "                          fontWeight: FontWeight.bold,",
      "                          fontFamily: DesignTokens.fontFamily,",
      "                        ),",
      "                      ),",
      "                    ),",
      "                  if (checked)",
      "                    Padding(",
      "                      padding: const EdgeInsets.only(left: 8.0, right: 4.0),",
      "                      child: buildAddOnDoublePill(",
      "                        ingId,",
      "                        isDouble,",
      "                        () => onToggleAddOn(ingId, !isDouble),",
      "                      ),",
      "                    ),",
      "                ],",
      "              );",
      "            }",
      "          }).toList(),",
      "          if (menuItem.optionalAddOns!.any((a) =>",
      "              (ingredientMetadata[a['ingredientId'] ?? a['id']]",
      "                      ?.type",
      "                      ?.toLowerCase() ==",
      "                  \"sauces\") ||",
      "              (a['type']?.toString()?.toLowerCase() == \"sauces\")))",
      "            Padding(",
      "              padding: const EdgeInsets.only(top: 6.0),",
      "              child: Text(",
      "                \"$maxFreeSauces free sauces, +${currencyFormat(context, extraSauceUpcharge)} each extra.\",",
      "                style: theme.textTheme.bodySmall?.copyWith(",
      "                  color: DesignTokens.secondaryTextColor,",
      "                  fontStyle: FontStyle.italic,",
      "                  fontFamily: DesignTokens.fontFamily,",
      "                ),",
      "              ),",
      "            ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 194,
      "file_size": 8038,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\customization\\pizza_sauce_selector_tab.dart",
    "content": [
      ""
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 1,
      "file_size": 2,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\customization\\portion_pill_toggle.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "",
      "class PortionPillToggle extends StatelessWidget {",
      "  final bool isDouble;",
      "  final VoidCallback onTap;",
      "",
      "  const PortionPillToggle({",
      "    Key? key,",
      "    required this.isDouble,",
      "    required this.onTap,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return GestureDetector(",
      "      onTap: onTap,",
      "      child: AnimatedContainer(",
      "        duration: Duration(milliseconds: 160),",
      "        padding: EdgeInsets.symmetric(horizontal: 12, vertical: 6),",
      "        decoration: BoxDecoration(",
      "          color:",
      "              isDouble ? DesignTokens.primaryColor : DesignTokens.surfaceColor,",
      "          borderRadius: BorderRadius.circular(18),",
      "          border: Border.all(",
      "            color: isDouble",
      "                ? DesignTokens.primaryColor",
      "                : DesignTokens.secondaryTextColor.withOpacity(0.25),",
      "            width: 1.5,",
      "          ),",
      "        ),",
      "        child: Text(",
      "          isDouble ? \"Double\" : \"Regular\",",
      "          style: TextStyle(",
      "            color: isDouble ? Colors.white : DesignTokens.textColor,",
      "            fontWeight: FontWeight.bold,",
      "            fontSize: 14,",
      "            fontFamily: DesignTokens.fontFamily,",
      "          ),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 44,
      "file_size": 1345,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\customization\\radio_customization_group.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/core/models/ingredient_metadata.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/utils/formatting.dart';",
      "",
      "class RadioCustomizationGroup extends StatelessWidget {",
      "  final Map<String, dynamic> group;",
      "  final ThemeData theme;",
      "  final AppLocalizations loc;",
      "  final Map<String, IngredientMetadata> ingredientMetadata;",
      "  final Map<String, String?> radioSelections;",
      "  final double Function(IngredientMetadata? meta) getIngredientUpcharge;",
      "  final void Function(String groupLabel, String? ingId) handleRadioSelect;",
      "",
      "  const RadioCustomizationGroup({",
      "    Key? key,",
      "    required this.group,",
      "    required this.theme,",
      "    required this.loc,",
      "    required this.ingredientMetadata,",
      "    required this.radioSelections,",
      "    required this.getIngredientUpcharge,",
      "    required this.handleRadioSelect,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final String groupLabel = group['label'] ?? '';",
      "    final List<String> ingredientIds =",
      "        (group['ingredientIds'] as List<dynamic>? ?? [])",
      "            .map((e) => e.toString())",
      "            .toList();",
      "",
      "    return Padding(",
      "      padding: const EdgeInsets.symmetric(vertical: 6.0),",
      "      child: Column(",
      "        crossAxisAlignment: CrossAxisAlignment.start,",
      "        children: [",
      "          Text(",
      "            groupLabel,",
      "            style: theme.textTheme.titleMedium?.copyWith(",
      "              color: DesignTokens.secondaryColor,",
      "              fontWeight: FontWeight.bold,",
      "              fontFamily: DesignTokens.fontFamily,",
      "            ),",
      "          ),",
      "          ...ingredientIds.map((ingId) {",
      "            final meta = ingredientMetadata[ingId];",
      "            final double upcharge = getIngredientUpcharge(meta);",
      "",
      "            return RadioListTile<String>(",
      "              dense: true,",
      "              value: ingId,",
      "              groupValue: radioSelections[groupLabel],",
      "              onChanged: (v) => handleRadioSelect(groupLabel, v),",
      "              title: Text(",
      "                meta?.name ?? ingId,",
      "                style: theme.textTheme.bodyLarge?.copyWith(",
      "                  color: DesignTokens.textColor,",
      "                  fontFamily: DesignTokens.fontFamily,",
      "                ),",
      "              ),",
      "              secondary: upcharge > 0",
      "                  ? Text(",
      "                      '+${currencyFormat(context, upcharge)}',",
      "                      style: theme.textTheme.bodyMedium?.copyWith(",
      "                        color: DesignTokens.secondaryColor,",
      "                        fontWeight: FontWeight.bold,",
      "                        fontFamily: DesignTokens.fontFamily,",
      "                      ),",
      "                    )",
      "                  : null,",
      "            );",
      "          }).toList(),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 80,
      "file_size": 2952,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\customization\\sauce_selector_group.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/widgets/portion_selector.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/models/ingredient_metadata.dart';",
      "import 'package:franchise_admin_portal/widgets/customization/customization_modal.dart'; // for PizzaSauceSelection (or use correct path)",
      "",
      "// Add any additional imports your project structure requires.",
      "",
      "class SauceSelectorGroup extends StatelessWidget {",
      "  final Map<String, dynamic> group;",
      "  final ThemeData theme;",
      "  final AppLocalizations loc;",
      "  final bool Function() isPizza;",
      "  final List<PizzaSauceSelection> pizzaSauceSelections;",
      "  final Map<String, IngredientMetadata> ingredientMetadata;",
      "  final bool sauceSplitValidationError;",
      "  final VoidCallback resetPizzaSauceSelections;",
      "  final void Function(VoidCallback fn) setState;",
      "  final Map<String, int> selectedSauceCounts;",
      "  final int Function() getFreeSauceCount;",
      "  final double Function() getExtraSauceUpcharge;",
      "",
      "  const SauceSelectorGroup({",
      "    Key? key,",
      "    required this.group,",
      "    required this.theme,",
      "    required this.loc,",
      "    required this.isPizza,",
      "    required this.pizzaSauceSelections,",
      "    required this.ingredientMetadata,",
      "    required this.sauceSplitValidationError,",
      "    required this.resetPizzaSauceSelections,",
      "    required this.setState,",
      "    required this.selectedSauceCounts,",
      "    required this.getFreeSauceCount,",
      "    required this.getExtraSauceUpcharge,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    if (isPizza()) {",
      "      int selectedCount = pizzaSauceSelections.where((s) => s.selected).length;",
      "",
      "      Portion? _takenPortion([int? ignoreIdx]) {",
      "        for (int i = 0; i < pizzaSauceSelections.length; i++) {",
      "          if (i == ignoreIdx) continue;",
      "          final s = pizzaSauceSelections[i];",
      "          if (s.selected && s.portion != Portion.whole) {",
      "            return s.portion;",
      "          }",
      "        }",
      "        return null;",
      "      }",
      "",
      "      final int wholeSelectedIdx = pizzaSauceSelections.indexWhere(",
      "        (s) => s.selected && s.portion == Portion.whole,",
      "      );",
      "",
      "      final hasCustom = pizzaSauceSelections.skip(1).any((s) => s.selected) ||",
      "          (pizzaSauceSelections.isNotEmpty &&",
      "              pizzaSauceSelections[0].portion != Portion.whole);",
      "",
      "      return Padding(",
      "        padding: const EdgeInsets.symmetric(vertical: 8.0),",
      "        child: Column(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            Row(",
      "              children: [",
      "                Expanded(",
      "                  child: Text(",
      "                    group['label'] ?? 'Sauces',",
      "                    style: theme.textTheme.titleMedium?.copyWith(",
      "                      color: DesignTokens.secondaryColor,",
      "                      fontWeight: FontWeight.bold,",
      "                      fontFamily: DesignTokens.fontFamily,",
      "                    ),",
      "                  ),",
      "                ),",
      "                if (hasCustom)",
      "                  OutlinedButton.icon(",
      "                    style: OutlinedButton.styleFrom(",
      "                      foregroundColor: DesignTokens.primaryColor,",
      "                      side: BorderSide(color: DesignTokens.primaryColor),",
      "                      padding: EdgeInsets.symmetric(horizontal: 8, vertical: 2),",
      "                      minimumSize: Size(0, 32),",
      "                    ),",
      "                    icon: Icon(Icons.refresh, size: 18),",
      "                    label: Text(\"Clear\", style: TextStyle(fontSize: 14)),",
      "                    onPressed: resetPizzaSauceSelections,",
      "                  ),",
      "              ],",
      "            ),",
      "            ...pizzaSauceSelections.asMap().entries.map((entry) {",
      "              final i = entry.key;",
      "              final sauce = entry.value;",
      "              final meta = ingredientMetadata[sauce.id];",
      "              final outOfStock = meta?.outOfStock == true;",
      "",
      "              Portion? otherPortion = _takenPortion(i);",
      "",
      "              Map<Portion, bool> disables = {",
      "                Portion.left: false,",
      "                Portion.right: false,",
      "                Portion.whole: false,",
      "              };",
      "",
      "              if (sauce.selected) {",
      "                if (otherPortion != null) {",
      "                  disables = {",
      "                    Portion.left: otherPortion == Portion.left,",
      "                    Portion.right: otherPortion == Portion.right,",
      "                    Portion.whole: true,",
      "                  };",
      "                } else if (selectedCount == 2) {",
      "                  disables = {",
      "                    Portion.left: sauce.portion != Portion.left,",
      "                    Portion.right: sauce.portion != Portion.right,",
      "                    Portion.whole: true,",
      "                  };",
      "                } else if (selectedCount == 1 &&",
      "                    sauce.portion != Portion.whole) {",
      "                  disables[Portion.whole] = true;",
      "                }",
      "              } else {",
      "                if (otherPortion != null) {",
      "                  disables = {",
      "                    Portion.left: otherPortion == Portion.left,",
      "                    Portion.right: otherPortion == Portion.right,",
      "                    Portion.whole: true,",
      "                  };",
      "                }",
      "              }",
      "",
      "              // Disable this sauce if a different sauce is selected as 'whole'",
      "              bool canSelect =",
      "                  sauce.selected || (selectedCount < 2 && !outOfStock);",
      "              if (wholeSelectedIdx != -1 && wholeSelectedIdx != i) {",
      "                canSelect = false; // Only allow selection of the 'whole' sauce",
      "                disables = {",
      "                  Portion.left: true,",
      "                  Portion.right: true,",
      "                  Portion.whole: true,",
      "                };",
      "              } else if (selectedCount == 2 && !sauce.selected) {",
      "                disables = {",
      "                  Portion.left: true,",
      "                  Portion.right: true,",
      "                  Portion.whole: true,",
      "                };",
      "                canSelect = false;",
      "              }",
      "",
      "              void handleCheckbox(bool? val) {",
      "                setState(() {",
      "                  if (val == true) {",
      "                    Portion? already = _takenPortion(i);",
      "                    if (already == Portion.left) {",
      "                      sauce.selected = true;",
      "                      sauce.portion = Portion.right;",
      "                    } else if (already == Portion.right) {",
      "                      sauce.selected = true;",
      "                      sauce.portion = Portion.left;",
      "                    } else {",
      "                      sauce.selected = true;",
      "                      sauce.portion = Portion.whole;",
      "                    }",
      "                  } else {",
      "                    sauce.selected = false;",
      "                    sauce.portion = Portion.whole;",
      "                    sauce.amount = 'regular';",
      "                  }",
      "                });",
      "              }",
      "",
      "              void handlePortionChange(Portion portion) {",
      "                if (disables[portion] == true) return;",
      "                setState(() {",
      "                  sauce.portion = portion;",
      "                });",
      "              }",
      "",
      "              return Card(",
      "                margin: const EdgeInsets.symmetric(vertical: 4.0),",
      "                elevation: 0,",
      "                color: sauce.selected",
      "                    ? DesignTokens.surfaceColor",
      "                    : Colors.transparent,",
      "                child: Column(",
      "                  crossAxisAlignment: CrossAxisAlignment.start,",
      "                  children: [",
      "                    Row(",
      "                      children: [",
      "                        Checkbox(",
      "                          value: sauce.selected,",
      "                          onChanged:",
      "                              canSelect && !outOfStock ? handleCheckbox : null,",
      "                        ),",
      "                        Expanded(",
      "                          child: Text(",
      "                            sauce.name,",
      "                            style: theme.textTheme.bodyLarge?.copyWith(",
      "                              color: outOfStock",
      "                                  ? DesignTokens.secondaryTextColor",
      "                                  : DesignTokens.textColor,",
      "                              fontFamily: DesignTokens.fontFamily,",
      "                            ),",
      "                          ),",
      "                        ),",
      "                        if (outOfStock)",
      "                          Padding(",
      "                            padding: const EdgeInsets.only(left: 6.0),",
      "                            child: Icon(Icons.block,",
      "                                color: DesignTokens.errorTextColor, size: 18),",
      "                          ),",
      "                      ],",
      "                    ),",
      "                    if (sauce.selected)",
      "                      Padding(",
      "                        padding: const EdgeInsets.only(",
      "                            left: 20.0, top: 4.0, right: 0.0, bottom: 4.0),",
      "                        child: Row(",
      "                          mainAxisAlignment: MainAxisAlignment.start,",
      "                          mainAxisSize: MainAxisSize.max,",
      "                          children: [",
      "                            Flexible(",
      "                              flex: 0,",
      "                              child: PortionSelector(",
      "                                value: sauce.portion,",
      "                                onChanged: handlePortionChange,",
      "                                size: 24,",
      "                                disables: disables,",
      "                              ),",
      "                            ),",
      "                            SizedBox(width: 8),",
      "                            Expanded(",
      "                              child: LayoutBuilder(",
      "                                builder: (context, constraints) {",
      "                                  return ConstrainedBox(",
      "                                    constraints: BoxConstraints(",
      "                                      maxWidth: 170,",
      "                                    ),",
      "                                    child: ToggleButtons(",
      "                                      isSelected: [",
      "                                        sauce.amount == 'light',",
      "                                        sauce.amount == 'regular',",
      "                                        sauce.amount == 'extra'",
      "                                      ],",
      "                                      onPressed: (idx) {",
      "                                        setState(() {",
      "                                          sauce.amount = [",
      "                                            'light',",
      "                                            'regular',",
      "                                            'extra'",
      "                                          ][idx];",
      "                                        });",
      "                                      },",
      "                                      borderRadius: BorderRadius.circular(10),",
      "                                      constraints: BoxConstraints(",
      "                                        minWidth: 38,",
      "                                        minHeight: 32,",
      "                                      ),",
      "                                      children: [",
      "                                        Padding(",
      "                                          padding: EdgeInsets.symmetric(",
      "                                              horizontal: 2),",
      "                                          child: Text('Light',",
      "                                              style: TextStyle(fontSize: 11)),",
      "                                        ),",
      "                                        Padding(",
      "                                          padding: EdgeInsets.symmetric(",
      "                                              horizontal: 2),",
      "                                          child: Text('Regular',",
      "                                              style: TextStyle(fontSize: 11)),",
      "                                        ),",
      "                                        Padding(",
      "                                          padding: EdgeInsets.symmetric(",
      "                                              horizontal: 2),",
      "                                          child: Text('Extra',",
      "                                              style: TextStyle(fontSize: 11)),",
      "                                        ),",
      "                                      ],",
      "                                    ),",
      "                                  );",
      "                                },",
      "                              ),",
      "                            ),",
      "                          ],",
      "                        ),",
      "                      ),",
      "                  ],",
      "                ),",
      "              );",
      "            }).toList(),",
      "            if (sauceSplitValidationError)",
      "              Padding(",
      "                padding: const EdgeInsets.only(left: 8.0, top: 2.0),",
      "                child: Text(",
      "                  \"For half & half, both sides must have a sauce (including 'No Sauce').\",",
      "                  style: theme.textTheme.bodySmall?.copyWith(",
      "                    color: DesignTokens.errorTextColor,",
      "                    fontStyle: FontStyle.italic,",
      "                  ),",
      "                ),",
      "              ),",
      "          ],",
      "        ),",
      "      );",
      "    }",
      "",
      "    // --- Non-pizza fallback logic ---",
      "    final groupLabel = group['label'] ?? '';",
      "    final ingredientIds = (group['ingredientIds'] as List<dynamic>? ?? [])",
      "        .map((e) => e.toString())",
      "        .toList();",
      "",
      "    final int freeSauces = getFreeSauceCount();",
      "    final double extraSauceUpcharge = getExtraSauceUpcharge();",
      "",
      "    for (final id in ingredientIds) {",
      "      selectedSauceCounts[id] ??= 0;",
      "    }",
      "",
      "    return Padding(",
      "      padding: const EdgeInsets.symmetric(vertical: 6.0),",
      "      child: Column(",
      "        crossAxisAlignment: CrossAxisAlignment.start,",
      "        children: [",
      "          Text(",
      "            \"$groupLabel ($freeSauces free, +\\$${extraSauceUpcharge.toStringAsFixed(2)} each extra)\",",
      "            style: theme.textTheme.titleMedium?.copyWith(",
      "              color: DesignTokens.secondaryColor,",
      "              fontWeight: FontWeight.bold,",
      "              fontFamily: DesignTokens.fontFamily,",
      "            ),",
      "          ),",
      "          ...ingredientIds.map((ingId) {",
      "            final meta = ingredientMetadata[ingId];",
      "            final count = selectedSauceCounts[ingId] ?? 0;",
      "            final outOfStock = meta?.outOfStock == true;",
      "",
      "            return Padding(",
      "              padding: const EdgeInsets.symmetric(vertical: 4.0),",
      "              child: Row(",
      "                children: [",
      "                  IconButton(",
      "                    icon: Icon(Icons.remove, size: 20),",
      "                    onPressed: !outOfStock && count > 0",
      "                        ? () => setState(",
      "                            () => selectedSauceCounts[ingId] = count - 1)",
      "                        : null,",
      "                  ),",
      "                  SizedBox(width: 2),",
      "                  Expanded(",
      "                    child: Text(",
      "                      meta?.name ?? ingId,",
      "                      style: theme.textTheme.bodyLarge?.copyWith(",
      "                        color: DesignTokens.textColor,",
      "                        fontFamily: DesignTokens.fontFamily,",
      "                      ),",
      "                    ),",
      "                  ),",
      "                  SizedBox(width: 8),",
      "                  Container(",
      "                    width: 28,",
      "                    alignment: Alignment.center,",
      "                    child: Text(",
      "                      'x$count',",
      "                      style: theme.textTheme.bodyLarge?.copyWith(",
      "                        fontWeight: FontWeight.bold,",
      "                        color: count > 0",
      "                            ? DesignTokens.primaryColor",
      "                            : DesignTokens.secondaryTextColor,",
      "                        fontFamily: DesignTokens.fontFamily,",
      "                      ),",
      "                    ),",
      "                  ),",
      "                  SizedBox(width: 8),",
      "                  IconButton(",
      "                    icon: Icon(Icons.add, size: 20),",
      "                    onPressed: !outOfStock",
      "                        ? () => setState(",
      "                            () => selectedSauceCounts[ingId] = count + 1)",
      "                        : null,",
      "                  ),",
      "                ],",
      "              ),",
      "            );",
      "          }).toList(),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 395,
      "file_size": 16462,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\customization\\size_dropdown.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/models/menu_item.dart';",
      "import 'package:franchise_admin_portal/core/utils/formatting.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "",
      "class SizeDropdown extends StatelessWidget {",
      "  final MenuItem menuItem;",
      "  final String? selectedSize;",
      "  final void Function(String?) onChanged;",
      "  final Widget? toppingCostLabel;",
      "  final String Function(String?) normalizeSizeKey;",
      "",
      "  const SizeDropdown({",
      "    Key? key,",
      "    required this.menuItem,",
      "    required this.selectedSize,",
      "    required this.onChanged,",
      "    this.toppingCostLabel,",
      "    required this.normalizeSizeKey,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final theme = Theme.of(context);",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    final sizes = menuItem.sizes!;",
      "",
      "    return Padding(",
      "      padding: const EdgeInsets.only(bottom: 8.0),",
      "      child: Column(",
      "        crossAxisAlignment: CrossAxisAlignment.start,",
      "        children: [",
      "          Row(",
      "            children: [",
      "              Text(",
      "                loc.sizeLabel,",
      "                style: theme.textTheme.titleMedium?.copyWith(",
      "                  color: DesignTokens.secondaryColor,",
      "                  fontWeight: FontWeight.bold,",
      "                  fontFamily: DesignTokens.fontFamily,",
      "                ),",
      "              ),",
      "              SizedBox(width: 16),",
      "              DropdownButton<String>(",
      "                value: selectedSize,",
      "                items: sizes",
      "                    .map((size) => DropdownMenuItem<String>(",
      "                          value: size.label,",
      "                          child: Text(",
      "                            size.label,",
      "                            style: theme.textTheme.bodyLarge,",
      "                          ),",
      "                        ))",
      "                    .toList(),",
      "                onChanged: onChanged,",
      "              ),",
      "              if (selectedSize != null &&",
      "                  menuItem.sizePrices != null &&",
      "                  menuItem.sizePrices![normalizeSizeKey(selectedSize)] != null)",
      "                Padding(",
      "                  padding: const EdgeInsets.only(left: 12.0),",
      "                  child: Text(",
      "                    currencyFormat(",
      "                        context,",
      "                        (menuItem.sizePrices![normalizeSizeKey(selectedSize)]",
      "                                as num)",
      "                            .toDouble()),",
      "                    style: theme.textTheme.titleMedium?.copyWith(",
      "                      color: DesignTokens.primaryColor,",
      "                      fontWeight: FontWeight.bold,",
      "                      fontFamily: DesignTokens.fontFamily,",
      "                    ),",
      "                  ),",
      "                ),",
      "            ],",
      "          ),",
      "          if (toppingCostLabel != null)",
      "            Padding(",
      "              padding: const EdgeInsets.only(left: 4.0, top: 2.0, bottom: 2.0),",
      "              child: toppingCostLabel,",
      "            ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 94,
      "file_size": 3352,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\customization\\topping_cost_label.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "",
      "typedef GetToppingUpcharge = double Function();",
      "typedef CurrencyFormat = String Function(BuildContext, double);",
      "",
      "class ToppingCostLabel extends StatelessWidget {",
      "  final ThemeData theme;",
      "  final AppLocalizations loc;",
      "  final GetToppingUpcharge getToppingUpcharge;",
      "  final CurrencyFormat currencyFormat;",
      "",
      "  const ToppingCostLabel({",
      "    Key? key,",
      "    required this.theme,",
      "    required this.loc,",
      "    required this.getToppingUpcharge,",
      "    required this.currencyFormat,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final upcharge = getToppingUpcharge();",
      "    return Row(",
      "      children: [",
      "        Text(",
      "          loc.additionalToppingCostLabel ?? \"Additional topping cost:\",",
      "          style: theme.textTheme.bodySmall?.copyWith(",
      "            color: DesignTokens.secondaryTextColor,",
      "            fontFamily: DesignTokens.fontFamily,",
      "            fontWeight: FontWeight.w500,",
      "          ),",
      "        ),",
      "        SizedBox(width: 8),",
      "        Text(",
      "          currencyFormat(context, upcharge),",
      "          style: theme.textTheme.bodySmall?.copyWith(",
      "            color: DesignTokens.primaryColor,",
      "            fontWeight: FontWeight.bold,",
      "            fontFamily: DesignTokens.fontFamily,",
      "          ),",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 47,
      "file_size": 1464,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\customization\\wings_dip_sauce_selector.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/models/menu_item.dart';",
      "import 'package:franchise_admin_portal/core/models/ingredient_metadata.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/utils/formatting.dart';",
      "",
      "class WingsDipSauceSelector extends StatelessWidget {",
      "  final MenuItem menuItem;",
      "  final ThemeData theme;",
      "  final AppLocalizations loc;",
      "  final Map<String, IngredientMetadata> ingredientMetadata;",
      "  final Map<String, int> sideDipCounts;",
      "  final int wingsDipSauceTabIndex;",
      "  final void Function(void Function()) setState;",
      "  final void Function(int newIndex) onTabChanged;",
      "",
      "  const WingsDipSauceSelector({",
      "    Key? key,",
      "    required this.menuItem,",
      "    required this.theme,",
      "    required this.loc,",
      "    required this.ingredientMetadata,",
      "    required this.sideDipCounts,",
      "    required this.wingsDipSauceTabIndex,",
      "    required this.setState,",
      "    required this.onTabChanged,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final dipsIds = menuItem.dippingSauceOptions ?? [];",
      "    final saucesAddOns = (menuItem.optionalAddOns ?? [])",
      "        .where((addOn) => addOn['type']?.toString().toLowerCase() == 'sauces')",
      "        .toList();",
      "",
      "    final upcharge = menuItem.sideDipUpcharge != null",
      "        ? menuItem.sideDipUpcharge![menuItem.sizes?.first] ?? 0.95",
      "        : 0.95;",
      "    final freeDipCups = menuItem.freeDipCupCount != null",
      "        ? menuItem.freeDipCupCount![menuItem.sizes?.first] ?? 0",
      "        : 0;",
      "",
      "    int getCount(String id) => sideDipCounts[id] ?? 0;",
      "",
      "    List<Widget> _buildDipRows() => dipsIds.map<Widget>((dipId) {",
      "          final meta = ingredientMetadata[dipId];",
      "          final count = getCount(dipId);",
      "          final outOfStock = meta?.outOfStock == true;",
      "          return Padding(",
      "            padding: const EdgeInsets.symmetric(vertical: 4.0),",
      "            child: Row(",
      "              children: [",
      "                IconButton(",
      "                  icon: Icon(Icons.remove, size: 20),",
      "                  onPressed: !outOfStock && count > 0",
      "                      ? () => setState(() => sideDipCounts[dipId] = count - 1)",
      "                      : null,",
      "                ),",
      "                const SizedBox(width: 2),",
      "                Expanded(",
      "                  child: Text(",
      "                    meta?.name ?? dipId,",
      "                    style: theme.textTheme.bodyLarge?.copyWith(",
      "                      color: DesignTokens.textColor,",
      "                      fontFamily: DesignTokens.fontFamily,",
      "                    ),",
      "                  ),",
      "                ),",
      "                const SizedBox(width: 8),",
      "                Text('x$count', style: theme.textTheme.bodyLarge),",
      "                const SizedBox(width: 8),",
      "                IconButton(",
      "                  icon: Icon(Icons.add, size: 20),",
      "                  onPressed: !outOfStock",
      "                      ? () => setState(() => sideDipCounts[dipId] = count + 1)",
      "                      : null,",
      "                ),",
      "              ],",
      "            ),",
      "          );",
      "        }).toList();",
      "",
      "    List<Widget> _buildSauceRows() => saucesAddOns.map<Widget>((addOn) {",
      "          final ingId = addOn['ingredientId'] ?? addOn['id'];",
      "          final meta = ingredientMetadata[ingId];",
      "          final count = getCount(ingId);",
      "          final outOfStock = meta?.outOfStock == true;",
      "          return Padding(",
      "            padding: const EdgeInsets.symmetric(vertical: 4.0),",
      "            child: Row(",
      "              children: [",
      "                IconButton(",
      "                  icon: Icon(Icons.remove, size: 20),",
      "                  onPressed: !outOfStock && count > 0",
      "                      ? () => setState(() => sideDipCounts[ingId] = count - 1)",
      "                      : null,",
      "                ),",
      "                const SizedBox(width: 2),",
      "                Expanded(",
      "                  child: Text(",
      "                    meta?.name ?? addOn['name'] ?? ingId,",
      "                    style: theme.textTheme.bodyLarge?.copyWith(",
      "                      color: DesignTokens.textColor,",
      "                      fontFamily: DesignTokens.fontFamily,",
      "                    ),",
      "                    overflow: TextOverflow.ellipsis,",
      "                  ),",
      "                ),",
      "                const SizedBox(width: 8),",
      "                Text('x$count', style: theme.textTheme.bodyLarge),",
      "                const SizedBox(width: 8),",
      "                IconButton(",
      "                  icon: Icon(Icons.add, size: 20),",
      "                  onPressed: !outOfStock",
      "                      ? () => setState(() => sideDipCounts[ingId] = count + 1)",
      "                      : null,",
      "                ),",
      "              ],",
      "            ),",
      "          );",
      "        }).toList();",
      "",
      "    final List<String> tabs = [\"Dips\", \"Sauces\"];",
      "",
      "    return Padding(",
      "      padding: const EdgeInsets.symmetric(vertical: 8.0),",
      "      child: Column(",
      "        crossAxisAlignment: CrossAxisAlignment.start,",
      "        children: [",
      "          Text(",
      "            \"Dips & Sauces\",",
      "            style: theme.textTheme.titleMedium?.copyWith(",
      "              color: DesignTokens.secondaryColor,",
      "              fontWeight: FontWeight.bold,",
      "              fontFamily: DesignTokens.fontFamily,",
      "            ),",
      "          ),",
      "          Text(",
      "            \"$freeDipCups free included. Additional dips +${currencyFormat(context, upcharge)} each.\",",
      "            style: theme.textTheme.bodySmall?.copyWith(",
      "              color: DesignTokens.secondaryTextColor,",
      "              fontStyle: FontStyle.italic,",
      "              fontFamily: DesignTokens.fontFamily,",
      "            ),",
      "          ),",
      "          const SizedBox(height: 8),",
      "          // Tab bar",
      "          Row(",
      "            children: List.generate(tabs.length, (i) {",
      "              final selected = wingsDipSauceTabIndex == i;",
      "              return Expanded(",
      "                child: GestureDetector(",
      "                  onTap: () => onTabChanged(i),",
      "                  child: Container(",
      "                    decoration: BoxDecoration(",
      "                      color: selected",
      "                          ? DesignTokens.primaryColor.withOpacity(0.11)",
      "                          : Colors.transparent,",
      "                      borderRadius: BorderRadius.circular(18),",
      "                      border: Border.all(",
      "                        color: selected",
      "                            ? DesignTokens.primaryColor",
      "                            : DesignTokens.secondaryTextColor.withOpacity(0.3),",
      "                        width: 1.5,",
      "                      ),",
      "                    ),",
      "                    padding: const EdgeInsets.symmetric(vertical: 10),",
      "                    alignment: Alignment.center,",
      "                    child: Text(",
      "                      tabs[i],",
      "                      style: theme.textTheme.titleMedium?.copyWith(",
      "                        color: selected",
      "                            ? DesignTokens.primaryColor",
      "                            : DesignTokens.textColor,",
      "                        fontWeight:",
      "                            selected ? FontWeight.bold : FontWeight.normal,",
      "                        fontFamily: DesignTokens.fontFamily,",
      "                      ),",
      "                    ),",
      "                  ),",
      "                ),",
      "              );",
      "            }),",
      "          ),",
      "          const SizedBox(height: 8),",
      "          if (wingsDipSauceTabIndex == 0)",
      "            ...(dipsIds.isNotEmpty",
      "                ? _buildDipRows()",
      "                : [",
      "                    Padding(",
      "                      padding: const EdgeInsets.symmetric(vertical: 14.0),",
      "                      child: Text(",
      "                        \"No dips available.\",",
      "                        style: theme.textTheme.bodyMedium?.copyWith(",
      "                          color: DesignTokens.secondaryTextColor,",
      "                          fontFamily: DesignTokens.fontFamily,",
      "                        ),",
      "                      ),",
      "                    )",
      "                  ]),",
      "          if (wingsDipSauceTabIndex == 1)",
      "            ...(saucesAddOns.isNotEmpty",
      "                ? _buildSauceRows()",
      "                : [",
      "                    Padding(",
      "                      padding: const EdgeInsets.symmetric(vertical: 14.0),",
      "                      child: Text(",
      "                        \"No sauces available.\",",
      "                        style: theme.textTheme.bodyMedium?.copyWith(",
      "                          color: DesignTokens.secondaryTextColor,",
      "                          fontFamily: DesignTokens.fontFamily,",
      "                        ),",
      "                      ),",
      "                    )",
      "                  ]),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 221,
      "file_size": 8717,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\customization\\wings_optional_addons_group.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/models/menu_item.dart';",
      "import 'package:franchise_admin_portal/core/models/ingredient_metadata.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "",
      "class WingsOptionalAddOnsGroup extends StatelessWidget {",
      "  final MenuItem menuItem;",
      "  final ThemeData theme;",
      "  final AppLocalizations loc;",
      "  final Map<String, IngredientMetadata> ingredientMetadata;",
      "  final Set<String> selectedAddOns;",
      "  final Map<String, bool> doubleAddOns;",
      "  final void Function(void Function()) setState;",
      "",
      "  /// Callback: (ingId, checked)",
      "  final void Function(String ingId, bool checked) onChanged;",
      "",
      "  const WingsOptionalAddOnsGroup({",
      "    Key? key,",
      "    required this.menuItem,",
      "    required this.theme,",
      "    required this.loc,",
      "    required this.ingredientMetadata,",
      "    required this.selectedAddOns,",
      "    required this.doubleAddOns,",
      "    required this.setState,",
      "    required this.onChanged,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    // Filter non-sauce add-ons only",
      "    final nonSauceAddOns = (menuItem.optionalAddOns ?? []).where((addOn) {",
      "      final meta = ingredientMetadata[addOn['ingredientId'] ?? addOn['id']];",
      "      final isSauce = (meta?.type?.toLowerCase() == \"sauces\") ||",
      "          (addOn['type']?.toString()?.toLowerCase() == \"sauces\");",
      "      return !isSauce;",
      "    }).toList();",
      "",
      "    if (nonSauceAddOns.isEmpty) return const SizedBox.shrink();",
      "",
      "    return Padding(",
      "      padding: const EdgeInsets.only(bottom: 8.0),",
      "      child: Column(",
      "        crossAxisAlignment: CrossAxisAlignment.start,",
      "        children: [",
      "          Text(",
      "            \"Other Add-Ons\",",
      "            style: theme.textTheme.titleMedium?.copyWith(",
      "              color: DesignTokens.secondaryColor,",
      "              fontWeight: FontWeight.bold,",
      "              fontFamily: DesignTokens.fontFamily,",
      "            ),",
      "          ),",
      "          ...nonSauceAddOns.map((addOn) {",
      "            final ingId = addOn['ingredientId'] ?? addOn['id'];",
      "            final meta = ingredientMetadata[ingId];",
      "            final checked = selectedAddOns.contains(ingId);",
      "            final upcharge = (meta != null &&",
      "                    meta.upcharge != null &&",
      "                    meta.upcharge!.isNotEmpty)",
      "                ? meta.upcharge!.values.first",
      "                : (addOn['price'] as num?)?.toDouble() ?? 0.0;",
      "",
      "            return Row(",
      "              children: [",
      "                Checkbox(",
      "                  value: checked,",
      "                  onChanged: meta?.outOfStock == true",
      "                      ? null",
      "                      : (val) {",
      "                          setState(() {",
      "                            onChanged(ingId, val ?? false);",
      "                          });",
      "                        },",
      "                ),",
      "                Expanded(",
      "                  child: Text(",
      "                    meta?.name ?? addOn['name'] ?? ingId,",
      "                    style: theme.textTheme.bodyLarge?.copyWith(",
      "                      color: DesignTokens.textColor,",
      "                      fontFamily: DesignTokens.fontFamily,",
      "                    ),",
      "                    overflow: TextOverflow.ellipsis,",
      "                  ),",
      "                ),",
      "                if (checked && upcharge > 0)",
      "                  Padding(",
      "                    padding: const EdgeInsets.only(left: 4.0),",
      "                    child: Text(",
      "                      '+${upcharge.toStringAsFixed(2)}',",
      "                      style: theme.textTheme.bodyMedium?.copyWith(",
      "                        color: DesignTokens.secondaryColor,",
      "                        fontWeight: FontWeight.bold,",
      "                        fontFamily: DesignTokens.fontFamily,",
      "                      ),",
      "                    ),",
      "                  ),",
      "              ],",
      "            );",
      "          }).toList(),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 107,
      "file_size": 3969,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\customization\\wings_portion_selector.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/core/models/menu_item.dart';",
      "import 'package:franchise_admin_portal/core/models/ingredient_metadata.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "",
      "class WingsPortionSelector extends StatelessWidget {",
      "  final MenuItem menuItem;",
      "  final ThemeData theme;",
      "  final AppLocalizations loc;",
      "  final String? selectedSize;",
      "  final Map<String, dynamic> ingredientMetadata;",
      "  final Map<String, String> selectedDippedSauces;",
      "  final void Function(void Function()) setState;",
      "",
      "  const WingsPortionSelector({",
      "    Key? key,",
      "    required this.menuItem,",
      "    required this.theme,",
      "    required this.loc,",
      "    required this.selectedSize,",
      "    required this.ingredientMetadata,",
      "    required this.selectedDippedSauces,",
      "    required this.setState,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final splitCount = menuItem.dippingSplits?[selectedSize] ?? 2;",
      "    final sauceOptions = menuItem.dippingSauceOptions ?? [];",
      "",
      "    if (splitCount == 0) return SizedBox.shrink();",
      "",
      "    return Padding(",
      "      padding: const EdgeInsets.symmetric(vertical: 8.0),",
      "      child: Column(",
      "        crossAxisAlignment: CrossAxisAlignment.start,",
      "        children: [",
      "          Text(",
      "            \"Build Your Wings\",",
      "            style: theme.textTheme.titleMedium?.copyWith(",
      "              color: DesignTokens.secondaryColor,",
      "              fontWeight: FontWeight.bold,",
      "              fontFamily: DesignTokens.fontFamily,",
      "            ),",
      "          ),",
      "          Text(",
      "            \"Choose a sauce for each portion below. 'Plain' means no sauce—just crispy wings.\",",
      "            style: theme.textTheme.bodySmall?.copyWith(",
      "              color: DesignTokens.secondaryTextColor,",
      "              fontStyle: FontStyle.italic,",
      "              fontFamily: DesignTokens.fontFamily,",
      "            ),",
      "          ),",
      "          ...List.generate(splitCount, (i) {",
      "            final key = 'split_$i';",
      "            final value = selectedDippedSauces[key] ?? \"plain\";",
      "            return Padding(",
      "              padding: const EdgeInsets.only(top: 6.0, left: 8.0),",
      "              child: DropdownButtonFormField<String>(",
      "                value: value,",
      "                decoration: InputDecoration(",
      "                  labelText: \"Portion ${i + 1}\",",
      "                ),",
      "                items: [",
      "                  const DropdownMenuItem(",
      "                    value: \"plain\",",
      "                    child: Text(\"Plain (no sauce)\"),",
      "                  ),",
      "                  ...sauceOptions.map((sauceId) => DropdownMenuItem(",
      "                        value: sauceId,",
      "                        child:",
      "                            Text(ingredientMetadata[sauceId]?.name ?? sauceId),",
      "                      )),",
      "                ],",
      "                onChanged: (val) {",
      "                  setState(() {",
      "                    selectedDippedSauces[key] = val ?? \"plain\";",
      "                  });",
      "                },",
      "              ),",
      "            );",
      "          }),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 88,
      "file_size": 3161,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\dashboard\\activity_feed_widget.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "",
      "class ActivityFeedWidget extends StatelessWidget {",
      "  final List<String>? activities;",
      "  const ActivityFeedWidget({Key? key, this.activities}) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    return Card(",
      "      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),",
      "      color: colorScheme.surface,",
      "      child: Padding(",
      "        padding: const EdgeInsets.all(16),",
      "        child: Column(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            Text(\"Recent Activity\",",
      "                style: Theme.of(context).textTheme.titleSmall),",
      "            SizedBox(height: 14),",
      "            activities == null || activities!.isEmpty",
      "                ? Center(",
      "                    child: Text(",
      "                      \"No recent activity.\",",
      "                      style: Theme.of(context).textTheme.bodySmall?.copyWith(",
      "                          color: colorScheme.onSurface.withOpacity(0.5)),",
      "                    ),",
      "                  )",
      "                : Expanded(",
      "                    child: ListView.builder(",
      "                      itemCount: activities!.length,",
      "                      itemBuilder: (context, idx) => ListTile(",
      "                        leading: Icon(Icons.history,",
      "                            size: 18, color: colorScheme.primary),",
      "                        title: Text(activities![idx],",
      "                            style: Theme.of(context).textTheme.bodyMedium),",
      "                        dense: true,",
      "                        visualDensity: VisualDensity.compact,",
      "                      ),",
      "                    ),",
      "                  ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 47,
      "file_size": 1790,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\dashboard\\analytics_placeholder_card.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "",
      "class AnalyticsPlaceholderCard extends StatelessWidget {",
      "  final String title;",
      "  const AnalyticsPlaceholderCard({Key? key, required this.title})",
      "      : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    return Card(",
      "      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),",
      "      color: colorScheme.surface,",
      "      child: Padding(",
      "        padding: const EdgeInsets.all(18.0),",
      "        child: Column(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            Text(title, style: Theme.of(context).textTheme.titleSmall),",
      "            const Spacer(),",
      "            Center(",
      "              child: Icon(Icons.show_chart,",
      "                  size: 46, color: colorScheme.surfaceVariant),",
      "            ),",
      "            SizedBox(height: 12),",
      "            Center(",
      "              child: Text(",
      "                \"Coming Soon\",",
      "                style: Theme.of(context)",
      "                    .textTheme",
      "                    .bodySmall",
      "                    ?.copyWith(color: colorScheme.onSurface.withOpacity(0.5)),",
      "              ),",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 40,
      "file_size": 1270,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\dashboard\\billing_summary_card.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/config/branding_config.dart';",
      "import 'package:franchise_admin_portal/widgets/dashboard/dashboard_section_card.dart';",
      "import 'package:franchise_admin_portal/core/services/invoice_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:intl/intl.dart';",
      "import 'package:flutter/foundation.dart';",
      "",
      "class BillingSummaryCard extends StatefulWidget {",
      "  const BillingSummaryCard({Key? key}) : super(key: key);",
      "",
      "  @override",
      "  State<BillingSummaryCard> createState() => _BillingSummaryCardState();",
      "}",
      "",
      "class _BillingSummaryCardState extends State<BillingSummaryCard> {",
      "  late Future<BillingSummaryData> _summaryFuture;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _summaryFuture = _fetchSummary(context);",
      "  }",
      "",
      "  Future<BillingSummaryData> _fetchSummary(BuildContext context) async {",
      "    try {",
      "      final franchiseId =",
      "          Provider.of<FranchiseProvider>(context, listen: false).franchiseId;",
      "      return await InvoiceService.getBillingSummary(franchiseId: franchiseId);",
      "    } catch (error, stackTrace) {",
      "      await ErrorLogger.log(",
      "        message: 'BillingSummaryCard: failed to load summary\\n$error',",
      "        stack: stackTrace?.toString(),",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final localize = AppLocalizations.of(context)!;",
      "    final theme = Theme.of(context);",
      "",
      "    return DashboardSectionCard(",
      "      title: localize.billingSummary,",
      "      icon: Icons.receipt_long,",
      "      builder: (context) {",
      "        return FutureBuilder<BillingSummaryData>(",
      "          future: _summaryFuture,",
      "          builder: (context, snapshot) {",
      "            if (snapshot.connectionState == ConnectionState.waiting) {",
      "              return Padding(",
      "                padding: const EdgeInsets.symmetric(vertical: 40),",
      "                child: Center(child: CircularProgressIndicator()),",
      "              );",
      "            }",
      "            if (snapshot.hasError) {",
      "              return _ErrorWidget(",
      "                errorMessage: localize.failedToLoadSummary,",
      "                onRetry: () =>",
      "                    setState(() => _summaryFuture = _fetchSummary(context)),",
      "              );",
      "            }",
      "            final data = snapshot.data!;",
      "            return _BillingSummaryContent(",
      "                data: data, localize: localize, theme: theme);",
      "          },",
      "        );",
      "      },",
      "    );",
      "  }",
      "}",
      "",
      "class _BillingSummaryContent extends StatelessWidget {",
      "  final BillingSummaryData data;",
      "  final AppLocalizations localize;",
      "  final ThemeData theme;",
      "",
      "  const _BillingSummaryContent({",
      "    required this.data,",
      "    required this.localize,",
      "    required this.theme,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final currencyFormat = NumberFormat.simpleCurrency(",
      "        locale: Localizations.localeOf(context).toString());",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        _SummaryRow(",
      "          label: localize.totalOutstanding,",
      "          value: currencyFormat.format(data.totalOutstanding),",
      "          valueColor: data.totalOutstanding > 0",
      "              ? theme.colorScheme.error",
      "              : theme.colorScheme.primary,",
      "        ),",
      "        const SizedBox(height: 10),",
      "        _SummaryRow(",
      "          label: localize.overdueInvoices,",
      "          value: '${data.overdueCount}',",
      "          valueColor: data.overdueCount > 0",
      "              ? theme.colorScheme.error",
      "              : theme.textTheme.bodyMedium?.color,",
      "        ),",
      "        const SizedBox(height: 10),",
      "        _SummaryRow(",
      "          label: localize.paidLastNDays(30),",
      "          value: currencyFormat.format(data.paidLast30Days),",
      "          valueColor: theme.colorScheme.secondary,",
      "        ),",
      "        const Divider(height: 32),",
      "        Row(",
      "          mainAxisAlignment: MainAxisAlignment.spaceBetween,",
      "          children: [",
      "            ElevatedButton.icon(",
      "              icon: const Icon(Icons.payment_rounded),",
      "              label: Text(localize.payNow),",
      "              style: ElevatedButton.styleFrom(",
      "                backgroundColor:",
      "                    BrandingConfig.accentColor ?? theme.colorScheme.primary,",
      "              ),",
      "              onPressed: data.hasOutstanding ? () => _onPayNow(context) : null,",
      "            ),",
      "            // OutlinedButton.icon(",
      "            //   icon: const Icon(Icons.download_rounded),",
      "            //   label: Text(localize.downloadSummary),",
      "            //   onPressed: () => _onDownloadSummary(context),",
      "            // ),",
      "            TextButton(",
      "              child: Text(localize.viewAllInvoices),",
      "              onPressed: () => Navigator.of(context).pushNamed('/hq/invoices'),",
      "            ),",
      "          ],",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "",
      "  void _onPayNow(BuildContext context) {",
      "    Navigator.of(context)",
      "        .pushNamed('/hq/invoices', arguments: {'payNow': true});",
      "  }",
      "",
      "  void _onDownloadSummary(BuildContext context) async {",
      "    try {",
      "      final franchiseId =",
      "          Provider.of<FranchiseProvider>(context, listen: false).franchiseId;",
      "      final result = await InvoiceService.downloadSummary(",
      "          franchiseId: franchiseId, context: context);",
      "      String msg;",
      "      if (kIsWeb) {",
      "        // Use a web download handler here if you want (e.g. anchor element).",
      "        msg = AppLocalizations.of(context)!.downloadStarted;",
      "      } else {",
      "        msg = 'Saved to: $result';",
      "      }",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(content: Text(msg)),",
      "      );",
      "    } catch (e, s) {",
      "      await ErrorLogger.log(",
      "        message: 'BillingSummaryCard: failed to download summary\\n$e',",
      "        stack: s.toString(),",
      "      );",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(content: Text(AppLocalizations.of(context)!.downloadFailed)),",
      "      );",
      "    }",
      "  }",
      "}",
      "",
      "class _SummaryRow extends StatelessWidget {",
      "  final String label;",
      "  final String value;",
      "  final Color? valueColor;",
      "  const _SummaryRow({",
      "    required this.label,",
      "    required this.value,",
      "    this.valueColor,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Row(",
      "      mainAxisAlignment: MainAxisAlignment.spaceBetween,",
      "      children: [",
      "        Text(label, style: Theme.of(context).textTheme.bodyMedium),",
      "        Text(",
      "          value,",
      "          style: Theme.of(context).textTheme.titleMedium?.copyWith(",
      "                color:",
      "                    valueColor ?? Theme.of(context).textTheme.bodyMedium?.color,",
      "                fontWeight: FontWeight.w600,",
      "              ),",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}",
      "",
      "class _ErrorWidget extends StatelessWidget {",
      "  final String errorMessage;",
      "  final VoidCallback onRetry;",
      "  const _ErrorWidget({",
      "    required this.errorMessage,",
      "    required this.onRetry,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final theme = Theme.of(context);",
      "    return Padding(",
      "      padding: const EdgeInsets.symmetric(vertical: 28),",
      "      child: Column(",
      "        mainAxisAlignment: MainAxisAlignment.center,",
      "        children: [",
      "          Icon(Icons.error_outline, color: theme.colorScheme.error),",
      "          const SizedBox(height: 12),",
      "          Text(",
      "            errorMessage,",
      "            style: theme.textTheme.bodyMedium",
      "                ?.copyWith(color: theme.colorScheme.error),",
      "            textAlign: TextAlign.center,",
      "          ),",
      "          const SizedBox(height: 10),",
      "          OutlinedButton.icon(",
      "            icon: const Icon(Icons.refresh),",
      "            label: Text(AppLocalizations.of(context)!.retry),",
      "            onPressed: onRetry,",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "// --- DATA MODEL ---",
      "",
      "class BillingSummaryData {",
      "  final double totalOutstanding;",
      "  final int overdueCount;",
      "  final double paidLast30Days;",
      "  final bool hasOutstanding;",
      "",
      "  BillingSummaryData({",
      "    required this.totalOutstanding,",
      "    required this.overdueCount,",
      "    required this.paidLast30Days,",
      "  }) : hasOutstanding = totalOutstanding > 0;",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 255,
      "file_size": 8310,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\dashboard\\dashboard_section_card.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:provider/provider.dart';",
      "",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/config/branding_config.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "import 'package:franchise_admin_portal/widgets/loading_shimmer_widget.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class DashboardSectionCard extends StatelessWidget {",
      "  final String title;",
      "  final IconData icon;",
      "  final WidgetBuilder builder;",
      "  final String? franchiseId;",
      "  final String? brandId;",
      "  final bool developerOnly;",
      "  final bool showFuturePlaceholders;",
      "",
      "  const DashboardSectionCard({",
      "    super.key,",
      "    required this.title,",
      "    required this.icon,",
      "    required this.builder,",
      "    this.franchiseId,",
      "    this.brandId,",
      "    this.developerOnly = false,",
      "    this.showFuturePlaceholders = false,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    final user = Provider.of<AdminUserProvider>(context).user;",
      "",
      "    final isDeveloper = user?.isDeveloper == true;",
      "",
      "    // Guard if developerOnly is true",
      "    if (developerOnly && !isDeveloper) return const SizedBox.shrink();",
      "",
      "    final brandColor = brandId != null",
      "        ? BrandingConfig.brandColorFor(brandId!)",
      "        : BrandingConfig.brandRed;",
      "",
      "    return Card(",
      "      shape: RoundedRectangleBorder(",
      "        borderRadius: BorderRadius.circular(DesignTokens.radius2xl),",
      "      ),",
      "      elevation: 0,",
      "      color: brandColor.withOpacity(0.04),",
      "      shadowColor: brandColor,",
      "      child: Padding(",
      "          padding: const EdgeInsets.all(DesignTokens.paddingLg),",
      "          child: ConstrainedBox(",
      "            constraints: const BoxConstraints(",
      "                minHeight: 200,",
      "                maxHeight: 320), // You may want to tweak maxHeight!",
      "            child: Column(",
      "              crossAxisAlignment: CrossAxisAlignment.start,",
      "              children: [",
      "                Row(",
      "                  children: [",
      "                    Icon(icon, color: brandColor),",
      "                    const SizedBox(width: 8),",
      "                    Text(",
      "                      title,",
      "                      style: Theme.of(context).textTheme.titleMedium?.copyWith(",
      "                            fontWeight: FontWeight.bold,",
      "                            color: brandColor,",
      "                          ),",
      "                    ),",
      "                  ],",
      "                ),",
      "                const SizedBox(height: 12),",
      "",
      "                // ---- Key Fix: Scrollable main card content ----",
      "                Expanded(",
      "                  child: SingleChildScrollView(",
      "                    child: Builder(",
      "                      builder: (context) {",
      "                        try {",
      "                          return builder(context);",
      "                        } catch (e, st) {",
      "                          final fs = Provider.of<FirestoreService>(context,",
      "                              listen: false);",
      "                          ErrorLogger.log(",
      "                            message: 'Error building section $title: $e',",
      "                            stack: st.toString(),",
      "                            source: 'DashboardSectionCard',",
      "                            screen: title,",
      "                            severity: 'error',",
      "                            contextData: {",
      "                              'franchiseId': franchiseId,",
      "                              'sectionTitle': title,",
      "                            },",
      "                          );",
      "",
      "                          return Text(",
      "                            loc.errorLoadingSection,",
      "                            style:",
      "                                Theme.of(context).textTheme.bodySmall?.copyWith(",
      "                                      color: colorScheme.error,",
      "                                    ),",
      "                          );",
      "                        }",
      "                      },",
      "                    ),",
      "                  ),",
      "                ),",
      "                // ---- end Key Fix ----",
      "",
      "                if (showFuturePlaceholders) ...[",
      "                  const SizedBox(height: 12),",
      "                  _FeaturePlaceholder(label: loc.featureComingSoonCashFlow),",
      "                  _FeaturePlaceholder(",
      "                      label: loc.featureComingSoonRevenueTrends),",
      "                ],",
      "              ],",
      "            ),",
      "          )),",
      "    );",
      "  }",
      "}",
      "",
      "class _FeaturePlaceholder extends StatelessWidget {",
      "  final String label;",
      "  const _FeaturePlaceholder({required this.label});",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final color = Theme.of(context).colorScheme.outline;",
      "    return Container(",
      "      margin: const EdgeInsets.only(top: 6),",
      "      padding: const EdgeInsets.all(10),",
      "      decoration: BoxDecoration(",
      "        border: Border.all(color: color.withOpacity(0.25)),",
      "        borderRadius: BorderRadius.circular(DesignTokens.radiusLg),",
      "      ),",
      "      child: Row(",
      "        children: [",
      "          const Icon(Icons.lightbulb_outline, size: 20, color: Colors.amber),",
      "          const SizedBox(width: 8),",
      "          Text(",
      "            label,",
      "            style: Theme.of(context).textTheme.bodySmall?.copyWith(",
      "                  fontStyle: FontStyle.italic,",
      "                ),",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 162,
      "file_size": 5833,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\dashboard\\dashboard_skeleton.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "",
      "class DashboardSkeleton extends StatelessWidget {",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    return Padding(",
      "      padding: const EdgeInsets.all(32.0),",
      "      child: Column(",
      "        children: [",
      "          Row(",
      "            children: List.generate(",
      "              4,",
      "              (_) => Expanded(",
      "                child: Container(",
      "                  margin: const EdgeInsets.symmetric(horizontal: 8),",
      "                  height: 80,",
      "                  decoration: BoxDecoration(",
      "                    color: colorScheme.surfaceVariant,",
      "                    borderRadius: BorderRadius.circular(16),",
      "                  ),",
      "                ),",
      "              ),",
      "            ),",
      "          ),",
      "          const SizedBox(height: 24),",
      "          Row(",
      "            children: List.generate(",
      "              2,",
      "              (_) => Expanded(",
      "                child: Container(",
      "                  margin: const EdgeInsets.symmetric(horizontal: 8),",
      "                  height: 180,",
      "                  decoration: BoxDecoration(",
      "                    color: colorScheme.surfaceVariant,",
      "                    borderRadius: BorderRadius.circular(16),",
      "                  ),",
      "                ),",
      "              ),",
      "            ),",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 46,
      "file_size": 1377,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\dashboard\\dashboard_switcher_dropdown.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/models/user.dart' as app;",
      "",
      "class DashboardSwitcherDropdown extends StatelessWidget {",
      "  final String currentScreen;",
      "  final app.User user;",
      "",
      "  const DashboardSwitcherDropdown({",
      "    super.key,",
      "    required this.currentScreen,",
      "    required this.user,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[DashboardSwitcherDropdown] loc is null! Localization not available.');",
      "      return const Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "",
      "    final roles = user.roles;",
      "    print(",
      "        '[DashboardSwitcherDropdown] build called with roles=$roles, currentScreen=\"$currentScreen\"');",
      "",
      "    // Only allow access if one of the supported roles is present",
      "    if (!roles.any((r) => [",
      "          'platform_owner',",
      "          'hq_owner',",
      "          'hq_manager',",
      "          'developer'",
      "        ].contains(r))) {",
      "      return const SizedBox.shrink();",
      "    }",
      "",
      "    final options = <_DashboardTarget>[",
      "      _DashboardTarget(",
      "        key: 'admin',",
      "        label: loc.adminDashboardTitle ?? 'Admin Dashboard',",
      "        route: '/admin/dashboard',",
      "      ),",
      "      if (roles.contains('developer'))",
      "        _DashboardTarget(",
      "          key: 'developer',",
      "          label: loc.developerDashboardTitle ?? 'Developer Dashboard',",
      "          route: '/developer/dashboard',",
      "        ),",
      "      if (roles.contains('hq_owner') || roles.contains('hq_manager'))",
      "        _DashboardTarget(",
      "          key: 'hq',",
      "          label: loc.ownerHQDashboardTitle ?? 'HQ Dashboard',",
      "          route: '/hq-owner/dashboard',",
      "        ),",
      "      if (roles.contains('platform_owner'))",
      "        _DashboardTarget(",
      "          key: 'platform_owner',",
      "          label: loc.platformOwnerDashboardTitle ?? 'Platform Owner Dashboard',",
      "          route: '/platform-owner/dashboard',",
      "        ),",
      "    ];",
      "",
      "    final current = options.firstWhere(",
      "      (opt) => opt.route.toLowerCase().contains(currentScreen.toLowerCase()),",
      "      orElse: () => options.first,",
      "    );",
      "",
      "    final isDark = Theme.of(context).brightness == Brightness.dark;",
      "",
      "    return DropdownButton<_DashboardTarget>(",
      "      value: current,",
      "      icon: Icon(",
      "        Icons.keyboard_arrow_down,",
      "        color: isDark ? Colors.white : Colors.black,",
      "      ),",
      "      style: TextStyle(",
      "        color: isDark ? Colors.white : Colors.black,",
      "        fontWeight: FontWeight.w600,",
      "      ),",
      "      underline: const SizedBox.shrink(),",
      "      onChanged: (selected) {",
      "        if (selected == null) return;",
      "        if (selected.route == ModalRoute.of(context)?.settings.name) return;",
      "",
      "        print(",
      "            '[DEBUG-NAV] FROM DASHBOARD SWITCHER DROPDOWN → Navigating to ${selected.route}');",
      "        Navigator.of(context).pushReplacementNamed(selected.route);",
      "      },",
      "      items: options.map((opt) {",
      "        return DropdownMenuItem<_DashboardTarget>(",
      "          value: opt,",
      "          child: Text(opt.label),",
      "        );",
      "      }).toList(),",
      "    );",
      "  }",
      "}",
      "",
      "class _DashboardTarget {",
      "  final String key;",
      "  final String label;",
      "  final String route;",
      "",
      "  _DashboardTarget({",
      "    required this.key,",
      "    required this.label,",
      "    required this.route,",
      "  });",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 112,
      "file_size": 3420,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\dashboard\\franchise_picker_dropdown.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/models/franchise_info.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "",
      "class FranchisePickerDropdown extends StatelessWidget {",
      "  final String? selectedFranchiseId;",
      "",
      "  const FranchisePickerDropdown({super.key, this.selectedFranchiseId});",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    print('[FranchisePickerDropdown] build called (dropdown in AppBar only)');",
      "",
      "    final franchiseProvider = Provider.of<FranchiseProvider>(context);",
      "    final user = Provider.of<AdminUserProvider>(context).user;",
      "    final loc = AppLocalizations.of(context);",
      "",
      "    final franchises = franchiseProvider.viewableFranchises;",
      "    print('[FranchisePickerDropdown] All franchises: $franchises');",
      "    final currentId = selectedFranchiseId ?? franchiseProvider.franchiseId;",
      "    final isDark = Theme.of(context).brightness == Brightness.dark;",
      "    if (franchises == null || franchises.isEmpty) {",
      "      return Tooltip(",
      "        message: loc?.noFranchisesAvailable ?? 'No franchises found',",
      "        child: Icon(Icons.store_mall_directory, color: Colors.grey.shade400),",
      "      );",
      "    }",
      "",
      "    final currentFranchise = franchises.firstWhere(",
      "      (f) => f.id == currentId,",
      "      orElse: () => franchises.first,",
      "    );",
      "",
      "    return DropdownButtonHideUnderline(",
      "      child: DropdownButton<String>(",
      "        value: currentFranchise.id,",
      "        icon: const Icon(Icons.keyboard_arrow_down_rounded),",
      "        style: Theme.of(context).textTheme.bodyMedium,",
      "        borderRadius: BorderRadius.circular(12),",
      "        dropdownColor: Theme.of(context).colorScheme.surface,",
      "        onChanged: (String? newValue) {",
      "          if (newValue != null && newValue != currentFranchise.id) {",
      "            print(",
      "                '[FranchisePickerDropdown] Selected new franchise ID: $newValue');",
      "            final selectedFranchise = franchises.firstWhere(",
      "              (f) => f.id == newValue,",
      "              orElse: () => FranchiseInfo(id: newValue, name: 'Unknown'),",
      "            );",
      "            print(",
      "                '[FranchisePickerDropdown] Selected franchise name: ${selectedFranchise.name}');",
      "",
      "            franchiseProvider.setFranchiseId(newValue);",
      "",
      "            // 🧠 Defer route transition slightly to allow provider update to propagate",
      "            Future.microtask(() {",
      "              print(",
      "                  '[FranchisePickerDropdown] Navigating to Admin Dashboard after franchise selection...');",
      "              Navigator.pushNamed(",
      "                context,",
      "                '/admin/dashboard?section=onboardingMenu',",
      "              );",
      "            });",
      "          }",
      "        },",
      "        items: franchises.map<DropdownMenuItem<String>>((f) {",
      "          return DropdownMenuItem<String>(",
      "            value: f.id,",
      "            child: Row(",
      "              children: [",
      "                Icon(",
      "                  Icons.store_mall_directory,",
      "                  color: isDark ? Colors.white : Colors.black,",
      "                ),",
      "                const SizedBox(width: 8),",
      "                Text(",
      "                  f.name,",
      "                  style: TextStyle(",
      "                    fontWeight: f.id == currentFranchise.id",
      "                        ? FontWeight.bold",
      "                        : FontWeight.normal,",
      "                    color: isDark ? Colors.white : Colors.black,",
      "                  ),",
      "                ),",
      "              ],",
      "            ),",
      "          );",
      "        }).toList(),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 94,
      "file_size": 3729,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\dashboard\\global_search_bar.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "",
      "class GlobalSearchBar extends StatefulWidget {",
      "  const GlobalSearchBar({Key? key}) : super(key: key);",
      "",
      "  @override",
      "  State<GlobalSearchBar> createState() => _GlobalSearchBarState();",
      "}",
      "",
      "class _GlobalSearchBarState extends State<GlobalSearchBar> {",
      "  final controller = TextEditingController();",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    return Container(",
      "      width: 250,",
      "      child: TextField(",
      "        controller: controller,",
      "        decoration: InputDecoration(",
      "          hintText: \"Search everything...\",",
      "          prefixIcon:",
      "              Icon(Icons.search, color: colorScheme.onSurface.withOpacity(0.6)),",
      "          border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),",
      "          fillColor: colorScheme.surfaceVariant,",
      "          filled: true,",
      "          contentPadding: EdgeInsets.symmetric(vertical: 0, horizontal: 12),",
      "        ),",
      "        style: Theme.of(context).textTheme.bodyMedium,",
      "        onSubmitted: (query) {",
      "          // TODO: Integrate global search logic",
      "          ScaffoldMessenger.of(context).showSnackBar(",
      "              SnackBar(content: Text('Global search coming soon!')));",
      "        },",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 38,
      "file_size": 1290,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\dashboard\\live_operational_snapshot_widget.dart",
    "content": [
      "// File: lib/admin/dashboard/widgets/live_operational_snapshot_widget.dart",
      "//",
      "// PURPOSE:",
      "// Displays real-time operational metrics for the currently selected franchise.",
      "// Controlled by the `liveSnapshotEnabled` flag in `FranchiseFeatureProvider`.",
      "// Data is streamed from Firestore in near real time.",
      "//",
      "// AUTHOR:",
      "// Auto-generated with production-readiness, logging, and maintainability in mind.",
      "//",
      "// DEPENDENCIES:",
      "// - franchise_provider.dart (for franchiseId context)",
      "// - error_logger.dart (for robust logging)",
      "// - cloud_firestore.dart",
      "// - provider.dart (for context.watch)",
      "",
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class LiveOperationalSnapshotWidget extends StatelessWidget {",
      "  final String franchiseId;",
      "  final bool expanded; // Controls layout size",
      "",
      "  const LiveOperationalSnapshotWidget({",
      "    Key? key,",
      "    required this.franchiseId,",
      "    required this.expanded,",
      "  }) : super(key: key);",
      "",
      "  /// Firestore stream to watch active, completed, and in_kitchen orders",
      "  Stream<QuerySnapshot<Map<String, dynamic>>> _liveOpsStream() {",
      "    debugPrint(",
      "        '[LiveOperationalSnapshotWidget] Starting stream for franchiseId: $franchiseId');",
      "    return FirebaseFirestore.instance",
      "        .collection('franchises')",
      "        .doc(franchiseId)",
      "        .collection('orders')",
      "        .where('status',",
      "            whereIn: ['active', 'completed', 'in_kitchen']).snapshots();",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return StreamBuilder<QuerySnapshot<Map<String, dynamic>>>(",
      "      stream: _liveOpsStream(),",
      "      builder: (context, snapshot) {",
      "        if (snapshot.hasError) {",
      "          // Check for index creation link in Firestore error",
      "          final errorStr = snapshot.error.toString();",
      "          if (errorStr.contains('FAILED_PRECONDITION') &&",
      "              errorStr.contains('index')) {",
      "            final linkMatch =",
      "                RegExp(r'https:\\/\\/console\\.firebase\\.google\\.com\\/[^\\s]+')",
      "                    .firstMatch(errorStr);",
      "            if (linkMatch != null) {",
      "              debugPrint(",
      "                  '[LiveOperationalSnapshotWidget] Firestore index required: ${linkMatch.group(0)}');",
      "            }",
      "          }",
      "",
      "          // Log the error",
      "          ErrorLogger.log(",
      "            message: 'Live ops snapshot stream error',",
      "            stack: snapshot.error.toString(),",
      "            source: 'LiveOperationalSnapshotWidget',",
      "            severity: 'error',",
      "            screen: 'dashboard_home_screen.dart',",
      "            contextData: {'franchiseId': franchiseId},",
      "          );",
      "          return const Text('Error loading live metrics.');",
      "        }",
      "",
      "        if (!snapshot.hasData) {",
      "          return const Center(child: CircularProgressIndicator());",
      "        }",
      "",
      "        final docs = snapshot.data!.docs;",
      "        debugPrint(",
      "            '[LiveOperationalSnapshotWidget] Received ${docs.length} order documents.');",
      "",
      "        final now = DateTime.now();",
      "        final oneHourAgo = now.subtract(const Duration(hours: 1));",
      "        final todayStart = DateTime(now.year, now.month, now.day);",
      "",
      "        try {",
      "          // --- Metric calculations ---",
      "          final activeOrders =",
      "              docs.where((d) => d['status'] == 'active').length;",
      "",
      "          final recentOrders = docs.where((d) {",
      "            final ts = (d['createdAt'] as Timestamp?)?.toDate();",
      "            return ts != null && ts.isAfter(oneHourAgo);",
      "          }).length;",
      "",
      "          final kitchenTickets =",
      "              docs.where((d) => d['status'] == 'in_kitchen').length;",
      "",
      "          final kitchenLoad = docs",
      "              .where((d) => d['status'] == 'in_kitchen')",
      "              .fold<int>(0, (sum, d) {",
      "            final count =",
      "                (d['items'] is List) ? (d['items'] as List).length : 0;",
      "            return sum + count;",
      "          });",
      "",
      "          final todayRevenue = docs.where((d) {",
      "            final ts = (d['createdAt'] as Timestamp?)?.toDate();",
      "            return ts != null &&",
      "                ts.isAfter(todayStart) &&",
      "                d['status'] == 'completed';",
      "          }).fold<double>(0.0, (sum, d) {",
      "            final val = d['total'];",
      "            return sum + ((val is num) ? val.toDouble() : 0.0);",
      "          });",
      "",
      "          final completedOrders = docs",
      "              .where(",
      "                  (d) => d['status'] == 'completed' && d['completedAt'] != null)",
      "              .take(20)",
      "              .map((d) {",
      "            final created = (d['createdAt'] as Timestamp?)?.toDate() ?? now;",
      "            final completed = (d['completedAt'] as Timestamp?)?.toDate() ?? now;",
      "            return completed.difference(created).inMinutes;",
      "          }).toList();",
      "",
      "          final avgFulfillmentTime = completedOrders.isEmpty",
      "              ? 0",
      "              : completedOrders.reduce((a, b) => a + b) /",
      "                  completedOrders.length;",
      "",
      "          debugPrint('[LiveOperationalSnapshotWidget] Metrics → '",
      "              'Active: $activeOrders, LastHour: $recentOrders, '",
      "              'KitchenTickets: $kitchenTickets, KitchenLoad: $kitchenLoad, '",
      "              'RevenueToday: $todayRevenue, AvgFulfillment: $avgFulfillmentTime');",
      "",
      "          // Expanded → 2×3 grid",
      "          if (expanded) {",
      "            return GridView.count(",
      "              crossAxisCount: 2,",
      "              shrinkWrap: true,",
      "              physics: const NeverScrollableScrollPhysics(),",
      "              crossAxisSpacing: 12,",
      "              mainAxisSpacing: 12,",
      "              childAspectRatio: 2.4,",
      "              children: [",
      "                _metricCard('Active Orders', activeOrders.toString(),",
      "                    Icons.shopping_cart),",
      "                _metricCard('Orders (Last Hour)', recentOrders.toString(),",
      "                    Icons.access_time),",
      "                _metricCard('Kitchen Tickets', kitchenTickets.toString(),",
      "                    Icons.kitchen),",
      "                _metricCard(",
      "                    'Kitchen Load', kitchenLoad.toString(), Icons.restaurant),",
      "                _metricCard('Revenue Today',",
      "                    '\\$${todayRevenue.toStringAsFixed(2)}', Icons.attach_money),",
      "                _metricCard('Avg Fulfillment (min)',",
      "                    avgFulfillmentTime.toStringAsFixed(1), Icons.timer),",
      "              ],",
      "            );",
      "          }",
      "",
      "          // Collapsed → single compact row",
      "          return Row(",
      "            mainAxisAlignment: MainAxisAlignment.spaceEvenly,",
      "            children: [",
      "              _metricCard(",
      "                  'Active', activeOrders.toString(), Icons.shopping_cart,",
      "                  compact: true),",
      "              _metricCard('1h', recentOrders.toString(), Icons.access_time,",
      "                  compact: true),",
      "              _metricCard('Rev', '\\$${todayRevenue.toStringAsFixed(0)}',",
      "                  Icons.attach_money,",
      "                  compact: true),",
      "            ],",
      "          );",
      "        } catch (e, st) {",
      "          ErrorLogger.log(",
      "            message: 'Error calculating live ops metrics',",
      "            stack: st.toString(),",
      "            source: 'LiveOperationalSnapshotWidget',",
      "            severity: 'error',",
      "            screen: 'dashboard_home_screen.dart',",
      "            contextData: {'franchiseId': franchiseId, 'docCount': docs.length},",
      "          );",
      "          return const Text('Error calculating metrics.');",
      "        }",
      "      },",
      "    );",
      "  }",
      "",
      "  /// Reusable metric card",
      "  Widget _metricCard(String title, String value, IconData icon,",
      "      {bool compact = false}) {",
      "    return Card(",
      "      elevation: 2,",
      "      child: Padding(",
      "        padding: const EdgeInsets.all(8.0),",
      "        child: Column(",
      "          mainAxisSize: MainAxisSize.min,",
      "          children: [",
      "            Icon(icon, size: compact ? 20 : 28, color: Colors.blueGrey),",
      "            const SizedBox(height: 4),",
      "            Text(value,",
      "                style: TextStyle(",
      "                    fontSize: compact ? 14 : 20, fontWeight: FontWeight.bold)),",
      "            const SizedBox(height: 2),",
      "            Text(title,",
      "                style:",
      "                    TextStyle(fontSize: compact ? 10 : 12, color: Colors.grey)),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 218,
      "file_size": 8407,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\dashboard\\maintenance_banner.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "",
      "class MaintenanceBanner extends StatelessWidget {",
      "  final bool show;",
      "  final String? message;",
      "  const MaintenanceBanner({Key? key, this.show = false, this.message})",
      "      : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    if (!show) return SizedBox.shrink();",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    return MaterialBanner(",
      "      content: Text(",
      "        message ??",
      "            \"The system is in maintenance mode. Some features may be unavailable.\",",
      "        style: TextStyle(color: colorScheme.onError),",
      "      ),",
      "      backgroundColor: colorScheme.error,",
      "      actions: [",
      "        TextButton(",
      "          onPressed: () {},",
      "          child: Text(\"Dismiss\", style: TextStyle(color: colorScheme.onError)),",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 28,
      "file_size": 841,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\dashboard\\notifications_panel.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "",
      "class NotificationsPanel extends StatelessWidget {",
      "  final List<String>? notifications;",
      "  const NotificationsPanel({Key? key, this.notifications}) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    return Card(",
      "      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),",
      "      color: colorScheme.surface,",
      "      child: Padding(",
      "        padding: const EdgeInsets.all(18.0),",
      "        child: Column(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            Row(",
      "              children: [",
      "                Icon(Icons.notifications_active_outlined,",
      "                    color: colorScheme.primary, size: 24),",
      "                SizedBox(width: 8),",
      "                Text(\"Notifications\",",
      "                    style: Theme.of(context).textTheme.titleSmall),",
      "              ],",
      "            ),",
      "            SizedBox(height: 12),",
      "            notifications == null || notifications!.isEmpty",
      "                ? Center(",
      "                    child: Text(",
      "                      \"You're all caught up!\",",
      "                      style: Theme.of(context).textTheme.bodyMedium?.copyWith(",
      "                          color: colorScheme.onSurface.withOpacity(0.5)),",
      "                    ),",
      "                  )",
      "                : Expanded(",
      "                    child: ListView.builder(",
      "                      itemCount: notifications!.length,",
      "                      itemBuilder: (context, idx) => ListTile(",
      "                        leading: Icon(Icons.notifications,",
      "                            color: colorScheme.primary, size: 18),",
      "                        title: Text(notifications![idx],",
      "                            style: Theme.of(context).textTheme.bodyMedium),",
      "                        dense: true,",
      "                        visualDensity: VisualDensity.compact,",
      "                      ),",
      "                    ),",
      "                  ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 54,
      "file_size": 2060,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\dashboard\\role_badge.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "",
      "class RoleBadge extends StatelessWidget {",
      "  final String role;",
      "  const RoleBadge({Key? key, required this.role}) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    Color badgeColor;",
      "    switch (role) {",
      "      case 'Owner':",
      "        badgeColor = colorScheme.primary;",
      "        break;",
      "      case 'Admin':",
      "        badgeColor = colorScheme.secondary;",
      "        break;",
      "      default:",
      "        badgeColor = colorScheme.tertiary ?? colorScheme.primaryContainer;",
      "    }",
      "    return Chip(",
      "      label: Text(role, style: TextStyle(color: colorScheme.onPrimary)),",
      "      backgroundColor: badgeColor,",
      "      visualDensity: VisualDensity.compact,",
      "      labelPadding: EdgeInsets.symmetric(horizontal: 8),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 28,
      "file_size": 841,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\dashboard\\urgent_status_card.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "",
      "class UrgentStatusCard extends StatelessWidget {",
      "  final List<String>? alerts;",
      "  const UrgentStatusCard({Key? key, this.alerts}) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    return Card(",
      "      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),",
      "      color: colorScheme.surface,",
      "      child: Padding(",
      "        padding: const EdgeInsets.all(18.0),",
      "        child: Column(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            Row(",
      "              children: [",
      "                Icon(Icons.warning_rounded, color: colorScheme.error, size: 24),",
      "                SizedBox(width: 8),",
      "                Text(\"Urgent Actions\",",
      "                    style: Theme.of(context).textTheme.titleSmall?.copyWith(",
      "                          color: colorScheme.error,",
      "                        )),",
      "              ],",
      "            ),",
      "            SizedBox(height: 12),",
      "            alerts == null || alerts!.isEmpty",
      "                ? Center(",
      "                    child: Text(\"No urgent actions!\",",
      "                        style: Theme.of(context).textTheme.bodyMedium?.copyWith(",
      "                            color: colorScheme.onSurface.withOpacity(0.5))),",
      "                  )",
      "                : Expanded(",
      "                    child: ListView.builder(",
      "                      itemCount: alerts!.length,",
      "                      itemBuilder: (context, idx) => ListTile(",
      "                        leading: Icon(Icons.error_outline,",
      "                            color: colorScheme.error, size: 20),",
      "                        title: Text(alerts![idx],",
      "                            style: Theme.of(context)",
      "                                .textTheme",
      "                                .bodyMedium",
      "                                ?.copyWith(color: colorScheme.error)),",
      "                        dense: true,",
      "                        visualDensity: VisualDensity.compact,",
      "                      ),",
      "                    ),",
      "                  ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 56,
      "file_size": 2159,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\developer\\audit_trail_section.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class AuditTrailSection extends StatefulWidget {",
      "  final String? franchiseId;",
      "  const AuditTrailSection({Key? key, this.franchiseId}) : super(key: key);",
      "",
      "  @override",
      "  State<AuditTrailSection> createState() => _AuditTrailSectionState();",
      "}",
      "",
      "class _AuditTrailSectionState extends State<AuditTrailSection> {",
      "  bool _loading = true;",
      "  String? _errorMsg;",
      "  List<AuditEntry> _entries = [];",
      "  String? _filterType;",
      "  String? _filterActor;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _fetchAuditTrail();",
      "  }",
      "",
      "  @override",
      "  void didUpdateWidget(covariant AuditTrailSection oldWidget) {",
      "    super.didUpdateWidget(oldWidget);",
      "    if (oldWidget.franchiseId != widget.franchiseId) {",
      "      _fetchAuditTrail();",
      "    }",
      "  }",
      "",
      "  Future<void> _fetchAuditTrail() async {",
      "    setState(() {",
      "      _loading = true;",
      "      _errorMsg = null;",
      "    });",
      "    try {",
      "      // TODO: Replace with FirestoreService audit log query (by franchiseId/type/actor)",
      "      await Future.delayed(const Duration(milliseconds: 500));",
      "      _entries = [",
      "        AuditEntry(",
      "          timestamp: DateTime.now().subtract(const Duration(minutes: 6)),",
      "          type: 'MenuUpdate',",
      "          description:",
      "              'Updated price of “Deluxe Pizza” from \\$15.99 to \\$16.49',",
      "          actor: 'jane@doughboys.com',",
      "          franchiseId: widget.franchiseId == 'all'",
      "              ? 'doughboyspizzeria'",
      "              : widget.franchiseId,",
      "        ),",
      "        AuditEntry(",
      "          timestamp:",
      "              DateTime.now().subtract(const Duration(hours: 1, minutes: 20)),",
      "          type: 'OrderRefund',",
      "          description: 'Issued refund for order #4562',",
      "          actor: 'manager@doughboys.com',",
      "          franchiseId: widget.franchiseId == 'all'",
      "              ? 'doughboyspizzeria'",
      "              : widget.franchiseId,",
      "        ),",
      "        AuditEntry(",
      "          timestamp: DateTime.now().subtract(const Duration(days: 2)),",
      "          type: 'UserPermission',",
      "          description: 'Granted admin privileges to staff1@doughboys.com',",
      "          actor: 'owner@doughboys.com',",
      "          franchiseId: widget.franchiseId == 'all'",
      "              ? 'doughboyspizzeria'",
      "              : widget.franchiseId,",
      "        ),",
      "      ];",
      "      setState(() => _loading = false);",
      "    } catch (e, stack) {",
      "      setState(() {",
      "        _errorMsg = e.toString();",
      "        _loading = false;",
      "      });",
      "      await ErrorLogger.log(",
      "        message: 'Failed to load audit trail: $e',",
      "        stack: stack.toString(),",
      "        source: 'AuditTrailSection',",
      "        screen: 'DeveloperDashboardScreen',",
      "        severity: 'warning',",
      "        contextData: {",
      "          'franchiseId': widget.franchiseId,",
      "        },",
      "      );",
      "    }",
      "  }",
      "",
      "  void _onTypeFilterChanged(String? newValue) {",
      "    setState(() {",
      "      _filterType = newValue;",
      "    });",
      "  }",
      "",
      "  void _onActorFilterChanged(String? newValue) {",
      "    setState(() {",
      "      _filterActor = newValue;",
      "    });",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "    final adminUser = Provider.of<AdminUserProvider>(context).user;",
      "    final isDeveloper = adminUser?.roles.contains('developer') ?? false;",
      "",
      "    final isAllFranchises = widget.franchiseId == 'all';",
      "",
      "    if (!isDeveloper) {",
      "      return Center(",
      "        child: Text(",
      "          loc.unauthorizedAccess,",
      "          style: theme.textTheme.titleLarge?.copyWith(",
      "            color: colorScheme.error,",
      "            fontWeight: FontWeight.bold,",
      "          ),",
      "        ),",
      "      );",
      "    }",
      "",
      "    // Extract unique types and actors for filters (for real: get from backend or unique on all entries)",
      "    final types = _entries.map((e) => e.type).toSet().toList()..sort();",
      "    final actors = _entries.map((e) => e.actor).toSet().toList()..sort();",
      "",
      "    final filtered = _entries.where((entry) {",
      "      final typeOk = _filterType == null || entry.type == _filterType;",
      "      final actorOk = _filterActor == null || entry.actor == _filterActor;",
      "      return typeOk && actorOk;",
      "    }).toList();",
      "",
      "    return Padding(",
      "      padding: const EdgeInsets.all(24.0),",
      "      child: Column(",
      "        crossAxisAlignment: CrossAxisAlignment.start,",
      "        children: [",
      "          Text(",
      "            isAllFranchises",
      "                ? '${loc.auditTrailSectionTitle} — ${loc.allFranchisesLabel ?? \"All Franchises\"}'",
      "                : '${loc.auditTrailSectionTitle} — ${widget.franchiseId}',",
      "            style: theme.textTheme.titleLarge?.copyWith(",
      "              color: colorScheme.primary,",
      "              fontWeight: FontWeight.bold,",
      "            ),",
      "          ),",
      "          const SizedBox(height: 14),",
      "          Text(",
      "            loc.auditTrailSectionDesc,",
      "            style: theme.textTheme.bodyMedium,",
      "          ),",
      "          const SizedBox(height: 18),",
      "          _buildFilterRow(loc, types, actors, colorScheme, theme),",
      "          const SizedBox(height: 18),",
      "          if (_loading)",
      "            Center(child: CircularProgressIndicator(color: colorScheme.primary))",
      "          else if (_errorMsg != null)",
      "            Card(",
      "              color: colorScheme.errorContainer,",
      "              child: Padding(",
      "                padding: const EdgeInsets.all(16.0),",
      "                child: Row(",
      "                  children: [",
      "                    Icon(Icons.error, color: colorScheme.error),",
      "                    const SizedBox(width: 12),",
      "                    Expanded(",
      "                      child: Text(",
      "                        '${loc.auditTrailSectionError}\\n$_errorMsg',",
      "                        style: theme.textTheme.bodyMedium",
      "                            ?.copyWith(color: colorScheme.error),",
      "                      ),",
      "                    ),",
      "                    IconButton(",
      "                      icon: Icon(Icons.refresh, color: colorScheme.primary),",
      "                      tooltip: loc.reload,",
      "                      onPressed: _fetchAuditTrail,",
      "                    ),",
      "                  ],",
      "                ),",
      "              ),",
      "            )",
      "          else if (filtered.isEmpty)",
      "            Center(child: Text(loc.auditTrailSectionEmpty))",
      "          else",
      "            _AuditTrailList(",
      "              entries: filtered,",
      "              colorScheme: colorScheme,",
      "              loc: loc,",
      "            ),",
      "          const SizedBox(height: 32),",
      "          _ComingSoonCard(",
      "            icon: Icons.compare_arrows,",
      "            title: loc.auditTrailSectionRevertComingSoon,",
      "            subtitle: loc.auditTrailSectionRevertDesc,",
      "            colorScheme: colorScheme,",
      "            theme: theme,",
      "          ),",
      "          _ComingSoonCard(",
      "            icon: Icons.auto_fix_high_outlined,",
      "            title: loc.auditTrailSectionExplainComingSoon,",
      "            subtitle: loc.auditTrailSectionExplainDesc,",
      "            colorScheme: colorScheme,",
      "            theme: theme,",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "",
      "  Widget _buildFilterRow(AppLocalizations loc, List<String> types,",
      "      List<String> actors, ColorScheme colorScheme, ThemeData theme) {",
      "    return Row(",
      "      children: [",
      "        Text('${loc.auditTrailSectionTypeFilter}:',",
      "            style: theme.textTheme.titleMedium),",
      "        const SizedBox(width: 10),",
      "        DropdownButton<String>(",
      "          value: _filterType,",
      "          hint: Text(loc.auditTrailSectionFilterAny),",
      "          items: [",
      "            DropdownMenuItem(",
      "                value: null, child: Text(loc.auditTrailSectionFilterAny)),",
      "            ...types.map(",
      "                (type) => DropdownMenuItem(value: type, child: Text(type))),",
      "          ],",
      "          onChanged: _onTypeFilterChanged,",
      "        ),",
      "        const SizedBox(width: 24),",
      "        Text('${loc.auditTrailSectionActorFilter}:',",
      "            style: theme.textTheme.titleMedium),",
      "        const SizedBox(width: 10),",
      "        DropdownButton<String>(",
      "          value: _filterActor,",
      "          hint: Text(loc.auditTrailSectionFilterAny),",
      "          items: [",
      "            DropdownMenuItem(",
      "                value: null, child: Text(loc.auditTrailSectionFilterAny)),",
      "            ...actors.map(",
      "                (actor) => DropdownMenuItem(value: actor, child: Text(actor))),",
      "          ],",
      "          onChanged: _onActorFilterChanged,",
      "        ),",
      "        const Spacer(),",
      "        IconButton(",
      "          icon: const Icon(Icons.refresh),",
      "          tooltip: loc.reload,",
      "          onPressed: _fetchAuditTrail,",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}",
      "",
      "class _AuditTrailList extends StatelessWidget {",
      "  final List<AuditEntry> entries;",
      "  final ColorScheme colorScheme;",
      "  final AppLocalizations loc;",
      "",
      "  const _AuditTrailList({",
      "    required this.entries,",
      "    required this.colorScheme,",
      "    required this.loc,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Card(",
      "      color: colorScheme.surface,",
      "      child: ListView.separated(",
      "        shrinkWrap: true,",
      "        physics: const NeverScrollableScrollPhysics(),",
      "        itemCount: entries.length,",
      "        separatorBuilder: (_, __) => const Divider(height: 1),",
      "        itemBuilder: (context, idx) {",
      "          final entry = entries[idx];",
      "          return ListTile(",
      "            leading: Icon(Icons.timeline, color: colorScheme.outline),",
      "            title: Text(entry.description),",
      "            subtitle: Text(",
      "              '${loc.auditTrailSectionAt} ${entry.type} • ${_formatDateTime(entry.timestamp)}\\n${loc.auditTrailSectionBy}: ${entry.actor}',",
      "              style: const TextStyle(fontSize: 13),",
      "            ),",
      "            trailing:",
      "                entry.franchiseId != null ? Text(entry.franchiseId!) : null,",
      "            shape: RoundedRectangleBorder(",
      "              borderRadius: BorderRadius.circular(DesignTokens.adminCardRadius),",
      "            ),",
      "            onTap: () {",
      "              // TODO: Show full audit entry modal/details.",
      "              ScaffoldMessenger.of(context).showSnackBar(",
      "                SnackBar(content: Text(loc.comingSoon)),",
      "              );",
      "            },",
      "          );",
      "        },",
      "      ),",
      "    );",
      "  }",
      "",
      "  String _formatDateTime(DateTime dt) {",
      "    return '${dt.year}-${dt.month.toString().padLeft(2, '0')}-${dt.day.toString().padLeft(2, '0')} '",
      "        '${dt.hour.toString().padLeft(2, '0')}:${dt.minute.toString().padLeft(2, '0')}';",
      "  }",
      "}",
      "",
      "class _ComingSoonCard extends StatelessWidget {",
      "  final IconData icon;",
      "  final String title;",
      "  final String subtitle;",
      "  final ColorScheme colorScheme;",
      "  final ThemeData theme;",
      "",
      "  const _ComingSoonCard({",
      "    required this.icon,",
      "    required this.title,",
      "    required this.subtitle,",
      "    required this.colorScheme,",
      "    required this.theme,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Card(",
      "      color: colorScheme.surfaceVariant.withOpacity(0.87),",
      "      elevation: DesignTokens.adminCardElevation,",
      "      shape: RoundedRectangleBorder(",
      "        borderRadius: BorderRadius.circular(DesignTokens.adminCardRadius),",
      "      ),",
      "      child: Padding(",
      "        padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 20),",
      "        child: Row(",
      "          children: [",
      "            Icon(icon, color: colorScheme.outline, size: 30),",
      "            const SizedBox(width: 18),",
      "            Expanded(",
      "              child: Column(",
      "                crossAxisAlignment: CrossAxisAlignment.start,",
      "                children: [",
      "                  Text(",
      "                    title,",
      "                    style: theme.textTheme.titleMedium?.copyWith(",
      "                      color: colorScheme.outline,",
      "                      fontWeight: FontWeight.bold,",
      "                    ),",
      "                  ),",
      "                  const SizedBox(height: 4),",
      "                  Text(",
      "                    subtitle,",
      "                    style: theme.textTheme.bodyMedium,",
      "                  ),",
      "                ],",
      "              ),",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "class AuditEntry {",
      "  final DateTime timestamp;",
      "  final String type;",
      "  final String description;",
      "  final String actor;",
      "  final String? franchiseId;",
      "",
      "  AuditEntry({",
      "    required this.timestamp,",
      "    required this.type,",
      "    required this.description,",
      "    required this.actor,",
      "    this.franchiseId,",
      "  });",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 390,
      "file_size": 13058,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\developer\\error_logs_section.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "import 'package:franchise_admin_portal/admin/developer/developer_error_logs_screen.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class ErrorLogsSection extends StatefulWidget {",
      "  final String? franchiseId;",
      "  const ErrorLogsSection({Key? key, this.franchiseId}) : super(key: key);",
      "",
      "  @override",
      "  State<ErrorLogsSection> createState() => _ErrorLogsSectionState();",
      "}",
      "",
      "class _ErrorLogsSectionState extends State<ErrorLogsSection> {",
      "  bool _loading = true;",
      "  String? _errorMsg;",
      "  List<ErrorLogSummary> _logs = [];",
      "  String? _filterSeverity;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _fetchLogs();",
      "  }",
      "",
      "  @override",
      "  void didUpdateWidget(covariant ErrorLogsSection oldWidget) {",
      "    super.didUpdateWidget(oldWidget);",
      "    if (oldWidget.franchiseId != widget.franchiseId) {",
      "      _fetchLogs();",
      "    }",
      "  }",
      "",
      "  Future<void> _fetchLogs() async {",
      "    setState(() {",
      "      _loading = true;",
      "      _errorMsg = null;",
      "    });",
      "",
      "    try {",
      "      final allLogs = await FirestoreService().getErrorLogSummaries();",
      "",
      "      print('✅ Retrieved ${allLogs.length} logs from Firestore');",
      "      for (final log in allLogs) {",
      "        print(",
      "            '[DEBUG] Log => ${log.timestamp} | ${log.severity} | ${log.message}');",
      "      }",
      "",
      "      final filteredLogs = _filterSeverity == null",
      "          ? allLogs",
      "          : allLogs.where((log) => log.severity == _filterSeverity).toList();",
      "      print('👀 Setting logs: ${filteredLogs.length} logs');",
      "      setState(() {",
      "        _logs = filteredLogs;",
      "        _loading = false;",
      "      });",
      "    } catch (e, stack) {",
      "      setState(() {",
      "        _errorMsg = e.toString();",
      "        _loading = false;",
      "      });",
      "",
      "      await ErrorLogger.log(",
      "        message: 'Failed to load error logs: $e',",
      "        stack: stack.toString(),",
      "        source: 'ErrorLogsSection',",
      "        screen: 'DeveloperDashboardScreen',",
      "        severity: 'warning',",
      "        contextData: {'franchiseId': widget.franchiseId},",
      "      );",
      "    }",
      "  }",
      "",
      "  void _onSeverityFilterChanged(String? newValue) {",
      "    setState(() {",
      "      _filterSeverity = newValue;",
      "    });",
      "    _fetchLogs(); // Refetch based on new severity filter",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    debugPrint('Loaded error_logs_section');",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "    final adminUser = Provider.of<AdminUserProvider>(context).user;",
      "    final isDeveloper = adminUser?.roles.contains('developer') ?? false;",
      "",
      "    // Developer-only access guard",
      "    if (!isDeveloper) {",
      "      return Center(",
      "        child: Text(",
      "          loc.unauthorizedAccess,",
      "          style: theme.textTheme.titleLarge?.copyWith(",
      "            color: colorScheme.error,",
      "            fontWeight: FontWeight.bold,",
      "          ),",
      "        ),",
      "      );",
      "    }",
      "",
      "    final isAllFranchises = widget.franchiseId == 'all';",
      "    final titleFranchiseLabel = isAllFranchises",
      "        ? (loc.allFranchisesLabel ?? \"All Franchises\")",
      "        : (widget.franchiseId ?? \"Unknown Franchise\");",
      "",
      "    return Padding(",
      "      padding: const EdgeInsets.all(24.0),",
      "      child: SingleChildScrollView(",
      "        physics: const AlwaysScrollableScrollPhysics(),",
      "        child: Column(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            Text(",
      "              '${loc.errorLogsSectionTitle} — $titleFranchiseLabel',",
      "              style: theme.textTheme.titleLarge?.copyWith(",
      "                color: colorScheme.primary,",
      "                fontWeight: FontWeight.bold,",
      "              ),",
      "            ),",
      "            const SizedBox(height: 14),",
      "            Text(",
      "              loc.errorLogsSectionDesc,",
      "              style: theme.textTheme.bodyMedium,",
      "            ),",
      "            const SizedBox(height: 18),",
      "            _buildFilterRow(loc, colorScheme, theme),",
      "            const SizedBox(height: 18),",
      "            if (_loading)",
      "              Center(",
      "                  child: CircularProgressIndicator(color: colorScheme.primary))",
      "            else if (_errorMsg != null)",
      "              Card(",
      "                color: colorScheme.errorContainer,",
      "                child: Padding(",
      "                  padding: const EdgeInsets.all(16.0),",
      "                  child: Row(",
      "                    children: [",
      "                      Icon(Icons.error, color: colorScheme.error),",
      "                      const SizedBox(width: 12),",
      "                      Expanded(",
      "                        child: Text(",
      "                          '${loc.errorLogsSectionError}\\n$_errorMsg',",
      "                          style: theme.textTheme.bodyMedium",
      "                              ?.copyWith(color: colorScheme.error),",
      "                        ),",
      "                      ),",
      "                      IconButton(",
      "                        icon: Icon(Icons.refresh, color: colorScheme.primary),",
      "                        tooltip: loc.reload,",
      "                        onPressed: _fetchLogs,",
      "                      ),",
      "                    ],",
      "                  ),",
      "                ),",
      "              )",
      "            else ...[",
      "              if (_logs.isEmpty) Center(child: Text(loc.errorLogsSectionEmpty)),",
      "              _ErrorLogList(",
      "                logs: _logs,",
      "                filterSeverity: _filterSeverity,",
      "                colorScheme: colorScheme,",
      "                loc: loc,",
      "              ),",
      "              const SizedBox(height: 16),",
      "              Align(",
      "                alignment: Alignment.centerRight,",
      "                child: OutlinedButton.icon(",
      "                  icon: const Icon(Icons.open_in_new),",
      "                  label: Text(loc.errorLogsSectionViewAll),",
      "                  onPressed: () {",
      "                    Navigator.of(context).push(",
      "                      MaterialPageRoute(",
      "                        builder: (_) => const DeveloperErrorLogsScreen(),",
      "                      ),",
      "                    );",
      "                  },",
      "                ),",
      "              ),",
      "              const SizedBox(height: 32),",
      "              _ComingSoonCard(",
      "                icon: Icons.query_stats,",
      "                title: loc.errorLogsSectionAnalyticsComingSoon,",
      "                subtitle: loc.errorLogsSectionAnalyticsDesc,",
      "                colorScheme: colorScheme,",
      "                theme: theme,",
      "              ),",
      "              _ComingSoonCard(",
      "                icon: Icons.lightbulb_outline,",
      "                title: loc.errorLogsSectionAIInsightsComingSoon,",
      "                subtitle: loc.errorLogsSectionAIInsightsDesc,",
      "                colorScheme: colorScheme,",
      "                theme: theme,",
      "              ),",
      "            ],",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  Widget _buildFilterRow(",
      "      AppLocalizations loc, ColorScheme colorScheme, ThemeData theme) {",
      "    return Row(",
      "      children: [",
      "        Text(loc.errorLogsSectionSeverityFilter,",
      "            style: theme.textTheme.titleMedium),",
      "        const SizedBox(width: 12),",
      "        DropdownButton<String>(",
      "          value: _filterSeverity,",
      "          hint: Text(loc.errorLogsSectionFilterAny),",
      "          items: [",
      "            DropdownMenuItem(",
      "                value: null, child: Text(loc.errorLogsSectionFilterAny)),",
      "            DropdownMenuItem(",
      "                value: 'error', child: Text(loc.errorLogsSectionSeverityError)),",
      "            DropdownMenuItem(",
      "                value: 'warning',",
      "                child: Text(loc.errorLogsSectionSeverityWarning)),",
      "            DropdownMenuItem(",
      "                value: 'fatal', child: Text(loc.errorLogsSectionSeverityFatal)),",
      "          ],",
      "          onChanged: _onSeverityFilterChanged,",
      "        ),",
      "        const Spacer(),",
      "        IconButton(",
      "          icon: const Icon(Icons.refresh),",
      "          tooltip: loc.reload,",
      "          onPressed: _fetchLogs,",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}",
      "",
      "IconData _iconForSeverity(String severity) {",
      "  switch (severity) {",
      "    case 'error':",
      "      return Icons.error;",
      "    case 'warning':",
      "      return Icons.warning;",
      "    case 'fatal':",
      "      return Icons.dangerous;",
      "    default:",
      "      return Icons.bug_report;",
      "  }",
      "}",
      "",
      "Color _colorForSeverity(String severity) {",
      "  switch (severity) {",
      "    case 'error':",
      "      return Colors.red;",
      "    case 'warning':",
      "      return Colors.orange;",
      "    case 'fatal':",
      "      return Colors.deepPurple;",
      "    default:",
      "      return Colors.grey;",
      "  }",
      "}",
      "",
      "class _ErrorLogList extends StatelessWidget {",
      "  final List<ErrorLogSummary> logs;",
      "  final String? filterSeverity;",
      "  final ColorScheme colorScheme;",
      "  final AppLocalizations loc;",
      "",
      "  const _ErrorLogList({",
      "    required this.logs,",
      "    required this.filterSeverity,",
      "    required this.colorScheme,",
      "    required this.loc,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final filtered = filterSeverity == null",
      "        ? logs",
      "        : logs.where((log) => log.severity == filterSeverity).toList();",
      "    if (filtered.isEmpty) {",
      "      return Center(child: Text(loc.errorLogsSectionEmpty));",
      "    }",
      "    return Card(",
      "      child: ListView.separated(",
      "        shrinkWrap: true,",
      "        physics: const NeverScrollableScrollPhysics(),",
      "        itemCount: filtered.length,",
      "        separatorBuilder: (_, __) => const Divider(height: 1),",
      "        itemBuilder: (context, idx) {",
      "          final log = filtered[idx];",
      "          return ListTile(",
      "            leading: Icon(",
      "              _iconForSeverity(log.severity),",
      "              color: _colorForSeverity(log.severity),",
      "            ),",
      "            title: Text(log.message),",
      "            subtitle: Text(",
      "              '${loc.errorLogsSectionAt} ${log.screen} — ${_formatDateTime(log.timestamp)}'",
      "              '${log.franchiseId != null ? \" — Franchise: ${log.franchiseId}\" : \"\"}',",
      "            ),",
      "            trailing: const Icon(Icons.chevron_right),",
      "            shape: RoundedRectangleBorder(",
      "              borderRadius: BorderRadius.circular(DesignTokens.adminCardRadius),",
      "            ),",
      "            onTap: () {",
      "              // TODO: Show detailed error log modal",
      "              ScaffoldMessenger.of(context).showSnackBar(",
      "                SnackBar(content: Text(loc.comingSoon)),",
      "              );",
      "            },",
      "          );",
      "        },",
      "      ),",
      "    );",
      "  }",
      "",
      "  String _formatDateTime(DateTime dt) {",
      "    return '${dt.year}-${dt.month.toString().padLeft(2, '0')}-${dt.day.toString().padLeft(2, '0')} '",
      "        '${dt.hour.toString().padLeft(2, '0')}:${dt.minute.toString().padLeft(2, '0')}';",
      "  }",
      "}",
      "",
      "class _ComingSoonCard extends StatelessWidget {",
      "  final IconData icon;",
      "  final String title;",
      "  final String subtitle;",
      "  final ColorScheme colorScheme;",
      "  final ThemeData theme;",
      "",
      "  const _ComingSoonCard({",
      "    required this.icon,",
      "    required this.title,",
      "    required this.subtitle,",
      "    required this.colorScheme,",
      "    required this.theme,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Card(",
      "      color: colorScheme.surfaceVariant.withOpacity(0.87),",
      "      elevation: DesignTokens.adminCardElevation,",
      "      shape: RoundedRectangleBorder(",
      "        borderRadius: BorderRadius.circular(DesignTokens.adminCardRadius),",
      "      ),",
      "      child: Padding(",
      "        padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 20),",
      "        child: Row(",
      "          children: [",
      "            Icon(icon, color: colorScheme.outline, size: 30),",
      "            const SizedBox(width: 18),",
      "            Expanded(",
      "              child: Column(",
      "                crossAxisAlignment: CrossAxisAlignment.start,",
      "                children: [",
      "                  Text(",
      "                    title,",
      "                    style: theme.textTheme.titleMedium?.copyWith(",
      "                      color: colorScheme.outline,",
      "                      fontWeight: FontWeight.bold,",
      "                    ),",
      "                  ),",
      "                  const SizedBox(height: 4),",
      "                  Text(",
      "                    subtitle,",
      "                    style: theme.textTheme.bodyMedium,",
      "                  ),",
      "                ],",
      "              ),",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "// Simple DTO for demonstration; replace with your error log model",
      "class ErrorLogSummary {",
      "  final String id;",
      "  final DateTime timestamp;",
      "  final String message;",
      "  final String severity;",
      "  final String screen;",
      "  final String? franchiseId;",
      "",
      "  ErrorLogSummary({",
      "    required this.id,",
      "    required this.timestamp,",
      "    required this.message,",
      "    required this.severity,",
      "    required this.screen,",
      "    this.franchiseId,",
      "  });",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 408,
      "file_size": 13258,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\developer\\feature_toggles_section.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class FeatureTogglesSection extends StatefulWidget {",
      "  final String? franchiseId;",
      "  const FeatureTogglesSection({Key? key, this.franchiseId}) : super(key: key);",
      "",
      "  @override",
      "  State<FeatureTogglesSection> createState() => _FeatureTogglesSectionState();",
      "}",
      "",
      "class _FeatureTogglesSectionState extends State<FeatureTogglesSection> {",
      "  bool _loading = true;",
      "  String? _errorMsg;",
      "  List<FeatureToggle> _toggles = [];",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _fetchFeatureToggles();",
      "  }",
      "",
      "  @override",
      "  void didUpdateWidget(covariant FeatureTogglesSection oldWidget) {",
      "    super.didUpdateWidget(oldWidget);",
      "    if (oldWidget.franchiseId != widget.franchiseId) {",
      "      _fetchFeatureToggles();",
      "    }",
      "  }",
      "",
      "  Future<void> _fetchFeatureToggles() async {",
      "    setState(() {",
      "      _loading = true;",
      "      _errorMsg = null;",
      "    });",
      "    try {",
      "      // TODO: Replace with real FirestoreService feature toggle fetch",
      "      await Future.delayed(const Duration(milliseconds: 500));",
      "      _toggles = [",
      "        FeatureToggle(",
      "          key: 'bulk_order_upload',",
      "          name: 'Bulk Order Upload',",
      "          description: 'Enable uploading orders via CSV/Excel.',",
      "          enabled: widget.franchiseId == 'all' ? false : true,",
      "        ),",
      "        FeatureToggle(",
      "          key: 'experimental_ai_recommendations',",
      "          name: 'AI Menu Recommendations',",
      "          description: 'Show AI-driven menu suggestions to users.',",
      "          enabled: false,",
      "        ),",
      "        FeatureToggle(",
      "          key: 'beta_coupon_engine',",
      "          name: 'Beta Coupon Engine',",
      "          description: 'Test new discount/coupon engine.',",
      "          enabled: false,",
      "        ),",
      "      ];",
      "      setState(() => _loading = false);",
      "    } catch (e, stack) {",
      "      setState(() {",
      "        _errorMsg = e.toString();",
      "        _loading = false;",
      "      });",
      "      await ErrorLogger.log(",
      "        message: 'Failed to load feature toggles: $e',",
      "        stack: stack.toString(),",
      "        source: 'FeatureTogglesSection',",
      "        screen: 'DeveloperDashboardScreen',",
      "        severity: 'warning',",
      "        contextData: {",
      "          'franchiseId': widget.franchiseId,",
      "        },",
      "      );",
      "    }",
      "  }",
      "",
      "  Future<void> _setFeatureToggle(FeatureToggle toggle, bool enabled) async {",
      "    try {",
      "      // TODO: Persist feature toggle change with FirestoreService",
      "      await Future.delayed(const Duration(milliseconds: 350));",
      "      setState(() {",
      "        _toggles = _toggles",
      "            .map((ft) =>",
      "                ft.key == toggle.key ? ft.copyWith(enabled: enabled) : ft)",
      "            .toList();",
      "      });",
      "      await ErrorLogger.log(",
      "        message: 'Feature toggle updated: ${toggle.key} -> $enabled',",
      "        source: 'FeatureTogglesSection',",
      "        screen: 'DeveloperDashboardScreen',",
      "        severity: 'info',",
      "        contextData: {",
      "          'franchiseId': widget.franchiseId,",
      "          'featureKey': toggle.key,",
      "          'enabled': enabled,",
      "          'event': 'feature_toggle',",
      "        },",
      "      );",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to update feature toggle: $e',",
      "        stack: stack.toString(),",
      "        source: 'FeatureTogglesSection',",
      "        screen: 'DeveloperDashboardScreen',",
      "        severity: 'error',",
      "        contextData: {",
      "          'franchiseId': widget.franchiseId,",
      "          'featureKey': toggle.key,",
      "          'enabled': enabled,",
      "        },",
      "      );",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(",
      "          content: Text('Failed to update toggle: $e'),",
      "          backgroundColor: Theme.of(context).colorScheme.error,",
      "        ),",
      "      );",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "    final adminUser = Provider.of<AdminUserProvider>(context).user;",
      "    final isDeveloper = adminUser?.roles.contains('developer') ?? false;",
      "",
      "    if (!isDeveloper) {",
      "      return Center(",
      "        child: Text(",
      "          loc.unauthorizedAccess,",
      "          style: theme.textTheme.titleLarge?.copyWith(",
      "            color: colorScheme.error,",
      "            fontWeight: FontWeight.bold,",
      "          ),",
      "        ),",
      "      );",
      "    }",
      "",
      "    final isAllFranchises = widget.franchiseId == 'all';",
      "",
      "    return Padding(",
      "      padding: const EdgeInsets.all(24.0),",
      "      child: Column(",
      "        crossAxisAlignment: CrossAxisAlignment.start,",
      "        children: [",
      "          Text(",
      "            isAllFranchises",
      "                ? '${loc.featureTogglesSectionTitle} — ${loc.allFranchisesLabel ?? \"All Franchises\"}'",
      "                : '${loc.featureTogglesSectionTitle} — ${widget.franchiseId}',",
      "            style: theme.textTheme.titleLarge?.copyWith(",
      "              color: colorScheme.primary,",
      "              fontWeight: FontWeight.bold,",
      "            ),",
      "          ),",
      "          const SizedBox(height: 14),",
      "          Text(",
      "            loc.featureTogglesSectionDesc,",
      "            style: theme.textTheme.bodyMedium,",
      "          ),",
      "          const SizedBox(height: 20),",
      "          if (_loading)",
      "            Center(child: CircularProgressIndicator(color: colorScheme.primary))",
      "          else if (_errorMsg != null)",
      "            Card(",
      "              color: colorScheme.errorContainer,",
      "              child: Padding(",
      "                padding: const EdgeInsets.all(16.0),",
      "                child: Row(",
      "                  children: [",
      "                    Icon(Icons.error, color: colorScheme.error),",
      "                    const SizedBox(width: 12),",
      "                    Expanded(",
      "                      child: Text(",
      "                        '${loc.featureTogglesSectionError}\\n$_errorMsg',",
      "                        style: theme.textTheme.bodyMedium",
      "                            ?.copyWith(color: colorScheme.error),",
      "                      ),",
      "                    ),",
      "                    IconButton(",
      "                      icon: Icon(Icons.refresh, color: colorScheme.primary),",
      "                      tooltip: loc.reload,",
      "                      onPressed: _fetchFeatureToggles,",
      "                    ),",
      "                  ],",
      "                ),",
      "              ),",
      "            )",
      "          else if (_toggles.isEmpty)",
      "            Center(child: Text(loc.featureTogglesSectionEmpty))",
      "          else",
      "            _FeatureToggleList(",
      "              toggles: _toggles,",
      "              onToggle: _setFeatureToggle,",
      "              colorScheme: colorScheme,",
      "              loc: loc,",
      "              isAllFranchises: isAllFranchises,",
      "            ),",
      "          const SizedBox(height: 34),",
      "          _ComingSoonCard(",
      "            icon: Icons.analytics,",
      "            title: loc.featureTogglesSectionAuditTrailComingSoon,",
      "            subtitle: loc.featureTogglesSectionAuditTrailDesc,",
      "            colorScheme: colorScheme,",
      "            theme: theme,",
      "          ),",
      "          _ComingSoonCard(",
      "            icon: Icons.lightbulb_outline,",
      "            title: loc.featureTogglesSectionAIBasedComingSoon,",
      "            subtitle: loc.featureTogglesSectionAIBasedDesc,",
      "            colorScheme: colorScheme,",
      "            theme: theme,",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "class _FeatureToggleList extends StatelessWidget {",
      "  final List<FeatureToggle> toggles;",
      "  final void Function(FeatureToggle, bool) onToggle;",
      "  final ColorScheme colorScheme;",
      "  final AppLocalizations loc;",
      "  final bool isAllFranchises;",
      "",
      "  const _FeatureToggleList({",
      "    required this.toggles,",
      "    required this.onToggle,",
      "    required this.colorScheme,",
      "    required this.loc,",
      "    required this.isAllFranchises,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Card(",
      "      color: colorScheme.surface,",
      "      child: ListView.separated(",
      "        shrinkWrap: true,",
      "        physics: const NeverScrollableScrollPhysics(),",
      "        itemCount: toggles.length,",
      "        separatorBuilder: (_, __) => const Divider(height: 1),",
      "        itemBuilder: (context, idx) {",
      "          final toggle = toggles[idx];",
      "          return ListTile(",
      "            leading: Icon(Icons.settings, color: colorScheme.outline),",
      "            title: Text(toggle.name),",
      "            subtitle: Text(toggle.description),",
      "            trailing: isAllFranchises",
      "                ? Tooltip(",
      "                    message: loc.featureTogglesSectionNoGlobalToggle,",
      "                    child: Switch(",
      "                      value: toggle.enabled,",
      "                      onChanged: null,",
      "                    ),",
      "                  )",
      "                : Switch(",
      "                    value: toggle.enabled,",
      "                    onChanged: (v) => onToggle(toggle, v),",
      "                  ),",
      "            shape: RoundedRectangleBorder(",
      "              borderRadius: BorderRadius.circular(DesignTokens.adminCardRadius),",
      "            ),",
      "          );",
      "        },",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "class _ComingSoonCard extends StatelessWidget {",
      "  final IconData icon;",
      "  final String title;",
      "  final String subtitle;",
      "  final ColorScheme colorScheme;",
      "  final ThemeData theme;",
      "",
      "  const _ComingSoonCard({",
      "    required this.icon,",
      "    required this.title,",
      "    required this.subtitle,",
      "    required this.colorScheme,",
      "    required this.theme,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Card(",
      "      color: colorScheme.surfaceVariant.withOpacity(0.87),",
      "      elevation: DesignTokens.adminCardElevation,",
      "      shape: RoundedRectangleBorder(",
      "        borderRadius: BorderRadius.circular(DesignTokens.adminCardRadius),",
      "      ),",
      "      child: Padding(",
      "        padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 20),",
      "        child: Row(",
      "          children: [",
      "            Icon(icon, color: colorScheme.outline, size: 30),",
      "            const SizedBox(width: 18),",
      "            Expanded(",
      "              child: Column(",
      "                crossAxisAlignment: CrossAxisAlignment.start,",
      "                children: [",
      "                  Text(",
      "                    title,",
      "                    style: theme.textTheme.titleMedium?.copyWith(",
      "                      color: colorScheme.outline,",
      "                      fontWeight: FontWeight.bold,",
      "                    ),",
      "                  ),",
      "                  const SizedBox(height: 4),",
      "                  Text(",
      "                    subtitle,",
      "                    style: theme.textTheme.bodyMedium,",
      "                  ),",
      "                ],",
      "              ),",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "class FeatureToggle {",
      "  final String key;",
      "  final String name;",
      "  final String description;",
      "  final bool enabled;",
      "",
      "  FeatureToggle({",
      "    required this.key,",
      "    required this.name,",
      "    required this.description,",
      "    required this.enabled,",
      "  });",
      "",
      "  FeatureToggle copyWith({",
      "    String? key,",
      "    String? name,",
      "    String? description,",
      "    bool? enabled,",
      "  }) {",
      "    return FeatureToggle(",
      "      key: key ?? this.key,",
      "      name: name ?? this.name,",
      "      description: description ?? this.description,",
      "      enabled: enabled ?? this.enabled,",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 368,
      "file_size": 11851,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\developer\\impersonation_dialog.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class ImpersonationDialog extends StatefulWidget {",
      "  final String franchiseId;",
      "  const ImpersonationDialog({Key? key, required this.franchiseId})",
      "      : super(key: key);",
      "",
      "  @override",
      "  State<ImpersonationDialog> createState() => _ImpersonationDialogState();",
      "}",
      "",
      "class _ImpersonationDialogState extends State<ImpersonationDialog> {",
      "  final TextEditingController _searchController = TextEditingController();",
      "  bool _loading = false;",
      "  String? _errorMsg;",
      "  List<ImpersonationUser> _users = [];",
      "  ImpersonationUser? _selectedUser;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _fetchUsers();",
      "  }",
      "",
      "  Future<void> _fetchUsers([String? query]) async {",
      "    setState(() {",
      "      _loading = true;",
      "      _errorMsg = null;",
      "      _users = [];",
      "    });",
      "    try {",
      "      // TODO: Replace with real FirestoreService user query, optionally using [query].",
      "      await Future.delayed(const Duration(milliseconds: 400));",
      "      final all = [",
      "        ImpersonationUser(",
      "            id: '1',",
      "            email: 'demo@doughboys.com',",
      "            name: 'Demo Customer',",
      "            role: 'customer'),",
      "        ImpersonationUser(",
      "            id: '2',",
      "            email: 'manager@doughboys.com',",
      "            name: 'Franchise Manager',",
      "            role: 'manager'),",
      "        ImpersonationUser(",
      "            id: '3',",
      "            email: 'dev@doughboys.com',",
      "            name: 'Developer User',",
      "            role: 'developer'),",
      "        ImpersonationUser(",
      "            id: '4',",
      "            email: 'testuser@doughboys.com',",
      "            name: 'Test User',",
      "            role: 'customer'),",
      "      ];",
      "      if (query != null && query.trim().isNotEmpty) {",
      "        _users = all",
      "            .where((u) =>",
      "                u.email.toLowerCase().contains(query.trim().toLowerCase()) ||",
      "                u.name.toLowerCase().contains(query.trim().toLowerCase()))",
      "            .toList();",
      "      } else {",
      "        _users = all;",
      "      }",
      "      setState(() => _loading = false);",
      "    } catch (e, stack) {",
      "      setState(() {",
      "        _errorMsg = e.toString();",
      "        _loading = false;",
      "      });",
      "      await ErrorLogger.log(",
      "        message: 'Failed to fetch users for impersonation: $e',",
      "        stack: stack.toString(),",
      "        source: 'ImpersonationDialog',",
      "        screen: 'DeveloperDashboardScreen',",
      "        severity: 'warning',",
      "        contextData: {",
      "          'franchiseId': widget.franchiseId,",
      "          'errorType': e.runtimeType.toString(),",
      "        },",
      "      );",
      "    }",
      "  }",
      "",
      "  void _onSearchChanged() {",
      "    _fetchUsers(_searchController.text);",
      "  }",
      "",
      "  void _onImpersonate(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[YourWidget] loc is null! Localization not available for this context.');",
      "      // Show a SnackBar or log error",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(content: Text('Localization missing! [debug]')),",
      "      );",
      "      return;",
      "    }",
      "    if (_selectedUser == null) {",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(content: Text(loc.impersonationDialogSelectUserFirst)),",
      "      );",
      "      return;",
      "    }",
      "    // TODO: Wire in actual impersonation logic, update provider/session, redirect as needed.",
      "    Navigator.of(context).pop(_selectedUser);",
      "    ScaffoldMessenger.of(context).showSnackBar(",
      "      SnackBar(",
      "          content: Text(",
      "              '${loc.impersonationDialogSuccessPrefix} ${_selectedUser!.email}')),",
      "    );",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      // Fallback UI for missing localization:",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "    final adminUser = Provider.of<AdminUserProvider>(context).user;",
      "    final isDeveloper = adminUser?.roles.contains('developer') ?? false;",
      "",
      "    if (!isDeveloper) {",
      "      return Dialog(",
      "        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),",
      "        child: Padding(",
      "          padding: const EdgeInsets.all(32.0),",
      "          child: Center(",
      "            child: Text(",
      "              loc.unauthorizedAccess,",
      "              style: theme.textTheme.titleLarge?.copyWith(",
      "                color: colorScheme.error,",
      "                fontWeight: FontWeight.bold,",
      "              ),",
      "            ),",
      "          ),",
      "        ),",
      "      );",
      "    }",
      "",
      "    return Dialog(",
      "      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),",
      "      child: ConstrainedBox(",
      "        constraints: const BoxConstraints(maxWidth: 480),",
      "        child: Padding(",
      "          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 28),",
      "          child: Column(",
      "            mainAxisSize: MainAxisSize.min,",
      "            children: [",
      "              Row(",
      "                children: [",
      "                  Icon(Icons.switch_account,",
      "                      color: colorScheme.primary, size: 28),",
      "                  const SizedBox(width: 12),",
      "                  Text(",
      "                    loc.impersonationDialogTitle,",
      "                    style: theme.textTheme.titleLarge?.copyWith(",
      "                      color: colorScheme.primary,",
      "                      fontWeight: FontWeight.bold,",
      "                    ),",
      "                  ),",
      "                  const Spacer(),",
      "                  IconButton(",
      "                    icon: const Icon(Icons.close),",
      "                    tooltip: loc.closeButtonLabel,",
      "                    onPressed: () => Navigator.of(context).pop(),",
      "                  ),",
      "                ],",
      "              ),",
      "              const SizedBox(height: 12),",
      "              _SecurityNotice(loc: loc, colorScheme: colorScheme, theme: theme),",
      "              const SizedBox(height: 12),",
      "              TextField(",
      "                controller: _searchController,",
      "                decoration: InputDecoration(",
      "                  prefixIcon: const Icon(Icons.search),",
      "                  hintText: loc.impersonationDialogSearchHint,",
      "                  border: OutlineInputBorder(",
      "                    borderRadius:",
      "                        BorderRadius.circular(DesignTokens.formFieldRadius),",
      "                  ),",
      "                  filled: true,",
      "                  fillColor: colorScheme.surfaceVariant,",
      "                  isDense: true,",
      "                  contentPadding:",
      "                      const EdgeInsets.symmetric(horizontal: 14, vertical: 10),",
      "                ),",
      "                onChanged: (_) => _onSearchChanged(),",
      "              ),",
      "              const SizedBox(height: 10),",
      "              if (_loading)",
      "                const Center(child: CircularProgressIndicator())",
      "              else if (_errorMsg != null)",
      "                Padding(",
      "                  padding: const EdgeInsets.symmetric(vertical: 12),",
      "                  child: Text(",
      "                    '${loc.impersonationDialogError}\\n$_errorMsg',",
      "                    style: theme.textTheme.bodyMedium",
      "                        ?.copyWith(color: colorScheme.error),",
      "                  ),",
      "                )",
      "              else",
      "                SizedBox(",
      "                  height: 180,",
      "                  child: _users.isEmpty",
      "                      ? Center(child: Text(loc.impersonationDialogNoUsersFound))",
      "                      : ListView.separated(",
      "                          itemCount: _users.length,",
      "                          separatorBuilder: (_, __) => const Divider(height: 1),",
      "                          itemBuilder: (context, idx) {",
      "                            final user = _users[idx];",
      "                            final isSelected = user == _selectedUser;",
      "                            return ListTile(",
      "                              leading: Icon(",
      "                                user.role == 'manager'",
      "                                    ? Icons.manage_accounts",
      "                                    : user.role == 'developer'",
      "                                        ? Icons.code",
      "                                        : Icons.account_circle,",
      "                                color: colorScheme.outline,",
      "                              ),",
      "                              title: Text('${user.name} (${user.email})'),",
      "                              subtitle: Text(user.role),",
      "                              selected: isSelected,",
      "                              selectedTileColor:",
      "                                  colorScheme.primary.withOpacity(0.06),",
      "                              onTap: () => setState(() => _selectedUser = user),",
      "                              shape: RoundedRectangleBorder(",
      "                                borderRadius: BorderRadius.circular(10),",
      "                              ),",
      "                            );",
      "                          },",
      "                        ),",
      "                ),",
      "              const SizedBox(height: 16),",
      "              ElevatedButton.icon(",
      "                icon: const Icon(Icons.login),",
      "                label: Text(loc.impersonationDialogButton),",
      "                onPressed: _selectedUser != null",
      "                    ? () => _onImpersonate(context)",
      "                    : null,",
      "                style: ElevatedButton.styleFrom(",
      "                  backgroundColor: colorScheme.primary,",
      "                  foregroundColor: colorScheme.onPrimary,",
      "                  padding:",
      "                      const EdgeInsets.symmetric(horizontal: 24, vertical: 12),",
      "                  shape: RoundedRectangleBorder(",
      "                    borderRadius:",
      "                        BorderRadius.circular(DesignTokens.adminButtonRadius),",
      "                  ),",
      "                  textStyle: theme.textTheme.titleMedium",
      "                      ?.copyWith(fontWeight: FontWeight.bold),",
      "                ),",
      "              ),",
      "              const SizedBox(height: 12),",
      "              _ComingSoonCard(",
      "                icon: Icons.shield,",
      "                title: loc.impersonationDialogAuditTrailComingSoon,",
      "                subtitle: loc.impersonationDialogAuditTrailDesc,",
      "                colorScheme: colorScheme,",
      "                theme: theme,",
      "              ),",
      "              _ComingSoonCard(",
      "                icon: Icons.settings_suggest,",
      "                title: loc.impersonationDialogAdvancedToolsComingSoon,",
      "                subtitle: loc.impersonationDialogAdvancedToolsDesc,",
      "                colorScheme: colorScheme,",
      "                theme: theme,",
      "              ),",
      "            ],",
      "          ),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "class _SecurityNotice extends StatelessWidget {",
      "  final AppLocalizations loc;",
      "  final ColorScheme colorScheme;",
      "  final ThemeData theme;",
      "",
      "  const _SecurityNotice({",
      "    required this.loc,",
      "    required this.colorScheme,",
      "    required this.theme,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Card(",
      "      color: colorScheme.errorContainer,",
      "      margin: EdgeInsets.zero,",
      "      shape: RoundedRectangleBorder(",
      "        borderRadius: BorderRadius.circular(DesignTokens.formFieldRadius),",
      "      ),",
      "      child: Padding(",
      "        padding: const EdgeInsets.symmetric(vertical: 8, horizontal: 14),",
      "        child: Row(",
      "          children: [",
      "            Icon(Icons.warning_amber_rounded,",
      "                color: colorScheme.error, size: 24),",
      "            const SizedBox(width: 10),",
      "            Expanded(",
      "              child: Text(",
      "                loc.impersonationDialogSecurityNotice,",
      "                style: theme.textTheme.bodyMedium?.copyWith(",
      "                  color: colorScheme.error,",
      "                  fontWeight: FontWeight.bold,",
      "                ),",
      "              ),",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "class _ComingSoonCard extends StatelessWidget {",
      "  final IconData icon;",
      "  final String title;",
      "  final String subtitle;",
      "  final ColorScheme colorScheme;",
      "  final ThemeData theme;",
      "",
      "  const _ComingSoonCard({",
      "    required this.icon,",
      "    required this.title,",
      "    required this.subtitle,",
      "    required this.colorScheme,",
      "    required this.theme,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Card(",
      "      color: colorScheme.surfaceVariant.withOpacity(0.87),",
      "      elevation: DesignTokens.adminCardElevation,",
      "      shape: RoundedRectangleBorder(",
      "        borderRadius: BorderRadius.circular(DesignTokens.adminCardRadius),",
      "      ),",
      "      child: Padding(",
      "        padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 16),",
      "        child: Row(",
      "          children: [",
      "            Icon(icon, color: colorScheme.outline, size: 30),",
      "            const SizedBox(width: 18),",
      "            Expanded(",
      "              child: Column(",
      "                crossAxisAlignment: CrossAxisAlignment.start,",
      "                children: [",
      "                  Text(",
      "                    title,",
      "                    style: theme.textTheme.titleMedium?.copyWith(",
      "                      color: colorScheme.outline,",
      "                      fontWeight: FontWeight.bold,",
      "                    ),",
      "                  ),",
      "                  const SizedBox(height: 4),",
      "                  Text(",
      "                    subtitle,",
      "                    style: theme.textTheme.bodyMedium,",
      "                  ),",
      "                ],",
      "              ),",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "class ImpersonationUser {",
      "  final String id;",
      "  final String email;",
      "  final String name;",
      "  final String role;",
      "",
      "  ImpersonationUser({",
      "    required this.id,",
      "    required this.email,",
      "    required this.name,",
      "    required this.role,",
      "  });",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 402,
      "file_size": 14254,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\developer\\impersonation_tools_section.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/widgets/developer/impersonation_dialog.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class ImpersonationToolsSection extends StatefulWidget {",
      "  final String? franchiseId;",
      "  const ImpersonationToolsSection({Key? key, this.franchiseId})",
      "      : super(key: key);",
      "",
      "  @override",
      "  State<ImpersonationToolsSection> createState() =>",
      "      _ImpersonationToolsSectionState();",
      "}",
      "",
      "class _ImpersonationToolsSectionState extends State<ImpersonationToolsSection> {",
      "  bool _loading = false;",
      "  String? _errorMsg;",
      "  List<UserSummary> _users = [];",
      "  String _search = '';",
      "  UserSummary? _selectedUser;",
      "  List<ImpersonationRecord> _recentImpersonations = [];",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _fetchUserList();",
      "    _fetchRecentImpersonations();",
      "  }",
      "",
      "  Future<void> _fetchUserList() async {",
      "    setState(() {",
      "      _loading = true;",
      "      _errorMsg = null;",
      "    });",
      "    try {",
      "      // TODO: Replace with real FirestoreService user query, filtered by franchiseId",
      "      await Future.delayed(const Duration(milliseconds: 500));",
      "      // Placeholder users; replace with real query results",
      "      _users = [",
      "        UserSummary(id: 'user1', email: 'jane@doughboys.com', role: 'owner'),",
      "        UserSummary(id: 'user2', email: 'staff1@doughboys.com', role: 'staff'),",
      "        UserSummary(id: 'user3', email: 'driver@doughboys.com', role: 'driver'),",
      "      ];",
      "      setState(() => _loading = false);",
      "    } catch (e, stack) {",
      "      setState(() {",
      "        _errorMsg = e.toString();",
      "        _loading = false;",
      "      });",
      "      await ErrorLogger.log(",
      "        message: 'Failed to fetch user list: $e',",
      "        stack: stack.toString(),",
      "        source: 'ImpersonationToolsSection',",
      "        screen: 'ImpersonationToolsSection',",
      "        severity: 'warning',",
      "        contextData: {",
      "          'franchiseId': widget.franchiseId,",
      "          'errorType': e.runtimeType.toString(),",
      "        },",
      "      );",
      "    }",
      "  }",
      "",
      "  Future<void> _fetchRecentImpersonations() async {",
      "    try {",
      "      // TODO: Replace with real FirestoreService query for recent impersonations",
      "      await Future.delayed(const Duration(milliseconds: 300));",
      "      // Placeholder impersonations",
      "      _recentImpersonations = [",
      "        ImpersonationRecord(",
      "            userEmail: 'jane@doughboys.com',",
      "            timestamp: DateTime.now().subtract(const Duration(hours: 2))),",
      "        ImpersonationRecord(",
      "            userEmail: 'driver@doughboys.com',",
      "            timestamp: DateTime.now().subtract(const Duration(days: 1))),",
      "      ];",
      "      setState(() {});",
      "    } catch (e, stack) {",
      "      // Non-blocking; just log error",
      "      await ErrorLogger.log(",
      "        message: 'Failed to fetch impersonation records: $e',",
      "        stack: stack.toString(),",
      "        source: 'ImpersonationToolsSection',",
      "        screen: 'ImpersonationToolsSection',",
      "        severity: 'info',",
      "        contextData: {",
      "          'franchiseId': widget.franchiseId,",
      "          'errorType': e.runtimeType.toString(),",
      "        },",
      "      );",
      "    }",
      "  }",
      "",
      "  Future<void> _impersonateUser(UserSummary user) async {",
      "    try {",
      "      // TODO: Implement real impersonation logic with backend/service",
      "      await Future.delayed(const Duration(milliseconds: 400));",
      "      await ErrorLogger.log(",
      "        message: 'Impersonation started: ${user.email}',",
      "        source: 'ImpersonationToolsSection',",
      "        screen: 'ImpersonationToolsSection',",
      "        severity: 'info',",
      "        contextData: {",
      "          'franchiseId': widget.franchiseId,",
      "          'impersonatedUserId': user.id,",
      "          'impersonatedUserRole': user.role,",
      "          'errorType': 'impersonation',",
      "        },",
      "      );",
      "      setState(() {",
      "        _selectedUser = user;",
      "        _recentImpersonations.insert(",
      "            0,",
      "            ImpersonationRecord(",
      "              userEmail: user.email,",
      "              timestamp: DateTime.now(),",
      "            ));",
      "      });",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(",
      "          content: Text('${user.email} impersonated.'),",
      "          backgroundColor: Theme.of(context).colorScheme.primary,",
      "        ),",
      "      );",
      "    } catch (e, stack) {",
      "      setState(() => _selectedUser = null);",
      "      await ErrorLogger.log(",
      "        message: 'Impersonation failed: $e',",
      "        stack: stack.toString(),",
      "        source: 'ImpersonationToolsSection',",
      "        screen: 'ImpersonationToolsSection',",
      "        severity: 'error',",
      "        contextData: {",
      "          'franchiseId': widget.franchiseId,",
      "          'impersonatedUserId': user.id,",
      "          'errorType': e.runtimeType.toString(),",
      "        },",
      "      );",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(",
      "          content: Text('Impersonation failed: $e'),",
      "          backgroundColor: Theme.of(context).colorScheme.error,",
      "        ),",
      "      );",
      "    }",
      "  }",
      "",
      "  Future<void> _openImpersonationDialog(",
      "      BuildContext context, String franchiseId) async {",
      "    final user = await showDialog<ImpersonationUser>(",
      "      context: context,",
      "      builder: (ctx) => ImpersonationDialog(franchiseId: franchiseId),",
      "    );",
      "    if (user != null) {",
      "      // TODO: Start impersonation session using user data.",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      // Fallback UI for missing localization:",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "    final adminUser = Provider.of<AdminUserProvider>(context).user;",
      "",
      "    // Developer-only guard (multi-role array)",
      "    final isDeveloper = adminUser?.roles.contains('developer') ?? false;",
      "",
      "    if (!isDeveloper) {",
      "      return Center(",
      "        child: Text(",
      "          loc.unauthorizedAccess,",
      "          style: theme.textTheme.titleLarge?.copyWith(",
      "            color: colorScheme.error,",
      "            fontWeight: FontWeight.bold,",
      "          ),",
      "        ),",
      "      );",
      "    }",
      "",
      "    return Padding(",
      "      padding: const EdgeInsets.all(24.0),",
      "      child: Column(",
      "        crossAxisAlignment: CrossAxisAlignment.start,",
      "        children: [",
      "          Text(",
      "            loc.impersonationToolsTitle,",
      "            style: theme.textTheme.titleLarge?.copyWith(",
      "              color: colorScheme.primary,",
      "              fontWeight: FontWeight.bold,",
      "            ),",
      "          ),",
      "          const SizedBox(height: 16),",
      "",
      "          Text(",
      "            loc.impersonationToolsDesc,",
      "            style: theme.textTheme.bodyMedium,",
      "          ),",
      "          const SizedBox(height: 22),",
      "",
      "          if (_errorMsg != null)",
      "            Card(",
      "              color: colorScheme.errorContainer,",
      "              child: Padding(",
      "                padding: const EdgeInsets.all(16.0),",
      "                child: Row(",
      "                  children: [",
      "                    Icon(Icons.error, color: colorScheme.error),",
      "                    const SizedBox(width: 12),",
      "                    Expanded(",
      "                      child: Text(",
      "                        '${loc.impersonationToolsLoadError}\\n$_errorMsg',",
      "                        style: theme.textTheme.bodyMedium",
      "                            ?.copyWith(color: colorScheme.error),",
      "                      ),",
      "                    ),",
      "                    IconButton(",
      "                      icon: Icon(Icons.refresh, color: colorScheme.primary),",
      "                      tooltip: loc.reload,",
      "                      onPressed: _fetchUserList,",
      "                    ),",
      "                  ],",
      "                ),",
      "              ),",
      "            ),",
      "",
      "          // User search/filter",
      "          if (_users.isNotEmpty) ...[",
      "            Row(",
      "              children: [",
      "                Expanded(",
      "                  child: TextField(",
      "                    decoration: InputDecoration(",
      "                      hintText: loc.impersonationToolsSearchHint,",
      "                      prefixIcon: const Icon(Icons.search),",
      "                      border: OutlineInputBorder(",
      "                        borderRadius:",
      "                            BorderRadius.circular(DesignTokens.formFieldRadius),",
      "                      ),",
      "                    ),",
      "                    onChanged: (txt) => setState(() => _search = txt),",
      "                  ),",
      "                ),",
      "                const SizedBox(width: 12),",
      "                ElevatedButton.icon(",
      "                  icon: Icon(Icons.refresh, color: colorScheme.onPrimary),",
      "                  label: Text(loc.reload),",
      "                  style: ElevatedButton.styleFrom(",
      "                    backgroundColor: colorScheme.primary,",
      "                  ),",
      "                  onPressed: _fetchUserList,",
      "                ),",
      "              ],",
      "            ),",
      "            const SizedBox(height: 20),",
      "          ],",
      "",
      "          if (_loading)",
      "            Center(",
      "                child: CircularProgressIndicator(color: colorScheme.primary)),",
      "",
      "          // User list to impersonate",
      "          if (!_loading && _users.isNotEmpty)",
      "            _UserList(",
      "              users: _users,",
      "              search: _search,",
      "              onImpersonate: _impersonateUser,",
      "              impersonatedUser: _selectedUser,",
      "              loc: loc,",
      "              colorScheme: colorScheme,",
      "            ),",
      "",
      "          if (!_loading && _users.isEmpty && _errorMsg == null)",
      "            Center(child: Text(loc.impersonationToolsNoUsersFound)),",
      "",
      "          const SizedBox(height: 30),",
      "",
      "          // Recent impersonations",
      "          _RecentImpersonationsCard(",
      "            records: _recentImpersonations,",
      "            loc: loc,",
      "            colorScheme: colorScheme,",
      "          ),",
      "",
      "          const SizedBox(height: 30),",
      "",
      "          // Future features/expansion areas",
      "          _ComingSoonCard(",
      "            icon: Icons.admin_panel_settings,",
      "            title: loc.impersonationToolsAuditTrailComingSoon,",
      "            subtitle: loc.impersonationToolsAuditTrailDesc,",
      "            colorScheme: colorScheme,",
      "            theme: theme,",
      "          ),",
      "          _ComingSoonCard(",
      "            icon: Icons.security,",
      "            title: loc.impersonationToolsRolePreviewComingSoon,",
      "            subtitle: loc.impersonationToolsRolePreviewDesc,",
      "            colorScheme: colorScheme,",
      "            theme: theme,",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "class _UserList extends StatelessWidget {",
      "  final List<UserSummary> users;",
      "  final String search;",
      "  final void Function(UserSummary) onImpersonate;",
      "  final UserSummary? impersonatedUser;",
      "  final AppLocalizations loc;",
      "  final ColorScheme colorScheme;",
      "",
      "  const _UserList({",
      "    required this.users,",
      "    required this.search,",
      "    required this.onImpersonate,",
      "    required this.impersonatedUser,",
      "    required this.loc,",
      "    required this.colorScheme,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final filtered = users",
      "        .where((u) =>",
      "            u.email.toLowerCase().contains(search.toLowerCase()) ||",
      "            u.role.toLowerCase().contains(search.toLowerCase()))",
      "        .toList();",
      "    if (filtered.isEmpty) {",
      "      return Center(child: Text(loc.impersonationToolsNoUsersFound));",
      "    }",
      "    return Card(",
      "      child: ListView.separated(",
      "        shrinkWrap: true,",
      "        physics: const NeverScrollableScrollPhysics(),",
      "        itemCount: filtered.length,",
      "        separatorBuilder: (_, __) => const Divider(height: 1),",
      "        itemBuilder: (context, idx) {",
      "          final user = filtered[idx];",
      "          final isActive = impersonatedUser?.id == user.id;",
      "          return ListTile(",
      "            leading: Icon(Icons.person,",
      "                color: isActive ? colorScheme.primary : colorScheme.outline),",
      "            title: Text(user.email),",
      "            subtitle: Text('${loc.impersonationToolsRoleLabel}: ${user.role}'),",
      "            trailing: ElevatedButton.icon(",
      "              icon: const Icon(Icons.switch_account_outlined),",
      "              label: Text(isActive",
      "                  ? loc.impersonationToolsImpersonating",
      "                  : loc.impersonationToolsImpersonate),",
      "              style: ElevatedButton.styleFrom(",
      "                backgroundColor:",
      "                    isActive ? colorScheme.secondary : colorScheme.primary,",
      "                foregroundColor: colorScheme.onPrimary,",
      "              ),",
      "              onPressed: isActive ? null : () => onImpersonate(user),",
      "            ),",
      "            shape: RoundedRectangleBorder(",
      "              borderRadius: BorderRadius.circular(DesignTokens.adminCardRadius),",
      "            ),",
      "          );",
      "        },",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "class _RecentImpersonationsCard extends StatelessWidget {",
      "  final List<ImpersonationRecord> records;",
      "  final AppLocalizations loc;",
      "  final ColorScheme colorScheme;",
      "",
      "  const _RecentImpersonationsCard({",
      "    required this.records,",
      "    required this.loc,",
      "    required this.colorScheme,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    if (records.isEmpty) return Container();",
      "    return Card(",
      "      color: colorScheme.surfaceVariant,",
      "      child: Padding(",
      "        padding: const EdgeInsets.all(16.0),",
      "        child: Column(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            Row(",
      "              children: [",
      "                Icon(Icons.history, color: colorScheme.outline, size: 24),",
      "                const SizedBox(width: 8),",
      "                Text(",
      "                  loc.impersonationToolsRecentImpersonations,",
      "                  style: Theme.of(context).textTheme.titleMedium?.copyWith(",
      "                        color: colorScheme.outline,",
      "                        fontWeight: FontWeight.bold,",
      "                      ),",
      "                ),",
      "              ],",
      "            ),",
      "            const SizedBox(height: 12),",
      "            ...records.map((r) => Padding(",
      "                  padding: const EdgeInsets.symmetric(vertical: 2),",
      "                  child: Text(",
      "                      '${r.userEmail}  —  ${_formatDateTime(r.timestamp)}'),",
      "                )),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  String _formatDateTime(DateTime dt) {",
      "    return '${dt.year}-${dt.month.toString().padLeft(2, '0')}-${dt.day.toString().padLeft(2, '0')} '",
      "        '${dt.hour.toString().padLeft(2, '0')}:${dt.minute.toString().padLeft(2, '0')}';",
      "  }",
      "}",
      "",
      "class _ComingSoonCard extends StatelessWidget {",
      "  final IconData icon;",
      "  final String title;",
      "  final String subtitle;",
      "  final ColorScheme colorScheme;",
      "  final ThemeData theme;",
      "",
      "  const _ComingSoonCard({",
      "    required this.icon,",
      "    required this.title,",
      "    required this.subtitle,",
      "    required this.colorScheme,",
      "    required this.theme,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Card(",
      "      color: colorScheme.surfaceVariant.withOpacity(0.87),",
      "      elevation: DesignTokens.adminCardElevation,",
      "      shape: RoundedRectangleBorder(",
      "        borderRadius: BorderRadius.circular(DesignTokens.adminCardRadius),",
      "      ),",
      "      child: Padding(",
      "        padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 20),",
      "        child: Row(",
      "          children: [",
      "            Icon(icon, color: colorScheme.outline, size: 30),",
      "            const SizedBox(width: 18),",
      "            Expanded(",
      "              child: Column(",
      "                crossAxisAlignment: CrossAxisAlignment.start,",
      "                children: [",
      "                  Text(",
      "                    title,",
      "                    style: theme.textTheme.titleMedium?.copyWith(",
      "                      color: colorScheme.outline,",
      "                      fontWeight: FontWeight.bold,",
      "                    ),",
      "                  ),",
      "                  const SizedBox(height: 4),",
      "                  Text(",
      "                    subtitle,",
      "                    style: theme.textTheme.bodyMedium,",
      "                  ),",
      "                ],",
      "              ),",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "// --- Simple DTOs for mock/demo. Replace with your actual user model/record.",
      "class UserSummary {",
      "  final String id;",
      "  final String email;",
      "  final String role;",
      "  UserSummary({required this.id, required this.email, required this.role});",
      "}",
      "",
      "class ImpersonationRecord {",
      "  final String userEmail;",
      "  final DateTime timestamp;",
      "  ImpersonationRecord({required this.userEmail, required this.timestamp});",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 504,
      "file_size": 16987,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\developer\\overview_section.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class OverviewSection extends StatefulWidget {",
      "  final String? franchiseId;",
      "  const OverviewSection({Key? key, this.franchiseId}) : super(key: key);",
      "",
      "  @override",
      "  State<OverviewSection> createState() => _OverviewSectionState();",
      "}",
      "",
      "class _OverviewSectionState extends State<OverviewSection> {",
      "  bool _loading = true;",
      "  String? _errorMsg;",
      "  Map<String, dynamic>? _stats;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _fetchStats();",
      "  }",
      "",
      "  @override",
      "  void didUpdateWidget(covariant OverviewSection oldWidget) {",
      "    super.didUpdateWidget(oldWidget);",
      "    if (oldWidget.franchiseId != widget.franchiseId) {",
      "      _fetchStats();",
      "    }",
      "  }",
      "",
      "  Future<void> _fetchStats() async {",
      "    setState(() {",
      "      _loading = true;",
      "      _errorMsg = null;",
      "    });",
      "    try {",
      "      // Fetch your analytics, revenue, order stats, and system health here.",
      "      // Placeholder: Replace with FirestoreService or your stats service.",
      "      // Example: FirestoreService().getDashboardStats(franchiseId)",
      "      await Future.delayed(",
      "          const Duration(milliseconds: 600)); // Simulate network",
      "",
      "      // Placeholder: Example stats structure, replace with real query!",
      "      _stats = {",
      "        'orders': widget.franchiseId == 'all' ? 2417 : 317,",
      "        'revenue': widget.franchiseId == 'all' ? 126876.25 : 13824.50,",
      "        'lastSync': DateTime.now().subtract(const Duration(minutes: 7)),",
      "        'uniqueCustomers': widget.franchiseId == 'all' ? 893 : 123,",
      "        'topSeller': 'Deluxe Pizza',",
      "        'avgOrderValue': 42.37,",
      "        'appVersion': '1.0.7',",
      "        'systemHealth': 'ok', // 'ok', 'warning', 'error'",
      "      };",
      "",
      "      setState(() => _loading = false);",
      "    } catch (e, stack) {",
      "      setState(() {",
      "        _errorMsg = e.toString();",
      "        _loading = false;",
      "      });",
      "      final firestoreService =",
      "          Provider.of<FirestoreService>(context, listen: false);",
      "      ErrorLogger.log(",
      "        message: 'Failed to fetch dashboard stats: $e',",
      "        stack: stack.toString(),",
      "        source: 'OverviewSection',",
      "        severity: 'warning',",
      "        screen: 'DeveloperDashboardScreen',",
      "        contextData: {",
      "          'franchiseId': widget.franchiseId,",
      "          // Add other context fields as needed",
      "        },",
      "      );",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      // Fallback UI for missing localization:",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "    final adminUser = Provider.of<AdminUserProvider>(context).user;",
      "    final isDeveloper = adminUser?.roles.contains('developer') ?? false;",
      "    final isAllFranchises = widget.franchiseId == 'all';",
      "",
      "    return Padding(",
      "      padding: const EdgeInsets.symmetric(horizontal: 24.0, vertical: 20.0),",
      "      child: Column(",
      "        crossAxisAlignment: CrossAxisAlignment.start,",
      "        children: [",
      "          Text(",
      "            isAllFranchises",
      "                ? '${loc.dashboardOverview} — ${loc.allFranchisesLabel ?? \"All Franchises\"}'",
      "                : '${loc.dashboardOverview} — ${widget.franchiseId}',",
      "            style: theme.textTheme.titleLarge?.copyWith(",
      "              fontWeight: FontWeight.bold,",
      "              color: colorScheme.primary,",
      "            ),",
      "          ),",
      "          const SizedBox(height: 18),",
      "          if (_loading)",
      "            Center(child: CircularProgressIndicator(color: colorScheme.primary))",
      "          else if (_errorMsg != null)",
      "            Card(",
      "              color: colorScheme.errorContainer,",
      "              margin: const EdgeInsets.only(bottom: 16),",
      "              child: Padding(",
      "                padding: const EdgeInsets.all(16.0),",
      "                child: Row(",
      "                  children: [",
      "                    Icon(Icons.error, color: colorScheme.error),",
      "                    const SizedBox(width: 12),",
      "                    Expanded(",
      "                      child: Text(",
      "                        '${loc.dashboardErrorLoadingStats}\\n$_errorMsg',",
      "                        style: theme.textTheme.bodyMedium",
      "                            ?.copyWith(color: colorScheme.error),",
      "                      ),",
      "                    ),",
      "                    IconButton(",
      "                      icon: Icon(Icons.refresh, color: colorScheme.primary),",
      "                      tooltip: loc.reload,",
      "                      onPressed: _fetchStats,",
      "                    )",
      "                  ],",
      "                ),",
      "              ),",
      "            )",
      "          else ...[",
      "            _DashboardStatCards(",
      "                stats: _stats!,",
      "                loc: loc,",
      "                colorScheme: colorScheme,",
      "                theme: theme,",
      "                isAllFranchises: isAllFranchises),",
      "",
      "            const SizedBox(height: 28),",
      "",
      "            // System Health Card",
      "            _SystemHealthCard(",
      "              health: _stats!['systemHealth'] as String,",
      "              lastSync: _stats!['lastSync'] as DateTime,",
      "              colorScheme: colorScheme,",
      "              loc: loc,",
      "            ),",
      "",
      "            const SizedBox(height: 32),",
      "",
      "            // Developer-only insights",
      "            if (isDeveloper) ...[",
      "              _DeveloperInsightCards(",
      "                  theme: theme,",
      "                  colorScheme: colorScheme,",
      "                  loc: loc,",
      "                  franchiseId: widget.franchiseId),",
      "              const SizedBox(height: 28),",
      "            ],",
      "",
      "            // Future features/expansion areas",
      "            _ComingSoonCard(",
      "              icon: Icons.trending_up,",
      "              title: loc.analyticsTrendsComingSoon,",
      "              subtitle: loc.analyticsTrendsDesc,",
      "              colorScheme: colorScheme,",
      "              theme: theme,",
      "            ),",
      "            _ComingSoonCard(",
      "              icon: Icons.lightbulb_outline,",
      "              title: loc.aiInsightsComingSoon,",
      "              subtitle: loc.aiInsightsDesc,",
      "              colorScheme: colorScheme,",
      "              theme: theme,",
      "            ),",
      "          ],",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "// Modular stat cards row",
      "class _DashboardStatCards extends StatelessWidget {",
      "  final Map<String, dynamic> stats;",
      "  final AppLocalizations loc;",
      "  final ColorScheme colorScheme;",
      "  final ThemeData theme;",
      "  final bool isAllFranchises;",
      "",
      "  const _DashboardStatCards({",
      "    required this.stats,",
      "    required this.loc,",
      "    required this.colorScheme,",
      "    required this.theme,",
      "    required this.isAllFranchises,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Wrap(",
      "      spacing: 18,",
      "      runSpacing: 16,",
      "      children: [",
      "        _StatCard(",
      "          icon: Icons.attach_money,",
      "          label: loc.dashboardRevenue,",
      "          value: stats['revenue'].toStringAsFixed(2),",
      "          color: colorScheme.primary,",
      "          isCurrency: true,",
      "        ),",
      "        _StatCard(",
      "          icon: Icons.shopping_bag,",
      "          label: loc.dashboardOrders,",
      "          value: stats['orders'].toString(),",
      "          color: colorScheme.secondary,",
      "        ),",
      "        _StatCard(",
      "          icon: Icons.group,",
      "          label: loc.dashboardUniqueCustomers,",
      "          value: stats['uniqueCustomers'].toString(),",
      "          color: colorScheme.tertiary ?? colorScheme.primary,",
      "        ),",
      "        _StatCard(",
      "          icon: Icons.star,",
      "          label: loc.dashboardTopSeller,",
      "          value: stats['topSeller'] ?? '-',",
      "          color: colorScheme.primary,",
      "        ),",
      "        _StatCard(",
      "          icon: Icons.trending_up,",
      "          label: loc.dashboardAvgOrderValue,",
      "          value: stats['avgOrderValue'].toStringAsFixed(2),",
      "          color: colorScheme.primary,",
      "          isCurrency: true,",
      "        ),",
      "        _StatCard(",
      "          icon: Icons.app_settings_alt,",
      "          label: loc.dashboardAppVersion,",
      "          value: stats['appVersion'] ?? '-',",
      "          color: colorScheme.outline,",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}",
      "",
      "class _StatCard extends StatelessWidget {",
      "  final IconData icon;",
      "  final String label;",
      "  final String value;",
      "  final Color color;",
      "  final bool isCurrency;",
      "",
      "  const _StatCard({",
      "    required this.icon,",
      "    required this.label,",
      "    required this.value,",
      "    required this.color,",
      "    this.isCurrency = false,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final theme = Theme.of(context);",
      "    return Card(",
      "      elevation: DesignTokens.adminCardElevation,",
      "      shape: RoundedRectangleBorder(",
      "        borderRadius: BorderRadius.circular(DesignTokens.adminCardRadius),",
      "      ),",
      "      child: Padding(",
      "        padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 18),",
      "        child: Row(",
      "          mainAxisSize: MainAxisSize.min,",
      "          children: [",
      "            Icon(icon, size: 32, color: color),",
      "            const SizedBox(width: 16),",
      "            Column(",
      "              crossAxisAlignment: CrossAxisAlignment.start,",
      "              children: [",
      "                Text(",
      "                  label,",
      "                  style: theme.textTheme.titleMedium?.copyWith(",
      "                    color: color,",
      "                    fontWeight: FontWeight.w600,",
      "                  ),",
      "                ),",
      "                Text(",
      "                  isCurrency ? '\\$${value}' : value,",
      "                  style: theme.textTheme.titleLarge?.copyWith(",
      "                    color: color,",
      "                    fontWeight: FontWeight.bold,",
      "                  ),",
      "                ),",
      "              ],",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "class _SystemHealthCard extends StatelessWidget {",
      "  final String health;",
      "  final DateTime lastSync;",
      "  final ColorScheme colorScheme;",
      "  final AppLocalizations loc;",
      "",
      "  const _SystemHealthCard({",
      "    required this.health,",
      "    required this.lastSync,",
      "    required this.colorScheme,",
      "    required this.loc,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    IconData icon;",
      "    Color iconColor;",
      "    String statusLabel;",
      "",
      "    if (health == 'ok') {",
      "      icon = Icons.check_circle_outline;",
      "      iconColor = Colors.green;",
      "      statusLabel = loc.dashboardHealthGood;",
      "    } else if (health == 'warning') {",
      "      icon = Icons.warning_amber_rounded;",
      "      iconColor = Colors.orange;",
      "      statusLabel = loc.dashboardHealthWarning;",
      "    } else {",
      "      icon = Icons.error_outline;",
      "      iconColor = Colors.red;",
      "      statusLabel = loc.dashboardHealthError;",
      "    }",
      "",
      "    return Card(",
      "      color: colorScheme.surfaceVariant,",
      "      margin: const EdgeInsets.only(bottom: 12),",
      "      shape: RoundedRectangleBorder(",
      "        borderRadius: BorderRadius.circular(DesignTokens.adminCardRadius),",
      "      ),",
      "      elevation: DesignTokens.adminCardElevation,",
      "      child: Padding(",
      "        padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 18),",
      "        child: Row(",
      "          children: [",
      "            Icon(icon, color: iconColor, size: 34),",
      "            const SizedBox(width: 18),",
      "            Expanded(",
      "              child: Column(",
      "                crossAxisAlignment: CrossAxisAlignment.start,",
      "                children: [",
      "                  Text(",
      "                    statusLabel,",
      "                    style: TextStyle(",
      "                      color: iconColor,",
      "                      fontWeight: FontWeight.bold,",
      "                      fontSize: 18,",
      "                    ),",
      "                  ),",
      "                  const SizedBox(height: 6),",
      "                  Text(",
      "                    '${loc.dashboardLastSync}: ${_formatDateTime(lastSync)}',",
      "                    style: Theme.of(context).textTheme.bodyMedium,",
      "                  ),",
      "                ],",
      "              ),",
      "            ),",
      "            IconButton(",
      "              icon: const Icon(Icons.refresh),",
      "              tooltip: loc.reload,",
      "              onPressed: () {",
      "                // Optionally, lift this callback via a prop to reload stats.",
      "              },",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  String _formatDateTime(DateTime dt) {",
      "    return '${dt.year}-${dt.month.toString().padLeft(2, '0')}-${dt.day.toString().padLeft(2, '0')} '",
      "        '${dt.hour.toString().padLeft(2, '0')}:${dt.minute.toString().padLeft(2, '0')}';",
      "  }",
      "}",
      "",
      "class _DeveloperInsightCards extends StatelessWidget {",
      "  final ThemeData theme;",
      "  final ColorScheme colorScheme;",
      "  final AppLocalizations loc;",
      "  final String? franchiseId;",
      "",
      "  const _DeveloperInsightCards({",
      "    required this.theme,",
      "    required this.colorScheme,",
      "    required this.loc,",
      "    this.franchiseId,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    // Placeholder: Insert real developer insights as built.",
      "    return Wrap(",
      "      spacing: 18,",
      "      runSpacing: 16,",
      "      children: [",
      "        Card(",
      "          color: colorScheme.surfaceVariant,",
      "          child: Padding(",
      "            padding: const EdgeInsets.all(20),",
      "            child: Row(",
      "              mainAxisSize: MainAxisSize.min,",
      "              children: [",
      "                Icon(Icons.info_outline, color: colorScheme.primary, size: 30),",
      "                const SizedBox(width: 18),",
      "                Column(",
      "                  crossAxisAlignment: CrossAxisAlignment.start,",
      "                  children: [",
      "                    Text(",
      "                      loc.developerMetricsComingSoon,",
      "                      style: theme.textTheme.titleMedium?.copyWith(",
      "                        color: colorScheme.primary,",
      "                        fontWeight: FontWeight.bold,",
      "                      ),",
      "                    ),",
      "                    Text(",
      "                      loc.developerMetricsDesc,",
      "                      style: theme.textTheme.bodyMedium,",
      "                    ),",
      "                  ],",
      "                ),",
      "              ],",
      "            ),",
      "          ),",
      "        ),",
      "        // Add more developer-only cards as real features roll out",
      "      ],",
      "    );",
      "  }",
      "}",
      "",
      "class _ComingSoonCard extends StatelessWidget {",
      "  final IconData icon;",
      "  final String title;",
      "  final String subtitle;",
      "  final ColorScheme colorScheme;",
      "  final ThemeData theme;",
      "",
      "  const _ComingSoonCard({",
      "    required this.icon,",
      "    required this.title,",
      "    required this.subtitle,",
      "    required this.colorScheme,",
      "    required this.theme,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Card(",
      "      color: colorScheme.surfaceVariant.withOpacity(0.86),",
      "      elevation: DesignTokens.adminCardElevation,",
      "      shape: RoundedRectangleBorder(",
      "        borderRadius: BorderRadius.circular(DesignTokens.adminCardRadius),",
      "      ),",
      "      child: Padding(",
      "        padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 22),",
      "        child: Row(",
      "          children: [",
      "            Icon(icon, color: colorScheme.outline, size: 34),",
      "            const SizedBox(width: 20),",
      "            Expanded(",
      "              child: Column(",
      "                crossAxisAlignment: CrossAxisAlignment.start,",
      "                children: [",
      "                  Text(",
      "                    title,",
      "                    style: theme.textTheme.titleMedium?.copyWith(",
      "                      color: colorScheme.outline,",
      "                      fontWeight: FontWeight.w600,",
      "                    ),",
      "                  ),",
      "                  const SizedBox(height: 5),",
      "                  Text(",
      "                    subtitle,",
      "                    style: theme.textTheme.bodyMedium,",
      "                  ),",
      "                ],",
      "              ),",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 509,
      "file_size": 16239,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\developer\\plugin_config_dialog.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class PluginConfigDialog extends StatefulWidget {",
      "  final String pluginId;",
      "  final String franchiseId;",
      "  final Map<String, dynamic>? initialConfig;",
      "",
      "  const PluginConfigDialog({",
      "    Key? key,",
      "    required this.pluginId,",
      "    required this.franchiseId,",
      "    this.initialConfig,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  State<PluginConfigDialog> createState() => _PluginConfigDialogState();",
      "}",
      "",
      "class _PluginConfigDialogState extends State<PluginConfigDialog> {",
      "  final _formKey = GlobalKey<FormState>();",
      "  late Map<String, dynamic> _config;",
      "  bool _loading = false;",
      "  String? _errorMsg;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _config = Map<String, dynamic>.from(widget.initialConfig ?? {});",
      "  }",
      "",
      "  void _updateField(String key, dynamic value) {",
      "    setState(() {",
      "      _config[key] = value;",
      "    });",
      "  }",
      "",
      "  Future<void> _saveConfig() async {",
      "    setState(() {",
      "      _loading = true;",
      "      _errorMsg = null;",
      "    });",
      "    try {",
      "      // TODO: Save config to Firestore/service, using pluginId + franchiseId",
      "      await Future.delayed(const Duration(milliseconds: 600));",
      "      setState(() => _loading = false);",
      "      Navigator.of(context).pop(_config);",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(",
      "            content:",
      "                Text(AppLocalizations.of(context)!.pluginConfigDialogSaved)),",
      "      );",
      "    } catch (e, stack) {",
      "      setState(() {",
      "        _errorMsg = e.toString();",
      "        _loading = false;",
      "      });",
      "      await ErrorLogger.log(",
      "        message: 'Failed to save plugin config: $e',",
      "        stack: stack.toString(),",
      "        source: 'PluginConfigDialog',",
      "        screen: 'PluginConfigDialog',",
      "        severity: 'error',",
      "        contextData: {",
      "          'franchiseId': widget.franchiseId,",
      "          'pluginId': widget.pluginId,",
      "        },",
      "      );",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      // Fallback UI for missing localization:",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "    final adminUser = Provider.of<AdminUserProvider>(context).user;",
      "    final isDeveloper = adminUser?.roles.contains('developer') ?? false;",
      "",
      "    if (!isDeveloper) {",
      "      return Dialog(",
      "        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),",
      "        child: Padding(",
      "          padding: const EdgeInsets.all(32.0),",
      "          child: Center(",
      "            child: Text(",
      "              loc.unauthorizedAccess,",
      "              style: theme.textTheme.titleLarge?.copyWith(",
      "                color: colorScheme.error,",
      "                fontWeight: FontWeight.bold,",
      "              ),",
      "            ),",
      "          ),",
      "        ),",
      "      );",
      "    }",
      "",
      "    return Dialog(",
      "      shape: RoundedRectangleBorder(",
      "        borderRadius: BorderRadius.circular(DesignTokens.adminDialogRadius),",
      "      ),",
      "      child: ConstrainedBox(",
      "        constraints: const BoxConstraints(maxWidth: 520),",
      "        child: Padding(",
      "          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 28),",
      "          child: Form(",
      "            key: _formKey,",
      "            child: Column(",
      "              mainAxisSize: MainAxisSize.min,",
      "              crossAxisAlignment: CrossAxisAlignment.start,",
      "              children: [",
      "                Row(",
      "                  children: [",
      "                    Icon(Icons.extension, color: colorScheme.primary, size: 28),",
      "                    const SizedBox(width: 12),",
      "                    Text(",
      "                      '${loc.pluginConfigDialogTitle} — ${widget.pluginId}',",
      "                      style: theme.textTheme.titleLarge?.copyWith(",
      "                        color: colorScheme.primary,",
      "                        fontWeight: FontWeight.bold,",
      "                      ),",
      "                    ),",
      "                    const Spacer(),",
      "                    IconButton(",
      "                      icon: const Icon(Icons.close),",
      "                      tooltip: loc.closeButtonLabel,",
      "                      onPressed: () => Navigator.of(context).pop(),",
      "                    ),",
      "                  ],",
      "                ),",
      "                const SizedBox(height: 8),",
      "                Text(",
      "                  loc.pluginConfigDialogDesc,",
      "                  style: theme.textTheme.bodyMedium,",
      "                ),",
      "                const SizedBox(height: 20),",
      "                if (_errorMsg != null)",
      "                  Padding(",
      "                    padding: const EdgeInsets.only(bottom: 14),",
      "                    child: Text(",
      "                      '${loc.pluginConfigDialogError}\\n$_errorMsg',",
      "                      style: theme.textTheme.bodyMedium",
      "                          ?.copyWith(color: colorScheme.error),",
      "                    ),",
      "                  ),",
      "                // ---- Dynamic config fields (demo structure, replace with your real schema) ----",
      "                ..._config.keys.map((key) =>",
      "                    _buildField(key, _config[key], loc, theme, colorScheme)),",
      "                if (_config.isEmpty)",
      "                  Padding(",
      "                    padding: const EdgeInsets.only(bottom: 14),",
      "                    child: Text(",
      "                      loc.pluginConfigDialogNoFields,",
      "                      style: theme.textTheme.bodyMedium",
      "                          ?.copyWith(color: colorScheme.outline),",
      "                    ),",
      "                  ),",
      "                // Future/expansion area for plugin-specific field editors here",
      "                const SizedBox(height: 12),",
      "                if (_loading)",
      "                  Center(child: CircularProgressIndicator())",
      "                else",
      "                  Row(",
      "                    mainAxisAlignment: MainAxisAlignment.end,",
      "                    children: [",
      "                      OutlinedButton.icon(",
      "                        icon: const Icon(Icons.undo),",
      "                        label: Text(loc.cancelButtonLabel),",
      "                        onPressed: () => Navigator.of(context).pop(),",
      "                      ),",
      "                      const SizedBox(width: 16),",
      "                      ElevatedButton.icon(",
      "                        icon: const Icon(Icons.save),",
      "                        label: Text(loc.pluginConfigDialogSaveButton),",
      "                        style: ElevatedButton.styleFrom(",
      "                          backgroundColor: colorScheme.primary,",
      "                          foregroundColor: colorScheme.onPrimary,",
      "                          padding: const EdgeInsets.symmetric(",
      "                              horizontal: 22, vertical: 10),",
      "                          shape: RoundedRectangleBorder(",
      "                            borderRadius: BorderRadius.circular(",
      "                                DesignTokens.adminButtonRadius),",
      "                          ),",
      "                          textStyle: theme.textTheme.titleMedium",
      "                              ?.copyWith(fontWeight: FontWeight.bold),",
      "                        ),",
      "                        onPressed: _saveConfig,",
      "                      ),",
      "                    ],",
      "                  ),",
      "                const SizedBox(height: 10),",
      "                _ComingSoonCard(",
      "                  icon: Icons.history,",
      "                  title: loc.pluginConfigDialogHistoryComingSoon,",
      "                  subtitle: loc.pluginConfigDialogHistoryDesc,",
      "                  colorScheme: colorScheme,",
      "                  theme: theme,",
      "                ),",
      "                _ComingSoonCard(",
      "                  icon: Icons.security,",
      "                  title: loc.pluginConfigDialogValidationComingSoon,",
      "                  subtitle: loc.pluginConfigDialogValidationDesc,",
      "                  colorScheme: colorScheme,",
      "                  theme: theme,",
      "                ),",
      "              ],",
      "            ),",
      "          ),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  Widget _buildField(",
      "    String key,",
      "    dynamic value,",
      "    AppLocalizations loc,",
      "    ThemeData theme,",
      "    ColorScheme colorScheme,",
      "  ) {",
      "    return Padding(",
      "      padding: const EdgeInsets.only(bottom: 14),",
      "      child: TextFormField(",
      "        initialValue: value?.toString() ?? '',",
      "        decoration: InputDecoration(",
      "          labelText: key,",
      "          border: OutlineInputBorder(",
      "            borderRadius: BorderRadius.circular(DesignTokens.formFieldRadius),",
      "          ),",
      "          isDense: true,",
      "          filled: true,",
      "          fillColor: colorScheme.surfaceVariant,",
      "        ),",
      "        onChanged: (val) => _updateField(key, val),",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "class _ComingSoonCard extends StatelessWidget {",
      "  final IconData icon;",
      "  final String title;",
      "  final String subtitle;",
      "  final ColorScheme colorScheme;",
      "  final ThemeData theme;",
      "",
      "  const _ComingSoonCard({",
      "    required this.icon,",
      "    required this.title,",
      "    required this.subtitle,",
      "    required this.colorScheme,",
      "    required this.theme,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Card(",
      "      color: colorScheme.surfaceVariant.withOpacity(0.87),",
      "      elevation: DesignTokens.adminCardElevation,",
      "      shape: RoundedRectangleBorder(",
      "        borderRadius: BorderRadius.circular(DesignTokens.adminCardRadius),",
      "      ),",
      "      child: Padding(",
      "        padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 14),",
      "        child: Row(",
      "          children: [",
      "            Icon(icon, color: colorScheme.outline, size: 26),",
      "            const SizedBox(width: 18),",
      "            Expanded(",
      "              child: Column(",
      "                crossAxisAlignment: CrossAxisAlignment.start,",
      "                children: [",
      "                  Text(",
      "                    title,",
      "                    style: theme.textTheme.titleMedium?.copyWith(",
      "                      color: colorScheme.outline,",
      "                      fontWeight: FontWeight.bold,",
      "                    ),",
      "                  ),",
      "                  const SizedBox(height: 3),",
      "                  Text(",
      "                    subtitle,",
      "                    style: theme.textTheme.bodyMedium,",
      "                  ),",
      "                ],",
      "              ),",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 306,
      "file_size": 10794,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\developer\\plugin_registry_section.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "import 'package:franchise_admin_portal/widgets/developer/plugin_config_dialog.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class PluginRegistrySection extends StatefulWidget {",
      "  final String? franchiseId;",
      "  const PluginRegistrySection({Key? key, this.franchiseId}) : super(key: key);",
      "",
      "  @override",
      "  State<PluginRegistrySection> createState() => _PluginRegistrySectionState();",
      "}",
      "",
      "class _PluginRegistrySectionState extends State<PluginRegistrySection> {",
      "  bool _loading = true;",
      "  String? _errorMsg;",
      "  List<PluginIntegration> _plugins = [];",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _fetchPlugins();",
      "  }",
      "",
      "  @override",
      "  void didUpdateWidget(covariant PluginRegistrySection oldWidget) {",
      "    super.didUpdateWidget(oldWidget);",
      "    if (oldWidget.franchiseId != widget.franchiseId) {",
      "      _fetchPlugins();",
      "    }",
      "  }",
      "",
      "  Future<void> _fetchPlugins() async {",
      "    setState(() {",
      "      _loading = true;",
      "      _errorMsg = null;",
      "    });",
      "    try {",
      "      // TODO: Replace with real FirestoreService fetch for plugins by franchiseId",
      "      await Future.delayed(const Duration(milliseconds: 500));",
      "      _plugins = [",
      "        PluginIntegration(",
      "          key: 'mailchimp',",
      "          name: 'Mailchimp',",
      "          description: 'Customer marketing & email campaigns.',",
      "          enabled: widget.franchiseId == 'all' ? false : true,",
      "          status: 'connected',",
      "          lastSync: DateTime.now().subtract(const Duration(hours: 2)),",
      "        ),",
      "        PluginIntegration(",
      "          key: 'slack_alerts',",
      "          name: 'Slack Alerts',",
      "          description: 'Order and error notifications in Slack.',",
      "          enabled: false,",
      "          status: 'disconnected',",
      "          lastSync: null,",
      "        ),",
      "        PluginIntegration(",
      "          key: 'custom_delivery',",
      "          name: 'Custom Delivery Provider',",
      "          description: 'Integrate with a 3rd-party delivery API.',",
      "          enabled: false,",
      "          status: 'error',",
      "          lastSync: DateTime.now().subtract(const Duration(days: 1)),",
      "        ),",
      "      ];",
      "      setState(() => _loading = false);",
      "    } catch (e, stack) {",
      "      setState(() {",
      "        _errorMsg = e.toString();",
      "        _loading = false;",
      "      });",
      "      await ErrorLogger.log(",
      "        message: 'Failed to load plugins: $e',",
      "        stack: stack.toString(),",
      "        source: 'PluginRegistrySection',",
      "        screen: 'DeveloperDashboardScreen',",
      "        severity: 'warning',",
      "        contextData: {",
      "          'franchiseId': widget.franchiseId,",
      "        },",
      "      );",
      "    }",
      "  }",
      "",
      "  Future<void> _togglePlugin(PluginIntegration plugin, bool enabled) async {",
      "    try {",
      "      // TODO: Implement actual plugin enable/disable logic in FirestoreService",
      "      await Future.delayed(const Duration(milliseconds: 350));",
      "      setState(() {",
      "        _plugins = _plugins",
      "            .map((p) => p.key == plugin.key ? p.copyWith(enabled: enabled) : p)",
      "            .toList();",
      "      });",
      "      await ErrorLogger.log(",
      "        message: 'Plugin toggled: ${plugin.key} -> $enabled',",
      "        source: 'PluginRegistrySection',",
      "        screen: 'DeveloperDashboardScreen',",
      "        severity: 'info',",
      "        contextData: {",
      "          'franchiseId': widget.franchiseId,",
      "          'pluginKey': plugin.key,",
      "          'enabled': enabled,",
      "        },",
      "      );",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to toggle plugin: $e',",
      "        stack: stack.toString(),",
      "        source: 'PluginRegistrySection',",
      "        screen: 'DeveloperDashboardScreen',",
      "        severity: 'error',",
      "        contextData: {",
      "          'franchiseId': widget.franchiseId,",
      "          'pluginKey': plugin.key,",
      "          'enabled': enabled,",
      "        },",
      "      );",
      "",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(",
      "          content: Text('Failed to update plugin: $e'),",
      "          backgroundColor: Theme.of(context).colorScheme.error,",
      "        ),",
      "      );",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      // Fallback UI for missing localization:",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "    final adminUser = Provider.of<AdminUserProvider>(context).user;",
      "    final isDeveloper = adminUser?.roles.contains('developer') ?? false;",
      "",
      "    if (!isDeveloper) {",
      "      return Center(",
      "        child: Text(",
      "          loc.unauthorizedAccess,",
      "          style: theme.textTheme.titleLarge?.copyWith(",
      "            color: colorScheme.error,",
      "            fontWeight: FontWeight.bold,",
      "          ),",
      "        ),",
      "      );",
      "    }",
      "",
      "    final isAllFranchises = widget.franchiseId == 'all';",
      "",
      "    return Padding(",
      "      padding: const EdgeInsets.all(24.0),",
      "      child: Column(",
      "        crossAxisAlignment: CrossAxisAlignment.start,",
      "        children: [",
      "          Text(",
      "            isAllFranchises",
      "                ? '${loc.pluginRegistrySectionTitle} — ${loc.allFranchisesLabel ?? \"All Franchises\"}'",
      "                : '${loc.pluginRegistrySectionTitle} — ${widget.franchiseId}',",
      "            style: theme.textTheme.titleLarge?.copyWith(",
      "              color: colorScheme.primary,",
      "              fontWeight: FontWeight.bold,",
      "            ),",
      "          ),",
      "          const SizedBox(height: 14),",
      "          Text(",
      "            loc.pluginRegistrySectionDesc,",
      "            style: theme.textTheme.bodyMedium,",
      "          ),",
      "          const SizedBox(height: 18),",
      "          if (_loading)",
      "            Center(child: CircularProgressIndicator(color: colorScheme.primary))",
      "          else if (_errorMsg != null)",
      "            Card(",
      "              color: colorScheme.errorContainer,",
      "              child: Padding(",
      "                padding: const EdgeInsets.all(16.0),",
      "                child: Row(",
      "                  children: [",
      "                    Icon(Icons.error, color: colorScheme.error),",
      "                    const SizedBox(width: 12),",
      "                    Expanded(",
      "                      child: Text(",
      "                        '${loc.pluginRegistrySectionError}\\n$_errorMsg',",
      "                        style: theme.textTheme.bodyMedium",
      "                            ?.copyWith(color: colorScheme.error),",
      "                      ),",
      "                    ),",
      "                    IconButton(",
      "                      icon: Icon(Icons.refresh, color: colorScheme.primary),",
      "                      tooltip: loc.reload,",
      "                      onPressed: _fetchPlugins,",
      "                    ),",
      "                  ],",
      "                ),",
      "              ),",
      "            )",
      "          else if (_plugins.isEmpty)",
      "            Center(child: Text(loc.pluginRegistrySectionEmpty))",
      "          else",
      "            _PluginList(",
      "              plugins: _plugins,",
      "              onToggle: _togglePlugin,",
      "              colorScheme: colorScheme,",
      "              loc: loc,",
      "              isAllFranchises: isAllFranchises,",
      "            ),",
      "          const SizedBox(height: 34),",
      "          _ComingSoonCard(",
      "            icon: Icons.analytics_outlined,",
      "            title: loc.pluginRegistrySectionMonitoringComingSoon,",
      "            subtitle: loc.pluginRegistrySectionMonitoringDesc,",
      "            colorScheme: colorScheme,",
      "            theme: theme,",
      "          ),",
      "          _ComingSoonCard(",
      "            icon: Icons.extension_rounded,",
      "            title: loc.pluginRegistrySectionMarketplaceComingSoon,",
      "            subtitle: loc.pluginRegistrySectionMarketplaceDesc,",
      "            colorScheme: colorScheme,",
      "            theme: theme,",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "class _PluginList extends StatelessWidget {",
      "  final List<PluginIntegration> plugins;",
      "  final void Function(PluginIntegration, bool) onToggle;",
      "  final ColorScheme colorScheme;",
      "  final AppLocalizations loc;",
      "  final bool isAllFranchises;",
      "",
      "  const _PluginList({",
      "    required this.plugins,",
      "    required this.onToggle,",
      "    required this.colorScheme,",
      "    required this.loc,",
      "    required this.isAllFranchises,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Card(",
      "      color: colorScheme.surface,",
      "      child: ListView.separated(",
      "        shrinkWrap: true,",
      "        physics: const NeverScrollableScrollPhysics(),",
      "        itemCount: plugins.length,",
      "        separatorBuilder: (_, __) => const Divider(height: 1),",
      "        itemBuilder: (context, idx) {",
      "          final plugin = plugins[idx];",
      "          return ListTile(",
      "            leading: Icon(Icons.extension, color: colorScheme.outline),",
      "            title: Text(plugin.name),",
      "            subtitle: Column(",
      "              crossAxisAlignment: CrossAxisAlignment.start,",
      "              children: [",
      "                Text(plugin.description),",
      "                const SizedBox(height: 3),",
      "                Row(",
      "                  children: [",
      "                    Icon(",
      "                      plugin.status == 'connected'",
      "                          ? Icons.check_circle_outline",
      "                          : plugin.status == 'error'",
      "                              ? Icons.error",
      "                              : Icons.link_off,",
      "                      size: 18,",
      "                      color: plugin.status == 'connected'",
      "                          ? Colors.green",
      "                          : plugin.status == 'error'",
      "                              ? Colors.red",
      "                              : Colors.orange,",
      "                    ),",
      "                    const SizedBox(width: 5),",
      "                    Text(",
      "                      plugin.status == 'connected'",
      "                          ? loc.pluginRegistrySectionStatusConnected",
      "                          : plugin.status == 'error'",
      "                              ? loc.pluginRegistrySectionStatusError",
      "                              : loc.pluginRegistrySectionStatusDisconnected,",
      "                      style: TextStyle(",
      "                        color: plugin.status == 'connected'",
      "                            ? Colors.green",
      "                            : plugin.status == 'error'",
      "                                ? Colors.red",
      "                                : Colors.orange,",
      "                        fontWeight: FontWeight.bold,",
      "                        fontSize: 13,",
      "                      ),",
      "                    ),",
      "                    if (plugin.lastSync != null) ...[",
      "                      const SizedBox(width: 12),",
      "                      Text(",
      "                        '${loc.pluginRegistrySectionLastSync}: ${_formatDateTime(plugin.lastSync!)}',",
      "                        style: const TextStyle(fontSize: 12),",
      "                      ),",
      "                    ]",
      "                  ],",
      "                )",
      "              ],",
      "            ),",
      "            trailing: Row(",
      "              mainAxisSize: MainAxisSize.min,",
      "              children: [",
      "                isAllFranchises",
      "                    ? Tooltip(",
      "                        message: loc.pluginRegistrySectionNoGlobalToggle,",
      "                        child: Switch(",
      "                          value: plugin.enabled,",
      "                          onChanged: null,",
      "                        ),",
      "                      )",
      "                    : Switch(",
      "                        value: plugin.enabled,",
      "                        onChanged: (v) => onToggle(plugin, v),",
      "                      ),",
      "                const SizedBox(width: 10),",
      "                IconButton(",
      "                  icon: const Icon(Icons.settings),",
      "                  tooltip:",
      "                      loc.pluginRegistrySectionConfigureButton, // Add to ARB!",
      "                  onPressed: () {",
      "                    final franchiseId =",
      "                        Provider.of<FranchiseProvider>(context, listen: false)",
      "                            .franchiseId;",
      "                    showDialog(",
      "                      context: context,",
      "                      builder: (_) => PluginConfigDialog(",
      "                        pluginId: plugin.key,",
      "                        franchiseId: franchiseId,",
      "                        initialConfig: <String,",
      "                            dynamic>{}, // Replace with actual config when available",
      "                      ),",
      "                    );",
      "                  },",
      "                ),",
      "              ],",
      "            ),",
      "            shape: RoundedRectangleBorder(",
      "              borderRadius: BorderRadius.circular(DesignTokens.adminCardRadius),",
      "            ),",
      "          );",
      "        },",
      "      ),",
      "    );",
      "  }",
      "",
      "  String _formatDateTime(DateTime dt) {",
      "    return '${dt.year}-${dt.month.toString().padLeft(2, '0')}-${dt.day.toString().padLeft(2, '0')} '",
      "        '${dt.hour.toString().padLeft(2, '0')}:${dt.minute.toString().padLeft(2, '0')}';",
      "  }",
      "}",
      "",
      "class _ComingSoonCard extends StatelessWidget {",
      "  final IconData icon;",
      "  final String title;",
      "  final String subtitle;",
      "  final ColorScheme colorScheme;",
      "  final ThemeData theme;",
      "",
      "  const _ComingSoonCard({",
      "    required this.icon,",
      "    required this.title,",
      "    required this.subtitle,",
      "    required this.colorScheme,",
      "    required this.theme,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Card(",
      "      color: colorScheme.surfaceVariant.withOpacity(0.87),",
      "      elevation: DesignTokens.adminCardElevation,",
      "      shape: RoundedRectangleBorder(",
      "        borderRadius: BorderRadius.circular(DesignTokens.adminCardRadius),",
      "      ),",
      "      child: Padding(",
      "        padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 20),",
      "        child: Row(",
      "          children: [",
      "            Icon(icon, color: colorScheme.outline, size: 30),",
      "            const SizedBox(width: 18),",
      "            Expanded(",
      "              child: Column(",
      "                crossAxisAlignment: CrossAxisAlignment.start,",
      "                children: [",
      "                  Text(",
      "                    title,",
      "                    style: theme.textTheme.titleMedium?.copyWith(",
      "                      color: colorScheme.outline,",
      "                      fontWeight: FontWeight.bold,",
      "                    ),",
      "                  ),",
      "                  const SizedBox(height: 4),",
      "                  Text(",
      "                    subtitle,",
      "                    style: theme.textTheme.bodyMedium,",
      "                  ),",
      "                ],",
      "              ),",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "class PluginIntegration {",
      "  final String key;",
      "  final String name;",
      "  final String description;",
      "  final bool enabled;",
      "  final String status; // connected, error, disconnected",
      "  final DateTime? lastSync;",
      "",
      "  PluginIntegration({",
      "    required this.key,",
      "    required this.name,",
      "    required this.description,",
      "    required this.enabled,",
      "    required this.status,",
      "    required this.lastSync,",
      "  });",
      "",
      "  PluginIntegration copyWith({",
      "    String? key,",
      "    String? name,",
      "    String? description,",
      "    bool? enabled,",
      "    String? status,",
      "    DateTime? lastSync,",
      "  }) {",
      "    return PluginIntegration(",
      "      key: key ?? this.key,",
      "      name: name ?? this.name,",
      "      description: description ?? this.description,",
      "      enabled: enabled ?? this.enabled,",
      "      status: status ?? this.status,",
      "      lastSync: lastSync ?? this.lastSync,",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 460,
      "file_size": 15795,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\developer\\schema_browser_section.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class SchemaBrowserSection extends StatefulWidget {",
      "  final String? franchiseId;",
      "  const SchemaBrowserSection({Key? key, this.franchiseId}) : super(key: key);",
      "",
      "  @override",
      "  State<SchemaBrowserSection> createState() => _SchemaBrowserSectionState();",
      "}",
      "",
      "class _SchemaBrowserSectionState extends State<SchemaBrowserSection> {",
      "  bool _loading = true;",
      "  String? _errorMsg;",
      "  List<SchemaSummary> _schemas = [];",
      "  String? _selectedSchemaId;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _fetchSchemas();",
      "  }",
      "",
      "  @override",
      "  void didUpdateWidget(covariant SchemaBrowserSection oldWidget) {",
      "    super.didUpdateWidget(oldWidget);",
      "    if (oldWidget.franchiseId != widget.franchiseId) {",
      "      _fetchSchemas();",
      "    }",
      "  }",
      "",
      "  Future<void> _fetchSchemas() async {",
      "    setState(() {",
      "      _loading = true;",
      "      _errorMsg = null;",
      "    });",
      "    try {",
      "      // TODO: Replace with real FirestoreService call for schema metadata",
      "      await Future.delayed(const Duration(milliseconds: 500));",
      "      _schemas = [",
      "        SchemaSummary(",
      "          id: 'menu',",
      "          name: 'Menu',",
      "          version: 'v3',",
      "          updatedAt: DateTime.now().subtract(const Duration(days: 2)),",
      "          status: 'active',",
      "        ),",
      "        SchemaSummary(",
      "          id: 'category',",
      "          name: 'Category',",
      "          version: 'v2',",
      "          updatedAt: DateTime.now().subtract(const Duration(days: 10)),",
      "          status: 'deprecated',",
      "        ),",
      "        SchemaSummary(",
      "          id: 'modifier',",
      "          name: 'Modifier',",
      "          version: 'v1',",
      "          updatedAt: DateTime.now().subtract(const Duration(days: 20)),",
      "          status: 'active',",
      "        ),",
      "      ];",
      "      setState(() => _loading = false);",
      "    } catch (e, stack) {",
      "      setState(() {",
      "        _errorMsg = e.toString();",
      "        _loading = false;",
      "      });",
      "      await ErrorLogger.log(",
      "        message: 'Failed to load schemas: $e',",
      "        stack: stack.toString(),",
      "        source: 'SchemaBrowserSection',",
      "        screen: 'DeveloperDashboardScreen',",
      "        severity: 'warning',",
      "        contextData: {",
      "          'franchiseId': widget.franchiseId,",
      "        },",
      "      );",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      // Fallback UI for missing localization:",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "    final adminUser = Provider.of<AdminUserProvider>(context).user;",
      "    final isDeveloper = adminUser?.roles.contains('developer') ?? false;",
      "",
      "    if (!isDeveloper) {",
      "      return Center(",
      "        child: Text(",
      "          loc.unauthorizedAccess,",
      "          style: theme.textTheme.titleLarge?.copyWith(",
      "            color: colorScheme.error,",
      "            fontWeight: FontWeight.bold,",
      "          ),",
      "        ),",
      "      );",
      "    }",
      "",
      "    final isAllFranchises = widget.franchiseId == 'all';",
      "",
      "    return Padding(",
      "      padding: const EdgeInsets.all(24.0),",
      "      child: Column(",
      "        crossAxisAlignment: CrossAxisAlignment.start,",
      "        children: [",
      "          Text(",
      "            isAllFranchises",
      "                ? '${loc.schemaBrowserSectionTitle} — ${loc.allFranchisesLabel ?? \"All Franchises\"}'",
      "                : '${loc.schemaBrowserSectionTitle} — ${widget.franchiseId}',",
      "            style: theme.textTheme.titleLarge?.copyWith(",
      "              color: colorScheme.primary,",
      "              fontWeight: FontWeight.bold,",
      "            ),",
      "          ),",
      "          const SizedBox(height: 14),",
      "          Text(",
      "            loc.schemaBrowserSectionDesc,",
      "            style: theme.textTheme.bodyMedium,",
      "          ),",
      "          const SizedBox(height: 18),",
      "          if (_loading)",
      "            Center(child: CircularProgressIndicator(color: colorScheme.primary))",
      "          else if (_errorMsg != null)",
      "            Card(",
      "              color: colorScheme.errorContainer,",
      "              child: Padding(",
      "                padding: const EdgeInsets.all(16.0),",
      "                child: Row(",
      "                  children: [",
      "                    Icon(Icons.error, color: colorScheme.error),",
      "                    const SizedBox(width: 12),",
      "                    Expanded(",
      "                      child: Text(",
      "                        '${loc.schemaBrowserSectionError}\\n$_errorMsg',",
      "                        style: theme.textTheme.bodyMedium",
      "                            ?.copyWith(color: colorScheme.error),",
      "                      ),",
      "                    ),",
      "                    IconButton(",
      "                      icon: Icon(Icons.refresh, color: colorScheme.primary),",
      "                      tooltip: loc.reload,",
      "                      onPressed: _fetchSchemas,",
      "                    ),",
      "                  ],",
      "                ),",
      "              ),",
      "            )",
      "          else if (_schemas.isEmpty)",
      "            Center(child: Text(loc.schemaBrowserSectionEmpty))",
      "          else",
      "            _SchemaList(",
      "              schemas: _schemas,",
      "              onSelect: (id) => setState(() => _selectedSchemaId = id),",
      "              colorScheme: colorScheme,",
      "              loc: loc,",
      "              selectedId: _selectedSchemaId,",
      "            ),",
      "          const SizedBox(height: 32),",
      "          if (_selectedSchemaId != null)",
      "            _SchemaDetailCard(",
      "              schema: _schemas.firstWhere((s) => s.id == _selectedSchemaId),",
      "              loc: loc,",
      "              theme: theme,",
      "              colorScheme: colorScheme,",
      "            ),",
      "          const SizedBox(height: 32),",
      "          _ComingSoonCard(",
      "            icon: Icons.compare_arrows,",
      "            title: loc.schemaBrowserSectionDiffsComingSoon,",
      "            subtitle: loc.schemaBrowserSectionDiffsDesc,",
      "            colorScheme: colorScheme,",
      "            theme: theme,",
      "          ),",
      "          _ComingSoonCard(",
      "            icon: Icons.check_circle_outline,",
      "            title: loc.schemaBrowserSectionValidationComingSoon,",
      "            subtitle: loc.schemaBrowserSectionValidationDesc,",
      "            colorScheme: colorScheme,",
      "            theme: theme,",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "class _SchemaList extends StatelessWidget {",
      "  final List<SchemaSummary> schemas;",
      "  final ValueChanged<String> onSelect;",
      "  final ColorScheme colorScheme;",
      "  final AppLocalizations loc;",
      "  final String? selectedId;",
      "",
      "  const _SchemaList({",
      "    required this.schemas,",
      "    required this.onSelect,",
      "    required this.colorScheme,",
      "    required this.loc,",
      "    required this.selectedId,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Card(",
      "      color: colorScheme.surface,",
      "      child: ListView.separated(",
      "        shrinkWrap: true,",
      "        physics: const NeverScrollableScrollPhysics(),",
      "        itemCount: schemas.length,",
      "        separatorBuilder: (_, __) => const Divider(height: 1),",
      "        itemBuilder: (context, idx) {",
      "          final schema = schemas[idx];",
      "          final isActive = selectedId == schema.id;",
      "          return ListTile(",
      "            leading: Icon(Icons.schema, color: colorScheme.outline),",
      "            title: Text('${schema.name} (${schema.version})'),",
      "            subtitle: Row(",
      "              children: [",
      "                Text(",
      "                    '${loc.schemaBrowserSectionUpdated}: ${_formatDateTime(schema.updatedAt)}'),",
      "                const SizedBox(width: 10),",
      "                Container(",
      "                  padding:",
      "                      const EdgeInsets.symmetric(horizontal: 8, vertical: 2),",
      "                  decoration: BoxDecoration(",
      "                    color: schema.status == 'active'",
      "                        ? Colors.green.withOpacity(0.12)",
      "                        : Colors.orange.withOpacity(0.12),",
      "                    borderRadius: BorderRadius.circular(10),",
      "                  ),",
      "                  child: Text(",
      "                    schema.status == 'active'",
      "                        ? loc.schemaBrowserSectionStatusActive",
      "                        : loc.schemaBrowserSectionStatusDeprecated,",
      "                    style: TextStyle(",
      "                      color: schema.status == 'active'",
      "                          ? Colors.green[800]",
      "                          : Colors.orange[800],",
      "                      fontWeight: FontWeight.bold,",
      "                      fontSize: 12,",
      "                    ),",
      "                  ),",
      "                ),",
      "              ],",
      "            ),",
      "            trailing: isActive",
      "                ? Icon(Icons.arrow_right, color: colorScheme.primary)",
      "                : null,",
      "            onTap: () => onSelect(schema.id),",
      "            selected: isActive,",
      "            shape: RoundedRectangleBorder(",
      "              borderRadius: BorderRadius.circular(DesignTokens.adminCardRadius),",
      "            ),",
      "          );",
      "        },",
      "      ),",
      "    );",
      "  }",
      "",
      "  String _formatDateTime(DateTime dt) {",
      "    return '${dt.year}-${dt.month.toString().padLeft(2, '0')}-${dt.day.toString().padLeft(2, '0')} '",
      "        '${dt.hour.toString().padLeft(2, '0')}:${dt.minute.toString().padLeft(2, '0')}';",
      "  }",
      "}",
      "",
      "class _SchemaDetailCard extends StatelessWidget {",
      "  final SchemaSummary schema;",
      "  final AppLocalizations loc;",
      "  final ThemeData theme;",
      "  final ColorScheme colorScheme;",
      "",
      "  const _SchemaDetailCard({",
      "    required this.schema,",
      "    required this.loc,",
      "    required this.theme,",
      "    required this.colorScheme,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    // TODO: Replace placeholder with full schema fields, JSON, versioning, etc.",
      "    return Card(",
      "      color: colorScheme.surfaceVariant,",
      "      shape: RoundedRectangleBorder(",
      "        borderRadius: BorderRadius.circular(DesignTokens.adminCardRadius),",
      "      ),",
      "      child: Padding(",
      "        padding: const EdgeInsets.all(20.0),",
      "        child: Column(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            Text(",
      "              '${loc.schemaBrowserSectionSchemaDetails}: ${schema.name} (${schema.version})',",
      "              style: theme.textTheme.titleMedium?.copyWith(",
      "                color: colorScheme.primary,",
      "                fontWeight: FontWeight.bold,",
      "              ),",
      "            ),",
      "            const SizedBox(height: 12),",
      "            Text(",
      "              '${loc.schemaBrowserSectionLastUpdated}: ${_formatDateTime(schema.updatedAt)}',",
      "              style: theme.textTheme.bodyMedium,",
      "            ),",
      "            const SizedBox(height: 16),",
      "            Text(",
      "              loc.schemaBrowserSectionDetailsPlaceholder,",
      "              style: theme.textTheme.bodyMedium?.copyWith(",
      "                fontStyle: FontStyle.italic,",
      "                color: colorScheme.outline,",
      "              ),",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  String _formatDateTime(DateTime dt) {",
      "    return '${dt.year}-${dt.month.toString().padLeft(2, '0')}-${dt.day.toString().padLeft(2, '0')} '",
      "        '${dt.hour.toString().padLeft(2, '0')}:${dt.minute.toString().padLeft(2, '0')}';",
      "  }",
      "}",
      "",
      "class _ComingSoonCard extends StatelessWidget {",
      "  final IconData icon;",
      "  final String title;",
      "  final String subtitle;",
      "  final ColorScheme colorScheme;",
      "  final ThemeData theme;",
      "",
      "  const _ComingSoonCard({",
      "    required this.icon,",
      "    required this.title,",
      "    required this.subtitle,",
      "    required this.colorScheme,",
      "    required this.theme,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Card(",
      "      color: colorScheme.surfaceVariant.withOpacity(0.87),",
      "      elevation: DesignTokens.adminCardElevation,",
      "      shape: RoundedRectangleBorder(",
      "        borderRadius: BorderRadius.circular(DesignTokens.adminCardRadius),",
      "      ),",
      "      child: Padding(",
      "        padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 20),",
      "        child: Row(",
      "          children: [",
      "            Icon(icon, color: colorScheme.outline, size: 30),",
      "            const SizedBox(width: 18),",
      "            Expanded(",
      "              child: Column(",
      "                crossAxisAlignment: CrossAxisAlignment.start,",
      "                children: [",
      "                  Text(",
      "                    title,",
      "                    style: theme.textTheme.titleMedium?.copyWith(",
      "                      color: colorScheme.outline,",
      "                      fontWeight: FontWeight.bold,",
      "                    ),",
      "                  ),",
      "                  const SizedBox(height: 4),",
      "                  Text(",
      "                    subtitle,",
      "                    style: theme.textTheme.bodyMedium,",
      "                  ),",
      "                ],",
      "              ),",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "class SchemaSummary {",
      "  final String id;",
      "  final String name;",
      "  final String version;",
      "  final DateTime updatedAt;",
      "  final String status; // active, deprecated",
      "",
      "  SchemaSummary({",
      "    required this.id,",
      "    required this.name,",
      "    required this.version,",
      "    required this.updatedAt,",
      "    required this.status,",
      "  });",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 410,
      "file_size": 13640,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\dialogs\\franchisee_invitation_dialog.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/widgets/financials/franchisee_invitation_service.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchisee_invitation_provider.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "",
      "class FranchiseeInvitationDialog extends StatefulWidget {",
      "  const FranchiseeInvitationDialog({super.key});",
      "",
      "  @override",
      "  State<FranchiseeInvitationDialog> createState() =>",
      "      _FranchiseeInvitationDialogState();",
      "}",
      "",
      "class _FranchiseeInvitationDialogState",
      "    extends State<FranchiseeInvitationDialog> {",
      "  final _formKey = GlobalKey<FormState>();",
      "  String? _email;",
      "  String? _franchiseName;",
      "  String? _role;",
      "  String? _notes;",
      "  bool _isLoading = false;",
      "  String? _error;",
      "  String? _success;",
      "",
      "  // Adjust these roles as appropriate",
      "  static const _roleOptions = [",
      "    'hq_owner',",
      "    'owner',",
      "    'admin',",
      "    'manager',",
      "    'staff',",
      "  ];",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      // Fallback UI for missing localization:",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "",
      "    return AlertDialog(",
      "      shape: RoundedRectangleBorder(",
      "        borderRadius: BorderRadius.circular(DesignTokens.dialogBorderRadius),",
      "      ),",
      "      title: Text(loc.inviteFranchisee),",
      "      content: Form(",
      "        key: _formKey,",
      "        child: SingleChildScrollView(",
      "          child: Column(",
      "            mainAxisSize: MainAxisSize.min,",
      "            children: [",
      "              if (_error != null)",
      "                Padding(",
      "                  padding: const EdgeInsets.only(bottom: 8.0),",
      "                  child: Text(",
      "                    _error!,",
      "                    style: TextStyle(",
      "                        color: colorScheme.error, fontWeight: FontWeight.w600),",
      "                  ),",
      "                ),",
      "              if (_success != null)",
      "                Padding(",
      "                  padding: const EdgeInsets.only(bottom: 8.0),",
      "                  child: Text(",
      "                    _success!,",
      "                    style: TextStyle(",
      "                        color: colorScheme.primary,",
      "                        fontWeight: FontWeight.w600),",
      "                  ),",
      "                ),",
      "              TextFormField(",
      "                decoration: InputDecoration(",
      "                  labelText: loc.email,",
      "                  hintText: 'franchisee@email.com',",
      "                ),",
      "                keyboardType: TextInputType.emailAddress,",
      "                validator: (val) {",
      "                  if (val == null || val.isEmpty) {",
      "                    return loc.requiredField;",
      "                  }",
      "                  final emailReg = RegExp(r'^[^@\\s]+@[^@\\s]+\\.[^@\\s]+$');",
      "                  if (!emailReg.hasMatch(val)) {",
      "                    return loc.invalidEmail;",
      "                  }",
      "                  return null;",
      "                },",
      "                onSaved: (val) => _email = val,",
      "                enabled: !_isLoading,",
      "              ),",
      "              const SizedBox(height: 10),",
      "              TextFormField(",
      "                decoration: InputDecoration(",
      "                  labelText: loc.franchiseName,",
      "                  hintText: loc.franchiseNameHint,",
      "                ),",
      "                onSaved: (val) => _franchiseName = val,",
      "                enabled: !_isLoading,",
      "              ),",
      "              const SizedBox(height: 10),",
      "              DropdownButtonFormField<String>(",
      "                decoration: InputDecoration(",
      "                  labelText: loc.role,",
      "                ),",
      "                value: _role,",
      "                items: _roleOptions",
      "                    .map((role) => DropdownMenuItem(",
      "                          value: role,",
      "                          child: Text(loc.roleLabel(role)),",
      "                        ))",
      "                    .toList(),",
      "                onChanged:",
      "                    _isLoading ? null : (val) => setState(() => _role = val),",
      "                validator: (val) => val == null ? loc.requiredField : null,",
      "              ),",
      "              const SizedBox(height: 10),",
      "              TextFormField(",
      "                decoration: InputDecoration(",
      "                  labelText: loc.notes,",
      "                ),",
      "                onSaved: (val) => _notes = val,",
      "                enabled: !_isLoading,",
      "                maxLines: 2,",
      "              ),",
      "            ],",
      "          ),",
      "        ),",
      "      ),",
      "      actions: [",
      "        TextButton(",
      "          onPressed: _isLoading ? null : () => Navigator.of(context).pop(),",
      "          child: Text(loc.cancel),",
      "        ),",
      "        ElevatedButton.icon(",
      "          icon: _isLoading",
      "              ? const SizedBox(",
      "                  width: 18,",
      "                  height: 18,",
      "                  child: CircularProgressIndicator(strokeWidth: 2),",
      "                )",
      "              : const Icon(Icons.send),",
      "          onPressed: _isLoading ? null : _submit,",
      "          label: Text(loc.invite),",
      "          style: ElevatedButton.styleFrom(",
      "            backgroundColor: colorScheme.primary,",
      "            foregroundColor: colorScheme.onPrimary,",
      "          ),",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "",
      "  Future<void> _submit() async {",
      "    setState(() {",
      "      _error = null;",
      "      _success = null;",
      "    });",
      "    if (!_formKey.currentState!.validate()) return;",
      "    _formKey.currentState!.save();",
      "",
      "    setState(() => _isLoading = true);",
      "    debugPrint('[FranchiseeInvitationDialog] Sending invite: email=$_email, '",
      "        'franchiseName=$_franchiseName, role=$_role, notes=$_notes');",
      "    try {",
      "      final invitationProvider =",
      "          Provider.of<FranchiseeInvitationProvider>(context, listen: false);",
      "",
      "      await invitationProvider.sendInvitation(",
      "        email: _email!,",
      "        franchiseName: _franchiseName ?? '',",
      "        role: _role!,",
      "        notes: _notes ?? '',",
      "      );",
      "",
      "      setState(() {",
      "        _success = AppLocalizations.of(context)!.invitationSent;",
      "        _isLoading = false;",
      "      });",
      "",
      "      // Optionally, close after a short delay",
      "      Future.delayed(const Duration(milliseconds: 1200), () {",
      "        if (mounted) Navigator.of(context).pop(true);",
      "      });",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to send franchisee invitation',",
      "        stack: stack.toString(),",
      "        severity: 'error',",
      "        source: 'FranchiseeInvitationDialog',",
      "        screen: 'PlatformOwnerDashboardScreen',",
      "        contextData: {",
      "          'exception': e.toString(),",
      "        },",
      "      );",
      "      setState(() {",
      "        _error = AppLocalizations.of(context)!.inviteErrorGeneric;",
      "        _isLoading = false;",
      "      });",
      "    }",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 210,
      "file_size": 7166,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\dialogs\\franchise_selector_dialog_content.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/models/franchise_info.dart'; // <-- use this",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "",
      "class FranchiseSelectorDialogContent extends StatelessWidget {",
      "  const FranchiseSelectorDialogContent({super.key});",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final firestoreService =",
      "        Provider.of<FirestoreService>(context, listen: false);",
      "    final franchiseProvider =",
      "        Provider.of<FranchiseProvider>(context, listen: false);",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      // Fallback UI for missing localization:",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "",
      "    return FutureBuilder<List<FranchiseInfo>>(",
      "      future:",
      "          firestoreService.getFranchises(), // must return List<FranchiseInfo>",
      "      builder: (context, snapshot) {",
      "        if (snapshot.connectionState == ConnectionState.waiting) {",
      "          return const Padding(",
      "            padding: EdgeInsets.all(16.0),",
      "            child: Center(child: CircularProgressIndicator()),",
      "          );",
      "        } else if (snapshot.hasError) {",
      "          return Padding(",
      "            padding: const EdgeInsets.all(16.0),",
      "            child: Text(",
      "              loc.failedToLoadFranchises,",
      "              style: const TextStyle(color: Colors.red),",
      "            ),",
      "          );",
      "        }",
      "",
      "        final franchises = snapshot.data ?? [];",
      "        return ListView.builder(",
      "          shrinkWrap: true,",
      "          itemCount: franchises.length,",
      "          itemBuilder: (context, index) {",
      "            final franchise = franchises[index];",
      "            return ListTile(",
      "              title: Text(franchise.name ?? franchise.id),",
      "              subtitle: Text('ID: ${franchise.id}'),",
      "              onTap: () {",
      "                franchiseProvider.setFranchiseId(franchise.id);",
      "                Navigator.of(context).pop(); // Close dialog",
      "              },",
      "            );",
      "          },",
      "        );",
      "      },",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 65,
      "file_size": 2418,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\dynamic_form\\customization_group_editor.dart",
    "content": [
      "import 'package:provider/provider.dart';",
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "",
      "class CustomizationGroupEditor extends StatefulWidget {",
      "  final String franchiseId;",
      "  final List<Map<String, dynamic>> customizations;",
      "  final void Function(List<Map<String, dynamic>>) onChanged;",
      "",
      "  const CustomizationGroupEditor({",
      "    super.key,",
      "    required this.franchiseId,",
      "    required this.customizations,",
      "    required this.onChanged,",
      "  });",
      "",
      "  @override",
      "  State<CustomizationGroupEditor> createState() =>",
      "      _CustomizationGroupEditorState();",
      "}",
      "",
      "class _CustomizationGroupEditorState extends State<CustomizationGroupEditor> {",
      "  int? _expandedIndex;",
      "  late List<Map<String, dynamic>> _groups;",
      "  List<Map<String, dynamic>> _templates = [];",
      "  List<Map<String, dynamic>> _ingredientMetadataList = [];",
      "  bool _loadingTemplates = false;",
      "  bool _loadingIngredients = false;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _groups = List<Map<String, dynamic>>.from(widget.customizations);",
      "    _loadTemplatesAndIngredients(widget.franchiseId);",
      "  }",
      "",
      "  Future<void> _loadTemplatesAndIngredients(String franchiseId) async {",
      "    setState(() {",
      "      _loadingTemplates = true;",
      "      _loadingIngredients = true;",
      "    });",
      "",
      "    final fs = Provider.of<FirestoreService>(context, listen: false);",
      "",
      "    // Await both futures first",
      "    final results = await Future.wait([",
      "      fs.fetchCustomizationTemplatesAsMaps(franchiseId),",
      "      fs.fetchIngredientMetadataAsMaps(franchiseId),",
      "    ]);",
      "",
      "    // Now you can safely print using results[0]",
      "    print('[DEBUG] Customization templates loaded: ${results[0].length}');",
      "    for (final tpl in results[0]) {",
      "      print(",
      "          '[DEBUG] Template: ${tpl['label']} | ingredientIds: ${tpl['ingredientIds']}');",
      "    }",
      "",
      "    if (!mounted) return;",
      "    setState(() {",
      "      _templates = List<Map<String, dynamic>>.from(results[0]);",
      "      _ingredientMetadataList = List<Map<String, dynamic>>.from(results[1]);",
      "      _loadingTemplates = false;",
      "      _loadingIngredients = false;",
      "    });",
      "  }",
      "",
      "  Map<String, dynamic>? _findTemplateByLabel(String label) {",
      "    try {",
      "      return _templates.firstWhere((tpl) {",
      "        final l = (tpl['label'] is Map ? tpl['label']['en'] : tpl['label'])",
      "            ?.toString();",
      "        return l?.toLowerCase() == label.toLowerCase();",
      "      });",
      "    } catch (_) {",
      "      return null;",
      "    }",
      "  }",
      "",
      "  Map<String, dynamic>? _findIngredientByName(String name) {",
      "    try {",
      "      return _ingredientMetadataList.firstWhere(",
      "        (ing) => ing['name'].toString().toLowerCase() == name.toLowerCase(),",
      "      );",
      "    } catch (_) {",
      "      return null;",
      "    }",
      "  }",
      "",
      "  String _getIngredientNameById(String id) {",
      "    final found = _ingredientMetadataList.firstWhere(",
      "      (ing) => ing['id'].toString() == id,",
      "      orElse: () => {},",
      "    );",
      "    print(",
      "        '[DEBUG][UI] Resolving ingredientId \"$id\": ${found['name'] ?? 'NOT FOUND'}');",
      "    return found['name'] ?? id;",
      "  }",
      "",
      "  void _addGroup() {",
      "    setState(() {",
      "      _groups.add({",
      "        'label': '',",
      "        'ingredientIds': <String>[],",
      "      });",
      "    });",
      "    _expandedIndex = _groups.length - 1; // Expand the new group",
      "    print(",
      "        '[DEBUG] Added new group: ${_groups.isNotEmpty ? _groups.last : 'EMPTY'}');",
      "    widget.onChanged(_groups);",
      "  }",
      "",
      "  void _removeGroup(int index) {",
      "    setState(() {",
      "      _groups.removeAt(index);",
      "      print('[DEBUG] Removed group at index $index. Groups now: $_groups');",
      "    });",
      "    widget.onChanged(_groups);",
      "  }",
      "",
      "  void _updateGroupLabel(int index, String value) {",
      "    setState(() {",
      "      _groups[index]['label'] = value.trim();",
      "      // Auto-populate from template if found",
      "      final tpl = _findTemplateByLabel(value.trim());",
      "      _expandedIndex = index; // Always expand group after label/template change",
      "      if (tpl != null) {",
      "        print('[DEBUG] Template found for label \"$value\": $tpl');",
      "        _groups[index]['ingredientIds'] =",
      "            List<String>.from(tpl['ingredientIds'] ?? []);",
      "        _groups[index]['inputMode'] = tpl['inputMode'];",
      "        _groups[index]['optionsSource'] = tpl['optionsSource'];",
      "        _groups[index]['locked'] = tpl['locked'];",
      "        print('[DEBUG] Group $index after template applied: ${_groups[index]}');",
      "      } else {",
      "        print('[DEBUG] No template found for label \"$value\".');",
      "      }",
      "    });",
      "    widget.onChanged(_groups);",
      "  }",
      "",
      "  void _addIngredientToGroup(int groupIndex, String ingredientName) {",
      "    final found = _findIngredientByName(ingredientName);",
      "    if (found == null) return;",
      "    setState(() {",
      "      print(",
      "          '[DEBUG] Added ingredient \"${found['id']}\" to group $groupIndex: ${_groups[groupIndex]['ingredientIds']}');",
      "      final ingredientIds =",
      "          List<String>.from(_groups[groupIndex]['ingredientIds'] ?? []);",
      "      if (!ingredientIds.contains(found['id'])) {",
      "        ingredientIds.add(found['id']);",
      "        _groups[groupIndex]['ingredientIds'] = ingredientIds;",
      "      }",
      "    });",
      "    widget.onChanged(_groups);",
      "  }",
      "",
      "  void _removeIngredientFromGroup(int groupIndex, int ingredientIndex) {",
      "    setState(() {",
      "      print(",
      "          '[DEBUG] Removed ingredient at index $ingredientIndex from group $groupIndex: ${_groups[groupIndex]['ingredientIds']}');",
      "      final ingredientIds =",
      "          List<String>.from(_groups[groupIndex]['ingredientIds'] ?? []);",
      "      if (ingredientIndex >= 0 && ingredientIndex < ingredientIds.length) {",
      "        ingredientIds.removeAt(ingredientIndex);",
      "        _groups[groupIndex]['ingredientIds'] = ingredientIds;",
      "      }",
      "    });",
      "    widget.onChanged(_groups);",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        Text(",
      "          \"Customizations\",",
      "          style: Theme.of(context)",
      "              .textTheme",
      "              .titleMedium",
      "              ?.copyWith(fontWeight: FontWeight.bold),",
      "        ),",
      "        const SizedBox(height: 8),",
      "        if (_loadingTemplates || _loadingIngredients)",
      "          const Padding(",
      "            padding: EdgeInsets.all(12),",
      "            child: Center(child: CircularProgressIndicator()),",
      "          ),",
      "        if (!_loadingTemplates && !_loadingIngredients && _groups.isEmpty)",
      "          Padding(",
      "            padding: const EdgeInsets.only(left: 8, bottom: 8),",
      "            child: Text(",
      "              \"No customization groups added.\",",
      "              style: TextStyle(",
      "                  fontStyle: FontStyle.italic, color: Colors.grey[600]),",
      "            ),",
      "          ),",
      "        ...List.generate(_groups.length, (groupIndex) {",
      "          final group = _groups[groupIndex];",
      "          return Padding(",
      "            padding: const EdgeInsets.only(bottom: 12),",
      "            child: Card(",
      "              margin: EdgeInsets.zero,",
      "              child: ExpansionTile(",
      "                key: Key('group_$groupIndex'),",
      "                initiallyExpanded: _expandedIndex == groupIndex,",
      "                onExpansionChanged: (expanded) {",
      "                  setState(() {",
      "                    _expandedIndex = expanded ? groupIndex : null;",
      "                  });",
      "                },",
      "                title: DropdownButtonFormField<String>(",
      "                  value: (group['label'] is Map",
      "                                  ? group['label']['en']",
      "                                  : group['label'])",
      "                              ?.toString()",
      "                              .isNotEmpty ==",
      "                          true",
      "                      ? (group['label'] is Map",
      "                              ? group['label']['en']",
      "                              : group['label'])",
      "                          ?.toString()",
      "                      : null,",
      "                  items: _templates.map((tpl) {",
      "                    final label = (tpl['label'] is Map",
      "                            ? tpl['label']['en']",
      "                            : tpl['label'])",
      "                        .toString();",
      "                    return DropdownMenuItem(value: label, child: Text(label));",
      "                  }).toList(),",
      "                  onChanged: (String? selectedLabel) {",
      "                    if (selectedLabel == null) return;",
      "                    _updateGroupLabel(groupIndex, selectedLabel);",
      "                    setState(() {",
      "                      _expandedIndex = groupIndex; // Auto-expand on selection",
      "                    });",
      "                  },",
      "                  decoration: const InputDecoration(",
      "                    labelText: 'Group Label (Template)',",
      "                  ),",
      "                ),",
      "                trailing: IconButton(",
      "                  icon:",
      "                      const Icon(Icons.delete_outline, color: Colors.redAccent),",
      "                  tooltip: 'Remove Group',",
      "                  onPressed: () => _removeGroup(groupIndex),",
      "                ),",
      "                children: [",
      "                  Column(",
      "                    crossAxisAlignment: CrossAxisAlignment.start,",
      "                    children: [",
      "                      // List each ingredient in the group with remove button",
      "                      ...(() {",
      "                        final ingredientIds =",
      "                            List<String>.from(group['ingredientIds'] ?? []);",
      "                        return List.generate(ingredientIds.length,",
      "                            (ingredientIdx) {",
      "                          final ingredientId = ingredientIds[ingredientIdx];",
      "                          return Row(",
      "                            children: [",
      "                              Expanded(",
      "                                child:",
      "                                    Text(_getIngredientNameById(ingredientId)),",
      "                              ),",
      "                              IconButton(",
      "                                icon: const Icon(Icons.delete,",
      "                                    color: Colors.redAccent),",
      "                                tooltip: 'Remove',",
      "                                onPressed: () => _removeIngredientFromGroup(",
      "                                    groupIndex, ingredientIdx),",
      "                              ),",
      "                            ],",
      "                          );",
      "                        });",
      "                      })(),",
      "                      // Add Ingredient Autocomplete",
      "                      Padding(",
      "                        padding: const EdgeInsets.only(top: 8.0, right: 24.0),",
      "                        child: Autocomplete<String>(",
      "                          optionsBuilder: (TextEditingValue textEditingValue) {",
      "                            return _ingredientMetadataList",
      "                                .map((e) => e['name'].toString())",
      "                                .where((option) => option",
      "                                    .toLowerCase()",
      "                                    .contains(",
      "                                        textEditingValue.text.toLowerCase()))",
      "                                .toList();",
      "                          },",
      "                          onSelected: (String selectedName) {",
      "                            _addIngredientToGroup(groupIndex, selectedName);",
      "                          },",
      "                          fieldViewBuilder: (context, controller, focusNode,",
      "                              onFieldSubmitted) {",
      "                            return TextFormField(",
      "                              controller: controller,",
      "                              focusNode: focusNode,",
      "                              decoration: const InputDecoration(",
      "                                  labelText: 'Add Ingredient by Name'),",
      "                              onFieldSubmitted: (_) => onFieldSubmitted(),",
      "                            );",
      "                          },",
      "                        ),",
      "                      ),",
      "                    ],",
      "                  ),",
      "                ],",
      "              ),",
      "            ),",
      "          );",
      "        }),",
      "        Align(",
      "          alignment: Alignment.centerLeft,",
      "          child: OutlinedButton.icon(",
      "            onPressed: _addGroup,",
      "            icon: Icon(Icons.add,",
      "                color: Theme.of(context).brightness == Brightness.dark",
      "                    ? Colors.white",
      "                    : colorScheme.primary),",
      "            style: OutlinedButton.styleFrom(",
      "              side: BorderSide(",
      "                color: Theme.of(context).brightness == Brightness.dark",
      "                    ? Colors.white",
      "                    : colorScheme.primary,",
      "              ),",
      "            ),",
      "            label: Text(",
      "              \"Add Customization Group\",",
      "              style: TextStyle(",
      "                color: Theme.of(context).brightness == Brightness.dark",
      "                    ? Colors.white",
      "                    : colorScheme.primary,",
      "              ),",
      "            ),",
      "          ),",
      "        ),",
      "        const SizedBox(height: 16),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 341,
      "file_size": 13023,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\dynamic_form\\dynamic_array_editor.dart",
    "content": [
      "import 'dart:convert';",
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "",
      "class DynamicArrayEditor extends StatefulWidget {",
      "  final String title;",
      "  final String arrayKey;",
      "  final List<Map<String, dynamic>> items;",
      "  final Map<String, dynamic> template;",
      "  final void Function(List<Map<String, dynamic>> updated) onChanged;",
      "  final String franchiseId;",
      "",
      "  const DynamicArrayEditor({",
      "    super.key,",
      "    required this.title,",
      "    required this.arrayKey,",
      "    required this.items,",
      "    required this.template,",
      "    required this.onChanged,",
      "    required this.franchiseId,",
      "  });",
      "",
      "  @override",
      "  State<DynamicArrayEditor> createState() => _DynamicArrayEditorState();",
      "}",
      "",
      "class _DynamicArrayEditorState extends State<DynamicArrayEditor> {",
      "  late List<Map<String, dynamic>> _items;",
      "  int? _expandedIndex;",
      "  List<Map<String, dynamic>> _ingredientMetadataList = [];",
      "  List<TextEditingController> _typeControllers = [];",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _items = List<Map<String, dynamic>>.from(widget.items);",
      "",
      "    _typeControllers = List.generate(_items.length, (i) {",
      "      return TextEditingController(text: _items[i]['type'] ?? '');",
      "    });",
      "",
      "    // Load ingredient metadata if available via Provider or FirestoreService",
      "    Future.microtask(() async {",
      "      final fs = Provider.of<FirestoreService>(context, listen: false);",
      "      final result = await fs.fetchIngredientMetadataAsMaps(widget.franchiseId);",
      "      if (mounted) {",
      "        setState(() {",
      "          _ingredientMetadataList = result;",
      "        });",
      "      }",
      "    });",
      "  }",
      "",
      "  Map<String, dynamic>? _findIngredientByName(String name) {",
      "    try {",
      "      final found = _ingredientMetadataList.firstWhere(",
      "        (ing) => ing['name'].toString().toLowerCase() == name.toLowerCase(),",
      "      );",
      "      print('[DEBUG] Ingredient found for \"$name\": $found');",
      "      return found;",
      "    } catch (e) {",
      "      print('[DEBUG] Ingredient not found for \"$name\".');",
      "      return null;",
      "    }",
      "  }",
      "",
      "  void _onItemChanged(int index, String field, dynamic value) {",
      "    setState(() {",
      "      _items[index][field] = value;",
      "    });",
      "    widget.onChanged(_items);",
      "  }",
      "",
      "  void _addItem() {",
      "    setState(() {",
      "      final newItem = <String, dynamic>{};",
      "      widget.template.forEach((key, config) {",
      "        final defaultVal =",
      "            (config is Map<String, dynamic>) ? config['default'] : null;",
      "        newItem[key] = _sanitizeValue(defaultVal ?? '');",
      "      });",
      "      _items.add(newItem);",
      "      _typeControllers",
      "          .add(TextEditingController(text: _items.last['type'] ?? ''));",
      "      _expandedIndex = _items.length - 1;",
      "    });",
      "    widget.onChanged(_items);",
      "  }",
      "",
      "  void _removeItem(int index) {",
      "    setState(() {",
      "      _items.removeAt(index);",
      "      _typeControllers.removeAt(index);",
      "      if (_expandedIndex == index) _expandedIndex = null;",
      "    });",
      "    widget.onChanged(_items);",
      "  }",
      "",
      "  bool _isInvalid(Map<String, dynamic> item) {",
      "    final mustHave = ['ingredientId', 'name', 'type'];",
      "    for (final key in mustHave) {",
      "      final val = item[key];",
      "      if (val == null || (val is String && val.trim().isEmpty)) {",
      "        return true;",
      "      }",
      "    }",
      "    return false;",
      "  }",
      "",
      "  dynamic _sanitizeValue(dynamic value) {",
      "    if (value is Map && value.containsKey('en')) {",
      "      return value['en'].toString();",
      "    } else if (value is Map) {",
      "      return jsonEncode(value);",
      "    } else if (value is List) {",
      "      return value.map(_sanitizeValue).toList();",
      "    } else {",
      "      return value?.toString() ?? '';",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        Row(",
      "          children: [",
      "            Text(",
      "              widget.title,",
      "              style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 16),",
      "            ),",
      "            const Spacer(),",
      "            IconButton(",
      "              icon: const Icon(Icons.add),",
      "              tooltip: \"Add item\",",
      "              onPressed: _addItem,",
      "            ),",
      "          ],",
      "        ),",
      "        const SizedBox(height: 6),",
      "        // The following column is safe: it does not cause scroll overflow.",
      "        Column(",
      "          children: List.generate(_items.length, (index) {",
      "            final item = _items[index];",
      "            final isInvalid = _isInvalid(item);",
      "            final isExpanded = index == _expandedIndex;",
      "            return Card(",
      "              margin: const EdgeInsets.only(bottom: 12),",
      "              shape: RoundedRectangleBorder(",
      "                side: isInvalid",
      "                    ? BorderSide(",
      "                        color: Colors.redAccent.withOpacity(0.6), width: 1.2)",
      "                    : BorderSide.none,",
      "                borderRadius: BorderRadius.circular(10),",
      "              ),",
      "              child: ExpansionTile(",
      "                key: Key('item_$index'),",
      "                initiallyExpanded: isExpanded,",
      "                onExpansionChanged: (val) {",
      "                  setState(() {",
      "                    _expandedIndex = val ? index : null;",
      "                  });",
      "                },",
      "                title: Text(",
      "                  item['name']?.toString().trim().isEmpty ?? true",
      "                      ? 'Unnamed ${widget.title.toLowerCase()}'",
      "                      : item['name'].toString(),",
      "                  style: const TextStyle(",
      "                      fontWeight: FontWeight.bold, fontSize: 16),",
      "                ),",
      "                trailing: IconButton(",
      "                  icon:",
      "                      const Icon(Icons.delete_forever, color: Colors.redAccent),",
      "                  tooltip: 'Remove',",
      "                  onPressed: () => _removeItem(index),",
      "                ),",
      "                children: [",
      "                  Padding(",
      "                    padding: const EdgeInsets.symmetric(",
      "                        horizontal: 16, vertical: 12),",
      "                    child: Column(",
      "                      children: [",
      "                        // Ingredient Name Dropdown/Autocomplete",
      "                        Padding(",
      "                          padding: const EdgeInsets.only(bottom: 8.0),",
      "                          child: Autocomplete<String>(",
      "                            initialValue:",
      "                                TextEditingValue(text: item['name'] ?? ''),",
      "                            optionsBuilder:",
      "                                (TextEditingValue textEditingValue) {",
      "                              if (textEditingValue.text == '') {",
      "                                return const Iterable<String>.empty();",
      "                              }",
      "                              return _ingredientMetadataList",
      "                                  .map((e) => e['name'].toString())",
      "                                  .where((option) => option",
      "                                      .toLowerCase()",
      "                                      .contains(",
      "                                          textEditingValue.text.toLowerCase()))",
      "                                  .toList();",
      "                            },",
      "                            onSelected: (String selected) {",
      "                              final found = _findIngredientByName(selected);",
      "                              setState(() {",
      "                                item['name'] = selected;",
      "                                if (found != null) {",
      "                                  item['ingredientId'] = found['id'];",
      "                                  item['type'] = found['type'];",
      "                                  item['typeLocked'] = true;",
      "                                  _typeControllers[index].text =",
      "                                      found['type'] ?? '';",
      "                                } else {",
      "                                  item['ingredientId'] = null;",
      "                                  item['type'] = '';",
      "                                  item['typeLocked'] = false;",
      "                                  _typeControllers[index].text = '';",
      "                                }",
      "                              });",
      "                              widget.onChanged(_items);",
      "                            },",
      "                            fieldViewBuilder: (context, controller, focusNode,",
      "                                onFieldSubmitted) {",
      "                              return TextFormField(",
      "                                controller: controller,",
      "                                focusNode: focusNode,",
      "                                decoration: const InputDecoration(",
      "                                    labelText: 'Ingredient Name'),",
      "                                onChanged: (val) {",
      "                                  final found = _findIngredientByName(val);",
      "                                  setState(() {",
      "                                    item['name'] = val;",
      "                                    if (found != null) {",
      "                                      item['ingredientId'] = found['id'];",
      "                                      item['type'] = found['type'];",
      "                                      item['typeLocked'] = true;",
      "                                      _typeControllers[index].text =",
      "                                          found['type'] ?? '';",
      "                                    } else {",
      "                                      item['ingredientId'] = null;",
      "                                      item['type'] = '';",
      "                                      item['typeLocked'] = false;",
      "                                      _typeControllers[index].text = '';",
      "                                    }",
      "                                  });",
      "                                  widget.onChanged(_items);",
      "                                },",
      "                              );",
      "                            },",
      "                          ),",
      "                        ),",
      "                        // Type Field (locked/unlocked)",
      "                        Padding(",
      "                          padding: const EdgeInsets.only(bottom: 8.0),",
      "                          child: TextFormField(",
      "                            enabled: !(item['typeLocked'] == true),",
      "                            controller: _typeControllers[index],",
      "                            decoration:",
      "                                const InputDecoration(labelText: 'Type'),",
      "                            onChanged: (val) {",
      "                              item['type'] = val;",
      "                              widget.onChanged(_items);",
      "                            },",
      "                          ),",
      "                        ),",
      "                        // Removable Checkbox (if present in template)",
      "                        if (widget.template.containsKey('removable'))",
      "                          Padding(",
      "                            padding: const EdgeInsets.only(bottom: 8.0),",
      "                            child: Row(",
      "                              children: [",
      "                                const Text(\"Removable\"),",
      "                                Checkbox(",
      "                                  value: item['removable'] ?? true,",
      "                                  onChanged: (val) {",
      "                                    setState(() {",
      "                                      item['removable'] = val ?? true;",
      "                                    });",
      "                                    widget.onChanged(_items);",
      "                                  },",
      "                                ),",
      "                              ],",
      "                            ),",
      "                          ),",
      "                      ],",
      "                    ),",
      "                  )",
      "                ],",
      "              ),",
      "            );",
      "          }),",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "",
      "  @override",
      "  void dispose() {",
      "    for (final c in _typeControllers) {",
      "      c.dispose();",
      "    }",
      "    super.dispose();",
      "  }",
      "",
      "  String _inferType(dynamic templateVal, dynamic realVal) {",
      "    final v = realVal ?? templateVal;",
      "    if (v is bool) return 'boolean';",
      "    if (v is num) return 'number';",
      "    if (v is List) return 'array';",
      "    if (v is Map) return 'map';",
      "    return 'string';",
      "  }",
      "",
      "  String _prettifyKey(String key) {",
      "    return key[0].toUpperCase() +",
      "        key",
      "            .substring(1)",
      "            .replaceAllMapped(RegExp(r'[A-Z]'), (m) => ' ${m.group(0)}');",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 320,
      "file_size": 12377,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\dynamic_form\\dynamic_field_input.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/widgets/dynamic_form/image_upload_field.dart';",
      "import 'package:franchise_admin_portal/widgets/dynamic_form/smart_dropdown_or_text_field.dart';",
      "import 'dart:convert';",
      "",
      "/// Universal dynamic input renderer for schema-driven forms.",
      "/// Handles all standard types: string, number, boolean, map (nutrition), array (not lists), image, dropdownOrText, etc.",
      "class DynamicFieldInput extends StatelessWidget {",
      "  final String fieldKey;",
      "  final Map<String, dynamic> config;",
      "  final dynamic value;",
      "  final String? errorText;",
      "  final ValueChanged<dynamic> onChanged;",
      "",
      "  const DynamicFieldInput({",
      "    super.key,",
      "    required this.fieldKey,",
      "    required this.config,",
      "    required this.value,",
      "    this.errorText,",
      "    required this.onChanged,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final type = config['type'] as String? ?? 'string';",
      "    final label = config['label'] is Map && config['label'].containsKey('en')",
      "        ? config['label']['en']",
      "        : config['label']?.toString() ?? fieldKey;",
      "    final hint = config['hint'] is Map && config['hint'].containsKey('en')",
      "        ? config['hint']['en']",
      "        : config['hint']?.toString() ?? '';",
      "    final inputMode = config['inputMode'] ?? '';",
      "    final requiredField = config['required'] == true;",
      "",
      "    // ✅ Normalize value for all input types",
      "    final dynamic sanitizedValue = value is String",
      "        ? value",
      "        : (value is Map && value.containsKey('en'))",
      "            ? value['en'].toString()",
      "            : (value is Map)",
      "                ? jsonEncode(value)",
      "                : value?.toString() ?? '';",
      "",
      "    Widget fieldWidget;",
      "",
      "    switch (type) {",
      "      case 'string':",
      "        if (inputMode == 'imageUrlOrUpload') {",
      "          fieldWidget = ImageUploadField(",
      "            label: label,",
      "            url: sanitizedValue,",
      "            onChanged: onChanged,",
      "          );",
      "        } else if (inputMode == 'dropdownOrText' ||",
      "            config['optionsSource'] != null) {",
      "          fieldWidget = SmartDropdownOrTextField(",
      "            fieldKey: fieldKey,",
      "            label: label,",
      "            value: sanitizedValue,",
      "            optionsSource: config['optionsSource'],",
      "            onChanged: onChanged,",
      "            hint: hint,",
      "            requiredField: requiredField,",
      "          );",
      "        } else {",
      "          fieldWidget = TextFormField(",
      "            initialValue: sanitizedValue,",
      "            decoration: InputDecoration(",
      "              labelText: label,",
      "              hintText: hint,",
      "              errorText: errorText,",
      "            ),",
      "            onChanged: onChanged,",
      "            validator: requiredField",
      "                ? (v) => (v == null || v.trim().isEmpty)",
      "                    ? '$label is required'",
      "                    : null",
      "                : null,",
      "          );",
      "        }",
      "        break;",
      "",
      "      case 'number':",
      "        fieldWidget = TextFormField(",
      "          initialValue: sanitizedValue,",
      "          decoration: InputDecoration(",
      "            labelText: label,",
      "            hintText: hint,",
      "            errorText: errorText,",
      "          ),",
      "          keyboardType: TextInputType.numberWithOptions(decimal: true),",
      "          onChanged: (v) => onChanged(num.tryParse(v) ?? 0),",
      "          validator: requiredField",
      "              ? (v) =>",
      "                  (v == null || v.trim().isEmpty) ? '$label is required' : null",
      "              : null,",
      "        );",
      "        break;",
      "",
      "      case 'boolean':",
      "        fieldWidget = SwitchListTile(",
      "          title: Text(label),",
      "          value: sanitizedValue == 'true' || sanitizedValue == true,",
      "          onChanged: onChanged,",
      "          activeColor: Theme.of(context).brightness == Brightness.dark",
      "              ? Colors.white",
      "              : Theme.of(context).colorScheme.primary,",
      "        );",
      "        break;",
      "",
      "      case 'array':",
      "        fieldWidget = const SizedBox.shrink(); // handled by higher widget",
      "        break;",
      "",
      "      case 'map':",
      "        if (fieldKey == 'nutrition') {",
      "          fieldWidget = _buildNutritionFields(context);",
      "        } else {",
      "          fieldWidget = TextFormField(",
      "            initialValue: sanitizedValue,",
      "            decoration: InputDecoration(",
      "              labelText: label,",
      "              hintText: hint,",
      "              errorText: errorText,",
      "            ),",
      "            onChanged: onChanged,",
      "          );",
      "        }",
      "        break;",
      "",
      "      default:",
      "        fieldWidget = TextFormField(",
      "          initialValue: sanitizedValue,",
      "          decoration: InputDecoration(",
      "            labelText: label,",
      "            hintText: hint,",
      "            errorText: errorText,",
      "          ),",
      "          onChanged: onChanged,",
      "        );",
      "    }",
      "",
      "    if (type != 'boolean' && (errorText ?? '').isNotEmpty) {",
      "      return Column(",
      "        crossAxisAlignment: CrossAxisAlignment.start,",
      "        children: [",
      "          fieldWidget,",
      "          Padding(",
      "            padding: const EdgeInsets.only(top: 4.0, left: 4.0),",
      "            child: Text(",
      "              errorText!,",
      "              style: TextStyle(color: Theme.of(context).colorScheme.error),",
      "            ),",
      "          )",
      "        ],",
      "      );",
      "    }",
      "",
      "    return fieldWidget;",
      "  }",
      "",
      "  Widget _buildNutritionFields(BuildContext context) {",
      "    final nutrition = value is Map<String, dynamic>",
      "        ? value",
      "        : {\"Calories\": 0, \"Carbs\": 0, \"Fat\": 0, \"Protein\": 0};",
      "",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        Text(",
      "          config['label'] is Map && config['label'].containsKey('en')",
      "              ? config['label']['en']",
      "              : config['label']?.toString() ?? \"Nutrition\",",
      "          style: const TextStyle(fontWeight: FontWeight.bold),",
      "        ),",
      "        const SizedBox(height: 6),",
      "        LayoutBuilder(",
      "          builder: (context, constraints) {",
      "            final spacing = constraints.maxWidth > 500 ? 10.0 : 6.0;",
      "            return Wrap(",
      "              spacing: spacing,",
      "              runSpacing: 8.0,",
      "              children: [",
      "                SizedBox(",
      "                  width: (constraints.maxWidth - spacing * 3) / 4,",
      "                  child: TextFormField(",
      "                    initialValue: (nutrition[\"Calories\"] ?? 0).toString(),",
      "                    decoration: const InputDecoration(labelText: \"Calories\"),",
      "                    keyboardType: TextInputType.number,",
      "                    onChanged: (v) => onChanged({",
      "                      ...nutrition,",
      "                      \"Calories\": int.tryParse(v) ?? 0,",
      "                    }),",
      "                  ),",
      "                ),",
      "                SizedBox(",
      "                  width: (constraints.maxWidth - spacing * 3) / 4,",
      "                  child: TextFormField(",
      "                    initialValue: (nutrition[\"Fat\"] ?? 0).toString(),",
      "                    decoration: const InputDecoration(labelText: \"Fat\"),",
      "                    keyboardType: TextInputType.number,",
      "                    onChanged: (v) => onChanged({",
      "                      ...nutrition,",
      "                      \"Fat\": double.tryParse(v) ?? 0.0,",
      "                    }),",
      "                  ),",
      "                ),",
      "                SizedBox(",
      "                  width: (constraints.maxWidth - spacing * 3) / 4,",
      "                  child: TextFormField(",
      "                    initialValue: (nutrition[\"Carbs\"] ?? 0).toString(),",
      "                    decoration: const InputDecoration(labelText: \"Carbs\"),",
      "                    keyboardType: TextInputType.number,",
      "                    onChanged: (v) => onChanged({",
      "                      ...nutrition,",
      "                      \"Carbs\": double.tryParse(v) ?? 0.0,",
      "                    }),",
      "                  ),",
      "                ),",
      "                SizedBox(",
      "                  width: (constraints.maxWidth - spacing * 3) / 4,",
      "                  child: TextFormField(",
      "                    initialValue: (nutrition[\"Protein\"] ?? 0).toString(),",
      "                    decoration: const InputDecoration(labelText: \"Protein\"),",
      "                    keyboardType: TextInputType.number,",
      "                    onChanged: (v) => onChanged({",
      "                      ...nutrition,",
      "                      \"Protein\": double.tryParse(v) ?? 0.0,",
      "                    }),",
      "                  ),",
      "                ),",
      "              ],",
      "            );",
      "          },",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 240,
      "file_size": 8384,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\dynamic_form\\dynamic_menu_item_form.dart",
    "content": [
      "import 'package:firebase_auth/firebase_auth.dart';",
      "import 'package:franchise_admin_portal/widgets/menu_item_validator.dart';",
      "import 'dart:convert';",
      "import 'package:franchise_admin_portal/core/models/customization.dart';",
      "import 'package:franchise_admin_portal/widgets/dynamic_form/smart_dropdown_or_text_field.dart';",
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/core/models/menu_item.dart';",
      "import 'package:franchise_admin_portal/core/models/nutrition_info.dart';",
      "import 'package:franchise_admin_portal/widgets/dynamic_form/dynamic_field_input.dart';",
      "import 'package:franchise_admin_portal/widgets/dynamic_form/dynamic_array_editor.dart';",
      "import 'package:franchise_admin_portal/widgets/dynamic_form/customization_group_editor.dart';",
      "import 'package:franchise_admin_portal/widgets/dynamic_form/image_upload_field.dart';",
      "",
      "class DynamicMenuItemForm extends StatefulWidget {",
      "  final Map<String, dynamic> schema;",
      "  final MenuItem? initialItem;",
      "  final void Function(MenuItem menuItem) onSave;",
      "  final VoidCallback? onCancel;",
      "  final String franchiseId;",
      "",
      "  const DynamicMenuItemForm({",
      "    super.key,",
      "    required this.schema,",
      "    this.initialItem,",
      "    required this.onSave,",
      "    this.onCancel,",
      "    required this.franchiseId,",
      "  });",
      "",
      "  @override",
      "  State<DynamicMenuItemForm> createState() => _DynamicMenuItemFormState();",
      "}",
      "",
      "class _DynamicMenuItemFormState extends State<DynamicMenuItemForm> {",
      "  final _formKey = GlobalKey<FormState>();",
      "  final Map<String, dynamic> _fieldValues = {};",
      "  final Map<String, String?> _fieldErrors = {};",
      "",
      "  List<Map<String, dynamic>> _includedIngredients = [];",
      "  List<Map<String, dynamic>> _optionalAddOns = [];",
      "  List<Map<String, dynamic>> _customizations = [];",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _initializeFromSchema();",
      "  }",
      "",
      "  void _initializeFromSchema() {",
      "    final initial = widget.initialItem?.toJson() ?? {};",
      "",
      "    // Only loop through scalar fields (schema['fields'])",
      "    final fields = widget.schema['fields'] as Map<String, dynamic>? ?? {};",
      "",
      "    for (final entry in fields.entries) {",
      "      final key = entry.key;",
      "      final fieldConfig = entry.value as Map<String, dynamic>;",
      "      final value = initial[key] ?? fieldConfig['default'];",
      "      _fieldValues[key] = _sanitizeValue(value);",
      "    }",
      "",
      "    // Handle includedIngredients (array of maps, not a scalar field)",
      "    if (initial['includedIngredients'] != null) {",
      "      _includedIngredients =",
      "          List<Map<String, dynamic>>.from(initial['includedIngredients']);",
      "    } else {",
      "      _includedIngredients = [];",
      "    }",
      "",
      "    // Handle optionalAddOns (array of maps, not a scalar field)",
      "    if (initial['optionalAddOns'] != null) {",
      "      _optionalAddOns =",
      "          List<Map<String, dynamic>>.from(initial['optionalAddOns']);",
      "    } else {",
      "      _optionalAddOns = [];",
      "    }",
      "",
      "    // Handle customizations (array of maps, not a scalar field)",
      "    if (initial['customizations'] != null) {",
      "      _customizations =",
      "          List<Map<String, dynamic>>.from(initial['customizations']);",
      "    } else {",
      "      _customizations = [];",
      "    }",
      "  }",
      "",
      "  dynamic _sanitizeValue(dynamic value) {",
      "    if (value is Map && value.containsKey('en')) {",
      "      return value['en'].toString();",
      "    } else if (value is Map<String, dynamic>) {",
      "      return value.map((k, v) => MapEntry(k, _sanitizeValue(v)));",
      "    } else if (value is List) {",
      "      return value.map((v) => _sanitizeValue(v)).toList();",
      "    } else {",
      "      return value;",
      "    }",
      "  }",
      "",
      "  void _onSavePressed() {",
      "    final isValid = _formKey.currentState?.validate() ?? false;",
      "    if (!isValid) {",
      "      print('[DEBUG] Form invalid. Aborting save.');",
      "      return;",
      "    }",
      "",
      "    // Set categoryId to match category slug (not item name)",
      "    if (_fieldValues.containsKey('category')) {",
      "      _fieldValues['categoryId'] = (_fieldValues['category'] as String)",
      "          .trim()",
      "          .toLowerCase()",
      "          .replaceAll(' ', '_');",
      "    }",
      "",
      "    // Set required fields",
      "    _fieldValues['available'] = true;",
      "    _fieldValues['schemaVersion'] = 1;",
      "    _fieldValues['image'] ??= '';",
      "",
      "    // Ensure base price is a number for customer UI",
      "    if (_fieldValues.containsKey('sizePrices')) {",
      "      final sizePrices = _fieldValues['sizePrices'] as Map<String, dynamic>;",
      "      if (sizePrices.isNotEmpty) {",
      "        _fieldValues['price'] = sizePrices.entries.first.value;",
      "      }",
      "    }",
      "",
      "    final item = MenuItem.fromMap({",
      "      ..._fieldValues,",
      "      'includedIngredients': _includedIngredients,",
      "      'optionalAddOns': _optionalAddOns,",
      "      'customizations': _customizations,",
      "    });",
      "",
      "    // Calculate extra sauce charges if applicable",
      "    final saucesGroup = _customizations.firstWhere(",
      "      (g) =>",
      "          (g['label'] is Map ? g['label']['en'] : g['label'])",
      "              ?.toString()",
      "              .toLowerCase() ==",
      "          'sauces',",
      "      orElse: () => {},",
      "    );",
      "",
      "    final maxFree = _fieldValues['maxFreeSauces'] ?? 0;",
      "    final upchargeRate =",
      "        double.tryParse('${_fieldValues['extraSauceUpcharge'] ?? 0}') ?? 0;",
      "    final selectedSauceCount =",
      "        (saucesGroup['ingredientIds'] as List?)?.length ?? 0;",
      "    final extraCount =",
      "        selectedSauceCount > maxFree ? selectedSauceCount - maxFree : 0;",
      "",
      "    item.extraCharges = {",
      "      'sauceUpcharge': extraCount * upchargeRate,",
      "    };",
      "",
      "    print('[DEBUG] Final MenuItem for submission: ${item.toJson()}');",
      "    widget.onSave(item);",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final fields = widget.schema['fields'] as Map<String, dynamic>? ?? {};",
      "    final sortedFields = fields.entries",
      "        .where((entry) => entry.key != 'categoryId')",
      "        .toList()",
      "      ..sort((a, b) => a.key.compareTo(b.key));",
      "",
      "    return Form(",
      "      key: _formKey,",
      "      child: Column(",
      "        crossAxisAlignment: CrossAxisAlignment.stretch,",
      "        children: [",
      "          ...sortedFields.map((entry) {",
      "            final key = entry.key;",
      "            final config = entry.value as Map<String, dynamic>;",
      "            final value = _fieldValues[key];",
      "            final error = _fieldErrors[key];",
      "",
      "            return Padding(",
      "              padding: const EdgeInsets.only(bottom: 12),",
      "              child: DynamicFieldInput(",
      "                fieldKey: key,",
      "                config: config,",
      "                value: value,",
      "                errorText: error,",
      "                onChanged: (val) {",
      "                  setState(() => _fieldValues[key] = val);",
      "                },",
      "              ),",
      "            );",
      "          }),",
      "          const Divider(thickness: 1.2),",
      "          DynamicArrayEditor(",
      "            title: 'Included Ingredients',",
      "            arrayKey: 'includedIngredients',",
      "            items: _includedIngredients,",
      "            template: widget.schema['includedIngredientsTemplate'] ?? {},",
      "            onChanged: (updated) =>",
      "                setState(() => _includedIngredients = updated),",
      "            franchiseId: widget.franchiseId,",
      "          ),",
      "          const SizedBox(height: 16),",
      "          DynamicArrayEditor(",
      "            title: 'Optional Add-Ons',",
      "            arrayKey: 'optionalAddOns',",
      "            items: _optionalAddOns,",
      "            template: widget.schema['optionalAddOnsTemplate'] ?? {},",
      "            onChanged: (updated) => setState(() => _optionalAddOns = updated),",
      "            franchiseId: widget.franchiseId,",
      "          ),",
      "          const SizedBox(height: 16),",
      "          CustomizationGroupEditor(",
      "            customizations: _customizations,",
      "            onChanged: (updated) => setState(() => _customizations = updated),",
      "            franchiseId: widget.franchiseId,",
      "          ),",
      "          const SizedBox(height: 24),",
      "          Row(",
      "            mainAxisAlignment: MainAxisAlignment.spaceBetween,",
      "            children: [",
      "              if (widget.onCancel != null)",
      "                TextButton(",
      "                  style: TextButton.styleFrom(",
      "                    foregroundColor:",
      "                        Theme.of(context).brightness == Brightness.dark",
      "                            ? Colors.white",
      "                            : Theme.of(context).colorScheme.primary,",
      "                  ),",
      "                  onPressed: widget.onCancel,",
      "                  child: Text('Cancel'),",
      "                ),",
      "              ElevatedButton(",
      "                style: ElevatedButton.styleFrom(",
      "                  backgroundColor:",
      "                      Theme.of(context).brightness == Brightness.dark",
      "                          ? Colors.white",
      "                          : Theme.of(context).colorScheme.primary,",
      "                  foregroundColor:",
      "                      Theme.of(context).brightness == Brightness.dark",
      "                          ? Colors.black",
      "                          : Theme.of(context).colorScheme.onPrimary,",
      "                ),",
      "                onPressed: _onSavePressed,",
      "                child: Text(",
      "                  'Save',",
      "                  style: TextStyle(",
      "                    color: Theme.of(context).brightness == Brightness.dark",
      "                        ? Colors.black",
      "                        : Theme.of(context).colorScheme.onPrimary,",
      "                  ),",
      "                ),",
      "              ),",
      "            ],",
      "          )",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 259,
      "file_size": 9309,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\dynamic_form\\image_upload_field.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:image_picker/image_picker.dart';",
      "import 'package:franchise_admin_portal/config/branding_config.dart';",
      "",
      "/// Renders an image upload or URL field combo.",
      "/// Used for admin editing of item preview image.",
      "class ImageUploadField extends StatefulWidget {",
      "  final String label;",
      "  final String? url;",
      "  final ValueChanged<String> onChanged;",
      "",
      "  const ImageUploadField({",
      "    super.key,",
      "    required this.label,",
      "    this.url,",
      "    required this.onChanged,",
      "  });",
      "",
      "  @override",
      "  State<ImageUploadField> createState() => _ImageUploadFieldState();",
      "}",
      "",
      "class _ImageUploadFieldState extends State<ImageUploadField> {",
      "  final TextEditingController _urlController = TextEditingController();",
      "  final ImagePicker _picker = ImagePicker();",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _urlController.text = widget.url ?? '';",
      "  }",
      "",
      "  @override",
      "  void dispose() {",
      "    _urlController.dispose();",
      "    super.dispose();",
      "  }",
      "",
      "  Future<void> _pickImage() async {",
      "    final picked = await _picker.pickImage(source: ImageSource.gallery);",
      "    if (picked != null) {",
      "      // In production: upload to storage & obtain secure URL",
      "      // For now: just simulate with file path",
      "      final simulatedUrl = picked.path;",
      "      _urlController.text = simulatedUrl;",
      "      widget.onChanged(simulatedUrl);",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final imageUrl = _urlController.text.trim();",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        Text(widget.label,",
      "            style: Theme.of(context)",
      "                .textTheme",
      "                .titleSmall",
      "                ?.copyWith(fontWeight: FontWeight.w600)),",
      "        const SizedBox(height: 6),",
      "        Row(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            if (imageUrl.isNotEmpty)",
      "              Padding(",
      "                padding: const EdgeInsets.only(right: 12),",
      "                child: Image.network(",
      "                  imageUrl,",
      "                  width: 70,",
      "                  height: 70,",
      "                  fit: BoxFit.cover,",
      "                  errorBuilder: (_, __, ___) => Image.asset(",
      "                    BrandingConfig.defaultCategoryIcon,",
      "                    width: 70,",
      "                    height: 70,",
      "                    fit: BoxFit.cover,",
      "                    errorBuilder: (_, __, ___) =>",
      "                        const Icon(Icons.broken_image, size: 40),",
      "                  ),",
      "                ),",
      "              ),",
      "            Expanded(",
      "              child: TextFormField(",
      "                controller: _urlController,",
      "                decoration: const InputDecoration(",
      "                  labelText: 'Image URL',",
      "                  hintText: 'Paste image URL or upload...',",
      "                ),",
      "                onChanged: widget.onChanged,",
      "              ),",
      "            ),",
      "            IconButton(",
      "              icon: const Icon(Icons.upload),",
      "              tooltip: 'Upload Image',",
      "              onPressed: _pickImage,",
      "            ),",
      "          ],",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 103,
      "file_size": 3164,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\dynamic_form\\smart_dropdown_or_text_field.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "",
      "class SmartDropdownOrTextField extends StatefulWidget {",
      "  final String label;",
      "  final dynamic value;",
      "  final String? optionsSource; // e.g., 'categories', 'ingredient_metadata'",
      "  final String? hint;",
      "  final bool requiredField;",
      "  final ValueChanged<String?> onChanged;",
      "  final String? fieldKey;",
      "",
      "  const SmartDropdownOrTextField({",
      "    super.key,",
      "    required this.label,",
      "    required this.value,",
      "    required this.onChanged,",
      "    this.optionsSource,",
      "    this.hint,",
      "    this.requiredField = false,",
      "    this.fieldKey,",
      "  });",
      "",
      "  @override",
      "  State<SmartDropdownOrTextField> createState() =>",
      "      _SmartDropdownOrTextFieldState();",
      "}",
      "",
      "class _SmartDropdownOrTextFieldState extends State<SmartDropdownOrTextField> {",
      "  final TextEditingController _controller = TextEditingController();",
      "  final LayerLink _layerLink = LayerLink();",
      "",
      "  OverlayEntry? _overlayEntry;",
      "  List<String> _allOptions = [];",
      "  List<String> _filteredOptions = [];",
      "  bool _loading = false;",
      "  bool _dropdownOpen = false;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    final initial = _normalizeValue(widget.value);",
      "    _controller.text = initial;",
      "    _controller.addListener(_onTextChanged);",
      "    _loadOptions();",
      "  }",
      "",
      "  @override",
      "  void dispose() {",
      "    _removeOverlay();",
      "    _controller.dispose();",
      "    super.dispose();",
      "  }",
      "",
      "  String _normalizeValue(dynamic value) {",
      "    if (value == null) return '';",
      "    if (value is String) return value;",
      "    if (value is Map && value.containsKey('en')) return value['en'].toString();",
      "    return value.toString();",
      "  }",
      "",
      "  void _onTextChanged() {",
      "    final input = _controller.text;",
      "    widget.onChanged(input.trim().isEmpty ? null : input.trim());",
      "",
      "    if (!_dropdownOpen || !mounted) return;",
      "",
      "    setState(() {",
      "      _filteredOptions = _allOptions",
      "          .where((o) => o.toLowerCase().contains(input.toLowerCase()))",
      "          .toList();",
      "    });",
      "",
      "    _updateOverlay();",
      "  }",
      "",
      "  Future<void> _loadOptions() async {",
      "    if (widget.optionsSource == null || !mounted) return;",
      "",
      "    setState(() => _loading = true);",
      "",
      "    try {",
      "      final snap = await FirebaseFirestore.instance",
      "          .collection(widget.optionsSource!)",
      "          .get();",
      "",
      "      final set = <String>{};",
      "      for (var doc in snap.docs) {",
      "        final data = doc.data();",
      "        final candidate = widget.fieldKey == 'type'",
      "            ? data['type']?.toString()",
      "            : data['name']?.toString() ?? doc.id;",
      "",
      "        if (candidate != null && candidate.trim().isNotEmpty) {",
      "          set.add(candidate.trim());",
      "        }",
      "      }",
      "",
      "      _allOptions = set.toList()..sort();",
      "      _filteredOptions = List.from(_allOptions);",
      "    } finally {",
      "      if (mounted) setState(() => _loading = false);",
      "    }",
      "  }",
      "",
      "  void _toggleDropdown() {",
      "    if (_dropdownOpen) {",
      "      _removeOverlay();",
      "    } else {",
      "      _filteredOptions = _allOptions",
      "          .where(",
      "              (o) => o.toLowerCase().contains(_controller.text.toLowerCase()))",
      "          .toList();",
      "      _showOverlay();",
      "    }",
      "  }",
      "",
      "  void _selectOption(String option) {",
      "    _controller.text = option;",
      "    widget.onChanged(option);",
      "    _removeOverlay();",
      "  }",
      "",
      "  void _showOverlay() {",
      "    _overlayEntry = _buildOverlayEntry();",
      "    if (!mounted) return;",
      "    Overlay.of(context).insert(_overlayEntry!);",
      "    _dropdownOpen = true;",
      "  }",
      "",
      "  void _removeOverlay() {",
      "    _overlayEntry?.remove();",
      "    _overlayEntry = null;",
      "    _dropdownOpen = false;",
      "  }",
      "",
      "  void _updateOverlay() {",
      "    if (!mounted) return;",
      "    WidgetsBinding.instance.addPostFrameCallback((_) {",
      "      _overlayEntry?.markNeedsBuild();",
      "    });",
      "  }",
      "",
      "  OverlayEntry _buildOverlayEntry() {",
      "    final renderBox = context.findRenderObject() as RenderBox;",
      "    final size = renderBox.size;",
      "",
      "    return OverlayEntry(",
      "      builder: (context) => Positioned(",
      "        width: size.width,",
      "        child: CompositedTransformFollower(",
      "          link: _layerLink,",
      "          showWhenUnlinked: false,",
      "          offset: Offset(0.0, size.height + 4),",
      "          child: Material(",
      "            elevation: 6,",
      "            borderRadius: BorderRadius.circular(6),",
      "            child: ConstrainedBox(",
      "              constraints: const BoxConstraints(maxHeight: 240),",
      "              child: ListView.builder(",
      "                padding: EdgeInsets.zero,",
      "                shrinkWrap: true,",
      "                itemCount: _filteredOptions.length,",
      "                itemBuilder: (context, index) {",
      "                  final option = _filteredOptions[index];",
      "                  return ListTile(",
      "                    dense: true,",
      "                    visualDensity: VisualDensity.compact,",
      "                    title: Text(option),",
      "                    onTap: () => _selectOption(option),",
      "                  );",
      "                },",
      "              ),",
      "            ),",
      "          ),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return CompositedTransformTarget(",
      "      link: _layerLink,",
      "      child: GestureDetector(",
      "        onTap: _removeOverlay,",
      "        behavior: HitTestBehavior.translucent,",
      "        child: TextFormField(",
      "          controller: _controller,",
      "          decoration: InputDecoration(",
      "            labelText: widget.label,",
      "            hintText: widget.hint,",
      "            errorText: widget.requiredField && _controller.text.trim().isEmpty",
      "                ? '${widget.label} is required'",
      "                : null,",
      "            suffixIcon: _loading",
      "                ? const Padding(",
      "                    padding: EdgeInsets.all(12),",
      "                    child: SizedBox(",
      "                      width: 18,",
      "                      height: 18,",
      "                      child: CircularProgressIndicator(strokeWidth: 2),",
      "                    ),",
      "                  )",
      "                : IconButton(",
      "                    icon: Icon(",
      "                      _dropdownOpen",
      "                          ? Icons.arrow_drop_up",
      "                          : Icons.arrow_drop_down,",
      "                    ),",
      "                    onPressed: _toggleDropdown,",
      "                  ),",
      "          ),",
      "          onTap: _removeOverlay,",
      "          onFieldSubmitted: (_) => _removeOverlay(),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 220,
      "file_size": 6336,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\feedback\\feedback_detail_dialog.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:intl/intl.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/models/feedback_entry.dart'",
      "    as model;",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "",
      "class FeedbackDetailDialog extends StatelessWidget {",
      "  final model.FeedbackEntry feedback;",
      "",
      "  const FeedbackDetailDialog({super.key, required this.feedback});",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context)!;",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    final isOrderFeedback = feedback.feedbackMode == 'orderExperience';",
      "",
      "    return AlertDialog(",
      "      title: Row(",
      "        children: [",
      "          Icon(",
      "            isOrderFeedback ? Icons.fastfood : Icons.app_settings_alt,",
      "            color: isOrderFeedback",
      "                ? DesignTokens.primaryColor",
      "                : DesignTokens.secondaryColor,",
      "            size: 28,",
      "          ),",
      "          const SizedBox(width: 8),",
      "          Expanded(",
      "            child: Text(",
      "              isOrderFeedback ? loc.filterOrderFeedback : loc.filterAppFeedback,",
      "              style: TextStyle(",
      "                fontWeight: FontWeight.bold,",
      "                color: colorScheme.onSurface,",
      "              ),",
      "            ),",
      "          ),",
      "          Row(",
      "            children: List.generate(",
      "              5,",
      "              (idx) => Icon(",
      "                idx < feedback.rating ? Icons.star : Icons.star_border,",
      "                color:",
      "                    idx < feedback.rating ? Colors.amber : Colors.grey.shade400,",
      "                size: 18,",
      "              ),",
      "            ),",
      "          ),",
      "        ],",
      "      ),",
      "      content: SingleChildScrollView(",
      "        child: Column(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            if (feedback.orderId.isNotEmpty)",
      "              Text(",
      "                '${loc.orderIdLabel}: ${feedback.orderId}',",
      "                style: TextStyle(color: colorScheme.onSurface),",
      "              ),",
      "            if (feedback.anonymous)",
      "              Padding(",
      "                padding: const EdgeInsets.only(top: 6),",
      "                child: Text(",
      "                  loc.feedbackAnonymous,",
      "                  style: TextStyle(color: colorScheme.outline),",
      "                ),",
      "              ),",
      "            if (feedback.categories.isNotEmpty)",
      "              Padding(",
      "                padding: const EdgeInsets.only(top: 8.0),",
      "                child: Column(",
      "                  crossAxisAlignment: CrossAxisAlignment.start,",
      "                  children: feedback.categories.map((catScore) {",
      "                    final parts = catScore.split(':');",
      "                    return Padding(",
      "                      padding: const EdgeInsets.only(bottom: 4),",
      "                      child: Chip(",
      "                        label: Text(",
      "                          parts.length > 1",
      "                              ? '${parts[0].trim()}: ${parts[1].trim()}'",
      "                              : catScore,",
      "                          style: const TextStyle(fontSize: 13),",
      "                        ),",
      "                        backgroundColor: DesignTokens.surfaceColor,",
      "                        side: BorderSide.none,",
      "                        visualDensity: VisualDensity.compact,",
      "                      ),",
      "                    );",
      "                  }).toList(),",
      "                ),",
      "              ),",
      "            Padding(",
      "              padding: const EdgeInsets.symmetric(vertical: 8),",
      "              child: Text(",
      "                feedback.comment?.isNotEmpty == true",
      "                    ? feedback.comment!",
      "                    : (feedback.message.isNotEmpty",
      "                        ? feedback.message",
      "                        : loc.noMessage),",
      "                style: TextStyle(",
      "                  fontSize: 15,",
      "                  color: colorScheme.onSurface,",
      "                ),",
      "              ),",
      "            ),",
      "            Text(",
      "              '${loc.submitted}: ${DateFormat('yyyy-MM-dd – HH:mm').format(feedback.timestamp)}',",
      "              style: TextStyle(fontSize: 12, color: colorScheme.outline),",
      "            ),",
      "            if (feedback.userId.isNotEmpty && !feedback.anonymous)",
      "              Padding(",
      "                padding: const EdgeInsets.only(top: 6),",
      "                child: Text(",
      "                  'User: ${feedback.userId}',",
      "                  style: TextStyle(fontSize: 12, color: colorScheme.outline),",
      "                ),",
      "              ),",
      "          ],",
      "        ),",
      "      ),",
      "      actions: [",
      "        TextButton(",
      "          onPressed: () => Navigator.of(context).pop(),",
      "          child: Text(loc.close),",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 130,
      "file_size": 4739,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\financials\\cash_flow_forecast_card.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/config/branding_config.dart';",
      "import 'package:franchise_admin_portal/widgets/dashboard/dashboard_section_card.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/models/cash_flow_forecast.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "import 'package:franchise_admin_portal/widgets/loading_shimmer_widget.dart';",
      "",
      "class CashFlowForecastCard extends StatefulWidget {",
      "  final String franchiseId;",
      "  final String? brandId;",
      "",
      "  const CashFlowForecastCard({",
      "    Key? key,",
      "    required this.franchiseId,",
      "    this.brandId,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  State<CashFlowForecastCard> createState() => _CashFlowForecastCardState();",
      "}",
      "",
      "class _CashFlowForecastCardState extends State<CashFlowForecastCard> {",
      "  late Future<CashFlowForecast?> _forecastFuture;",
      "  late ColorScheme _colors;",
      "  bool _isDeveloper = false;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _forecastFuture = _loadForecast();",
      "    _checkRole();",
      "  }",
      "",
      "  void _checkRole() {",
      "    final user = context.read<AdminUserProvider>().user;",
      "    final roles = user?.roles ?? [];",
      "    setState(() {",
      "      _isDeveloper = roles.contains('developer') ||",
      "          roles.contains('hq_owner') ||",
      "          roles.contains('finance_manager');",
      "    });",
      "  }",
      "",
      "  Future<CashFlowForecast?> _loadForecast() async {",
      "    try {",
      "      final firestoreService =",
      "          Provider.of<FirestoreService>(context, listen: false);",
      "      // Replace with your Firestore structure for forecast data:",
      "      final doc =",
      "          await firestoreService.getCashFlowForecast(widget.franchiseId);",
      "      print('Loaded cash flow forecast: $doc');",
      "      print(\"CashFlowForecastCard franchiseId: ${widget.franchiseId}\");",
      "      if (doc == null) return null;",
      "      // Use period as the id if available, or \"\" if not present:",
      "      return CashFlowForecast.fromFirestore(doc, doc['period'] ?? '');",
      "    } catch (e, st) {",
      "      final firestoreService =",
      "          Provider.of<FirestoreService>(context, listen: false);",
      "      await ErrorLogger.log(",
      "        message: 'Failed to load cash flow forecast: $e',",
      "        source: 'CashFlowForecastCard',",
      "        screen: 'CashFlowForecastCard',",
      "        stack: st.toString(),",
      "        severity: 'error',",
      "        contextData: {",
      "          'franchiseId': widget.franchiseId,",
      "        },",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    print('[CashFlowForecastCard] build called');",
      "    _colors = Theme.of(context).colorScheme;",
      "    final localizations = AppLocalizations.of(context);",
      "",
      "    if (!_isDeveloper) return const SizedBox.shrink();",
      "",
      "    return DashboardSectionCard(",
      "      title: localizations?.featureComingSoonCashFlow ?? 'Cash Flow Forecast',",
      "      icon: Icons.trending_up_rounded,",
      "      franchiseId: widget.franchiseId,",
      "      brandId: widget.brandId,",
      "      developerOnly: true,",
      "      showFuturePlaceholders: false,",
      "      builder: (context) {",
      "        return FutureBuilder<CashFlowForecast?>(",
      "          future: _forecastFuture,",
      "          builder: (context, snapshot) {",
      "            if (snapshot.connectionState == ConnectionState.waiting) {",
      "              return const LoadingShimmerWidget();",
      "            }",
      "",
      "            if (snapshot.hasError) {",
      "              return _ErrorCard(",
      "                message: localizations?.errorLoadingKpi ??",
      "                    'Failed to load forecast.',",
      "                onRetry: () => setState(() {",
      "                  _forecastFuture = _loadForecast();",
      "                }),",
      "              );",
      "            }",
      "",
      "            final forecast = snapshot.data;",
      "            if (forecast == null) {",
      "              // If no forecast, show placeholder/future feature card.",
      "              return _FeaturePlaceholder(",
      "                label: localizations?.featureComingSoonCashFlow ??",
      "                    'Cash Flow Forecast (coming soon)',",
      "              );",
      "            }",
      "",
      "            final brandColor = BrandingConfig.brandRed;",
      "",
      "            return Column(",
      "              crossAxisAlignment: CrossAxisAlignment.stretch,",
      "              children: [",
      "                _ForecastRow(",
      "                  localizations: localizations,",
      "                  forecast: forecast,",
      "                  brandColor: brandColor,",
      "                ),",
      "                const SizedBox(height: 8),",
      "                _FeaturePlaceholder(",
      "                  label: localizations?.featureComingSoonRevenueTrends ??",
      "                      'Per-Location Revenue Trends (coming soon)',",
      "                ),",
      "                if (_isDeveloper &&",
      "                    Theme.of(context).brightness == Brightness.dark)",
      "                  Padding(",
      "                    padding: const EdgeInsets.only(top: 8.0),",
      "                    child: Text(",
      "                      'Debug: FranchiseId=${widget.franchiseId}, BrandId=${widget.brandId}',",
      "                      style: Theme.of(context)",
      "                          .textTheme",
      "                          .labelSmall",
      "                          ?.copyWith(color: _colors.outline),",
      "                    ),",
      "                  ),",
      "              ],",
      "            );",
      "          },",
      "        );",
      "      },",
      "    );",
      "  }",
      "}",
      "",
      "class _ForecastRow extends StatelessWidget {",
      "  final AppLocalizations? localizations;",
      "  final CashFlowForecast forecast;",
      "  final Color brandColor;",
      "",
      "  const _ForecastRow({",
      "    required this.localizations,",
      "    required this.forecast,",
      "    required this.brandColor,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final _colors = Theme.of(context).colorScheme;",
      "    final currency = 'USD'; // Replace with dynamic if needed",
      "",
      "    Widget _forecastTile(",
      "      IconData icon,",
      "      String label,",
      "      double value, {",
      "      Color? color,",
      "      String? tooltip,",
      "    }) {",
      "      return Tooltip(",
      "        message: tooltip ?? label,",
      "        child: Column(",
      "          mainAxisAlignment: MainAxisAlignment.center,",
      "          children: [",
      "            Icon(icon, size: 32, color: color ?? _colors.primary),",
      "            const SizedBox(height: 6),",
      "            Text(",
      "              label,",
      "              style: Theme.of(context).textTheme.labelSmall?.copyWith(",
      "                    color: _colors.onSurface.withOpacity(0.6),",
      "                  ),",
      "            ),",
      "            const SizedBox(height: 2),",
      "            Text(",
      "              value.toStringAsFixed(2),",
      "              style: Theme.of(context).textTheme.titleLarge?.copyWith(",
      "                    color: color ?? _colors.primary,",
      "                    fontWeight: FontWeight.bold,",
      "                  ),",
      "            ),",
      "          ],",
      "        ),",
      "      );",
      "    }",
      "",
      "    return Row(",
      "      mainAxisAlignment: MainAxisAlignment.spaceBetween,",
      "      children: [",
      "        _forecastTile(",
      "          Icons.account_balance_wallet_outlined,",
      "          localizations?.openingBalance ?? 'Opening Balance',",
      "          forecast.openingBalance,",
      "          color: _colors.primary,",
      "        ),",
      "        _forecastTile(",
      "          Icons.trending_up,",
      "          localizations?.projectedInflow ?? 'Projected Inflow',",
      "          forecast.projectedInflow,",
      "          color: Colors.green,",
      "        ),",
      "        _forecastTile(",
      "          Icons.trending_down,",
      "          localizations?.projectedOutflow ?? 'Projected Outflow',",
      "          forecast.projectedOutflow,",
      "          color: Colors.redAccent,",
      "        ),",
      "        _forecastTile(",
      "          Icons.attach_money,",
      "          localizations?.projectedClosing ?? 'Projected Closing',",
      "          forecast.projectedClosingBalance,",
      "          color: brandColor,",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}",
      "",
      "class _ErrorCard extends StatelessWidget {",
      "  final String message;",
      "  final VoidCallback onRetry;",
      "",
      "  const _ErrorCard({required this.message, required this.onRetry});",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Card(",
      "      color: Theme.of(context).colorScheme.errorContainer,",
      "      child: Padding(",
      "        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),",
      "        child: Row(",
      "          children: [",
      "            const Icon(Icons.error_outline, color: Colors.redAccent),",
      "            const SizedBox(width: 12),",
      "            Expanded(",
      "              child: Text(",
      "                message,",
      "                style: Theme.of(context).textTheme.bodyMedium?.copyWith(",
      "                      color: Theme.of(context).colorScheme.onErrorContainer,",
      "                    ),",
      "              ),",
      "            ),",
      "            TextButton.icon(",
      "              onPressed: onRetry,",
      "              icon: const Icon(Icons.refresh),",
      "              label: Text(AppLocalizations.of(context)?.retry ?? 'Retry'),",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "class _FeaturePlaceholder extends StatelessWidget {",
      "  final String label;",
      "  const _FeaturePlaceholder({required this.label});",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Container(",
      "      margin: const EdgeInsets.only(top: 8),",
      "      padding: const EdgeInsets.all(12),",
      "      decoration: BoxDecoration(",
      "        border: Border.all(",
      "          color: Theme.of(context).colorScheme.outline.withOpacity(0.2),",
      "        ),",
      "        borderRadius: BorderRadius.circular(DesignTokens.radiusLg),",
      "      ),",
      "      child: Row(",
      "        children: [",
      "          const Icon(Icons.lightbulb_outline, size: 20, color: Colors.amber),",
      "          const SizedBox(width: 8),",
      "          Expanded(",
      "            child: Text(",
      "              label,",
      "              style: Theme.of(context).textTheme.bodySmall?.copyWith(",
      "                    fontStyle: FontStyle.italic,",
      "                  ),",
      "            ),",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 304,
      "file_size": 10056,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\financials\\dashboard_stat_card.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "",
      "class DashboardStatCard<T extends num> extends StatelessWidget {",
      "  final String label;",
      "  final IconData icon;",
      "  final Future<T> Function() getValue;",
      "  final Color? color;",
      "  final String? tooltip;",
      "  final String? semanticLabel;",
      "  final String Function(T value)? formatter;",
      "",
      "  const DashboardStatCard({",
      "    Key? key,",
      "    required this.label,",
      "    required this.icon,",
      "    required this.getValue,",
      "    this.color,",
      "    this.tooltip,",
      "    this.semanticLabel,",
      "    this.formatter,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final cardColor = color ?? Theme.of(context).colorScheme.primary;",
      "    final background = Theme.of(context).cardColor;",
      "",
      "    return Semantics(",
      "      label: semanticLabel ?? label,",
      "      container: true,",
      "      child: Tooltip(",
      "        message: tooltip ?? label,",
      "        child: Card(",
      "          elevation: 3,",
      "          margin: const EdgeInsets.all(8),",
      "          shape: RoundedRectangleBorder(",
      "            borderRadius: BorderRadius.circular(16),",
      "          ),",
      "          child: Padding(",
      "            padding: const EdgeInsets.all(20),",
      "            child: FutureBuilder<T>(",
      "              future: getValue(),",
      "              builder: (context, snapshot) {",
      "                if (snapshot.connectionState == ConnectionState.waiting) {",
      "                  // Loading State",
      "                  return Column(",
      "                    mainAxisSize: MainAxisSize.min,",
      "                    mainAxisAlignment: MainAxisAlignment.center,",
      "                    children: [",
      "                      CircularProgressIndicator(",
      "                        valueColor: AlwaysStoppedAnimation<Color>(cardColor),",
      "                      ),",
      "                      const SizedBox(height: 14),",
      "                      Container(",
      "                        height: 18,",
      "                        width: 60,",
      "                        decoration: BoxDecoration(",
      "                          color: background.withOpacity(0.2),",
      "                          borderRadius: BorderRadius.circular(8),",
      "                        ),",
      "                      ),",
      "                      const SizedBox(height: 12),",
      "                      Container(",
      "                        height: 10,",
      "                        width: 80,",
      "                        decoration: BoxDecoration(",
      "                          color: background.withOpacity(0.16),",
      "                          borderRadius: BorderRadius.circular(6),",
      "                        ),",
      "                      ),",
      "                    ],",
      "                  );",
      "                }",
      "                if (snapshot.hasError) {",
      "                  // Error State",
      "                  return Column(",
      "                    mainAxisSize: MainAxisSize.min,",
      "                    mainAxisAlignment: MainAxisAlignment.center,",
      "                    children: [",
      "                      Icon(Icons.error,",
      "                          color: Theme.of(context).colorScheme.error, size: 32),",
      "                      const SizedBox(height: 8),",
      "                      Text(",
      "                        'Error',",
      "                        style: TextStyle(",
      "                          fontWeight: FontWeight.bold,",
      "                          color: Theme.of(context).colorScheme.error,",
      "                        ),",
      "                      ),",
      "                      const SizedBox(height: 4),",
      "                      Flexible(",
      "                        child: FittedBox(",
      "                          fit: BoxFit.scaleDown,",
      "                          child: Text(",
      "                            snapshot.error.toString(),",
      "                            style: TextStyle(",
      "                              fontSize: 12,",
      "                              color: Theme.of(context).colorScheme.error,",
      "                            ),",
      "                            textAlign: TextAlign.center,",
      "                            overflow: TextOverflow.ellipsis,",
      "                            maxLines: 2,",
      "                          ),",
      "                        ),",
      "                      ),",
      "                    ],",
      "                  );",
      "                }",
      "                final value = (snapshot.data ?? (T == int ? 0 : 0.0)) as T;",
      "                final display =",
      "                    formatter != null ? formatter!(value) : value.toString();",
      "",
      "                return Column(",
      "                  mainAxisAlignment: MainAxisAlignment.center,",
      "                  mainAxisSize: MainAxisSize.min,",
      "                  children: [",
      "                    Container(",
      "                      decoration: BoxDecoration(",
      "                        color: cardColor.withOpacity(0.12),",
      "                        borderRadius: BorderRadius.circular(10),",
      "                      ),",
      "                      padding: const EdgeInsets.all(10),",
      "                      child: Icon(",
      "                        icon,",
      "                        color: cardColor,",
      "                        size: 36,",
      "                        semanticLabel: semanticLabel ?? label,",
      "                      ),",
      "                    ),",
      "                    const SizedBox(height: 14),",
      "                    Flexible(",
      "                      child: FittedBox(",
      "                        fit: BoxFit.scaleDown,",
      "                        child: Text(",
      "                          display,",
      "                          style: TextStyle(",
      "                            fontSize: 32,",
      "                            fontWeight: FontWeight.bold,",
      "                            color: cardColor,",
      "                          ),",
      "                          semanticsLabel: display,",
      "                        ),",
      "                      ),",
      "                    ),",
      "                    const SizedBox(height: 6),",
      "                    Flexible(",
      "                      child: FittedBox(",
      "                        fit: BoxFit.scaleDown,",
      "                        child: Text(",
      "                          label,",
      "                          style: Theme.of(context)",
      "                              .textTheme",
      "                              .bodyMedium",
      "                              ?.copyWith(",
      "                                color: Theme.of(context).colorScheme.onSurface,",
      "                              ),",
      "                          textAlign: TextAlign.center,",
      "                        ),",
      "                      ),",
      "                    ),",
      "                  ],",
      "                );",
      "              },",
      "            ),",
      "          ),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 170,
      "file_size": 6401,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\financials\\franchisee_invitation_service.dart",
    "content": [
      "// File: lib/core/services/franchisee_invitation_service.dart",
      "",
      "import 'package:cloud_functions/cloud_functions.dart';",
      "import 'package:cloud_firestore/cloud_firestore.dart';",
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/core/models/franchisee_invitation.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class FranchiseeInvitationService {",
      "  final FirestoreService firestoreService;",
      "",
      "  FranchiseeInvitationService({required this.firestoreService});",
      "",
      "  /// Stream invitations (optionally filter by status/inviter)",
      "  Stream<List<FranchiseeInvitation>> invitationsStream({",
      "    String? status,",
      "    String? inviterUserId,",
      "  }) {",
      "    return firestoreService.invitationStream(",
      "      status: status,",
      "      inviterUserId: inviterUserId,",
      "    );",
      "  }",
      "",
      "  /// Fetch all invitations (optionally filter)",
      "  Future<List<FranchiseeInvitation>> fetchInvitations({",
      "    String? status,",
      "    String? inviterUserId,",
      "    String? email,",
      "  }) async {",
      "    try {",
      "      return await firestoreService.fetchInvitations(",
      "        status: status,",
      "        inviterUserId: inviterUserId,",
      "        email: email,",
      "      );",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to fetch invitations',",
      "        stack: stack.toString(),",
      "        source: 'FranchiseeInvitationService.fetchInvitations',",
      "        screen: 'FranchiseeInvitation',",
      "        contextData: {'exception': e.toString()},",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Fetch invitation by Firestore doc ID",
      "  Future<FranchiseeInvitation?> fetchInvitationById(String id) async {",
      "    try {",
      "      return await firestoreService.fetchInvitationById(id);",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to fetch invitation by ID',",
      "        stack: stack.toString(),",
      "        source: 'FranchiseeInvitationService.fetchInvitationById',",
      "        screen: 'FranchiseeInvitation',",
      "        contextData: {'id': id, 'exception': e.toString()},",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Invite a new franchisee via Cloud Function (inviteAndSetRole)",
      "  /// Throws on error.",
      "  Future<void> inviteFranchisee({",
      "    required String email,",
      "    required String role,",
      "    required String inviterUserId,",
      "    String? franchiseName,",
      "    String? password, // may be required by backend if user does not exist",
      "    Map<String, dynamic>? extraData, // For future extensibility",
      "  }) async {",
      "    try {",
      "      final HttpsCallable callable = FirebaseFunctions.instance.httpsCallable(",
      "        'inviteAndSetRole',",
      "      );",
      "      final Map<String, dynamic> data = {",
      "        'email': email,",
      "        'role': role,",
      "        if (password != null) 'password': password,",
      "        if (franchiseName != null) 'franchiseName': franchiseName,",
      "        if (extraData != null) ...extraData,",
      "      };",
      "      final result = await callable.call(data);",
      "      if (result.data?['status'] != 'ok') {",
      "        throw Exception('Invite failed: ${result.data}');",
      "      }",
      "      // Firestore record will be created by function (backend-of-truth)",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to invite franchisee via Cloud Function',",
      "        stack: stack.toString(),",
      "        source: 'FranchiseeInvitationService.inviteFranchisee',",
      "        screen: 'FranchiseeInvitation',",
      "        contextData: {",
      "          'email': email,",
      "          'role': role,",
      "          'exception': e.toString(),",
      "        },",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Update invitation metadata (admin usage)",
      "  Future<void> updateInvitation(String id, Map<String, dynamic> data) async {",
      "    try {",
      "      await firestoreService.updateInvitation(id, data);",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to update invitation',",
      "        stack: stack.toString(),",
      "        source: 'FranchiseeInvitationService.updateInvitation',",
      "        screen: 'FranchiseeInvitation',",
      "        contextData: {'id': id, 'data': data, 'exception': e.toString()},",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Cancel/revoke an invitation (soft-cancel, not hard delete)",
      "  Future<void> cancelInvitation(String id, {String? revokedByUserId}) async {",
      "    try {",
      "      await firestoreService.cancelInvitation(id,",
      "          revokedByUserId: revokedByUserId);",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to cancel invitation',",
      "        stack: stack.toString(),",
      "        source: 'FranchiseeInvitationService.cancelInvitation',",
      "        screen: 'FranchiseeInvitation',",
      "        contextData: {",
      "          'id': id,",
      "          'revokedBy': revokedByUserId,",
      "          'exception': e.toString()",
      "        },",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Delete an invitation (permanent)",
      "  Future<void> deleteInvitation(String id) async {",
      "    try {",
      "      await firestoreService.deleteInvitation(id);",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to delete invitation',",
      "        stack: stack.toString(),",
      "        source: 'FranchiseeInvitationService.deleteInvitation',",
      "        screen: 'FranchiseeInvitation',",
      "        contextData: {'id': id, 'exception': e.toString()},",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Expire invitation (for auto-expiry, admin, or time-based cleanup)",
      "  Future<void> expireInvitation(String id) async {",
      "    try {",
      "      await firestoreService.expireInvitation(id);",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to expire invitation',",
      "        stack: stack.toString(),",
      "        source: 'FranchiseeInvitationService.expireInvitation',",
      "        screen: 'FranchiseeInvitation',",
      "        contextData: {'id': id, 'exception': e.toString()},",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  /// Mark as re-sent (record metadata only, actual invite handled by cloud function)",
      "  Future<void> markInvitationResent(String id) async {",
      "    try {",
      "      await firestoreService.markInvitationResent(id);",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: 'Failed to mark invitation as re-sent',",
      "        stack: stack.toString(),",
      "        source: 'FranchiseeInvitationService.markInvitationResent',",
      "        screen: 'FranchiseeInvitation',",
      "        contextData: {'id': id, 'exception': e.toString()},",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  // === Developer Only: Debug Util ===",
      "  @visibleForTesting",
      "  Future<List<FranchiseeInvitation>> debugFetchAllInvitationsRaw() async {",
      "    return await firestoreService.fetchInvitations();",
      "  }",
      "",
      "  // === Future Feature Placeholders ===",
      "",
      "  /// Bulk invite (not yet implemented)",
      "  Future<void> bulkInviteFranchisees(",
      "      List<Map<String, dynamic>> inviteDataList) async {",
      "    throw UnimplementedError('Bulk invitation is a planned feature.');",
      "  }",
      "",
      "  /// Export invitations (not yet implemented)",
      "  Future<void> exportInvitations() async {",
      "    throw UnimplementedError('Export invitations is a planned feature.');",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 211,
      "file_size": 7071,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\financials\\franchisee_invoice_list.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/models/platform_invoice.dart';",
      "import 'package:franchise_admin_portal/widgets/financials/franchisee_invoice_tile.dart';",
      "import 'package:franchise_admin_portal/widgets/admin/admin_empty_state_widget.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/config/branding_config.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class FranchiseeInvoiceList extends StatelessWidget {",
      "  final List<PlatformInvoice> invoices;",
      "  final String? brandId;",
      "",
      "  const FranchiseeInvoiceList({",
      "    super.key,",
      "    required this.invoices,",
      "    this.brandId,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      ErrorLogger.log(",
      "        message: 'Localization context is null',",
      "        source: 'FranchiseeInvoiceList',",
      "        screen: 'franchisee_invoice_list.dart',",
      "        severity: 'warning',",
      "      );",
      "      return const SizedBox.shrink();",
      "    }",
      "",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    final brandColor = brandId != null",
      "        ? BrandingConfig.brandColorFor(brandId!)",
      "        : BrandingConfig.brandRed;",
      "",
      "    debugPrint('[FranchiseeInvoiceList] Received ${invoices.length} invoices');",
      "    for (var inv in invoices) {",
      "      debugPrint(",
      "        '[FranchiseeInvoiceList] Invoice: id=${inv.id}, amount=${inv.amount ?? inv.amount}, status=${inv.status}, dueDate=${inv.dueDate}',",
      "      );",
      "    }",
      "",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        Text(",
      "          loc.platformInvoices,",
      "          style: Theme.of(context).textTheme.titleMedium?.copyWith(",
      "                fontWeight: FontWeight.bold,",
      "                color: brandColor,",
      "              ),",
      "        ),",
      "        const SizedBox(height: DesignTokens.paddingMd),",
      "        if (invoices.isEmpty)",
      "          AdminEmptyStateWidget(",
      "            title: loc.platformInvoices,",
      "            message: loc.noBillingRecords,",
      "            actionLabel: loc.tryAgain,",
      "            onAction: () {",
      "              ErrorLogger.log(",
      "                message: 'User triggered retry on empty invoice list',",
      "                source: 'FranchiseeInvoiceList',",
      "                screen: 'franchisee_invoice_list.dart',",
      "                severity: 'info',",
      "              );",
      "            },",
      "          )",
      "        else",
      "          ListView.separated(",
      "            itemCount: invoices.length,",
      "            shrinkWrap: true,",
      "            physics: const NeverScrollableScrollPhysics(),",
      "            separatorBuilder: (_, __) =>",
      "                const SizedBox(height: DesignTokens.adminCardSpacing),",
      "            itemBuilder: (context, index) {",
      "              final invoice = invoices[index];",
      "              debugPrint(",
      "                '[FranchiseeInvoiceList] Rendering tile for invoice ${invoice.id} - ${invoice.status}',",
      "              );",
      "              return FranchiseeInvoiceTile(invoice: invoice);",
      "            },",
      "          ),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 88,
      "file_size": 3193,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\financials\\franchisee_invoice_tile.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/models/platform_invoice.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/config/app_config.dart';",
      "import 'package:franchise_admin_portal/widgets/financials/pay_invoice_dialog.dart';",
      "import 'package:franchise_admin_portal/core/constants/invoice_status.dart';",
      "",
      "class FranchiseeInvoiceTile extends StatelessWidget {",
      "  final PlatformInvoice invoice;",
      "  final AppConfig config;",
      "",
      "  FranchiseeInvoiceTile({",
      "    Key? key,",
      "    required this.invoice,",
      "    AppConfig? config,",
      "  })  : config = config ?? AppConfig.instance,",
      "        super(key: key);",
      "",
      "  InvoiceStatus parseInvoiceStatus(String value) {",
      "    return InvoiceStatus.values.firstWhere(",
      "      (s) => s.name == value,",
      "      orElse: () => InvoiceStatus.unpaid,",
      "    );",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context)!;",
      "    final color = Theme.of(context).colorScheme;",
      "",
      "    return Card(",
      "      margin: const EdgeInsets.symmetric(vertical: 8, horizontal: 4),",
      "      elevation: 2,",
      "      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),",
      "      child: InkWell(",
      "        onTap: () async {",
      "          try {",
      "            await showDialog(",
      "              context: context,",
      "              builder: (_) => PayInvoiceDialog(invoice: invoice),",
      "            );",
      "          } catch (e, stack) {",
      "            await ErrorLogger.log(",
      "              message: e.toString(),",
      "              stack: stack.toString(),",
      "              source: 'FranchiseeInvoiceTile',",
      "              screen: 'InvoiceTile',",
      "              severity: 'error',",
      "              contextData: {'invoiceId': invoice.id},",
      "            );",
      "          }",
      "        },",
      "        borderRadius: BorderRadius.circular(12),",
      "        child: Padding(",
      "          padding: const EdgeInsets.all(DesignTokens.paddingMd),",
      "          child: Row(",
      "            mainAxisAlignment: MainAxisAlignment.spaceBetween,",
      "            children: [",
      "              _buildInvoiceInfo(loc, color),",
      "              _buildAmountSection(loc, color),",
      "            ],",
      "          ),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  Widget _buildInvoiceInfo(AppLocalizations loc, ColorScheme color) {",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        Text(",
      "          '${loc.invoiceNumber}: ${invoice.invoiceNumber}',",
      "          style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 16),",
      "        ),",
      "        const SizedBox(height: 4),",
      "        Text(",
      "          '${loc.dueDate}: ${_formatDate(invoice.dueDate)}',",
      "          style: TextStyle(color: color.onSurfaceVariant, fontSize: 13),",
      "        ),",
      "        const SizedBox(height: 4),",
      "        _buildStatusChip(parseInvoiceStatus(invoice.status), loc),",
      "      ],",
      "    );",
      "  }",
      "",
      "  Widget _buildAmountSection(AppLocalizations loc, ColorScheme color) {",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.end,",
      "      children: [",
      "        Text(",
      "          '${invoice.amount.toStringAsFixed(2)} ${invoice.currency}',",
      "          style: TextStyle(",
      "            fontWeight: FontWeight.bold,",
      "            fontSize: 16,",
      "            color: color.primary,",
      "          ),",
      "        ),",
      "        if (parseInvoiceStatus(invoice.status) != InvoiceStatus.paid)",
      "          TextButton(",
      "            onPressed: null, // Actual logic handled onTap of the card",
      "            child: Text(loc.payNow),",
      "          ),",
      "      ],",
      "    );",
      "  }",
      "",
      "  Widget _buildStatusChip(InvoiceStatus status, AppLocalizations loc) {",
      "    final label = _localizedStatus(status, loc);",
      "    final color = _statusColor(status);",
      "",
      "    return Chip(",
      "      label: Text(label, style: const TextStyle(color: Colors.white)),",
      "      backgroundColor: color,",
      "    );",
      "  }",
      "",
      "  String _localizedStatus(InvoiceStatus status, AppLocalizations loc) {",
      "    switch (status) {",
      "      case InvoiceStatus.paid:",
      "        return loc.statusPaid;",
      "      case InvoiceStatus.overdue:",
      "        return loc.statusOverdue;",
      "      case InvoiceStatus.sent:",
      "        return loc.statusSent;",
      "      case InvoiceStatus.draft:",
      "        return loc.statusDraft;",
      "      case InvoiceStatus.refunded:",
      "        return loc.statusRefunded;",
      "      case InvoiceStatus.voided:",
      "        return loc.statusVoided;",
      "      case InvoiceStatus.failed:",
      "        return loc.statusFailed;",
      "      case InvoiceStatus.unpaid:",
      "        return loc.statusUnpaid;",
      "      case InvoiceStatus.partial:",
      "        return loc.statusPartial;",
      "    }",
      "  }",
      "",
      "  Color _statusColor(InvoiceStatus status) {",
      "    switch (status) {",
      "      case InvoiceStatus.paid:",
      "        return Colors.green;",
      "      case InvoiceStatus.overdue:",
      "        return Colors.red;",
      "      case InvoiceStatus.sent:",
      "        return Colors.blue;",
      "      case InvoiceStatus.draft:",
      "        return Colors.grey;",
      "      case InvoiceStatus.refunded:",
      "        return Colors.orange;",
      "      case InvoiceStatus.failed:",
      "      case InvoiceStatus.voided:",
      "        return Colors.black45;",
      "      case InvoiceStatus.unpaid:",
      "        return Colors.orangeAccent;",
      "      case InvoiceStatus.partial:",
      "        return Colors.amber;",
      "    }",
      "  }",
      "",
      "  String _formatDate(DateTime? date) {",
      "    if (date == null) return '-';",
      "    final local = date.toLocal();",
      "    return '${local.month}/${local.day}/${local.year}';",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 171,
      "file_size": 5572,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\financials\\franchisee_payment_list.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/models/platform_payment.dart';",
      "import 'package:franchise_admin_portal/widgets/financials/franchisee_payment_tile.dart';",
      "",
      "class FranchiseePaymentList extends StatelessWidget {",
      "  final List<PlatformPayment> payments;",
      "",
      "  const FranchiseePaymentList({",
      "    super.key,",
      "    required this.payments,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    debugPrint(",
      "        '[FranchiseePaymentList] Received payments: ${payments.map((p) => \"${p.id}:${p.amount} ${p.currency}\").toList()}');",
      "",
      "    final loc = AppLocalizations.of(context)!;",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        Text(",
      "          loc.platformPayments,",
      "          style: theme.textTheme.titleMedium?.copyWith(",
      "            color: colorScheme.primary,",
      "            fontWeight: FontWeight.bold,",
      "          ),",
      "        ),",
      "        const SizedBox(height: 12),",
      "        if (payments.isEmpty)",
      "          Padding(",
      "            padding: const EdgeInsets.symmetric(vertical: 20),",
      "            child: Text(",
      "              loc.noBillingRecords,",
      "              style: theme.textTheme.bodyMedium?.copyWith(",
      "                color: colorScheme.onSurface.withOpacity(0.6),",
      "              ),",
      "            ),",
      "          )",
      "        else",
      "          ListView.separated(",
      "            shrinkWrap: true,",
      "            physics: const NeverScrollableScrollPhysics(),",
      "            itemCount: payments.length,",
      "            separatorBuilder: (_, __) => const Divider(height: 16),",
      "            itemBuilder: (context, index) {",
      "              final payment = payments[index];",
      "              debugPrint(",
      "                  '[FranchiseePaymentList] Rendering tile for payment ${payment.id} (${payment.amount} ${payment.currency})');",
      "",
      "              return FranchiseePaymentTile(payment: payment);",
      "            },",
      "          ),",
      "        const SizedBox(height: 12),",
      "        Text(",
      "          '[${loc.featureComingSoon(\"Filters / Search\")}]',",
      "          style: theme.textTheme.labelMedium?.copyWith(",
      "            color: colorScheme.outline,",
      "          ),",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 68,
      "file_size": 2330,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\financials\\franchisee_payment_tile.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/models/platform_payment.dart';",
      "import 'package:intl/intl.dart';",
      "",
      "class FranchiseePaymentTile extends StatelessWidget {",
      "  final PlatformPayment payment;",
      "",
      "  const FranchiseePaymentTile({",
      "    Key? key,",
      "    required this.payment,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context)!;",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "",
      "    final date =",
      "        payment.executedAt ?? payment.scheduledFor ?? payment.createdAt;",
      "    final formattedDate = date != null ? DateFormat.yMMMd().format(date) : '-';",
      "",
      "    final methodIcon = _buildMethodIcon(payment.paymentMethod);",
      "    final statusColor = _statusColor(payment.status, colorScheme);",
      "    final isRecurring = payment.type == 'recurring';",
      "    final isSplit = payment.type == 'split';",
      "",
      "    return Card(",
      "      margin: const EdgeInsets.symmetric(vertical: 6, horizontal: 0),",
      "      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),",
      "      elevation: 1,",
      "      child: Padding(",
      "        padding: const EdgeInsets.all(DesignTokens.paddingMd),",
      "        child: Row(",
      "          children: [",
      "            CircleAvatar(",
      "              backgroundColor: colorScheme.surfaceVariant,",
      "              radius: 20,",
      "              child: methodIcon,",
      "            ),",
      "            const SizedBox(width: 12),",
      "            Expanded(",
      "              child: Column(",
      "                crossAxisAlignment: CrossAxisAlignment.start,",
      "                children: [",
      "                  Text(",
      "                    '${payment.amount.toStringAsFixed(2)} ${payment.currency}',",
      "                    style: theme.textTheme.titleMedium",
      "                        ?.copyWith(fontWeight: FontWeight.bold),",
      "                  ),",
      "                  const SizedBox(height: 4),",
      "                  Text(",
      "                    '${loc.paymentMethod}: ${payment.paymentMethod}',",
      "                    style: theme.textTheme.bodySmall",
      "                        ?.copyWith(color: colorScheme.onSurfaceVariant),",
      "                  ),",
      "                  if (isRecurring || isSplit)",
      "                    Padding(",
      "                      padding: const EdgeInsets.only(top: 2),",
      "                      child: Row(",
      "                        children: [",
      "                          if (isRecurring)",
      "                            _buildChip(loc.recurringRule, Icons.loop,",
      "                                colorScheme.secondary),",
      "                          if (isSplit)",
      "                            _buildChip(loc.splitPayment, Icons.call_split,",
      "                                colorScheme.tertiary),",
      "                        ],",
      "                      ),",
      "                    ),",
      "                ],",
      "              ),",
      "            ),",
      "            Column(",
      "              crossAxisAlignment: CrossAxisAlignment.end,",
      "              children: [",
      "                Chip(",
      "                  label: Text(payment.status,",
      "                      style: const TextStyle(color: Colors.white)),",
      "                  backgroundColor: statusColor,",
      "                  labelPadding: const EdgeInsets.symmetric(horizontal: 10),",
      "                ),",
      "                const SizedBox(height: 4),",
      "                Text(",
      "                  formattedDate,",
      "                  style: theme.textTheme.bodySmall",
      "                      ?.copyWith(color: colorScheme.outline),",
      "                ),",
      "              ],",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  Widget _buildMethodIcon(String method) {",
      "    final icon = switch (method.toLowerCase()) {",
      "      'paypal' => Icons.account_balance_wallet,",
      "      'credit_card' || 'debit_card' => Icons.credit_card,",
      "      'check' => Icons.receipt_long,",
      "      'ach' => Icons.swap_horiz,",
      "      _ => Icons.payment,",
      "    };",
      "",
      "    return Icon(icon, size: 20);",
      "  }",
      "",
      "  Color _statusColor(String status, ColorScheme scheme) {",
      "    switch (status.toLowerCase()) {",
      "      case 'pending':",
      "        return scheme.secondary;",
      "      case 'completed':",
      "        return Colors.green;",
      "      case 'failed':",
      "      case 'error':",
      "        return scheme.error;",
      "      default:",
      "        return scheme.outline;",
      "    }",
      "  }",
      "",
      "  Widget _buildChip(String? label, IconData icon, Color color) {",
      "    if (label == null) return const SizedBox.shrink();",
      "",
      "    return Container(",
      "      margin: const EdgeInsets.only(right: 6),",
      "      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),",
      "      decoration: BoxDecoration(",
      "        color: color.withOpacity(0.1),",
      "        borderRadius: BorderRadius.circular(12),",
      "      ),",
      "      child: Row(",
      "        mainAxisSize: MainAxisSize.min,",
      "        children: [",
      "          Icon(icon, size: 14, color: color),",
      "          const SizedBox(width: 4),",
      "          Text(",
      "            label,",
      "            style: TextStyle(fontSize: 12, color: color),",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 148,
      "file_size": 5094,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\financials\\franchise_financial_kpi_card.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/config/branding_config.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/widgets/dashboard/dashboard_section_card.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/formatting.dart'",
      "    as formatting;",
      "import 'package:franchise_admin_portal/widgets/loading_shimmer_widget.dart';",
      "",
      "class FranchiseFinancialKpiCard extends StatefulWidget {",
      "  final String franchiseId;",
      "  final String? brandId;",
      "",
      "  const FranchiseFinancialKpiCard({",
      "    Key? key,",
      "    required this.franchiseId,",
      "    this.brandId,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  State<FranchiseFinancialKpiCard> createState() =>",
      "      _FranchiseFinancialKpiCardState();",
      "}",
      "",
      "class _FranchiseFinancialKpiCardState extends State<FranchiseFinancialKpiCard> {",
      "  late Future<Map<String, dynamic>> _kpiFuture;",
      "  late ColorScheme _colors;",
      "  bool _isDeveloper = false;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _kpiFuture = _loadKpis();",
      "    _checkRole();",
      "  }",
      "",
      "  void _checkRole() {",
      "    final user = context.read<AdminUserProvider>().user;",
      "    final roles = user?.roles ?? [];",
      "    setState(() {",
      "      _isDeveloper = roles.contains('developer') ||",
      "          roles.contains('hq_owner') ||",
      "          roles.contains('finance_manager');",
      "    });",
      "  }",
      "",
      "  Future<Map<String, dynamic>> _loadKpis() async {",
      "    try {",
      "      final firestoreService =",
      "          Provider.of<FirestoreService>(context, listen: false);",
      "",
      "      final analytics = await firestoreService",
      "          .getFranchiseAnalyticsSummary(widget.franchiseId);",
      "      final outstanding =",
      "          await firestoreService.getOutstandingInvoices(widget.franchiseId);",
      "      final lastPayout =",
      "          await firestoreService.getLastPayout(widget.franchiseId);",
      "",
      "      return {",
      "        'analytics': analytics,",
      "        'outstanding': outstanding,",
      "        'lastPayout': lastPayout,",
      "      };",
      "    } catch (e, st) {",
      "      final firestoreService =",
      "          Provider.of<FirestoreService>(context, listen: false);",
      "      ErrorLogger.log(",
      "        message: 'Failed to load KPIs: $e',",
      "        source: 'FranchiseFinancialKpiCard',",
      "        screen: 'FranchiseFinancialKpiCard',",
      "        stack: st.toString(),",
      "        severity: 'error',",
      "        contextData: {",
      "          'franchiseId': widget.franchiseId,",
      "        },",
      "      );",
      "      rethrow;",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    print('[FranchiseFinancialKpiCard] build called');",
      "    _colors = Theme.of(context).colorScheme;",
      "    final localizations = AppLocalizations.of(context);",
      "",
      "    if (!_isDeveloper) return const SizedBox.shrink();",
      "",
      "    return DashboardSectionCard(",
      "      title: localizations?.kpiFinancials ?? 'Financial KPIs',",
      "      icon: Icons.analytics_outlined,",
      "      franchiseId: widget.franchiseId,",
      "      brandId: widget.brandId,",
      "      developerOnly: true,",
      "      showFuturePlaceholders: false,",
      "      builder: (context) {",
      "        return FutureBuilder<Map<String, dynamic>>(",
      "          future: _kpiFuture,",
      "          builder: (context, snapshot) {",
      "            if (snapshot.connectionState == ConnectionState.waiting) {",
      "              return const LoadingShimmerWidget();",
      "            }",
      "",
      "            Widget cardContent;",
      "",
      "            if (snapshot.hasError) {",
      "              cardContent = Card(",
      "                color: Theme.of(context).colorScheme.errorContainer,",
      "                shape: RoundedRectangleBorder(",
      "                  borderRadius: BorderRadius.circular(DesignTokens.radiusLg),",
      "                ),",
      "                child: Padding(",
      "                  padding: const EdgeInsets.all(DesignTokens.paddingMd),",
      "                  child: Row(",
      "                    children: [",
      "                      const Icon(Icons.error_outline, color: Colors.redAccent),",
      "                      const SizedBox(width: 12),",
      "                      Expanded(",
      "                        child: Text(",
      "                          localizations?.errorLoadingKpi ??",
      "                              'Failed to load KPIs.',",
      "                          style:",
      "                              Theme.of(context).textTheme.bodyMedium?.copyWith(",
      "                                    color: DesignTokens.textColor,",
      "                                  ),",
      "                        ),",
      "                      ),",
      "                      TextButton.icon(",
      "                        onPressed: () => setState(() {",
      "                          _kpiFuture = _loadKpis();",
      "                        }),",
      "                        icon: const Icon(Icons.refresh),",
      "                        label: Text(localizations?.retry ?? 'Retry'),",
      "                      ),",
      "                    ],",
      "                  ),",
      "                ),",
      "              );",
      "            } else {",
      "              final analytics =",
      "                  snapshot.data?['analytics'] as Map<String, dynamic>? ?? {};",
      "              final outstanding = snapshot.data?['outstanding'] ?? 0.0;",
      "              final lastPayout =",
      "                  snapshot.data?['lastPayout'] as Map<String, dynamic>? ?? {};",
      "",
      "              cardContent = Column(",
      "                crossAxisAlignment: CrossAxisAlignment.stretch,",
      "                children: [",
      "                  _KpiRow(",
      "                    localizations: localizations,",
      "                    analytics: analytics,",
      "                    outstanding: outstanding,",
      "                    lastPayout: lastPayout,",
      "                  ),",
      "                  const SizedBox(height: 8),",
      "                  if (_isDeveloper &&",
      "                      Theme.of(context).brightness == Brightness.dark)",
      "                    Padding(",
      "                      padding: const EdgeInsets.only(top: 8.0),",
      "                      child: Text(",
      "                        'Debug: FranchiseId=${widget.franchiseId}, BrandId=${widget.brandId}',",
      "                        style: Theme.of(context)",
      "                            .textTheme",
      "                            .labelSmall",
      "                            ?.copyWith(color: _colors.outline),",
      "                      ),",
      "                    ),",
      "                ],",
      "              );",
      "            }",
      "",
      "            // --------- THIS IS THE KEY FIX ---------",
      "            return LayoutBuilder(",
      "              builder: (context, constraints) {",
      "                // If the card is being rendered in a small fixed height (GridView/SizedBox), force scroll",
      "                if (constraints.maxHeight < 320) {",
      "                  // 320 is a reasonable height for all content to fit; adjust as needed",
      "                  return SingleChildScrollView(",
      "                    child: ConstrainedBox(",
      "                      constraints:",
      "                          BoxConstraints(minHeight: constraints.maxHeight),",
      "                      child: cardContent,",
      "                    ),",
      "                  );",
      "                } else {",
      "                  // Allow content to expand naturally if there is space",
      "                  return cardContent;",
      "                }",
      "              },",
      "            );",
      "            // ---------------------------------------",
      "          },",
      "        );",
      "      },",
      "    );",
      "  }",
      "}",
      "",
      "class _KpiRow extends StatelessWidget {",
      "  final AppLocalizations? localizations;",
      "  final Map<String, dynamic> analytics;",
      "  final double outstanding;",
      "  final Map<String, dynamic> lastPayout;",
      "",
      "  const _KpiRow({",
      "    required this.localizations,",
      "    required this.analytics,",
      "    required this.outstanding,",
      "    required this.lastPayout,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final _colors = Theme.of(context).colorScheme;",
      "    final currency = analytics['currency'] ?? 'USD';",
      "",
      "    Widget _kpiTile(",
      "      IconData icon,",
      "      String label,",
      "      dynamic value, {",
      "      Color? color,",
      "      String? tooltip,",
      "    }) {",
      "      return Tooltip(",
      "        message: tooltip ?? label,",
      "        child: Column(",
      "          mainAxisAlignment: MainAxisAlignment.center,",
      "          children: [",
      "            Icon(icon, size: 32, color: color ?? _colors.primary),",
      "            const SizedBox(height: 6),",
      "            Text(",
      "              label,",
      "              style: Theme.of(context).textTheme.labelSmall?.copyWith(",
      "                    color: _colors.onSurface.withOpacity(0.6),",
      "                  ),",
      "            ),",
      "            const SizedBox(height: 2),",
      "            Text(",
      "              value is num",
      "                  ? formatting.formatCurrency(value, currency)",
      "                  : (value?.toString() ?? '--'),",
      "              style: Theme.of(context).textTheme.titleLarge?.copyWith(",
      "                    color: color ?? _colors.primary,",
      "                    fontWeight: FontWeight.bold,",
      "                  ),",
      "            ),",
      "          ],",
      "        ),",
      "      );",
      "    }",
      "",
      "    return Row(",
      "      mainAxisAlignment: MainAxisAlignment.spaceBetween,",
      "      children: [",
      "        _kpiTile(",
      "          Icons.attach_money,",
      "          localizations?.kpiRevenue ?? 'Revenue',",
      "          analytics['totalRevenue'] ?? 0,",
      "          color: _colors.primary,",
      "        ),",
      "        _kpiTile(",
      "          Icons.receipt_long_outlined,",
      "          localizations?.kpiOutstanding ?? 'Outstanding',",
      "          outstanding,",
      "          color: Colors.redAccent,",
      "        ),",
      "        _kpiTile(",
      "          Icons.payments_outlined,",
      "          localizations?.kpiLastPayout ?? 'Last Payout',",
      "          lastPayout['amount'] ?? '--',",
      "          color: Colors.green,",
      "          tooltip: lastPayout['date'] != null",
      "              ? '${localizations?.kpiPayoutDate ?? 'Date'}: ${lastPayout['date']}'",
      "              : null,",
      "        ),",
      "        _kpiTile(",
      "          Icons.trending_up_outlined,",
      "          localizations?.kpiAvgOrder ?? 'Avg. Order',",
      "          analytics['averageOrderValue'] ?? '--',",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}",
      "",
      "class _ErrorCard extends StatelessWidget {",
      "  final String message;",
      "  final VoidCallback onRetry;",
      "",
      "  const _ErrorCard({required this.message, required this.onRetry});",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Card(",
      "      color: Theme.of(context).colorScheme.errorContainer,",
      "      child: Padding(",
      "        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),",
      "        child: Row(",
      "          children: [",
      "            const Icon(Icons.error_outline, color: Colors.redAccent),",
      "            const SizedBox(width: 12),",
      "            Expanded(",
      "              child: Text(",
      "                message,",
      "                style: Theme.of(context).textTheme.bodyMedium?.copyWith(",
      "                      color: Theme.of(context).colorScheme.onErrorContainer,",
      "                    ),",
      "              ),",
      "            ),",
      "            TextButton.icon(",
      "              onPressed: onRetry,",
      "              icon: const Icon(Icons.refresh),",
      "              label: Text(AppLocalizations.of(context)?.retry ?? 'Retry'),",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "class _FeaturePlaceholder extends StatelessWidget {",
      "  final String label;",
      "  const _FeaturePlaceholder({required this.label});",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Container(",
      "      margin: const EdgeInsets.only(top: 8),",
      "      padding: const EdgeInsets.all(12),",
      "      decoration: BoxDecoration(",
      "        border: Border.all(",
      "          color: Theme.of(context).colorScheme.outline.withOpacity(0.2),",
      "        ),",
      "        borderRadius: BorderRadius.circular(DesignTokens.radiusLg),",
      "      ),",
      "      child: Row(",
      "        children: [",
      "          const Icon(Icons.lightbulb_outline, size: 20, color: Colors.amber),",
      "          const SizedBox(width: 8),",
      "          Expanded(",
      "            child: Text(",
      "              label,",
      "              style: Theme.of(context).textTheme.bodySmall?.copyWith(",
      "                    fontStyle: FontStyle.italic,",
      "                  ),",
      "            ),",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 357,
      "file_size": 12206,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\financials\\invoices_card.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "",
      "class InvoicesCard extends StatelessWidget {",
      "  final int totalInvoices;",
      "  final int openInvoiceCount;",
      "  final int overdueInvoiceCount;",
      "  final double overdueAmount;",
      "  final int paidInvoiceCount;",
      "  final double outstandingBalance;",
      "  final DateTime? lastInvoiceDate;",
      "",
      "  final VoidCallback onViewAllPressed;",
      "  final VoidCallback? onCreateInvoicePressed;",
      "",
      "  const InvoicesCard({",
      "    Key? key,",
      "    required this.totalInvoices,",
      "    required this.openInvoiceCount,",
      "    required this.overdueInvoiceCount,",
      "    required this.overdueAmount,",
      "    required this.paidInvoiceCount,",
      "    required this.outstandingBalance,",
      "    this.lastInvoiceDate,",
      "    required this.onViewAllPressed,",
      "    this.onCreateInvoicePressed,",
      "  }) : super(key: key);",
      "",
      "  String _formatNumber(int number) {",
      "    if (number >= 1000) return '${(number / 1000).toStringAsFixed(1)}K';",
      "    return number.toString();",
      "  }",
      "",
      "  String _formatDate(BuildContext context, DateTime? date) {",
      "    if (date == null) return '-';",
      "    return MaterialLocalizations.of(context).formatShortDate(date);",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[InvoicesCard] loc is null! Localization not available for this context.');",
      "      return const SizedBox.shrink();",
      "    }",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "",
      "    return Semantics(",
      "      label: loc.invoices ?? \"Invoices Summary\",",
      "      child: Card(",
      "        color: colorScheme.surfaceVariant,",
      "        elevation: DesignTokens.adminCardElevation,",
      "        shape: RoundedRectangleBorder(",
      "          borderRadius: BorderRadius.circular(DesignTokens.adminCardRadius),",
      "        ),",
      "        child: Padding(",
      "          padding: const EdgeInsets.all(18),",
      "          child: Column(",
      "            crossAxisAlignment: CrossAxisAlignment.start,",
      "            children: [",
      "              // Header Row: Title + Actions",
      "              Row(",
      "                children: [",
      "                  Icon(Icons.description_outlined, color: colorScheme.primary),",
      "                  const SizedBox(width: 10),",
      "                  Text(loc.invoices ?? \"Invoices\",",
      "                      style: Theme.of(context).textTheme.titleMedium),",
      "                  const Spacer(),",
      "                  if (onCreateInvoicePressed != null)",
      "                    IconButton(",
      "                      icon: Icon(Icons.add_circle_outline,",
      "                          color: colorScheme.primary),",
      "                      tooltip: loc.createInvoice ?? \"Create Invoice\",",
      "                      onPressed: onCreateInvoicePressed,",
      "                      splashRadius: 20,",
      "                    ),",
      "                  Tooltip(",
      "                    message: loc.viewAllInvoices ?? \"View All Invoices\",",
      "                    child: IconButton(",
      "                      icon: Icon(Icons.open_in_new, color: colorScheme.primary),",
      "                      onPressed: onViewAllPressed,",
      "                      tooltip: loc.viewAllInvoices ?? \"View All Invoices\",",
      "                      splashRadius: 20,",
      "                    ),",
      "                  ),",
      "                ],",
      "              ),",
      "",
      "              const SizedBox(height: 14),",
      "",
      "              // Stats Rows",
      "              Wrap(",
      "                spacing: 20,",
      "                runSpacing: 10,",
      "                children: [",
      "                  _StatTile(",
      "                    label: loc.totalInvoices ?? \"Total Invoices\",",
      "                    value: _formatNumber(totalInvoices),",
      "                    icon: Icons.format_list_numbered,",
      "                    color: colorScheme.primary,",
      "                  ),",
      "                  _StatTile(",
      "                    label: loc.openInvoices ?? \"Open\",",
      "                    value: _formatNumber(openInvoiceCount),",
      "                    icon: Icons.pending_actions,",
      "                    color: Colors.orange.shade700,",
      "                  ),",
      "                  _StatTile(",
      "                    label: loc.overdueInvoices ?? \"Overdue\",",
      "                    value:",
      "                        '$overdueInvoiceCount (${overdueAmount.toStringAsFixed(2)})',",
      "                    icon: Icons.error_outline,",
      "                    color: colorScheme.error,",
      "                  ),",
      "                  _StatTile(",
      "                    label: loc.paidInvoices ?? \"Paid\",",
      "                    value: _formatNumber(paidInvoiceCount),",
      "                    icon: Icons.check_circle_outline,",
      "                    color: Colors.green.shade600,",
      "                  ),",
      "                  _StatTile(",
      "                    label: loc.outstandingBalance ?? \"Outstanding\",",
      "                    value: '\\$${outstandingBalance.toStringAsFixed(2)}',",
      "                    icon: Icons.account_balance_wallet_outlined,",
      "                    color: Colors.red.shade700,",
      "                  ),",
      "                  _StatTile(",
      "                    label: loc.lastInvoiceDate ?? \"Last Invoice\",",
      "                    value: _formatDate(context, lastInvoiceDate),",
      "                    icon: Icons.calendar_today_outlined,",
      "                    color: colorScheme.onSurface.withOpacity(0.6),",
      "                  ),",
      "                ],",
      "              ),",
      "            ],",
      "          ),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "class _StatTile extends StatelessWidget {",
      "  final String label;",
      "  final String value;",
      "  final IconData icon;",
      "  final Color color;",
      "",
      "  const _StatTile({",
      "    required this.label,",
      "    required this.value,",
      "    required this.icon,",
      "    required this.color,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final textColor = Theme.of(context).colorScheme.onSurface;",
      "    return SizedBox(",
      "      width: 140,",
      "      child: Row(",
      "        children: [",
      "          CircleAvatar(",
      "            backgroundColor: color.withOpacity(0.15),",
      "            child: Icon(icon, color: color),",
      "            radius: 18,",
      "          ),",
      "          const SizedBox(width: 8),",
      "          Flexible(",
      "            child: Column(",
      "              crossAxisAlignment: CrossAxisAlignment.start,",
      "              children: [",
      "                Text(label,",
      "                    style: TextStyle(",
      "                        fontSize: 13, color: textColor.withOpacity(0.7))),",
      "                Text(value,",
      "                    style: TextStyle(",
      "                      fontWeight: FontWeight.bold,",
      "                      fontSize: 16,",
      "                      color: textColor,",
      "                    )),",
      "              ],",
      "            ),",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 192,
      "file_size": 6665,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\financials\\invoice_data_table.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "",
      "import 'package:franchise_admin_portal/core/models/invoice.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "/// InvoiceDataTable",
      "/// Responsive, paginated, sortable data table for invoices.",
      "/// Supports multi-selection, bulk actions, and contextual menus.",
      "/// Uses localization for all labels and messages.",
      "/// Applies theming and spacing from DesignTokens.",
      "/// Designed for desktop and mobile with adaptive UI.",
      "/// Logs errors using error_logger.",
      "/// Modular for integration in HQ/Owner dashboard sections.",
      "",
      "typedef InvoiceSelectionChanged = void Function(List<Invoice> selectedInvoices);",
      "typedef InvoiceActionCallback = Future<void> Function(List<Invoice> invoices);",
      "",
      "class InvoiceDataTable extends StatefulWidget {",
      "  final List<Invoice> invoices;",
      "  final InvoiceSelectionChanged? onSelectionChanged;",
      "  final InvoiceActionCallback? onBulkMarkPaid;",
      "  final InvoiceActionCallback? onBulkSendReminder;",
      "",
      "  const InvoiceDataTable({",
      "    Key? key,",
      "    required this.invoices,",
      "    this.onSelectionChanged,",
      "    this.onBulkMarkPaid,",
      "    this.onBulkSendReminder,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  State<InvoiceDataTable> createState() => _InvoiceDataTableState();",
      "}",
      "",
      "class _InvoiceDataTableState extends State<InvoiceDataTable> {",
      "  final Set<Invoice> _selectedInvoices = {};",
      "  late List<Invoice> _sortedInvoices;",
      "  int _sortColumnIndex = 3; // default sort by Total",
      "  bool _sortAscending = false;",
      "  static const int _rowsPerPage = 10;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _sortedInvoices = List.of(widget.invoices);",
      "    _sortInvoices();",
      "  }",
      "",
      "  @override",
      "  void didUpdateWidget(covariant InvoiceDataTable oldWidget) {",
      "    super.didUpdateWidget(oldWidget);",
      "    if (oldWidget.invoices != widget.invoices) {",
      "      _sortedInvoices = List.of(widget.invoices);",
      "      _sortInvoices();",
      "      _selectedInvoices.clear();",
      "      widget.onSelectionChanged?.call(_selectedInvoices.toList());",
      "    }",
      "  }",
      "",
      "  void _sortInvoices() {",
      "    _sortedInvoices.sort((a, b) {",
      "      int cmp;",
      "      switch (_sortColumnIndex) {",
      "        case 0:",
      "          cmp = a.invoiceNumber.compareTo(b.invoiceNumber);",
      "          break;",
      "        case 1:",
      "          cmp = a.status.toString().compareTo(b.status.toString());",
      "          break;",
      "        case 2:",
      "          cmp = a.issuedAt?.compareTo(b.issuedAt ?? DateTime(0)) ?? 0;",
      "          break;",
      "        case 3:",
      "          cmp = a.total.compareTo(b.total);",
      "          break;",
      "        default:",
      "          cmp = 0;",
      "      }",
      "      return _sortAscending ? cmp : -cmp;",
      "    });",
      "  }",
      "",
      "  void _onSort(int columnIndex, bool ascending) {",
      "    setState(() {",
      "      _sortColumnIndex = columnIndex;",
      "      _sortAscending = ascending;",
      "      _sortInvoices();",
      "    });",
      "  }",
      "",
      "  void _onSelectAll(bool? checked) {",
      "    setState(() {",
      "      if (checked == true) {",
      "        _selectedInvoices.addAll(_sortedInvoices);",
      "      } else {",
      "        _selectedInvoices.clear();",
      "      }",
      "      widget.onSelectionChanged?.call(_selectedInvoices.toList());",
      "    });",
      "  }",
      "",
      "  void _onSelectRow(bool? selected, Invoice invoice) {",
      "    setState(() {",
      "      if (selected == true) {",
      "        _selectedInvoices.add(invoice);",
      "      } else {",
      "        _selectedInvoices.remove(invoice);",
      "      }",
      "      widget.onSelectionChanged?.call(_selectedInvoices.toList());",
      "    });",
      "  }",
      "",
      "  Future<void> _handleBulkAction(",
      "      Future<void> Function(List<Invoice>)? action) async {",
      "    if (action == null) return;",
      "    try {",
      "      await action(_selectedInvoices.toList());",
      "      setState(() {",
      "        _selectedInvoices.clear();",
      "        widget.onSelectionChanged?.call(_selectedInvoices.toList());",
      "      });",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(content: Text(AppLocalizations.of(context)!.actionCompleted)),",
      "      );",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: e.toString(),",
      "        stack: stack.toString(),",
      "        source: 'InvoiceDataTable',",
      "        screen: '_handleBulkAction',",
      "        severity: 'error',",
      "      );",
      "      if (mounted) {",
      "        ScaffoldMessenger.of(context).showSnackBar(",
      "          SnackBar(content: Text(AppLocalizations.of(context)!.actionFailed)),",
      "        );",
      "      }",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[${runtimeType}] loc is null! Localization not available for this context.');",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "",
      "    if (_sortedInvoices.isEmpty) {",
      "      return Center(",
      "        child: Text(loc.noInvoicesFound),",
      "      );",
      "    }",
      "",
      "    final columns = [",
      "      DataColumn(",
      "        label: Text(loc.invoiceNumber),",
      "        onSort: _onSort,",
      "        numeric: false,",
      "      ),",
      "      DataColumn(",
      "        label: Text(loc.status),",
      "        onSort: _onSort,",
      "      ),",
      "      DataColumn(",
      "        label: Text(loc.issueDate),",
      "        onSort: _onSort,",
      "      ),",
      "      DataColumn(",
      "        label: Text(loc.total),",
      "        onSort: _onSort,",
      "        numeric: true,",
      "      ),",
      "    ];",
      "",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        if (_selectedInvoices.isNotEmpty)",
      "          Padding(",
      "            padding:",
      "                const EdgeInsets.symmetric(vertical: DesignTokens.paddingMd),",
      "            child: Row(",
      "              children: [",
      "                ElevatedButton.icon(",
      "                  icon: const Icon(Icons.check_circle),",
      "                  label: Text(loc.markSelectedPaid),",
      "                  onPressed: () => _handleBulkAction(widget.onBulkMarkPaid),",
      "                ),",
      "                const SizedBox(width: DesignTokens.paddingMd),",
      "                ElevatedButton.icon(",
      "                  icon: const Icon(Icons.email),",
      "                  label: Text(loc.sendPaymentReminder),",
      "                  onPressed: () => _handleBulkAction(widget.onBulkSendReminder),",
      "                ),",
      "              ],",
      "            ),",
      "          ),",
      "        PaginatedDataTable(",
      "          header: Text(loc.invoices),",
      "          columns: columns,",
      "          source: _InvoiceDataSource(",
      "            invoices: _sortedInvoices,",
      "            selectedInvoices: _selectedInvoices,",
      "            onSelectRow: _onSelectRow,",
      "            context: context,",
      "          ),",
      "          sortColumnIndex: _sortColumnIndex,",
      "          sortAscending: _sortAscending,",
      "          rowsPerPage: _rowsPerPage,",
      "          onSelectAll: _onSelectAll,",
      "          showCheckboxColumn: true,",
      "          columnSpacing: DesignTokens.paddingMd,",
      "          horizontalMargin: DesignTokens.paddingMd,",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}",
      "",
      "class _InvoiceDataSource extends DataTableSource {",
      "  final List<Invoice> invoices;",
      "  final Set<Invoice> selectedInvoices;",
      "  final Function(bool?, Invoice) onSelectRow;",
      "  final BuildContext context;",
      "",
      "  _InvoiceDataSource({",
      "    required this.invoices,",
      "    required this.selectedInvoices,",
      "    required this.onSelectRow,",
      "    required this.context,",
      "  });",
      "",
      "  @override",
      "  DataRow? getRow(int index) {",
      "    if (index >= invoices.length) return null;",
      "    final invoice = invoices[index];",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[InvoiceDataTable] loc is null! Localization not available for this context.');",
      "      // Just skip the row to prevent type errors:",
      "      return null;",
      "    }",
      "",
      "    String statusString = invoice.status.toString().split('.').last;",
      "    String issuedDateString = invoice.issuedAt != null",
      "        ? MaterialLocalizations.of(context).formatShortDate(invoice.issuedAt!)",
      "        : '';",
      "",
      "    return DataRow.byIndex(",
      "      index: index,",
      "      selected: selectedInvoices.contains(invoice),",
      "      onSelectChanged: (selected) => onSelectRow(selected, invoice),",
      "      cells: [",
      "        DataCell(Text(invoice.invoiceNumber)),",
      "        DataCell(Text(statusString)),",
      "        DataCell(Text(issuedDateString)),",
      "        DataCell(",
      "            Text('${invoice.total.toStringAsFixed(2)} ${invoice.currency}')),",
      "      ],",
      "    );",
      "  }",
      "",
      "  @override",
      "  bool get isRowCountApproximate => false;",
      "",
      "  @override",
      "  int get rowCount => invoices.length;",
      "",
      "  @override",
      "  int get selectedRowCount => selectedInvoices.length;",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 279,
      "file_size": 8516,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\financials\\invoice_export_dialog.dart",
    "content": [
      "// File: lib/admin/hq_owner/invoice_export_dialog.dart",
      "",
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "",
      "import 'package:franchise_admin_portal/core/models/invoice.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/export_utils.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "",
      "/// InvoiceExportDialog",
      "/// Dialog widget to allow HQ/Owner users to export invoices data.",
      "/// Supports export format selection (CSV, PDF placeholder),",
      "/// date range filtering, and selection of all or filtered invoices.",
      "///",
      "/// Integrates with FirestoreService to fetch data,",
      "/// uses ExportUtils for CSV generation,",
      "/// and logs errors with ErrorLogger.",
      "///",
      "/// Designed with localization, theming, and modularity in mind.",
      "",
      "class InvoiceExportDialog extends StatefulWidget {",
      "  final String franchiseId;",
      "",
      "  const InvoiceExportDialog({Key? key, required this.franchiseId})",
      "      : super(key: key);",
      "",
      "  @override",
      "  State<InvoiceExportDialog> createState() => _InvoiceExportDialogState();",
      "}",
      "",
      "class _InvoiceExportDialogState extends State<InvoiceExportDialog> {",
      "  final FirestoreService _firestoreService = FirestoreService();",
      "",
      "  DateTime? _startDate;",
      "  DateTime? _endDate;",
      "  String _exportFormat = 'csv'; // 'csv' or 'pdf'",
      "",
      "  bool _loading = false;",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[InvoiceExportDialog] loc is null! Localization not available for this context.');",
      "      return const SizedBox.shrink();",
      "    }",
      "",
      "    return AlertDialog(",
      "      title: Text(loc.exportInvoices),",
      "      content: SingleChildScrollView(",
      "        child: Column(",
      "          mainAxisSize: MainAxisSize.min,",
      "          children: [",
      "            _buildDatePicker(context, loc, label: loc.startDate,",
      "                onSelected: (d) {",
      "              setState(() => _startDate = d);",
      "            }, selectedDate: _startDate),",
      "            const SizedBox(height: DesignTokens.paddingMd),",
      "            _buildDatePicker(context, loc, label: loc.endDate, onSelected: (d) {",
      "              setState(() => _endDate = d);",
      "            }, selectedDate: _endDate),",
      "            const SizedBox(height: DesignTokens.paddingMd),",
      "            _buildFormatSelector(loc),",
      "          ],",
      "        ),",
      "      ),",
      "      actions: [",
      "        TextButton(",
      "          onPressed: _loading ? null : () => Navigator.of(context).pop(),",
      "          child: Text(loc.cancel),",
      "        ),",
      "        ElevatedButton(",
      "          onPressed: _loading ? null : _exportInvoices,",
      "          child: _loading",
      "              ? SizedBox(",
      "                  height: 20,",
      "                  width: 20,",
      "                  child: CircularProgressIndicator(",
      "                    strokeWidth: 2,",
      "                    color: Theme.of(context).colorScheme.onPrimary,",
      "                  ),",
      "                )",
      "              : Text(loc.export),",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "",
      "  Widget _buildDatePicker(BuildContext context, AppLocalizations loc,",
      "      {required String label,",
      "      required ValueChanged<DateTime> onSelected,",
      "      DateTime? selectedDate}) {",
      "    return Row(",
      "      children: [",
      "        Expanded(child: Text(label)),",
      "        TextButton(",
      "          onPressed: () async {",
      "            final now = DateTime.now();",
      "            final picked = await showDatePicker(",
      "              context: context,",
      "              initialDate: selectedDate ?? now,",
      "              firstDate: DateTime(now.year - 10),",
      "              lastDate: now,",
      "            );",
      "            if (picked != null) {",
      "              onSelected(picked);",
      "            }",
      "          },",
      "          child: Text(selectedDate != null",
      "              ? MaterialLocalizations.of(context).formatShortDate(selectedDate)",
      "              : loc.selectDate),",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "",
      "  Widget _buildFormatSelector(AppLocalizations loc) {",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        Text(loc.exportFormat),",
      "        RadioListTile<String>(",
      "          title: Text('CSV'),",
      "          value: 'csv',",
      "          groupValue: _exportFormat,",
      "          onChanged: (val) {",
      "            if (val != null) {",
      "              setState(() => _exportFormat = val);",
      "            }",
      "          },",
      "        ),",
      "        RadioListTile<String>(",
      "          title: Text('PDF (Coming Soon)'),",
      "          value: 'pdf',",
      "          groupValue: _exportFormat,",
      "          onChanged: null, // Disabled for now",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "",
      "  Future<void> _exportInvoices() async {",
      "    setState(() {",
      "      _loading = true;",
      "    });",
      "    try {",
      "      final invoices = await _firestoreService.fetchInvoicesFiltered(",
      "        franchiseId: widget.franchiseId,",
      "        startDate: _startDate,",
      "        endDate: _endDate,",
      "      );",
      "",
      "      String exportedData;",
      "      if (_exportFormat == 'csv') {",
      "        exportedData = ExportUtils.invoicesToCsv(context, invoices);",
      "      } else {",
      "        // Placeholder for PDF export implementation",
      "        exportedData = '';",
      "      }",
      "",
      "      // TODO: Trigger file save or share dialog with exportedData",
      "      // This is app-specific: platform file pickers or share plugins",
      "      // For now, just print to console:",
      "      debugPrint('Exported Data:\\n$exportedData');",
      "",
      "      Navigator.of(context).pop(); // Close dialog on success",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: e.toString(),",
      "        stack: stack.toString(),",
      "        source: 'InvoiceExportDialog',",
      "        screen: '_exportInvoices',",
      "        severity: 'error',",
      "        contextData: {",
      "          'franchiseId': widget.franchiseId,",
      "          'startDate': _startDate?.toIso8601String(),",
      "          'endDate': _endDate?.toIso8601String(),",
      "          'exportFormat': _exportFormat,",
      "        },",
      "      );",
      "      if (mounted) {",
      "        ScaffoldMessenger.of(context).showSnackBar(",
      "          SnackBar(",
      "              content: Text(AppLocalizations.of(context)?.exportFailed ??",
      "                  'Export failed')),",
      "        );",
      "      }",
      "    } finally {",
      "      if (mounted) {",
      "        setState(() {",
      "          _loading = false;",
      "        });",
      "      }",
      "    }",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 199,
      "file_size": 6385,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\financials\\kpi_card.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "",
      "class KpiCard extends StatelessWidget {",
      "  final String title;",
      "  final String value;",
      "  final bool loading;",
      "  final IconData? icon;",
      "  const KpiCard({",
      "    Key? key,",
      "    required this.title,",
      "    required this.value,",
      "    this.loading = false,",
      "    this.icon,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    return Card(",
      "      elevation: 2,",
      "      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),",
      "      color: colorScheme.surface,",
      "      child: Padding(",
      "        padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 22),",
      "        child: Column(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            Row(",
      "              children: [",
      "                if (icon != null) ...[",
      "                  Icon(icon, color: colorScheme.primary, size: 28),",
      "                  SizedBox(width: 8),",
      "                ],",
      "                Expanded(",
      "                  child: Text(title,",
      "                      style: Theme.of(context).textTheme.titleSmall?.copyWith(",
      "                            color: colorScheme.onSurface.withOpacity(0.8),",
      "                          )),",
      "                ),",
      "              ],",
      "            ),",
      "            const SizedBox(height: 16),",
      "            loading",
      "                ? Container(",
      "                    width: 48,",
      "                    height: 22,",
      "                    decoration: BoxDecoration(",
      "                        color: colorScheme.surfaceVariant,",
      "                        borderRadius: BorderRadius.circular(8)),",
      "                  )",
      "                : Text(value,",
      "                    style: Theme.of(context).textTheme.displaySmall?.copyWith(",
      "                        fontWeight: FontWeight.bold,",
      "                        color: colorScheme.primary)),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 60,
      "file_size": 1942,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\financials\\payouts_filter_bar.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/payout_filter_provider.dart';",
      "import 'package:franchise_admin_portal/config/branding_config.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class PayoutsFilterBar extends StatefulWidget {",
      "  final bool developerMode;",
      "",
      "  const PayoutsFilterBar({",
      "    Key? key,",
      "    this.developerMode = false,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  State<PayoutsFilterBar> createState() => _PayoutsFilterBarState();",
      "}",
      "",
      "class _PayoutsFilterBarState extends State<PayoutsFilterBar> {",
      "  late TextEditingController _searchController;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    final provider = Provider.of<PayoutFilterProvider>(context, listen: false);",
      "    _searchController = TextEditingController(text: provider.searchQuery);",
      "",
      "    // Listen for provider searchQuery changes and update controller",
      "    provider.addListener(_providerListener);",
      "  }",
      "",
      "  void _providerListener() {",
      "    final provider = Provider.of<PayoutFilterProvider>(context, listen: false);",
      "    // Avoid endless loop",
      "    if (_searchController.text != provider.searchQuery) {",
      "      _searchController.text = provider.searchQuery;",
      "      _searchController.selection = TextSelection.fromPosition(",
      "          TextPosition(offset: _searchController.text.length));",
      "    }",
      "  }",
      "",
      "  @override",
      "  void dispose() {",
      "    final provider = Provider.of<PayoutFilterProvider>(context, listen: false);",
      "    provider.removeListener(_providerListener);",
      "    _searchController.dispose();",
      "    super.dispose();",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[PayoutsFilterBar] loc is null! Localization not available for this context.');",
      "      // Return a placeholder container, not a Scaffold!",
      "      return SizedBox.shrink();",
      "    }",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "    final filterProvider = Provider.of<PayoutFilterProvider>(context);",
      "",
      "    return Card(",
      "      color: colorScheme.surfaceVariant,",
      "      margin: const EdgeInsets.only(bottom: 14),",
      "      shape: RoundedRectangleBorder(",
      "        borderRadius: BorderRadius.circular(DesignTokens.adminCardRadius),",
      "      ),",
      "      child: Padding(",
      "        padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 12),",
      "        child: Row(",
      "          children: [",
      "            // Status Dropdown",
      "            DropdownButton<String>(",
      "              value: filterProvider.status,",
      "              style: theme.textTheme.bodyMedium,",
      "              icon: const Icon(Icons.arrow_drop_down),",
      "              underline: const SizedBox(),",
      "              dropdownColor: colorScheme.surface,",
      "              items: [",
      "                DropdownMenuItem(",
      "                  value: 'all',",
      "                  child: Text(loc.all ?? \"All\"),",
      "                ),",
      "                DropdownMenuItem(",
      "                  value: 'pending',",
      "                  child: Text(loc.pending),",
      "                ),",
      "                DropdownMenuItem(",
      "                  value: 'sent',",
      "                  child: Text(loc.sent),",
      "                ),",
      "                DropdownMenuItem(",
      "                  value: 'failed',",
      "                  child: Text(loc.failed),",
      "                ),",
      "              ],",
      "              onChanged: (v) {",
      "                if (v != null && v != filterProvider.status) {",
      "                  filterProvider.setStatus(v);",
      "                }",
      "              },",
      "            ),",
      "            const SizedBox(width: 14),",
      "",
      "            // Search Bar (full text)",
      "            Expanded(",
      "              child: TextField(",
      "                controller: _searchController,",
      "                style: theme.textTheme.bodyMedium,",
      "                decoration: InputDecoration(",
      "                  prefixIcon: const Icon(Icons.search),",
      "                  hintText: loc.searchPayoutsHint ?? 'Search payouts...',",
      "                  filled: true,",
      "                  fillColor: colorScheme.background,",
      "                  contentPadding:",
      "                      const EdgeInsets.symmetric(vertical: 0, horizontal: 14),",
      "                  border: OutlineInputBorder(",
      "                    borderRadius:",
      "                        BorderRadius.circular(DesignTokens.adminCardRadius),",
      "                    borderSide: BorderSide(color: colorScheme.outlineVariant),",
      "                  ),",
      "                  enabledBorder: OutlineInputBorder(",
      "                    borderRadius:",
      "                        BorderRadius.circular(DesignTokens.adminCardRadius),",
      "                    borderSide: BorderSide(color: colorScheme.outlineVariant),",
      "                  ),",
      "                  isDense: true,",
      "                ),",
      "                onChanged: (value) {",
      "                  try {",
      "                    filterProvider.setSearchQuery(value);",
      "                  } catch (e, stack) {",
      "                    ErrorLogger.log(",
      "                      message:",
      "                          'Failed to update search query in PayoutsFilterBar: $e',",
      "                      stack: stack.toString(),",
      "                      source: 'PayoutsFilterBar',",
      "                      screen: 'payouts_filter_bar.dart',",
      "                      severity: 'warning',",
      "                    );",
      "                  }",
      "                },",
      "              ),",
      "            ),",
      "            const SizedBox(width: 14),",
      "",
      "            // Developer-only/Feature placeholder: future filtering advanced options",
      "            if (widget.developerMode)",
      "              Tooltip(",
      "                message: loc.featureComingSoon('Advanced Filtering'),",
      "                child: IconButton(",
      "                  icon: const Icon(Icons.filter_alt_rounded),",
      "                  color: colorScheme.primary,",
      "                  onPressed: () {",
      "                    ScaffoldMessenger.of(context).showSnackBar(",
      "                      SnackBar(",
      "                          content: Text(",
      "                              loc.featureComingSoon('Advanced Filtering'))),",
      "                    );",
      "                  },",
      "                ),",
      "              ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 171,
      "file_size": 6361,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\financials\\payout_detail_dialog.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/models/payout.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/config/branding_config.dart';",
      "import 'package:franchise_admin_portal/widgets/empty_state_widget.dart';",
      "",
      "// Add the two new widgets here:",
      "import 'package:franchise_admin_portal/widgets/financials/payout_note_editor.dart';",
      "import 'package:franchise_admin_portal/admin/hq_owner/widgets/attachment_uploader.dart';",
      "",
      "class PayoutDetailDialog extends StatefulWidget {",
      "  final String payoutId;",
      "  const PayoutDetailDialog({Key? key, required this.payoutId})",
      "      : super(key: key);",
      "",
      "  @override",
      "  State<PayoutDetailDialog> createState() => _PayoutDetailDialogState();",
      "}",
      "",
      "class _PayoutDetailDialogState extends State<PayoutDetailDialog> {",
      "  late Future<Map<String, dynamic>?> _futurePayoutDetails;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _futurePayoutDetails =",
      "        FirestoreService().getPayoutDetailsWithAudit(widget.payoutId);",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[PayoutDetailDialog] loc is null! Localization not available for this context.');",
      "      return const SizedBox.shrink();",
      "    }",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "",
      "    return Dialog(",
      "      insetPadding: const EdgeInsets.symmetric(horizontal: 32, vertical: 48),",
      "      child: ConstrainedBox(",
      "        constraints: const BoxConstraints(maxWidth: 700, minHeight: 360),",
      "        child: FutureBuilder<Map<String, dynamic>?>(",
      "          future: _futurePayoutDetails,",
      "          builder: (context, snapshot) {",
      "            if (snapshot.connectionState == ConnectionState.waiting) {",
      "              return const Center(",
      "                  child: Padding(",
      "                      padding: EdgeInsets.all(40),",
      "                      child: CircularProgressIndicator()));",
      "            }",
      "            if (snapshot.hasError) {",
      "              ErrorLogger.log(",
      "                message: 'Failed to load payout details: ${snapshot.error}',",
      "                stack: snapshot.stackTrace?.toString(),",
      "                screen: 'PayoutDetailDialog',",
      "                source: 'PayoutDetailDialog',",
      "                severity: 'error',",
      "                contextData: {'payoutId': widget.payoutId},",
      "              );",
      "              return EmptyStateWidget(",
      "                title: loc.failedToLoadSummary,",
      "                message: loc.tryAgainLater,",
      "                imageAsset: BrandingConfig.bannerPlaceholder,",
      "                onRetry: () => setState(() {",
      "                  _futurePayoutDetails = FirestoreService()",
      "                      .getPayoutDetailsWithAudit(widget.payoutId);",
      "                }),",
      "                buttonText: loc.retry,",
      "              );",
      "            }",
      "            final data = snapshot.data;",
      "            if (data == null) {",
      "              return EmptyStateWidget(",
      "                title: loc.noDataFound ?? 'No Data',",
      "                message: loc.payoutNotFound ?? 'Payout not found.',",
      "                imageAsset: BrandingConfig.bannerPlaceholder,",
      "                onRetry: () => setState(() {",
      "                  _futurePayoutDetails = FirestoreService()",
      "                      .getPayoutDetailsWithAudit(widget.payoutId);",
      "                }),",
      "                buttonText: loc.retry,",
      "              );",
      "            }",
      "",
      "            final payout = Payout.fromFirestore(data, data['id']);",
      "            final List<Map<String, dynamic>> auditTrail =",
      "                (data['audit_trail'] as List<dynamic>? ?? [])",
      "                    .map((e) => Map<String, dynamic>.from(e))",
      "                    .toList();",
      "",
      "            // Wire in all new features, modular and replace old logic!",
      "            return Scaffold(",
      "              backgroundColor: colorScheme.background,",
      "              appBar: AppBar(",
      "                backgroundColor: colorScheme.surface,",
      "                title: Text('${loc.payoutDetail} (${payout.id})'),",
      "                actions: [",
      "                  IconButton(",
      "                    icon: const Icon(Icons.refresh),",
      "                    tooltip: loc.retry,",
      "                    onPressed: () => setState(() {",
      "                      _futurePayoutDetails = FirestoreService()",
      "                          .getPayoutDetailsWithAudit(widget.payoutId);",
      "                    }),",
      "                  ),",
      "                  IconButton(",
      "                    icon: const Icon(Icons.close),",
      "                    tooltip: loc.close,",
      "                    onPressed: () => Navigator.of(context).maybePop(),",
      "                  ),",
      "                ],",
      "              ),",
      "              body: SingleChildScrollView(",
      "                padding: const EdgeInsets.all(28),",
      "                child: Column(",
      "                  crossAxisAlignment: CrossAxisAlignment.start,",
      "                  children: [",
      "                    _PayoutSummarySection(",
      "                        payout: payout, loc: loc, theme: theme),",
      "                    const SizedBox(height: 28),",
      "                    _AuditTrailSection(",
      "                        auditTrail: auditTrail, loc: loc, theme: theme),",
      "                    const SizedBox(height: 24),",
      "                    // 1. AttachmentUploader",
      "                    AttachmentUploader(",
      "                      payoutId: payout.id,",
      "                      // Pass other needed args (user id, role, etc) as required by your widget",
      "                      existingAttachments:",
      "                          payout.customFields['attachments'] ?? [],",
      "                      onUploaded: () => setState(() {",
      "                        // Re-fetch details to get new attachments",
      "                        _futurePayoutDetails = FirestoreService()",
      "                            .getPayoutDetailsWithAudit(widget.payoutId);",
      "                      }),",
      "                      onDeleted: () => setState(() {",
      "                        _futurePayoutDetails = FirestoreService()",
      "                            .getPayoutDetailsWithAudit(widget.payoutId);",
      "                      }),",
      "                    ),",
      "                    const SizedBox(height: 24),",
      "                    // 2. PayoutNoteEditor",
      "                    PayoutNoteEditor(",
      "                      payoutId: payout.id,",
      "                      // Ideally wire in the correct user id from app state/provider:",
      "                      userId:",
      "                          null, // <-- Replace with correct userId if available",
      "                      developerOnly: false, // Or guard by role",
      "                      initialNotes: payout.customFields['comments'] != null",
      "                          ? List<Map<String, dynamic>>.from(",
      "                              payout.customFields['comments'])",
      "                          : null,",
      "                    ),",
      "                    const SizedBox(height: 20),",
      "                    // Any future features (disputes, adjustments, etc) go below",
      "                  ],",
      "                ),",
      "              ),",
      "            );",
      "          },",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "// These three stateless widgets remain unchanged except for the removal of any legacy notes/attachments display. All support note and attachment UI/logic is now in the new widgets above.",
      "class _PayoutSummarySection extends StatelessWidget {",
      "  final Payout payout;",
      "  final AppLocalizations loc;",
      "  final ThemeData theme;",
      "",
      "  const _PayoutSummarySection({",
      "    required this.payout,",
      "    required this.loc,",
      "    required this.theme,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    String formatDate(DateTime? dt) =>",
      "        dt != null ? MaterialLocalizations.of(context).formatFullDate(dt) : '-';",
      "",
      "    Widget value(String v) => Text(v, style: theme.textTheme.bodyMedium);",
      "    Widget valueBold(String v) => Text(v,",
      "        style:",
      "            theme.textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold));",
      "",
      "    return Card(",
      "      margin: EdgeInsets.zero,",
      "      child: Padding(",
      "        padding: const EdgeInsets.all(24),",
      "        child: Table(",
      "          columnWidths: const {",
      "            0: IntrinsicColumnWidth(),",
      "            1: FlexColumnWidth(),",
      "            2: IntrinsicColumnWidth(),",
      "            3: FlexColumnWidth(),",
      "          },",
      "          children: [",
      "            TableRow(children: [",
      "              Text('${loc.status}:', style: theme.textTheme.bodyMedium),",
      "              valueBold(payout.status),",
      "              Text('${loc.amount}:', style: theme.textTheme.bodyMedium),",
      "              value('\\$${payout.amount.toStringAsFixed(2)} ${payout.currency}'),",
      "            ]),",
      "            TableRow(children: [",
      "              Text('${loc.payoutMethod ?? \"Method\"}:',",
      "                  style: theme.textTheme.bodyMedium),",
      "              value(payout.customFields['method'] ?? '-'),",
      "              Text('${loc.bankAccount ?? \"Account\"}:',",
      "                  style: theme.textTheme.bodyMedium),",
      "              value(payout.customFields['bank_account_last4'] != null",
      "                  ? '****${payout.customFields['bank_account_last4']}'",
      "                  : '-'),",
      "            ]),",
      "            TableRow(children: [",
      "              Text('${loc.createdAt}:', style: theme.textTheme.bodyMedium),",
      "              value(formatDate(payout.scheduledAt)),",
      "              Text('${loc.sentAt ?? \"Sent At\"}:',",
      "                  style: theme.textTheme.bodyMedium),",
      "              value(formatDate(payout.sentAt)),",
      "            ]),",
      "            TableRow(children: [",
      "              Text('${loc.notes}:', style: theme.textTheme.bodyMedium),",
      "              TableCell(",
      "                verticalAlignment: TableCellVerticalAlignment.middle,",
      "                child: value(payout.customFields['notes'] ?? '-'),",
      "              ),",
      "              Text('${loc.failureReason}:', style: theme.textTheme.bodyMedium),",
      "              value(payout.failureReason ?? '-'),",
      "            ]),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "class _AuditTrailSection extends StatelessWidget {",
      "  final List<Map<String, dynamic>> auditTrail;",
      "  final AppLocalizations loc;",
      "  final ThemeData theme;",
      "",
      "  const _AuditTrailSection({",
      "    required this.auditTrail,",
      "    required this.loc,",
      "    required this.theme,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    if (auditTrail.isEmpty) {",
      "      return Card(",
      "        color: theme.colorScheme.surfaceVariant,",
      "        child: Padding(",
      "          padding: const EdgeInsets.all(18),",
      "          child: Text(loc.noAuditTrailFound ?? \"No audit trail found.\",",
      "              style: theme.textTheme.bodySmall),",
      "        ),",
      "      );",
      "    }",
      "    return Card(",
      "      margin: EdgeInsets.zero,",
      "      child: Padding(",
      "        padding: const EdgeInsets.all(18),",
      "        child: Column(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            Text(loc.auditTrail, style: theme.textTheme.titleSmall),",
      "            const SizedBox(height: 6),",
      "            for (final event in auditTrail)",
      "              Padding(",
      "                padding: const EdgeInsets.symmetric(vertical: 2.5),",
      "                child: Row(",
      "                  children: [",
      "                    Icon(Icons.circle,",
      "                        size: 10, color: theme.colorScheme.primary),",
      "                    const SizedBox(width: 8),",
      "                    Expanded(child: Text(event['event'] ?? '')),",
      "                    if (event['timestamp'] != null)",
      "                      Text(",
      "                        MaterialLocalizations.of(context).formatShortDate(",
      "                          (event['timestamp'] is DateTime)",
      "                              ? event['timestamp']",
      "                              : DateTime.tryParse(",
      "                                      event['timestamp']?.toString() ?? '') ??",
      "                                  DateTime.now(),",
      "                        ),",
      "                        style: theme.textTheme.bodySmall",
      "                            ?.copyWith(color: theme.disabledColor),",
      "                      ),",
      "                  ],",
      "                ),",
      "              ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 305,
      "file_size": 12303,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\financials\\payout_note_editor.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/config/branding_config.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "/// Widget to add/view notes/comments on a payout.",
      "class PayoutNoteEditor extends StatefulWidget {",
      "  final String payoutId;",
      "  final String? userId;",
      "  final bool developerOnly;",
      "  final List<Map<String, dynamic>>? initialNotes;",
      "",
      "  const PayoutNoteEditor({",
      "    super.key,",
      "    required this.payoutId,",
      "    this.userId,",
      "    this.developerOnly = false,",
      "    this.initialNotes,",
      "  });",
      "",
      "  @override",
      "  State<PayoutNoteEditor> createState() => _PayoutNoteEditorState();",
      "}",
      "",
      "class _PayoutNoteEditorState extends State<PayoutNoteEditor> {",
      "  final _controller = TextEditingController();",
      "  final _focusNode = FocusNode();",
      "  bool _submitting = false;",
      "  String? _error;",
      "  List<Map<String, dynamic>> _notes = [];",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _notes = widget.initialNotes ?? [];",
      "    _fetchNotes();",
      "  }",
      "",
      "  Future<void> _fetchNotes() async {",
      "    try {",
      "      final notes = await FirestoreService().getPayoutComments(widget.payoutId);",
      "      setState(() => _notes = notes);",
      "    } catch (e, stack) {",
      "      ErrorLogger.log(",
      "        message: 'Failed to fetch payout comments: $e',",
      "        stack: stack.toString(),",
      "        source: 'PayoutNoteEditor',",
      "        screen: 'payout_note_editor.dart',",
      "        severity: 'error',",
      "      );",
      "    }",
      "  }",
      "",
      "  Future<void> _addNote() async {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[PayoutNoteEditor] loc is null! Localization not available for this context.');",
      "      return;",
      "    }",
      "    final text = _controller.text.trim();",
      "    if (text.isEmpty) return;",
      "    setState(() {",
      "      _submitting = true;",
      "      _error = null;",
      "    });",
      "    try {",
      "      final note = {",
      "        'message': text,",
      "        'createdAt': DateTime.now().toUtc().toIso8601String(),",
      "        'userId': widget.userId,",
      "        // You could add username, avatar, etc.",
      "      };",
      "      await FirestoreService().addPayoutComment(widget.payoutId, note);",
      "      _controller.clear();",
      "      _focusNode.unfocus();",
      "      setState(() {",
      "        _notes.insert(0, note);",
      "        _submitting = false;",
      "      });",
      "    } catch (e, stack) {",
      "      ErrorLogger.log(",
      "        message: 'Failed to add payout note: $e',",
      "        stack: stack.toString(),",
      "        source: 'PayoutNoteEditor',",
      "        screen: 'payout_note_editor.dart',",
      "        severity: 'error',",
      "      );",
      "      setState(() {",
      "        _submitting = false;",
      "        _error = e.toString();",
      "      });",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(content: Text(loc.failedToSave ?? 'Failed to save note.')),",
      "      );",
      "    }",
      "  }",
      "",
      "  Future<void> _removeNote(Map<String, dynamic> note) async {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[PayoutNoteEditor] loc is null! Localization not available for this context.');",
      "      return;",
      "    }",
      "    try {",
      "      await FirestoreService().removePayoutComment(widget.payoutId, note);",
      "      setState(() {",
      "        _notes.remove(note);",
      "      });",
      "    } catch (e, stack) {",
      "      ErrorLogger.log(",
      "        message: 'Failed to remove payout note: $e',",
      "        stack: stack.toString(),",
      "        source: 'PayoutNoteEditor',",
      "        screen: 'payout_note_editor.dart',",
      "        severity: 'error',",
      "      );",
      "      ScaffoldMessenger.of(context).showSnackBar(",
      "        SnackBar(content: Text(loc.failedToDelete ?? 'Failed to delete note.')),",
      "      );",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[PayoutNoteEditor] loc is null! Localization not available for this context.');",
      "      return const SizedBox.shrink();",
      "    }",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "",
      "    final canAdd = !widget.developerOnly ||",
      "        (widget.developerOnly &&",
      "            Theme.of(context).brightness == Brightness.dark);",
      "",
      "    return Card(",
      "      color: colorScheme.surfaceVariant,",
      "      margin: const EdgeInsets.symmetric(vertical: 12),",
      "      shape: RoundedRectangleBorder(",
      "        borderRadius: BorderRadius.circular(DesignTokens.adminCardRadius),",
      "      ),",
      "      child: Padding(",
      "        padding: const EdgeInsets.all(16.0),",
      "        child: Column(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            Text(loc.notes ?? \"Notes\", style: theme.textTheme.titleMedium),",
      "            const SizedBox(height: 12),",
      "            if (canAdd)",
      "              Row(",
      "                children: [",
      "                  Expanded(",
      "                    child: TextField(",
      "                      controller: _controller,",
      "                      focusNode: _focusNode,",
      "                      enabled: !_submitting,",
      "                      decoration: InputDecoration(",
      "                        hintText: loc.addNoteHint ?? \"Add a note...\",",
      "                        border: OutlineInputBorder(",
      "                          borderRadius: BorderRadius.circular(",
      "                              DesignTokens.adminButtonRadius),",
      "                        ),",
      "                        isDense: true,",
      "                        contentPadding: const EdgeInsets.symmetric(",
      "                            vertical: 8, horizontal: 12),",
      "                      ),",
      "                      minLines: 1,",
      "                      maxLines: 4,",
      "                    ),",
      "                  ),",
      "                  const SizedBox(width: 8),",
      "                  IconButton(",
      "                    icon: _submitting",
      "                        ? const SizedBox(",
      "                            width: 20,",
      "                            height: 20,",
      "                            child: CircularProgressIndicator(strokeWidth: 2))",
      "                        : const Icon(Icons.send),",
      "                    tooltip: loc.addNote ?? \"Add Note\",",
      "                    onPressed: _submitting ? null : _addNote,",
      "                  ),",
      "                ],",
      "              ),",
      "            if (_error != null) ...[",
      "              const SizedBox(height: 6),",
      "              Text(",
      "                _error!,",
      "                style: theme.textTheme.bodySmall",
      "                    ?.copyWith(color: colorScheme.error),",
      "              ),",
      "            ],",
      "            const SizedBox(height: 16),",
      "            if (_notes.isEmpty)",
      "              Text(loc.noNotesYet ?? \"No notes yet.\",",
      "                  style: theme.textTheme.bodySmall),",
      "            if (_notes.isNotEmpty)",
      "              Column(",
      "                children: _notes",
      "                    .map((note) => ListTile(",
      "                          leading: const Icon(Icons.sticky_note_2_outlined),",
      "                          title: Text(note['message'] ?? '',",
      "                              style: theme.textTheme.bodyMedium),",
      "                          subtitle: Text(",
      "                            _formatDate(note['createdAt'], context),",
      "                            style: theme.textTheme.labelSmall",
      "                                ?.copyWith(color: colorScheme.outline),",
      "                          ),",
      "                          trailing: canAdd",
      "                              ? IconButton(",
      "                                  icon: Icon(Icons.delete,",
      "                                      color: colorScheme.error),",
      "                                  tooltip: loc.delete ?? 'Delete',",
      "                                  onPressed: () => _removeNote(note),",
      "                                )",
      "                              : null,",
      "                          // Optionally, support long-press to remove:",
      "                          onLongPress: canAdd",
      "                              ? () async {",
      "                                  final shouldDelete = await showDialog<bool>(",
      "                                    context: context,",
      "                                    builder: (ctx) => AlertDialog(",
      "                                      title: Text(",
      "                                          loc.deleteNote ?? 'Delete note?'),",
      "                                      content: Text(loc.confirmDeleteNote ??",
      "                                          'Are you sure you want to delete this note?'),",
      "                                      actions: [",
      "                                        TextButton(",
      "                                          onPressed: () =>",
      "                                              Navigator.pop(ctx, false),",
      "                                          child: Text(loc.cancel ?? 'Cancel'),",
      "                                        ),",
      "                                        TextButton(",
      "                                          onPressed: () =>",
      "                                              Navigator.pop(ctx, true),",
      "                                          child: Text(loc.delete ?? 'Delete'),",
      "                                        ),",
      "                                      ],",
      "                                    ),",
      "                                  );",
      "                                  if (shouldDelete == true) {",
      "                                    _removeNote(note);",
      "                                  }",
      "                                }",
      "                              : null,",
      "                        ))",
      "                    .toList(),",
      "              ),",
      "            Padding(",
      "              padding: const EdgeInsets.only(top: 10),",
      "              child: Text(",
      "                loc.featureComingSoon('Rich Text, tagging, attachments'),",
      "                style: theme.textTheme.bodySmall",
      "                    ?.copyWith(color: colorScheme.outline),",
      "              ),",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  String _formatDate(dynamic value, BuildContext context) {",
      "    if (value == null) return '';",
      "    try {",
      "      final dt = value is String ? DateTime.parse(value) : value as DateTime;",
      "      return MaterialLocalizations.of(context).formatShortDate(dt);",
      "    } catch (_) {",
      "      return value.toString();",
      "    }",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 277,
      "file_size": 10314,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\financials\\payout_status_card.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/config/branding_config.dart';",
      "import 'package:franchise_admin_portal/widgets/dashboard/dashboard_section_card.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/admin/features/alerts/alerts_repository.dart';",
      "import 'package:franchise_admin_portal/core/models/alert_model.dart';",
      "import 'package:franchise_admin_portal/core/models/dashboard_section.dart';",
      "import 'package:franchise_admin_portal/core/providers/user_profile_notifier.dart';",
      "",
      "/// Dashboard card: At-a-glance payout summary + live payout-related alerts.",
      "class PayoutStatusCard extends StatelessWidget {",
      "  const PayoutStatusCard({Key? key}) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[PayoutStatusCard] loc is null! Localization not available for this context.');",
      "      return const SizedBox.shrink();",
      "    }",
      "    final theme = Theme.of(context);",
      "    final franchiseId = context.watch<FranchiseProvider>().franchiseId;",
      "    final colorScheme = theme.colorScheme;",
      "",
      "    // 🧑‍💻 Developer-only access guard (example: show only for owners/managers/dev)",
      "    final user = Provider.of<UserProfileNotifier>(context, listen: false).user;",
      "    if (user == null ||",
      "        !user.roles.any(",
      "            (role) => ['hq_owner', 'hq_manager', 'developer'].contains(role))) {",
      "      return const SizedBox.shrink();",
      "    }",
      "",
      "    return DashboardSectionCard(",
      "      title: loc.payoutStatus,",
      "      icon: Icons.payments_rounded,",
      "      builder: (context) => _PayoutCardContent(",
      "        franchiseId: franchiseId,",
      "        loc: loc,",
      "        theme: theme,",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "class _PayoutCardContent extends StatefulWidget {",
      "  final String franchiseId;",
      "  final AppLocalizations loc;",
      "  final ThemeData theme;",
      "",
      "  const _PayoutCardContent({",
      "    required this.franchiseId,",
      "    required this.loc,",
      "    required this.theme,",
      "  });",
      "",
      "  @override",
      "  State<_PayoutCardContent> createState() => _PayoutCardContentState();",
      "}",
      "",
      "class _PayoutCardContentState extends State<_PayoutCardContent> {",
      "  late Future<Map<String, int>> _future;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _future = FirestoreService().getPayoutStatsForFranchise(widget.franchiseId);",
      "  }",
      "",
      "  void _retry() {",
      "    setState(() {",
      "      _future =",
      "          FirestoreService().getPayoutStatsForFranchise(widget.franchiseId);",
      "    });",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final alertsRepo = AlertsRepository();",
      "    return StreamBuilder<List<AlertModel>>(",
      "      stream: alertsRepo.watchActiveAlerts(franchiseId: widget.franchiseId).map(",
      "          (alerts) => alerts",
      "              .where((a) =>",
      "                  a.type == 'payout_failed' || a.type == 'payout_pending')",
      "              .toList()),",
      "      builder: (context, alertSnap) {",
      "        return FutureBuilder<Map<String, int>>(",
      "          future: _future,",
      "          builder: (context, payoutSnap) {",
      "            if (payoutSnap.connectionState == ConnectionState.waiting) {",
      "              return const Center(child: CircularProgressIndicator());",
      "            }",
      "            if (payoutSnap.hasError) {",
      "              ErrorLogger.log(",
      "                message:",
      "                    'PayoutStatusCard: failed to load payout stats\\n${payoutSnap.error}',",
      "                stack: payoutSnap.stackTrace?.toString(),",
      "              );",
      "              return _ErrorWidget(",
      "                message: widget.loc.failedToLoadSummary,",
      "                onRetry: _retry,",
      "              );",
      "            }",
      "            final payoutStats = payoutSnap.data ?? {};",
      "            final pending = payoutStats['pending'] ?? 0;",
      "            final sent = payoutStats['sent'] ?? 0;",
      "            final failed = payoutStats['failed'] ?? 0;",
      "",
      "            final payoutAlerts = alertSnap.data ?? [];",
      "            final hasAlert = payoutAlerts.isNotEmpty;",
      "            final topAlert = hasAlert ? payoutAlerts.first : null;",
      "",
      "            return Padding(",
      "              padding: const EdgeInsets.all(10),",
      "              child: Column(",
      "                crossAxisAlignment: CrossAxisAlignment.start,",
      "                children: [",
      "                  if (hasAlert) ...[",
      "                    _AlertBanner(",
      "                        alert: topAlert!, theme: widget.theme, loc: widget.loc),",
      "                    const SizedBox(height: 12),",
      "                  ],",
      "                  Row(",
      "                    children: [",
      "                      _StatusDot(color: widget.theme.colorScheme.primary),",
      "                      const SizedBox(width: 4),",
      "                      Text(\"${widget.loc.pending}: $pending\",",
      "                          style: TextStyle(",
      "                              color: widget.theme.colorScheme.primary)),",
      "                      const SizedBox(width: 14),",
      "                      _StatusDot(color: widget.theme.colorScheme.secondary),",
      "                      const SizedBox(width: 4),",
      "                      Text(\"${widget.loc.sent}: $sent\",",
      "                          style: TextStyle(",
      "                              color: widget.theme.colorScheme.secondary)),",
      "                      const SizedBox(width: 14),",
      "                      _StatusDot(color: widget.theme.colorScheme.error),",
      "                      const SizedBox(width: 4),",
      "                      Text(\"${widget.loc.failed}: $failed\",",
      "                          style:",
      "                              TextStyle(color: widget.theme.colorScheme.error)),",
      "                    ],",
      "                  ),",
      "                  const SizedBox(height: 16),",
      "                  OutlinedButton.icon(",
      "                    icon: const Icon(Icons.payments_outlined),",
      "                    label: Text(widget.loc.viewPayouts),",
      "                    onPressed: () {",
      "                      Navigator.of(context).pushNamed('/hq/payouts');",
      "                    },",
      "                  ),",
      "                ],",
      "              ),",
      "            );",
      "          },",
      "        );",
      "      },",
      "    );",
      "  }",
      "}",
      "",
      "class _StatusDot extends StatelessWidget {",
      "  final Color color;",
      "  const _StatusDot({required this.color, Key? key}) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return CircleAvatar(radius: 6, backgroundColor: color);",
      "  }",
      "}",
      "",
      "class _AlertBanner extends StatelessWidget {",
      "  final AlertModel alert;",
      "  final ThemeData theme;",
      "  final AppLocalizations loc;",
      "  const _AlertBanner(",
      "      {required this.alert, required this.theme, required this.loc});",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final levelColor = alert.level == 'critical'",
      "        ? theme.colorScheme.error",
      "        : (alert.level == 'warning'",
      "            ? theme.colorScheme.secondary",
      "            : theme.colorScheme.primary);",
      "",
      "    return Card(",
      "        color: levelColor.withOpacity(0.12),",
      "        margin: EdgeInsets.zero,",
      "        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(7)),",
      "        child: ListTile(",
      "          leading: Icon(Icons.warning_rounded, color: levelColor),",
      "          title: Text(",
      "            alert.title.isNotEmpty",
      "                ? alert.title",
      "                : (alert.body.isNotEmpty",
      "                    ? alert.body",
      "                    : loc.payoutAlert ?? \"Payout alert\"),",
      "          ),",
      "          subtitle: alert.body.isNotEmpty",
      "              ? Text(alert.body)",
      "              : (alert.createdAt != null",
      "                  ? Text(MaterialLocalizations.of(context)",
      "                      .formatFullDate(alert.createdAt))",
      "                  : null),",
      "          trailing: IconButton(",
      "            icon: Icon(Icons.close, color: theme.disabledColor),",
      "            onPressed: () {",
      "              // Placeholder for dismiss",
      "              ScaffoldMessenger.of(context).showSnackBar(SnackBar(",
      "                  content: Text(loc.featureComingSoon('Payout History'))));",
      "            },",
      "          ),",
      "        ));",
      "  }",
      "}",
      "",
      "class _ErrorWidget extends StatelessWidget {",
      "  final String message;",
      "  final VoidCallback onRetry;",
      "  const _ErrorWidget({required this.message, required this.onRetry});",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final theme = Theme.of(context);",
      "    return Padding(",
      "      padding: const EdgeInsets.symmetric(vertical: 28),",
      "      child: Column(",
      "        mainAxisAlignment: MainAxisAlignment.center,",
      "        children: [",
      "          Icon(Icons.error_outline, color: theme.colorScheme.error),",
      "          const SizedBox(height: 12),",
      "          Text(",
      "            message,",
      "            style: theme.textTheme.bodyMedium",
      "                ?.copyWith(color: theme.colorScheme.error),",
      "            textAlign: TextAlign.center,",
      "          ),",
      "          const SizedBox(height: 10),",
      "          OutlinedButton.icon(",
      "            icon: const Icon(Icons.refresh),",
      "            label: Text(AppLocalizations.of(context)!.retry),",
      "            onPressed: onRetry,",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 253,
      "file_size": 9315,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\financials\\pay_invoice_dialog.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:provider/provider.dart';",
      "",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/models/platform_invoice.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/core/providers/role_guard.dart';",
      "",
      "class PayInvoiceDialog extends StatefulWidget {",
      "  final PlatformInvoice invoice;",
      "",
      "  PayInvoiceDialog({Key? key, required this.invoice}) : super(key: key) {",
      "    debugPrint(",
      "        '[PayInvoiceDialog] Constructor: invoice=${invoice.invoiceNumber}, id=${invoice.id}');",
      "  }",
      "",
      "  @override",
      "  State<PayInvoiceDialog> createState() => _PayInvoiceDialogState();",
      "}",
      "",
      "class _PayInvoiceDialogState extends State<PayInvoiceDialog> {",
      "  String? _selectedMethod;",
      "  bool _loading = false;",
      "",
      "  final List<String> _methods = ['Credit Card', 'PayPal', 'Check', 'ACH'];",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    debugPrint(",
      "        '[PayInvoiceDialog] build called for invoice=${widget.invoice.invoiceNumber}');",
      "    final loc = AppLocalizations.of(context)!;",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "",
      "    return RoleGuard(",
      "      allowedRoles: ['developer', 'hq_owner'],",
      "      featureName: 'PayPlatformInvoice',",
      "      screen: 'PayInvoiceDialog',",
      "      child: AlertDialog(",
      "        title: Text(loc.payInvoice),",
      "        content: Column(",
      "          mainAxisSize: MainAxisSize.min,",
      "          children: [",
      "            ListTile(",
      "              title:",
      "                  Text('${loc.invoiceNumber}: ${widget.invoice.invoiceNumber}'),",
      "              subtitle: Text(",
      "                  '${loc.total}: \\$${widget.invoice.amount.toStringAsFixed(2)}'),",
      "            ),",
      "            const SizedBox(height: 10),",
      "            DropdownButtonFormField<String>(",
      "              value: _selectedMethod,",
      "              decoration: InputDecoration(",
      "                labelText: loc.paymentMethod,",
      "                border: const OutlineInputBorder(),",
      "              ),",
      "              items: _methods",
      "                  .map((method) => DropdownMenuItem<String>(",
      "                        value: method,",
      "                        child: Text(method),",
      "                      ))",
      "                  .toList(),",
      "              onChanged: (val) {",
      "                setState(() {",
      "                  _selectedMethod = val;",
      "                });",
      "              },",
      "            ),",
      "            const SizedBox(height: 12),",
      "            Text(",
      "              loc.noteDevOnlyPlaceholder,",
      "              style: Theme.of(context).textTheme.bodySmall?.copyWith(",
      "                    color: colorScheme.onSurface.withOpacity(0.5),",
      "                  ),",
      "            ),",
      "          ],",
      "        ),",
      "        actions: [",
      "          TextButton(",
      "            onPressed: _loading ? null : () => Navigator.of(context).pop(),",
      "            child: Text(loc.cancel),",
      "          ),",
      "          ElevatedButton(",
      "            onPressed: _loading || _selectedMethod == null",
      "                ? null",
      "                : () async {",
      "                    setState(() => _loading = true);",
      "                    try {",
      "                      // TODO: Replace with actual payment integration logic",
      "                      await FirestoreService().markPlatformInvoicePaid(",
      "                          widget.invoice.id!, _selectedMethod!);",
      "                      Navigator.of(context).pop(true);",
      "                    } catch (e, stack) {",
      "                      await ErrorLogger.log(",
      "                        message: e.toString(),",
      "                        stack: stack.toString(),",
      "                        source: 'PayInvoiceDialog',",
      "                        screen: 'PayInvoiceDialog',",
      "                        severity: 'error',",
      "                        contextData: {",
      "                          'invoiceId': widget.invoice.id,",
      "                          'method': _selectedMethod,",
      "                        },",
      "                      );",
      "                      ScaffoldMessenger.of(context).showSnackBar(",
      "                        SnackBar(content: Text(loc.paymentFailed)),",
      "                      );",
      "                    } finally {",
      "                      if (mounted) setState(() => _loading = false);",
      "                    }",
      "                  },",
      "            child: _loading",
      "                ? const CircularProgressIndicator.adaptive()",
      "                : Text(loc.confirmPayment),",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 122,
      "file_size": 4691,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\financials\\platform_financial_kpi_row.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/config/branding_config.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "",
      "class PlatformFinancialKpiRow extends StatelessWidget {",
      "  final double mrr;",
      "  final double arr;",
      "  final int activeFranchises;",
      "  final double recentPayouts;",
      "",
      "  const PlatformFinancialKpiRow({",
      "    super.key,",
      "    required this.mrr,",
      "    required this.arr,",
      "    required this.activeFranchises,",
      "    required this.recentPayouts,",
      "  });",
      "",
      "  String _formatCurrency(BuildContext context, double value) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[PlatformFinancialKpiRow] loc is null! Localization not available for this context.');",
      "      // Return a sensible string fallback, NOT a widget:",
      "      return '--'; // Or value.toStringAsFixed(2)",
      "    }",
      "    return loc.currencyFormat(value);",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[Platform financial KIP row BUILD] loc is null! Localization not available for this context.');",
      "      // Handle gracefully or show fallback UI",
      "      return Scaffold(",
      "        body: Center(child: Text('Localization missing! [debug]')),",
      "      );",
      "    }",
      "    final theme = Theme.of(context);",
      "",
      "    final kpis = [",
      "      _KpiBlock(",
      "        label: loc.platformKpiMrr,",
      "        value: _formatCurrency(context, mrr),",
      "        color: BrandingConfig.brandRed,",
      "      ),",
      "      _KpiBlock(",
      "        label: loc.platformKpiArr,",
      "        value: _formatCurrency(context, arr),",
      "        color: theme.colorScheme.secondary,",
      "      ),",
      "      _KpiBlock(",
      "        label: loc.platformKpiActiveFranchises,",
      "        value: activeFranchises.toString(),",
      "        color: theme.colorScheme.primary,",
      "      ),",
      "      _KpiBlock(",
      "        label: loc.platformKpiRecentPayouts,",
      "        value: _formatCurrency(context, recentPayouts),",
      "        color: theme.colorScheme.tertiary,",
      "      ),",
      "      // 💡 Future Feature Placeholder (uncomment as needed)",
      "      // _KpiBlock(label: loc.platformKpiChurn, value: \"...\", color: Colors.orange),",
      "    ];",
      "",
      "    return LayoutBuilder(",
      "      builder: (context, constraints) {",
      "        final isWide = constraints.maxWidth > 800;",
      "        return Padding(",
      "          padding: const EdgeInsets.symmetric(vertical: 2.0, horizontal: 0),",
      "          child: isWide",
      "              ? Row(",
      "                  mainAxisAlignment: MainAxisAlignment.spaceBetween,",
      "                  children: kpis,",
      "                )",
      "              : Column(",
      "                  crossAxisAlignment: CrossAxisAlignment.start,",
      "                  children: kpis",
      "                      .map((w) => Padding(",
      "                            padding: const EdgeInsets.symmetric(vertical: 8),",
      "                            child: w,",
      "                          ))",
      "                      .toList(),",
      "                ),",
      "        );",
      "      },",
      "    );",
      "  }",
      "}",
      "",
      "class _KpiBlock extends StatelessWidget {",
      "  final String label;",
      "  final String value;",
      "  final Color color;",
      "",
      "  const _KpiBlock({",
      "    required this.label,",
      "    required this.value,",
      "    required this.color,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final theme = Theme.of(context);",
      "",
      "    return Container(",
      "      constraints: const BoxConstraints(minWidth: 120),",
      "      padding: const EdgeInsets.symmetric(vertical: 10, horizontal: 10),",
      "      decoration: BoxDecoration(",
      "        color: color.withOpacity(0.07),",
      "        borderRadius: BorderRadius.circular(DesignTokens.cardBorderRadiusSmall),",
      "        border: Border.all(",
      "          color: color.withOpacity(0.22),",
      "          width: 1.5,",
      "        ),",
      "      ),",
      "      child: Column(",
      "        crossAxisAlignment: CrossAxisAlignment.start,",
      "        children: [",
      "          Text(",
      "            value,",
      "            style: theme.textTheme.titleLarge?.copyWith(",
      "              color: color,",
      "              fontWeight: FontWeight.w700,",
      "              letterSpacing: -0.5,",
      "            ),",
      "            maxLines: 1,",
      "            overflow: TextOverflow.ellipsis,",
      "          ),",
      "          const SizedBox(height: 6),",
      "          Text(",
      "            label,",
      "            style: theme.textTheme.bodySmall?.copyWith(",
      "              color: color.withOpacity(0.9),",
      "              fontWeight: FontWeight.w500,",
      "            ),",
      "            maxLines: 2,",
      "            overflow: TextOverflow.ellipsis,",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 147,
      "file_size": 4581,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\financials\\platform_revenue_stats_row.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/config/branding_config.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "",
      "class PlatformRevenueStatsRow extends StatelessWidget {",
      "  final double totalRevenueYtd;",
      "  final double subscriptionRevenue;",
      "  final double royaltyRevenue;",
      "  final double overdueAmount;",
      "",
      "  const PlatformRevenueStatsRow({",
      "    super.key,",
      "    required this.totalRevenueYtd,",
      "    required this.subscriptionRevenue,",
      "    required this.royaltyRevenue,",
      "    required this.overdueAmount,",
      "  });",
      "",
      "  String _formatCurrency(BuildContext context, double value) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[_formatCurrency] loc is null! Localization not available for this context.');",
      "      // Return a sensible fallback string instead of a widget:",
      "      return value.toStringAsFixed(2); // Or just return '--'",
      "    }",
      "    // Uses intl/currency formatting per locale if available",
      "    return loc.currencyFormat(value);",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[PlatformRevenueStatsRow] loc is null! Localization not available for this context.');",
      "      return Card(",
      "        color: Colors.red.shade100,",
      "        child: Padding(",
      "          padding: const EdgeInsets.all(24),",
      "          child: Row(",
      "            children: [",
      "              Icon(Icons.error, color: Colors.red),",
      "              const SizedBox(width: 12),",
      "              Expanded(",
      "                  child: Text('Localization missing! [debug]',",
      "                      style: TextStyle(color: Colors.red))),",
      "            ],",
      "          ),",
      "        ),",
      "      );",
      "    }",
      "    final theme = Theme.of(context);",
      "    final isDark = theme.brightness == Brightness.dark;",
      "",
      "    // Modular/future expansion - add new stat blocks below as needed",
      "    final stats = [",
      "      _RevenueStatBlock(",
      "        label: loc.platformStatTotalRevenueYtd,",
      "        value: _formatCurrency(context, totalRevenueYtd),",
      "        highlight: true,",
      "      ),",
      "      _RevenueStatBlock(",
      "        label: loc.platformStatSubscriptionRevenue,",
      "        value: _formatCurrency(context, subscriptionRevenue),",
      "      ),",
      "      _RevenueStatBlock(",
      "        label: loc.platformStatRoyaltyRevenue,",
      "        value: _formatCurrency(context, royaltyRevenue),",
      "      ),",
      "      _RevenueStatBlock(",
      "        label: loc.platformStatOverdueAmount,",
      "        value: _formatCurrency(context, overdueAmount),",
      "        warning: overdueAmount > 0,",
      "      ),",
      "      // 💡 Future Feature Placeholders (uncomment/add here)",
      "      // _RevenueStatBlock(label: loc.platformStatRefunds, value: ...),",
      "    ];",
      "",
      "    return LayoutBuilder(",
      "      builder: (context, constraints) {",
      "        // Responsive: stack vertically on narrow screens",
      "        final isWide = constraints.maxWidth > 800;",
      "        return Padding(",
      "          padding: const EdgeInsets.symmetric(vertical: 4.0, horizontal: 0),",
      "          child: isWide",
      "              ? Row(",
      "                  mainAxisAlignment: MainAxisAlignment.spaceBetween,",
      "                  children: stats,",
      "                )",
      "              : Column(",
      "                  crossAxisAlignment: CrossAxisAlignment.start,",
      "                  children: stats",
      "                      .map((w) => Padding(",
      "                            padding: const EdgeInsets.symmetric(vertical: 8),",
      "                            child: w,",
      "                          ))",
      "                      .toList(),",
      "                ),",
      "        );",
      "      },",
      "    );",
      "  }",
      "}",
      "",
      "// Modular stat block with theme/config tokens",
      "class _RevenueStatBlock extends StatelessWidget {",
      "  final String label;",
      "  final String value;",
      "  final bool highlight;",
      "  final bool warning;",
      "",
      "  const _RevenueStatBlock({",
      "    required this.label,",
      "    required this.value,",
      "    this.highlight = false,",
      "    this.warning = false,",
      "  });",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "    final labelColor =",
      "        warning ? colorScheme.error : colorScheme.onSurfaceVariant;",
      "    final valueColor = highlight",
      "        ? BrandingConfig.brandRed",
      "        : (warning ? colorScheme.error : colorScheme.primary);",
      "",
      "    return Container(",
      "      constraints: const BoxConstraints(minWidth: 150),",
      "      padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 12),",
      "      decoration: BoxDecoration(",
      "        color: theme.colorScheme.surfaceVariant.withOpacity(0.13),",
      "        borderRadius: BorderRadius.circular(DesignTokens.cardBorderRadiusSmall),",
      "        border: Border.all(",
      "          color: warning",
      "              ? colorScheme.error",
      "              : (highlight",
      "                  ? BrandingConfig.brandRed.withOpacity(0.25)",
      "                  : colorScheme.outlineVariant.withOpacity(0.15)),",
      "          width: highlight ? 2 : 1,",
      "        ),",
      "      ),",
      "      child: Column(",
      "        crossAxisAlignment: CrossAxisAlignment.start,",
      "        children: [",
      "          Text(",
      "            value,",
      "            style: theme.textTheme.headlineMedium?.copyWith(",
      "              color: valueColor,",
      "              fontWeight: highlight ? FontWeight.bold : FontWeight.w600,",
      "              letterSpacing: -1,",
      "            ),",
      "            maxLines: 1,",
      "            overflow: TextOverflow.ellipsis,",
      "          ),",
      "          const SizedBox(height: 6),",
      "          Text(",
      "            label,",
      "            style: theme.textTheme.bodySmall?.copyWith(",
      "              color: labelColor,",
      "              fontWeight: FontWeight.w500,",
      "              letterSpacing: 0,",
      "            ),",
      "            maxLines: 2,",
      "            overflow: TextOverflow.ellipsis,",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 174,
      "file_size": 5858,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\financials\\platform_revenue_summary_panel.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "import 'package:franchise_admin_portal/config/branding_config.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:franchise_admin_portal/widgets/financials/platform_revenue_stats_row.dart';",
      "import 'package:franchise_admin_portal/widgets/financials/platform_financial_kpi_row.dart';",
      "import 'package:provider/provider.dart';",
      "",
      "class PlatformRevenueSummaryPanel extends StatefulWidget {",
      "  const PlatformRevenueSummaryPanel({super.key});",
      "",
      "  @override",
      "  State<PlatformRevenueSummaryPanel> createState() =>",
      "      _PlatformRevenueSummaryPanelState();",
      "}",
      "",
      "class _PlatformRevenueSummaryPanelState",
      "    extends State<PlatformRevenueSummaryPanel> {",
      "  bool _loading = true;",
      "  bool _error = false;",
      "  String? _errorMsg;",
      "",
      "  // Revenue Overview Data (Top Row)",
      "  double totalRevenueYtd = 0;",
      "  double subscriptionRevenue = 0;",
      "  double royaltyRevenue = 0;",
      "  double overdueAmount = 0;",
      "",
      "  // KPIs (Second Row)",
      "  double mrr = 0;",
      "  double arr = 0;",
      "  int activeFranchises = 0;",
      "  double recentPayouts = 0;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _loadPlatformFinancials();",
      "  }",
      "",
      "  Future<void> _loadPlatformFinancials() async {",
      "    setState(() {",
      "      _loading = true;",
      "      _error = false;",
      "      _errorMsg = null;",
      "    });",
      "",
      "    try {",
      "      // You should implement/extend these methods in firestore_service.dart",
      "      final financials =",
      "          await FirestoreService().fetchPlatformRevenueOverview();",
      "      final kpis = await FirestoreService().fetchPlatformFinancialKpis();",
      "",
      "      setState(() {",
      "        totalRevenueYtd = financials.totalRevenueYtd;",
      "        subscriptionRevenue = financials.subscriptionRevenue;",
      "        royaltyRevenue = financials.royaltyRevenue;",
      "        overdueAmount = financials.overdueAmount;",
      "",
      "        mrr = kpis.mrr;",
      "        arr = kpis.arr;",
      "        activeFranchises = kpis.activeFranchises;",
      "        recentPayouts = kpis.recentPayouts;",
      "        _loading = false;",
      "      });",
      "    } catch (e, stack) {",
      "      await ErrorLogger.log(",
      "        message: e.toString(),",
      "        stack: stack.toString(),",
      "        source: 'PlatformRevenueSummaryPanel',",
      "        screen: '_loadPlatformFinancials',",
      "        severity: 'error',",
      "        contextData: {",
      "          'userEmail': Provider.of<AdminUserProvider>(context, listen: false)",
      "              .user",
      "              ?.email,",
      "        },",
      "      );",
      "      setState(() {",
      "        _error = true;",
      "        _errorMsg = e.toString();",
      "        _loading = false;",
      "      });",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[PlatformRevenueSummaryPanel] loc is null! Localization not available for this context.');",
      "      return Card(",
      "        color: Colors.red.shade100,",
      "        child: Padding(",
      "          padding: const EdgeInsets.all(24),",
      "          child: Row(",
      "            children: [",
      "              Icon(Icons.error, color: Colors.red),",
      "              const SizedBox(width: 12),",
      "              Expanded(",
      "                  child: Text('Localization missing! [debug]',",
      "                      style: TextStyle(color: Colors.red))),",
      "            ],",
      "          ),",
      "        ),",
      "      );",
      "    }",
      "    final theme = Theme.of(context);",
      "    final isDark = theme.brightness == Brightness.dark;",
      "",
      "    return Card(",
      "      elevation: 0,",
      "      margin: EdgeInsets.symmetric(vertical: 12, horizontal: 0),",
      "      color:",
      "          isDark ? theme.colorScheme.surfaceVariant : theme.colorScheme.surface,",
      "      shape: RoundedRectangleBorder(",
      "        borderRadius: BorderRadius.circular(DesignTokens.cardBorderRadiusLarge),",
      "      ),",
      "      child: Padding(",
      "        padding: const EdgeInsets.all(28.0),",
      "        child: Column(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            Text(",
      "              loc.platformOwnerRevenueSummaryTitle,",
      "              style: theme.textTheme.titleLarge?.copyWith(",
      "                color: BrandingConfig.brandRed,",
      "                fontWeight: FontWeight.bold,",
      "              ),",
      "            ),",
      "            const SizedBox(height: 12),",
      "            if (_loading)",
      "              Center(child: CircularProgressIndicator())",
      "            else if (_error)",
      "              Column(",
      "                children: [",
      "                  Text(",
      "                    loc.genericErrorOccurred,",
      "                    style: theme.textTheme.bodyMedium?.copyWith(",
      "                      color: theme.colorScheme.error,",
      "                    ),",
      "                  ),",
      "                  if (_errorMsg != null)",
      "                    Text(",
      "                      _errorMsg!,",
      "                      style: theme.textTheme.bodySmall?.copyWith(",
      "                        color: theme.colorScheme.error,",
      "                      ),",
      "                    ),",
      "                  const SizedBox(height: 10),",
      "                  ElevatedButton(",
      "                    onPressed: _loadPlatformFinancials,",
      "                    child: Text(loc.retry),",
      "                  ),",
      "                ],",
      "              )",
      "            else",
      "              Column(",
      "                crossAxisAlignment: CrossAxisAlignment.start,",
      "                children: [",
      "                  // Top Row: Revenue Overview",
      "                  PlatformRevenueStatsRow(",
      "                    totalRevenueYtd: totalRevenueYtd,",
      "                    subscriptionRevenue: subscriptionRevenue,",
      "                    royaltyRevenue: royaltyRevenue,",
      "                    overdueAmount: overdueAmount,",
      "                  ),",
      "                  const SizedBox(height: 24),",
      "                  // Second Row: KPIs and Projections",
      "                  PlatformFinancialKpiRow(",
      "                    mrr: mrr,",
      "                    arr: arr,",
      "                    activeFranchises: activeFranchises,",
      "                    recentPayouts: recentPayouts,",
      "                  ),",
      "                  const SizedBox(height: 10),",
      "                  // Future Feature Placeholder",
      "                  if (false)",
      "                    Padding(",
      "                      padding: const EdgeInsets.only(top: 18.0),",
      "                      child: Text(",
      "                        '[Future: SaaS Churn Rate, Growth Cohorts, ARPU]',",
      "                        style: theme.textTheme.labelMedium?.copyWith(",
      "                          color: theme.colorScheme.outline,",
      "                        ),",
      "                      ),",
      "                    ),",
      "                ],",
      "              ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 199,
      "file_size": 6861,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\financials\\revenue_stat_card.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:intl/intl.dart';",
      "",
      "enum RevenuePeriod { daily, weekly, monthly }",
      "",
      "class RevenueStatCard extends StatefulWidget {",
      "  final String franchiseId;",
      "  const RevenueStatCard({Key? key, required this.franchiseId})",
      "      : super(key: key);",
      "",
      "  @override",
      "  State<RevenueStatCard> createState() => _RevenueStatCardState();",
      "}",
      "",
      "class _RevenueStatCardState extends State<RevenueStatCard> {",
      "  RevenuePeriod _period = RevenuePeriod.daily;",
      "",
      "  String get _label {",
      "    switch (_period) {",
      "      case RevenuePeriod.daily:",
      "        return 'Total Revenue (Today)';",
      "      case RevenuePeriod.weekly:",
      "        return 'Total Revenue (This Week)';",
      "      case RevenuePeriod.monthly:",
      "        return 'Total Revenue (This Month)';",
      "    }",
      "  }",
      "",
      "  String get _tooltip {",
      "    switch (_period) {",
      "      case RevenuePeriod.daily:",
      "        return 'Total revenue for today';",
      "      case RevenuePeriod.weekly:",
      "        return 'Total revenue for this week';",
      "      case RevenuePeriod.monthly:",
      "        return 'Total revenue for this month';",
      "    }",
      "  }",
      "",
      "  Future<double> _getValue(BuildContext context, String franchiseId) {",
      "    final firestore = context.read<FirestoreService>();",
      "    switch (_period) {",
      "      case RevenuePeriod.daily:",
      "        return firestore.getTotalRevenueToday(franchiseId);",
      "      case RevenuePeriod.weekly:",
      "        return firestore.getTotalRevenueForPeriod(franchiseId, 'week');",
      "      case RevenuePeriod.monthly:",
      "        return firestore.getTotalRevenueForPeriod(franchiseId, 'month');",
      "      default:",
      "        return Future.value(0);",
      "    }",
      "  }",
      "",
      "  String _formatValue(double value) {",
      "    final formatter = NumberFormat.simpleCurrency(decimalDigits: 2);",
      "    return formatter.format(value);",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final cardColor = Theme.of(context).colorScheme.primary;",
      "    final background = Theme.of(context).cardColor;",
      "",
      "    return Semantics(",
      "      label: _label,",
      "      container: true,",
      "      child: Tooltip(",
      "        message: _tooltip,",
      "        child: Card(",
      "          elevation: 3,",
      "          margin: const EdgeInsets.all(8),",
      "          shape: RoundedRectangleBorder(",
      "            borderRadius: BorderRadius.circular(16),",
      "          ),",
      "          child: Stack(",
      "            children: [",
      "              // Menu at top right, absolute",
      "              Positioned(",
      "                right: 6,",
      "                top: 6,",
      "                child: PopupMenuButton<RevenuePeriod>(",
      "                  icon: const Icon(Icons.more_vert),",
      "                  tooltip: 'Select period',",
      "                  onSelected: (period) {",
      "                    setState(() {",
      "                      _period = period;",
      "                    });",
      "                  },",
      "                  itemBuilder: (context) => [",
      "                    PopupMenuItem(",
      "                      value: RevenuePeriod.daily,",
      "                      child: Text('Today'),",
      "                    ),",
      "                    PopupMenuItem(",
      "                      value: RevenuePeriod.weekly,",
      "                      child: Text('This Week'),",
      "                    ),",
      "                    PopupMenuItem(",
      "                      value: RevenuePeriod.monthly,",
      "                      child: Text('This Month'),",
      "                    ),",
      "                  ],",
      "                ),",
      "              ),",
      "              // Main KPI column, always vertically centered",
      "              Padding(",
      "                padding: const EdgeInsets.all(20),",
      "                child: Center(",
      "                  child: FutureBuilder<double>(",
      "                    future: _getValue(context, widget.franchiseId),",
      "                    builder: (context, snapshot) {",
      "                      if (snapshot.connectionState == ConnectionState.waiting) {",
      "                        return Column(",
      "                          mainAxisSize: MainAxisSize.min,",
      "                          mainAxisAlignment: MainAxisAlignment.center,",
      "                          children: [",
      "                            Container(",
      "                              decoration: BoxDecoration(",
      "                                color: cardColor.withOpacity(0.12),",
      "                                borderRadius: BorderRadius.circular(10),",
      "                              ),",
      "                              padding: const EdgeInsets.all(10),",
      "                              child: Icon(",
      "                                Icons.attach_money,",
      "                                color: cardColor,",
      "                                size: 36,",
      "                              ),",
      "                            ),",
      "                            const SizedBox(height: 14),",
      "                            CircularProgressIndicator(",
      "                              valueColor:",
      "                                  AlwaysStoppedAnimation<Color>(cardColor),",
      "                            ),",
      "                            const SizedBox(height: 8),",
      "                          ],",
      "                        );",
      "                      }",
      "                      if (snapshot.hasError) {",
      "                        return Column(",
      "                          mainAxisSize: MainAxisSize.min,",
      "                          mainAxisAlignment: MainAxisAlignment.center,",
      "                          children: [",
      "                            Container(",
      "                              decoration: BoxDecoration(",
      "                                color: cardColor.withOpacity(0.12),",
      "                                borderRadius: BorderRadius.circular(10),",
      "                              ),",
      "                              padding: const EdgeInsets.all(10),",
      "                              child: Icon(",
      "                                Icons.attach_money,",
      "                                color: cardColor,",
      "                                size: 36,",
      "                              ),",
      "                            ),",
      "                            const SizedBox(height: 14),",
      "                            Icon(Icons.error, color: Colors.red, size: 28),",
      "                            Text('Error', style: TextStyle(color: Colors.red)),",
      "                          ],",
      "                        );",
      "                      }",
      "                      final value = snapshot.data ?? 0.0;",
      "                      final display = _formatValue(value);",
      "",
      "                      return Column(",
      "                        mainAxisAlignment: MainAxisAlignment.center,",
      "                        mainAxisSize: MainAxisSize.min,",
      "                        children: [",
      "                          Container(",
      "                            decoration: BoxDecoration(",
      "                              color: cardColor.withOpacity(0.12),",
      "                              borderRadius: BorderRadius.circular(10),",
      "                            ),",
      "                            padding: const EdgeInsets.all(10),",
      "                            child: Icon(",
      "                              Icons.attach_money,",
      "                              color: cardColor,",
      "                              size: 36,",
      "                            ),",
      "                          ),",
      "                          const SizedBox(height: 14),",
      "                          Flexible(",
      "                            child: FittedBox(",
      "                              fit: BoxFit.scaleDown,",
      "                              child: Text(",
      "                                display,",
      "                                style: TextStyle(",
      "                                  fontSize: 32,",
      "                                  fontWeight: FontWeight.bold,",
      "                                  color: cardColor,",
      "                                ),",
      "                                semanticsLabel: display,",
      "                              ),",
      "                            ),",
      "                          ),",
      "                          const SizedBox(height: 6),",
      "                          Flexible(",
      "                            child: FittedBox(",
      "                              fit: BoxFit.scaleDown,",
      "                              child: Text(",
      "                                _label,",
      "                                style: Theme.of(context)",
      "                                    .textTheme",
      "                                    .bodyMedium",
      "                                    ?.copyWith(",
      "                                      color: Theme.of(context)",
      "                                          .colorScheme",
      "                                          .onSurface,",
      "                                    ),",
      "                                textAlign: TextAlign.center,",
      "                              ),",
      "                            ),",
      "                          ),",
      "                        ],",
      "                      );",
      "                    },",
      "                  ),",
      "                ),",
      "              ),",
      "            ],",
      "          ),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 227,
      "file_size": 8895,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\header\\cart_icon_badge.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "",
      "/// Displays a shopping cart icon with a dynamic badge count.",
      "/// Pass in a [cartItemCountStream] that emits the item count as an integer.",
      "/// The [onPressed] callback is called when the icon is tapped.",
      "/// [tooltip], [iconColor], [badgeColor], [iconSize] are all customizable.",
      "class CartIconBadge extends StatelessWidget {",
      "  final Stream<int> cartItemCountStream;",
      "  final VoidCallback? onPressed;",
      "  final String? tooltip;",
      "  final Color? iconColor;",
      "  final Color? badgeColor;",
      "  final double? iconSize;",
      "",
      "  const CartIconBadge({",
      "    Key? key,",
      "    required this.cartItemCountStream,",
      "    this.onPressed,",
      "    this.tooltip,",
      "    this.iconColor,",
      "    this.badgeColor,",
      "    this.iconSize,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return StreamBuilder<int>(",
      "      stream: cartItemCountStream,",
      "      initialData: 0,",
      "      builder: (context, snapshot) {",
      "        final cartItems = snapshot.data ?? 0;",
      "        return IconButton(",
      "          icon: Stack(",
      "            clipBehavior: Clip.none,",
      "            children: [",
      "              Icon(",
      "                Icons.shopping_cart,",
      "                size: iconSize ?? DesignTokens.iconSize,",
      "                color: iconColor ?? DesignTokens.foregroundColor,",
      "                semanticLabel: tooltip,",
      "              ),",
      "              if (cartItems > 0)",
      "                Positioned(",
      "                  right: -2,",
      "                  top: -2,",
      "                  child: Container(",
      "                    padding:",
      "                        const EdgeInsets.all(DesignTokens.cartBadgePadding),",
      "                    decoration: BoxDecoration(",
      "                      color: badgeColor ?? DesignTokens.errorColor,",
      "                      borderRadius:",
      "                          BorderRadius.circular(DesignTokens.badgeRadius),",
      "                    ),",
      "                    constraints: const BoxConstraints(",
      "                      minWidth: DesignTokens.badgeMinSize,",
      "                      minHeight: DesignTokens.badgeMinSize,",
      "                    ),",
      "                    child: Text(",
      "                      '$cartItems',",
      "                      style: const TextStyle(",
      "                        color: DesignTokens.foregroundColor,",
      "                        fontSize: DesignTokens.captionFontSize,",
      "                        fontWeight: DesignTokens.titleFontWeight,",
      "                      ),",
      "                      textAlign: TextAlign.center,",
      "                    ),",
      "                  ),",
      "                ),",
      "            ],",
      "          ),",
      "          tooltip: tooltip,",
      "          onPressed: onPressed,",
      "        );",
      "      },",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 78,
      "file_size": 2730,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\header\\franchise_app_bar.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "",
      "/// A modular, franchise-ready AppBar widget.",
      "/// Expandable: supports title, logo, subtitle, custom actions, colors, and more.",
      "class FranchiseAppBar extends StatelessWidget implements PreferredSizeWidget {",
      "  final String title;",
      "  final TextStyle? titleStyle;",
      "  final bool centerTitle;",
      "  final bool showLogo;",
      "  final String? logoAsset;",
      "  final double logoHeight;",
      "  final List<Widget>? actions;",
      "  final Widget? leading;",
      "  final Color? backgroundColor;",
      "  final Color? foregroundColor;",
      "  final double? elevation;",
      "  final bool showBottomDivider;",
      "  final PreferredSizeWidget? bottom;",
      "",
      "  /// For further expansion: add subtitle, back button logic, etc.",
      "  const FranchiseAppBar({",
      "    Key? key,",
      "    required this.title,",
      "    this.titleStyle,",
      "    this.centerTitle = true,",
      "    this.showLogo = false,",
      "    this.logoAsset,",
      "    this.logoHeight = 40,",
      "    this.actions,",
      "    this.leading,",
      "    this.backgroundColor,",
      "    this.foregroundColor,",
      "    this.elevation,",
      "    this.showBottomDivider = false,",
      "    this.bottom,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Size get preferredSize =>",
      "      Size.fromHeight(kToolbarHeight + (bottom?.preferredSize.height ?? 0));",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final theme = Theme.of(context);",
      "    final colorScheme = theme.colorScheme;",
      "    final bool displayLogo =",
      "        showLogo && logoAsset != null && logoAsset!.isNotEmpty;",
      "",
      "    final Color appBarBg = backgroundColor ??",
      "        theme.appBarTheme.backgroundColor ??",
      "        colorScheme.primary;",
      "    final Color appBarFg = foregroundColor ??",
      "        theme.appBarTheme.foregroundColor ??",
      "        colorScheme.onPrimary;",
      "    final double appBarElevation =",
      "        elevation ?? theme.appBarTheme.elevation ?? 0;",
      "",
      "    final titleWidget = displayLogo",
      "        ? Row(",
      "            mainAxisSize: MainAxisSize.min,",
      "            children: [",
      "              Image.asset(",
      "                logoAsset!,",
      "                height: logoHeight,",
      "                fit: BoxFit.contain,",
      "                semanticLabel: title,",
      "              ),",
      "              const SizedBox(width: 10),",
      "              Flexible(",
      "                child: Text(",
      "                  title,",
      "                  style: titleStyle ??",
      "                      TextStyle(",
      "                        fontSize: DesignTokens.titleFontSize,",
      "                        fontWeight: DesignTokens.titleFontWeight,",
      "                        fontFamily: DesignTokens.fontFamily,",
      "                        color: appBarFg,",
      "                      ),",
      "                  maxLines: 1,",
      "                  overflow: TextOverflow.ellipsis,",
      "                ),",
      "              ),",
      "            ],",
      "          )",
      "        : Text(",
      "            title,",
      "            style: titleStyle ??",
      "                TextStyle(",
      "                  fontSize: DesignTokens.titleFontSize,",
      "                  fontWeight: DesignTokens.titleFontWeight,",
      "                  fontFamily: DesignTokens.fontFamily,",
      "                  color: appBarFg,",
      "                ),",
      "            maxLines: 1,",
      "            overflow: TextOverflow.ellipsis,",
      "          );",
      "",
      "    // Divider: Use dividerColor from theme",
      "    final dividerColor = Theme.of(context).dividerColor;",
      "",
      "    return AppBar(",
      "      backgroundColor: appBarBg,",
      "      elevation: appBarElevation,",
      "      centerTitle: displayLogo ? false : centerTitle,",
      "      iconTheme: IconThemeData(",
      "        color: appBarFg,",
      "      ),",
      "      leading: leading,",
      "      title: titleWidget,",
      "      actions: actions,",
      "      bottom: showBottomDivider",
      "          ? PreferredSize(",
      "              preferredSize: const Size.fromHeight(1.0),",
      "              child: Container(",
      "                color: dividerColor,",
      "                height: 1.0,",
      "              ),",
      "            )",
      "          : bottom,",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 123,
      "file_size": 3885,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\header\\help_icon_button.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/widgets/help/help_dialog.dart';",
      "",
      "class HelpIconButton extends StatelessWidget {",
      "  const HelpIconButton({Key? key}) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final isDark = Theme.of(context).brightness == Brightness.dark;",
      "",
      "    return IconButton(",
      "      tooltip: 'Help & Support',",
      "      icon: Icon(",
      "        Icons.help_outline,",
      "        color: isDark ? Colors.white : Colors.black,",
      "      ),",
      "      onPressed: () => showDialog(",
      "        context: context,",
      "        builder: (_) => const HelpDialog(),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 23,
      "file_size": 648,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\header\\notifications_icon_button.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "",
      "class NotificationsIconButton extends StatefulWidget {",
      "  const NotificationsIconButton({Key? key}) : super(key: key);",
      "",
      "  @override",
      "  State<NotificationsIconButton> createState() =>",
      "      _NotificationsIconButtonState();",
      "}",
      "",
      "class _NotificationsIconButtonState extends State<NotificationsIconButton> {",
      "  bool _panelOpen = false;",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final isDark = Theme.of(context).brightness == Brightness.dark;",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "",
      "    final int notificationCount = 0; // TODO: Replace with real data source",
      "",
      "    return SizedBox(",
      "      width: 48,",
      "      height: 48,",
      "      child: Stack(",
      "        clipBehavior: Clip.none,",
      "        children: [",
      "          Positioned.fill(",
      "            child: IconButton(",
      "              tooltip: \"Notifications\",",
      "              icon: Icon(",
      "                Icons.notifications_none_outlined,",
      "                color: isDark ? Colors.white : Colors.black,",
      "              ),",
      "              onPressed: () async {",
      "                setState(() => _panelOpen = !_panelOpen);",
      "                if (_panelOpen) {",
      "                  await showDialog(",
      "                    context: context,",
      "                    builder: (_) => Dialog(",
      "                      backgroundColor: colorScheme.background,",
      "                      shape: RoundedRectangleBorder(",
      "                        borderRadius: BorderRadius.circular(12),",
      "                      ),",
      "                      child: const SizedBox(",
      "                        width: 340,",
      "                        height: 400,",
      "                        child: Center(child: Text(\"No notifications.\")),",
      "                        // TODO: Replace with NotificationsPanel(notifications: [])",
      "                      ),",
      "                    ),",
      "                  );",
      "                  setState(() => _panelOpen = false);",
      "                }",
      "              },",
      "            ),",
      "          ),",
      "          if (notificationCount > 0)",
      "            Positioned(",
      "              right: 8,",
      "              top: 10,",
      "              child: Container(",
      "                width: 10,",
      "                height: 10,",
      "                decoration: BoxDecoration(",
      "                  color: colorScheme.error,",
      "                  shape: BoxShape.circle,",
      "                ),",
      "              ),",
      "            ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 74,
      "file_size": 2398,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\header\\profile_icon_button.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "",
      "/// A modular profile icon button for AppBars, easily reused across the app.",
      "/// Supports custom icon, tooltip, color, and onPressed logic.",
      "class ProfileIconButton extends StatelessWidget {",
      "  final VoidCallback? onPressed;",
      "  final String? tooltip;",
      "  final Color? iconColor;",
      "  final double? iconSize;",
      "",
      "  const ProfileIconButton({",
      "    Key? key,",
      "    this.onPressed,",
      "    this.tooltip,",
      "    this.iconColor,",
      "    this.iconSize,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return IconButton(",
      "      icon: Icon(",
      "        Icons.person,",
      "        size: iconSize ?? DesignTokens.iconSize,",
      "        color: iconColor ?? DesignTokens.foregroundColor,",
      "        semanticLabel: tooltip,",
      "      ),",
      "      tooltip: tooltip,",
      "      onPressed: onPressed,",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 33,
      "file_size": 913,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\header\\settings_icon_button.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/widgets/settings/settings_dialog.dart';",
      "",
      "class SettingsIconButton extends StatelessWidget {",
      "  const SettingsIconButton({Key? key}) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final isDark = Theme.of(context).brightness == Brightness.dark;",
      "",
      "    return IconButton(",
      "      tooltip: 'Settings',",
      "      icon: Icon(",
      "        Icons.settings,",
      "        color: isDark ? Colors.white : Colors.black,",
      "      ),",
      "      onPressed: () => showDialog(",
      "        context: context,",
      "        builder: (_) => const SettingsDialog(),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 23,
      "file_size": 658,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\help\\contact_support_section.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "",
      "class ContactSupportSection extends StatelessWidget {",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        Text(\"Contact Support\", style: Theme.of(context).textTheme.titleMedium),",
      "        const SizedBox(height: 8),",
      "        Text(\"Email: support@doughboyspizza.com\"),",
      "        Text(\"Phone: +1 (800) 555-1234\"),",
      "        const SizedBox(height: 8),",
      "        OutlinedButton.icon(",
      "          icon: const Icon(Icons.chat_bubble_outline),",
      "          label: const Text(\"Start Live Chat\"),",
      "          onPressed: () {",
      "            ScaffoldMessenger.of(context).showSnackBar(",
      "                const SnackBar(content: Text('Live chat coming soon!')));",
      "          },",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 25,
      "file_size": 838,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\help\\faq_section.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "",
      "class FAQSection extends StatelessWidget {",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        Text(\"Frequently Asked Questions\",",
      "            style: Theme.of(context).textTheme.titleMedium),",
      "        const SizedBox(height: 8),",
      "        Text(",
      "            \"Q: How do I reset my password?\\nA: Go to settings > reset password.\"),",
      "        Text(\"Q: How do I contact support?\\nA: Use the contact section above.\"),",
      "        const SizedBox(height: 8),",
      "        Text(\"More FAQs coming soon...\",",
      "            style: Theme.of(context).textTheme.bodySmall),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 21,
      "file_size": 720,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\help\\help_dialog.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/widgets/help/contact_support_section.dart';",
      "import 'package:franchise_admin_portal/widgets/help/faq_section.dart';",
      "import 'package:franchise_admin_portal/widgets/help/release_notes_section.dart';",
      "import 'package:franchise_admin_portal/widgets/help/shortcuts_guide_section.dart';",
      "",
      "class HelpDialog extends StatelessWidget {",
      "  const HelpDialog({Key? key}) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    return Dialog(",
      "      backgroundColor: colorScheme.background,",
      "      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),",
      "      child: SingleChildScrollView(",
      "        padding: const EdgeInsets.all(28),",
      "        child: Column(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            Text(\"Help & Support\",",
      "                style: Theme.of(context).textTheme.headlineSmall),",
      "            const SizedBox(height: 24),",
      "            ContactSupportSection(),",
      "            const Divider(height: 32),",
      "            FAQSection(),",
      "            const Divider(height: 32),",
      "            ReleaseNotesSection(),",
      "            const Divider(height: 32),",
      "            ShortcutsGuideSection(),",
      "            const SizedBox(height: 8),",
      "            Align(",
      "              alignment: Alignment.bottomRight,",
      "              child: TextButton(",
      "                onPressed: () => Navigator.of(context).pop(),",
      "                child: const Text(\"Close\"),",
      "              ),",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 44,
      "file_size": 1644,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\help\\release_notes_section.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "",
      "class ReleaseNotesSection extends StatelessWidget {",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        Text(\"Release Notes\", style: Theme.of(context).textTheme.titleMedium),",
      "        const SizedBox(height: 8),",
      "        Text(\"v1.0.0 - Initial release of Doughboys Franchise Admin Portal.\"),",
      "        const SizedBox(height: 8),",
      "        Text(\"Release notes and new features will appear here.\"),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 17,
      "file_size": 566,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\help\\shortcuts_guide_section.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "",
      "class ShortcutsGuideSection extends StatelessWidget {",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        Text(\"Shortcuts Guide\", style: Theme.of(context).textTheme.titleMedium),",
      "        const SizedBox(height: 8),",
      "        Text(\"Shortcuts coming soon!\"),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 15,
      "file_size": 428,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\orders\\export_analytics_dialog.dart",
    "content": [
      "import 'dart:io';",
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/models/analytics_summary.dart';",
      "import 'package:franchise_admin_portal/core/utils/export_utils.dart';",
      "import 'package:share_plus/share_plus.dart';",
      "import 'package:path_provider/path_provider.dart';",
      "",
      "class ExportAnalyticsDialogSingleSummary extends StatelessWidget {",
      "  final AnalyticsSummary summary;",
      "",
      "  const ExportAnalyticsDialogSingleSummary({super.key, required this.summary});",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final csv = ExportUtils.analyticsSummaryToCsv(context, summary);",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    final textTheme = Theme.of(context).textTheme;",
      "",
      "    return AlertDialog(",
      "      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(22)),",
      "      backgroundColor: colorScheme.surface,",
      "      title: Text(",
      "        'Export Analytics Data',",
      "        style: textTheme.titleLarge?.copyWith(",
      "          fontWeight: FontWeight.bold,",
      "          color: colorScheme.onSurface,",
      "        ),",
      "        textAlign: TextAlign.center,",
      "      ),",
      "      content: Column(",
      "        mainAxisSize: MainAxisSize.min,",
      "        children: [",
      "          Text(",
      "            'Analytics export generated.',",
      "            style: textTheme.bodyMedium?.copyWith(",
      "              color: Colors.green,",
      "              fontWeight: FontWeight.w500,",
      "            ),",
      "          ),",
      "          const SizedBox(height: 8),",
      "          Container(",
      "            padding: const EdgeInsets.all(8),",
      "            decoration: BoxDecoration(",
      "              color: colorScheme.surfaceVariant,",
      "              borderRadius: BorderRadius.circular(8),",
      "              border: Border.all(color: colorScheme.outline.withOpacity(0.4)),",
      "            ),",
      "            constraints: const BoxConstraints(maxHeight: 220),",
      "            child: SingleChildScrollView(",
      "              child: SelectableText(",
      "                csv,",
      "                style: textTheme.bodySmall?.copyWith(",
      "                  fontFamily: 'monospace',",
      "                  fontSize: 12,",
      "                  color: colorScheme.onSurface,",
      "                ),",
      "              ),",
      "            ),",
      "          ),",
      "        ],",
      "      ),",
      "      actions: [",
      "        Padding(",
      "          padding: const EdgeInsets.only(bottom: 16, left: 8, right: 8, top: 8),",
      "          child: Row(",
      "            mainAxisAlignment: MainAxisAlignment.spaceEvenly,",
      "            children: [",
      "              SizedBox(",
      "                width: 100,",
      "                height: 40,",
      "                child: OutlinedButton.icon(",
      "                  icon: const Icon(Icons.share, size: 24),",
      "                  label: const Text('Share', style: TextStyle(fontSize: 18)),",
      "                  style: OutlinedButton.styleFrom(",
      "                    side:",
      "                        BorderSide(color: DesignTokens.primaryColor, width: 2),",
      "                    foregroundColor: DesignTokens.primaryColor,",
      "                    backgroundColor: colorScheme.surface,",
      "                    shape: RoundedRectangleBorder(",
      "                      borderRadius: BorderRadius.circular(22),",
      "                    ),",
      "                    padding: const EdgeInsets.symmetric(vertical: 4),",
      "                  ),",
      "                  onPressed: () async {",
      "                    final dir = await getTemporaryDirectory();",
      "                    final file = File(",
      "                      '${dir.path}/analytics_export_${summary.period}.csv',",
      "                    );",
      "                    await file.writeAsString(csv);",
      "                    await Share.shareXFiles(",
      "                      [XFile(file.path)],",
      "                      text: 'Analytics Export (${summary.period})',",
      "                    );",
      "                  },",
      "                ),",
      "              ),",
      "              const SizedBox(width: 16),",
      "              SizedBox(",
      "                width: 100,",
      "                height: 40,",
      "                child: ElevatedButton(",
      "                  onPressed: () => Navigator.of(context).pop(),",
      "                  style: ElevatedButton.styleFrom(",
      "                    backgroundColor: DesignTokens.primaryColor,",
      "                    foregroundColor: Colors.white,",
      "                    textStyle: const TextStyle(",
      "                      fontSize: 18,",
      "                      fontWeight: FontWeight.w600,",
      "                    ),",
      "                    shape: RoundedRectangleBorder(",
      "                      borderRadius: BorderRadius.circular(22),",
      "                    ),",
      "                    padding: const EdgeInsets.symmetric(vertical: 4),",
      "                  ),",
      "                  child: const Text('Close'),",
      "                ),",
      "              ),",
      "            ],",
      "          ),",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 125,
      "file_size": 4784,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\orders\\feedback_card.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "import 'package:franchise_admin_portal/core/models/analytics_summary.dart';",
      "",
      "class FeedbackCard extends StatelessWidget {",
      "  final AnalyticsSummary summary;",
      "",
      "  const FeedbackCard({super.key, required this.summary});",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    final textTheme = Theme.of(context).textTheme;",
      "",
      "    return Card(",
      "      color: colorScheme.surface,",
      "      elevation: 2,",
      "      margin: const EdgeInsets.symmetric(vertical: 6),",
      "      shape: RoundedRectangleBorder(",
      "        borderRadius: BorderRadius.circular(14),",
      "      ),",
      "      child: IntrinsicHeight(",
      "        child: Row(",
      "          crossAxisAlignment: CrossAxisAlignment.stretch,",
      "          children: [",
      "            Container(",
      "              width: 5,",
      "              decoration: BoxDecoration(",
      "                color: DesignTokens.primaryColor.withOpacity(0.9),",
      "                borderRadius: const BorderRadius.only(",
      "                  topLeft: Radius.circular(14),",
      "                  bottomLeft: Radius.circular(14),",
      "                ),",
      "              ),",
      "            ),",
      "            Expanded(",
      "              child: Padding(",
      "                padding: const EdgeInsets.all(16),",
      "                child: Column(",
      "                  crossAxisAlignment: CrossAxisAlignment.start,",
      "                  children: [",
      "                    Wrap(",
      "                      spacing: 16,",
      "                      runSpacing: 8,",
      "                      crossAxisAlignment: WrapCrossAlignment.center,",
      "                      children: [",
      "                        Row(",
      "                          mainAxisSize: MainAxisSize.min,",
      "                          children: [",
      "                            Icon(Icons.star_rounded,",
      "                                color: Colors.amber[700], size: 22),",
      "                            const SizedBox(width: 6),",
      "                            Text(\"Overall Avg: \",",
      "                                style: textTheme.bodyMedium?.copyWith(",
      "                                  fontWeight: FontWeight.w500,",
      "                                  color: colorScheme.onSurface,",
      "                                )),",
      "                            Text(",
      "                              summary.feedbackStats?[\"averageStarRating\"] !=",
      "                                      null",
      "                                  ? (summary.feedbackStats![\"averageStarRating\"]",
      "                                          as num)",
      "                                      .toStringAsFixed(2)",
      "                                  : \"-\",",
      "                              style: textTheme.bodyLarge?.copyWith(",
      "                                fontWeight: FontWeight.bold,",
      "                                color: DesignTokens.primaryColor,",
      "                              ),",
      "                            ),",
      "                          ],",
      "                        ),",
      "                        Row(",
      "                          mainAxisSize: MainAxisSize.min,",
      "                          children: [",
      "                            Icon(Icons.people_alt_rounded,",
      "                                color: Colors.blueGrey[700], size: 20),",
      "                            const SizedBox(width: 4),",
      "                            Text(\"Feedbacks: \",",
      "                                style: textTheme.bodyMedium?.copyWith(",
      "                                  fontWeight: FontWeight.w500,",
      "                                  color: colorScheme.onSurface,",
      "                                )),",
      "                            Text(",
      "                              summary.feedbackStats?[\"totalFeedbacks\"]",
      "                                      ?.toString() ??",
      "                                  \"-\",",
      "                              style: textTheme.bodyMedium?.copyWith(",
      "                                fontWeight: FontWeight.bold,",
      "                                color: colorScheme.onSurface,",
      "                              ),",
      "                            ),",
      "                          ],",
      "                        ),",
      "                        Row(",
      "                          mainAxisSize: MainAxisSize.min,",
      "                          children: [",
      "                            Text(\"Participation Rate: \",",
      "                                style: textTheme.bodyMedium?.copyWith(",
      "                                  fontWeight: FontWeight.w500,",
      "                                  color: colorScheme.onSurface,",
      "                                )),",
      "                            Text(",
      "                              summary.feedbackStats?[\"participationRate\"] !=",
      "                                      null",
      "                                  ? \"${(summary.feedbackStats![\"participationRate\"] * 100).toStringAsFixed(1)}%\"",
      "                                  : \"-\",",
      "                              style: textTheme.bodyMedium?.copyWith(",
      "                                fontWeight: FontWeight.bold,",
      "                                color: colorScheme.onSurface,",
      "                              ),",
      "                            ),",
      "                          ],",
      "                        ),",
      "                      ],",
      "                    ),",
      "                    const SizedBox(height: 14),",
      "                    const Divider(height: 16),",
      "                    if (summary.feedbackStats?[\"orderFeedback\"] != null)",
      "                      _buildFeedbackSection(",
      "                        context,",
      "                        label: \"Order Feedback (meals, delivery)\",",
      "                        data: summary.feedbackStats![\"orderFeedback\"],",
      "                        icon: Icons.fastfood_rounded,",
      "                        iconColor: Colors.red[700]!,",
      "                      ),",
      "                    if (summary.feedbackStats?[\"appFeedback\"] != null)",
      "                      _buildFeedbackSection(",
      "                        context,",
      "                        label: \"App Feedback (ordering, UI)\",",
      "                        data: summary.feedbackStats![\"appFeedback\"],",
      "                        icon: Icons.app_settings_alt_rounded,",
      "                        iconColor: Colors.green[700]!,",
      "                      ),",
      "                  ],",
      "                ),",
      "              ),",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  Widget _buildFeedbackSection(",
      "    BuildContext context, {",
      "    required String label,",
      "    required Map data,",
      "    required IconData icon,",
      "    required Color iconColor,",
      "  }) {",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    final textTheme = Theme.of(context).textTheme;",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        Row(",
      "          children: [",
      "            Icon(icon, color: iconColor, size: 20),",
      "            const SizedBox(width: 8),",
      "            Text(",
      "              label,",
      "              style: textTheme.bodyMedium?.copyWith(",
      "                fontWeight: FontWeight.bold,",
      "                color: colorScheme.onSurface,",
      "              ),",
      "            ),",
      "            const Spacer(),",
      "            Icon(Icons.star, color: Colors.amber, size: 18),",
      "            Text(",
      "              data['avgStarRating'] != null",
      "                  ? (data['avgStarRating'] as num).toStringAsFixed(2)",
      "                  : \"-\",",
      "              style: textTheme.bodyMedium?.copyWith(",
      "                fontWeight: FontWeight.bold,",
      "                color: colorScheme.onSurface,",
      "              ),",
      "            ),",
      "          ],",
      "        ),",
      "        const SizedBox(height: 2),",
      "        if (data['count'] != null)",
      "          Padding(",
      "            padding: const EdgeInsets.only(left: 28.0),",
      "            child: Text(",
      "              \"Count: ${data['count']}\",",
      "              style: textTheme.bodySmall?.copyWith(",
      "                color: colorScheme.onSurface.withOpacity(0.6),",
      "              ),",
      "            ),",
      "          ),",
      "        if (data['avgCategories'] != null)",
      "          Padding(",
      "            padding: const EdgeInsets.only(left: 28.0, top: 6, bottom: 10),",
      "            child: Column(",
      "              crossAxisAlignment: CrossAxisAlignment.start,",
      "              children: (data['avgCategories'] as Map).entries.map<Widget>(",
      "                (entry) {",
      "                  return Padding(",
      "                    padding: const EdgeInsets.symmetric(vertical: 1),",
      "                    child: Row(",
      "                      children: [",
      "                        Icon(Icons.label_outline,",
      "                            size: 16,",
      "                            color: colorScheme.onSurface.withOpacity(0.5)),",
      "                        const SizedBox(width: 6),",
      "                        Text(",
      "                          \"${entry.key}: \",",
      "                          style: textTheme.bodySmall?.copyWith(",
      "                            fontWeight: FontWeight.w500,",
      "                            color: colorScheme.onSurface,",
      "                          ),",
      "                        ),",
      "                        Text(",
      "                          entry.value != null",
      "                              ? (entry.value as num).toStringAsFixed(2)",
      "                              : \"-\",",
      "                          style: textTheme.bodySmall?.copyWith(",
      "                            fontWeight: FontWeight.bold,",
      "                            color: DesignTokens.primaryColor,",
      "                          ),",
      "                        ),",
      "                      ],",
      "                    ),",
      "                  );",
      "                },",
      "              ).toList(),",
      "            ),",
      "          ),",
      "        const Divider(height: 18),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 233,
      "file_size": 9549,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\orders\\order_detail_dialog.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/core/models/order.dart' as order_model;",
      "import 'package:franchise_admin_portal/config/design_tokens.dart';",
      "",
      "class OrderDetailDialog extends StatelessWidget {",
      "  final order_model.Order order;",
      "",
      "  const OrderDetailDialog({super.key, required this.order});",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    final textTheme = Theme.of(context).textTheme;",
      "",
      "    return AlertDialog(",
      "      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),",
      "      backgroundColor: colorScheme.surface,",
      "      title: Text(",
      "        \"Order #${order.id}\",",
      "        style: textTheme.titleLarge?.copyWith(",
      "          fontWeight: FontWeight.bold,",
      "          color: colorScheme.onSurface,",
      "        ),",
      "      ),",
      "      content: SingleChildScrollView(",
      "        child: Column(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            Text(\"Customer: ${order.userNameDisplay}\",",
      "                style: textTheme.bodyMedium?.copyWith(",
      "                  color: colorScheme.onSurface,",
      "                )),",
      "            const SizedBox(height: 12),",
      "            Text(\"Items:\",",
      "                style: textTheme.labelLarge?.copyWith(",
      "                  fontWeight: FontWeight.bold,",
      "                  color: colorScheme.primary,",
      "                )),",
      "            const SizedBox(height: 4),",
      "            ...order.items.map(",
      "              (item) => Padding(",
      "                padding: const EdgeInsets.symmetric(vertical: 2.0),",
      "                child: Text(",
      "                  \"- ${item.name} x${item.quantity} \"",
      "                  \"(\\$${(item.price * item.quantity).toStringAsFixed(2)})\",",
      "                  style: textTheme.bodySmall?.copyWith(",
      "                    color: colorScheme.onSurface,",
      "                  ),",
      "                ),",
      "              ),",
      "            ),",
      "            const SizedBox(height: 12),",
      "            Text(",
      "              \"Total: \\$${order.total.toStringAsFixed(2)}\",",
      "              style: textTheme.bodyLarge?.copyWith(",
      "                fontWeight: FontWeight.bold,",
      "                color: colorScheme.secondary,",
      "              ),",
      "            ),",
      "            const SizedBox(height: 4),",
      "            Text(\"Status: ${order.status}\",",
      "                style: textTheme.bodyMedium?.copyWith(",
      "                  color: colorScheme.onSurface,",
      "                )),",
      "            Text(\"Placed: ${order.timestamp}\",",
      "                style: textTheme.bodyMedium?.copyWith(",
      "                  color: colorScheme.onSurface,",
      "                )),",
      "            if (order.refundStatus != null)",
      "              Text(\"Refund: ${order.refundStatus}\",",
      "                  style: textTheme.bodyMedium?.copyWith(",
      "                    color: Colors.red[700],",
      "                    fontWeight: FontWeight.w500,",
      "                  )),",
      "          ],",
      "        ),",
      "      ),",
      "      actions: [",
      "        Padding(",
      "          padding: const EdgeInsets.only(right: 12, bottom: 10),",
      "          child: TextButton(",
      "            onPressed: () => Navigator.of(context).pop(),",
      "            style: TextButton.styleFrom(",
      "              foregroundColor: colorScheme.primary,",
      "              textStyle: const TextStyle(fontWeight: FontWeight.w600),",
      "            ),",
      "            child: const Text(\"Close\"),",
      "          ),",
      "        )",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 93,
      "file_size": 3406,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\profile\\account_details_panel.dart",
    "content": [
      "// File: lib/widgets/profile/account_details_panel.dart",
      "",
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/core/models/user.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "",
      "class AccountDetailsPanel extends StatefulWidget {",
      "  final User user;",
      "  final VoidCallback? onProfileUpdated;",
      "",
      "  const AccountDetailsPanel({",
      "    Key? key,",
      "    required this.user,",
      "    this.onProfileUpdated,",
      "  }) : super(key: key);",
      "",
      "  @override",
      "  State<AccountDetailsPanel> createState() => _AccountDetailsPanelState();",
      "}",
      "",
      "class _AccountDetailsPanelState extends State<AccountDetailsPanel> {",
      "  late TextEditingController _nameController;",
      "  late TextEditingController _phoneController;",
      "  late String _language;",
      "  bool _editing = false;",
      "  bool _saving = false;",
      "  String? _error;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _nameController = TextEditingController(text: widget.user.name);",
      "    _phoneController =",
      "        TextEditingController(text: widget.user.phoneNumber ?? '');",
      "    _language = widget.user.language;",
      "  }",
      "",
      "  @override",
      "  void dispose() {",
      "    _nameController.dispose();",
      "    _phoneController.dispose();",
      "    super.dispose();",
      "  }",
      "",
      "  Future<void> _saveChanges() async {",
      "    setState(() {",
      "      _saving = true;",
      "      _error = null;",
      "    });",
      "    try {",
      "      await FirestoreService().updateUserProfile(widget.user.id, {",
      "        'name': _nameController.text.trim(),",
      "        'phoneNumber': _phoneController.text.trim(),",
      "        'language': _language,",
      "      });",
      "      setState(() => _editing = false);",
      "      widget.onProfileUpdated?.call();",
      "    } catch (e, st) {",
      "      setState(() => _error = e.toString());",
      "      await ErrorLogger.log(",
      "        message: 'Failed to update profile: $e',",
      "        stack: st.toString(),",
      "        source: 'AccountDetailsPanel',",
      "        screen: 'account_details_panel',",
      "        severity: 'error',",
      "      );",
      "    } finally {",
      "      setState(() => _saving = false);",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[AccountDetailsPanel] loc is null! Localization not available for this context.');",
      "      // Return a minimal error card or placeholder (never Scaffold from a widget)",
      "      return Card(",
      "        color: Colors.red.shade100,",
      "        child: Padding(",
      "          padding: const EdgeInsets.all(24),",
      "          child: Row(",
      "            children: [",
      "              Icon(Icons.error, color: Colors.red),",
      "              const SizedBox(width: 12),",
      "              Expanded(",
      "                  child: Text('Localization missing! [debug]',",
      "                      style: TextStyle(color: Colors.red))),",
      "            ],",
      "          ),",
      "        ),",
      "      );",
      "    }",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "",
      "    return Card(",
      "      margin: EdgeInsets.zero,",
      "      color: Theme.of(context).colorScheme.surfaceVariant.withOpacity(0.13),",
      "      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),",
      "      child: Padding(",
      "        padding: const EdgeInsets.all(24),",
      "        child: Column(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            Row(",
      "              children: [",
      "                Icon(Icons.person_outline, color: colorScheme.primary),",
      "                const SizedBox(width: 8),",
      "                Text(loc.accountDetails,",
      "                    style: Theme.of(context).textTheme.titleMedium),",
      "                const Spacer(),",
      "                if (!_editing)",
      "                  IconButton(",
      "                    icon: Icon(Icons.edit),",
      "                    tooltip: loc.edit,",
      "                    onPressed: () => setState(() => _editing = true),",
      "                  ),",
      "              ],",
      "            ),",
      "            const SizedBox(height: 18),",
      "            if (_error != null)",
      "              Padding(",
      "                padding: const EdgeInsets.only(bottom: 12),",
      "                child:",
      "                    Text(_error!, style: TextStyle(color: colorScheme.error)),",
      "              ),",
      "            _editing",
      "                ? _buildEditFields(context, loc)",
      "                : _buildViewFields(context, loc),",
      "            if (_editing)",
      "              Row(",
      "                children: [",
      "                  ElevatedButton(",
      "                    onPressed: _saving ? null : _saveChanges,",
      "                    child:",
      "                        _saving ? CircularProgressIndicator() : Text(loc.save),",
      "                  ),",
      "                  const SizedBox(width: 12),",
      "                  OutlinedButton(",
      "                    onPressed:",
      "                        _saving ? null : () => setState(() => _editing = false),",
      "                    child: Text(loc.cancel),",
      "                  ),",
      "                ],",
      "              ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  Widget _buildViewFields(BuildContext context, AppLocalizations loc) {",
      "    final user = widget.user;",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        Text('${loc.name}: ${user.name}',",
      "            style: Theme.of(context).textTheme.bodyMedium),",
      "        const SizedBox(height: 4),",
      "        Text('${loc.email}: ${user.email}',",
      "            style: Theme.of(context).textTheme.bodyMedium),",
      "        if (user.phoneNumber != null && user.phoneNumber!.isNotEmpty)",
      "          Padding(",
      "            padding: const EdgeInsets.only(top: 4),",
      "            child: Text('${loc.phone}: ${user.phoneNumber}',",
      "                style: Theme.of(context).textTheme.bodyMedium),",
      "          ),",
      "        Padding(",
      "          padding: const EdgeInsets.only(top: 4),",
      "          child: Text('${loc.language}: ${user.language}',",
      "              style: Theme.of(context).textTheme.bodyMedium),",
      "        ),",
      "        Padding(",
      "          padding: const EdgeInsets.only(top: 4),",
      "          child: Text('${loc.roles}: ${user.roles.join(\", \")}',",
      "              style: Theme.of(context).textTheme.bodyMedium),",
      "        ),",
      "        Padding(",
      "          padding: const EdgeInsets.only(top: 4),",
      "          child: Text('${loc.status}: ${user.status}',",
      "              style: Theme.of(context).textTheme.bodyMedium),",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "",
      "  Widget _buildEditFields(BuildContext context, AppLocalizations loc) {",
      "    final languageOptions = [",
      "      DropdownMenuItem(value: 'en', child: Text('English')),",
      "      // Add other supported languages here.",
      "    ];",
      "",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        TextFormField(",
      "          controller: _nameController,",
      "          decoration: InputDecoration(labelText: loc.name),",
      "        ),",
      "        const SizedBox(height: 8),",
      "        TextFormField(",
      "          controller: _phoneController,",
      "          decoration: InputDecoration(labelText: loc.phone),",
      "        ),",
      "        const SizedBox(height: 8),",
      "        DropdownButtonFormField<String>(",
      "          value: _language,",
      "          decoration: InputDecoration(labelText: loc.language),",
      "          items: languageOptions,",
      "          onChanged: (val) => setState(() => _language = val ?? 'en'),",
      "        ),",
      "        const SizedBox(height: 12),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 219,
      "file_size": 7379,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\profile\\profile_loading_gate.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/services/auth_service.dart';",
      "",
      "class ProfileLoadingGate extends StatelessWidget {",
      "  final Widget Function(BuildContext, dynamic /*app.User*/) builder;",
      "  const ProfileLoadingGate({required this.builder, Key? key}) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final profileUser = Provider.of<AuthService>(context).profileUser;",
      "    if (profileUser == null) {",
      "      return const Scaffold(",
      "        body: Center(",
      "          child: CircularProgressIndicator(),",
      "        ),",
      "      );",
      "    }",
      "    return builder(context, profileUser);",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 21,
      "file_size": 702,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\profile\\user_avatar_menu.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:firebase_auth/firebase_auth.dart' as fb_auth;",
      "import 'package:franchise_admin_portal/config/branding_config.dart';",
      "import 'package:franchise_admin_portal/core/providers/admin_user_provider.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "",
      "class UserAvatarMenu extends StatelessWidget {",
      "  final double size;",
      "  final Color? backgroundColor;",
      "  const UserAvatarMenu({Key? key, this.size = 36, this.backgroundColor})",
      "      : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final userProvider = Provider.of<AdminUserProvider>(context, listen: false);",
      "    final user = userProvider.user;",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      print(",
      "          '[UserAvatarMenu] loc is null! Localization not available for this context.');",
      "      // Return a minimal placeholder avatar with a tooltip or similar",
      "      return CircleAvatar(",
      "        radius: size / 2,",
      "        backgroundColor:",
      "            backgroundColor ?? Theme.of(context).colorScheme.surfaceVariant,",
      "        child: Icon(Icons.error, color: Colors.red),",
      "      );",
      "    }",
      "    final avatarUrl = user?.avatarUrl ??",
      "        fb_auth.FirebaseAuth.instance.currentUser?.photoURL ??",
      "        '';",
      "",
      "    return PopupMenuButton<_AvatarMenuAction>(",
      "      tooltip: loc.account ?? \"Account\",",
      "      offset: Offset(0, size + 6),",
      "      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),",
      "      onSelected: (action) async {",
      "        if (action == _AvatarMenuAction.profile) {",
      "          // Route to profile screen (update as needed)",
      "          Navigator.of(context).pushNamed('/profile');",
      "        } else if (action == _AvatarMenuAction.signout) {",
      "          await fb_auth.FirebaseAuth.instance.signOut();",
      "          Provider.of<AdminUserProvider>(context, listen: false).clear();",
      "          Navigator.of(context)",
      "              .pushNamedAndRemoveUntil('/sign-in', (_) => false);",
      "        }",
      "      },",
      "      itemBuilder: (context) => [",
      "        PopupMenuItem(",
      "          value: _AvatarMenuAction.profile,",
      "          child: ListTile(",
      "            leading: Icon(Icons.account_circle_outlined),",
      "            title: Text(loc.account ?? \"Profile\"),",
      "          ),",
      "        ),",
      "        PopupMenuItem(",
      "          value: _AvatarMenuAction.signout,",
      "          child: ListTile(",
      "            leading: Icon(Icons.logout),",
      "            title: Text(loc.signOut ?? \"Sign out\"),",
      "          ),",
      "        ),",
      "      ],",
      "      child: CircleAvatar(",
      "        radius: size / 2,",
      "        backgroundColor:",
      "            backgroundColor ?? Theme.of(context).colorScheme.surfaceVariant,",
      "        backgroundImage: avatarUrl.isNotEmpty",
      "            ? NetworkImage(avatarUrl)",
      "            : AssetImage(BrandingConfig.defaultProfileIcon) as ImageProvider,",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "enum _AvatarMenuAction { profile, signout }"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 77,
      "file_size": 2951,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\settings\\about_section.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "",
      "class AboutSection extends StatelessWidget {",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    // Replace with actual build/version in a real app",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        Text(\"About\", style: Theme.of(context).textTheme.titleMedium),",
      "        const SizedBox(height: 8),",
      "        Text(\"Doughboys Franchise Admin Portal\"),",
      "        Text(\"Version: 1.0.0 (build 100)\"),",
      "        const SizedBox(height: 8),",
      "        Text(\"© 2025 Doughboys Inc. All rights reserved.\",",
      "            style: Theme.of(context).textTheme.bodySmall),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 20,
      "file_size": 677,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\settings\\feedback_button.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "",
      "class FeedbackButton extends StatelessWidget {",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return OutlinedButton.icon(",
      "      onPressed: () {",
      "        ScaffoldMessenger.of(context).showSnackBar(",
      "            const SnackBar(content: Text('Feedback coming soon!')));",
      "      },",
      "      icon: const Icon(Icons.feedback_outlined),",
      "      label: const Text(\"Feedback\"),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 15,
      "file_size": 437,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\settings\\keyboard_shortcuts_section.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "",
      "class KeyboardShortcutsSection extends StatelessWidget {",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        Text(\"Keyboard Shortcuts\",",
      "            style: Theme.of(context).textTheme.titleMedium),",
      "        const SizedBox(height: 8),",
      "        Text(\"Shortcuts coming soon!\",",
      "            style: Theme.of(context).textTheme.bodySmall),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 17,
      "file_size": 506,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\settings\\language_selector.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "",
      "class LanguageSelector extends StatelessWidget {",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    // Replace with actual languages when available",
      "    final languages = const [",
      "      DropdownMenuItem(value: 'en', child: Text('English')),",
      "      DropdownMenuItem(",
      "          value: 'es',",
      "          child: Text('Español (coming soon)',",
      "              style: TextStyle(color: Colors.grey))),",
      "    ];",
      "",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        Text(\"Language\", style: Theme.of(context).textTheme.titleMedium),",
      "        const SizedBox(height: 10),",
      "        DropdownButtonFormField(",
      "          value: 'en',",
      "          items: languages,",
      "          onChanged: (val) {",
      "            // TODO: Handle language change and persist selection",
      "            ScaffoldMessenger.of(context).showSnackBar(",
      "                const SnackBar(content: Text('Language change coming soon!')));",
      "          },",
      "          decoration: const InputDecoration(",
      "            border: OutlineInputBorder(),",
      "          ),",
      "        ),",
      "        const SizedBox(height: 4),",
      "        Text(\"More languages coming soon...\",",
      "            style: Theme.of(context).textTheme.bodySmall),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 38,
      "file_size": 1279,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\settings\\legal_section.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "",
      "class LegalSection extends StatelessWidget {",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        Text(\"Legal\", style: Theme.of(context).textTheme.titleMedium),",
      "        const SizedBox(height: 8),",
      "        TextButton(",
      "          onPressed: () {",
      "            // TODO: Link or open dialog",
      "            ScaffoldMessenger.of(context).showSnackBar(",
      "                const SnackBar(content: Text('Terms coming soon!')));",
      "          },",
      "          child: const Text(\"Terms of Service\"),",
      "        ),",
      "        TextButton(",
      "          onPressed: () {",
      "            // TODO: Link or open dialog",
      "            ScaffoldMessenger.of(context).showSnackBar(",
      "                const SnackBar(content: Text('Privacy coming soon!')));",
      "          },",
      "          child: const Text(\"Privacy Policy\"),",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 30,
      "file_size": 956,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\settings\\settings_dialog.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:franchise_admin_portal/widgets/settings/theme_mode_selector.dart';",
      "import 'package:franchise_admin_portal/widgets/settings/language_selector.dart';",
      "import 'package:franchise_admin_portal/widgets/settings/about_section.dart';",
      "import 'package:franchise_admin_portal/widgets/settings/legal_section.dart';",
      "import 'package:franchise_admin_portal/widgets/settings/keyboard_shortcuts_section.dart';",
      "import 'package:franchise_admin_portal/widgets/settings/support_chat_button.dart';",
      "import 'package:franchise_admin_portal/widgets/settings/feedback_button.dart';",
      "",
      "class SettingsDialog extends StatelessWidget {",
      "  const SettingsDialog({Key? key}) : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "    return Dialog(",
      "      backgroundColor: colorScheme.background,",
      "      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),",
      "      child: SingleChildScrollView(",
      "        padding: const EdgeInsets.all(28),",
      "        child: Column(",
      "          crossAxisAlignment: CrossAxisAlignment.start,",
      "          children: [",
      "            Text(\"Settings\", style: Theme.of(context).textTheme.headlineSmall),",
      "            const SizedBox(height: 24),",
      "            ThemeModeSelector(),",
      "            const SizedBox(height: 16),",
      "            LanguageSelector(),",
      "            const Divider(height: 32),",
      "            AboutSection(),",
      "            const Divider(height: 32),",
      "            LegalSection(),",
      "            const Divider(height: 32),",
      "            KeyboardShortcutsSection(),",
      "            const Divider(height: 32),",
      "            Row(",
      "              children: [",
      "                SupportChatButton(),",
      "                const SizedBox(width: 20),",
      "                FeedbackButton(),",
      "              ],",
      "            ),",
      "            const SizedBox(height: 8),",
      "            Align(",
      "              alignment: Alignment.bottomRight,",
      "              child: TextButton(",
      "                onPressed: () => Navigator.of(context).pop(),",
      "                child: const Text(\"Close\"),",
      "              ),",
      "            ),",
      "          ],",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 56,
      "file_size": 2188,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\settings\\support_chat_button.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "",
      "class SupportChatButton extends StatelessWidget {",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return OutlinedButton.icon(",
      "      onPressed: () {",
      "        ScaffoldMessenger.of(context).showSnackBar(",
      "            const SnackBar(content: Text('Support chat coming soon!')));",
      "      },",
      "      icon: const Icon(Icons.chat_bubble_outline),",
      "      label: const Text(\"Support Chat\"),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 15,
      "file_size": 450,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\settings\\theme_mode_selector.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/theme_provider.dart';",
      "",
      "class ThemeModeSelector extends StatelessWidget {",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final themeProvider = Provider.of<ThemeProvider>(context);",
      "    final isDark = themeProvider.themeMode == ThemeMode.dark;",
      "    final isSystem = themeProvider.themeMode == ThemeMode.system;",
      "",
      "    return Column(",
      "      crossAxisAlignment: CrossAxisAlignment.start,",
      "      children: [",
      "        Text(\"Theme\", style: Theme.of(context).textTheme.titleMedium),",
      "        const SizedBox(height: 10),",
      "        Row(",
      "          children: [",
      "            ChoiceChip(",
      "              label: const Text(\"Light\"),",
      "              selected: themeProvider.themeMode == ThemeMode.light,",
      "              onSelected: (_) => themeProvider.setThemeMode(ThemeMode.light),",
      "            ),",
      "            const SizedBox(width: 8),",
      "            ChoiceChip(",
      "              label: const Text(\"Dark\"),",
      "              selected: isDark,",
      "              onSelected: (_) => themeProvider.setThemeMode(ThemeMode.dark),",
      "            ),",
      "            const SizedBox(width: 8),",
      "            ChoiceChip(",
      "              label: const Text(\"System\"),",
      "              selected: isSystem,",
      "              onSelected: (_) => themeProvider.setThemeMode(ThemeMode.system),",
      "            ),",
      "          ],",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 41,
      "file_size": 1446,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\staff\\show_add_staff_dialog.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:franchise_admin_portal/core/services/firestore_service.dart';",
      "import 'package:franchise_admin_portal/core/providers/franchise_provider.dart';",
      "import 'package:franchise_admin_portal/core/utils/error_logger.dart';",
      "",
      "class AddStaffDialog extends StatefulWidget {",
      "  final AppLocalizations loc;",
      "  const AddStaffDialog({super.key, required this.loc});",
      "",
      "  @override",
      "  State<AddStaffDialog> createState() => _AddStaffDialogState();",
      "}",
      "",
      "class _AddStaffDialogState extends State<AddStaffDialog> {",
      "  final _formKey = GlobalKey<FormState>();",
      "  String _name = '';",
      "  String _email = '';",
      "  String _role = 'staff';",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context);",
      "    if (loc == null) {",
      "      ErrorLogger.log(",
      "        message:",
      "            'AppLocalizations.of(context) returned null in AddStaffDialog.',",
      "        source: 'show_add_staff_dialog.dart',",
      "        screen: 'AddStaffDialog',",
      "        severity: 'error',",
      "        contextData: {",
      "          'widget': 'AddStaffDialog',",
      "          'location': 'build()',",
      "        },",
      "      );",
      "      return const AlertDialog(",
      "        content: Text('Localization missing – AddStaffDialog'),",
      "      );",
      "    }",
      "",
      "    final service = Provider.of<FirestoreService>(context, listen: false);",
      "    final franchiseId =",
      "        Provider.of<FranchiseProvider>(context, listen: false).franchiseId;",
      "    final colorScheme = Theme.of(context).colorScheme;",
      "",
      "    return AlertDialog(",
      "      backgroundColor: colorScheme.background,",
      "      surfaceTintColor: Colors.transparent,",
      "      title: Text(",
      "        loc.staffAddStaffDialogTitle,",
      "        style: TextStyle(",
      "          color: colorScheme.onBackground,",
      "          fontWeight: FontWeight.bold,",
      "          fontSize: 20,",
      "        ),",
      "      ),",
      "      content: SingleChildScrollView(",
      "        child: Form(",
      "          key: _formKey,",
      "          child: Column(",
      "            mainAxisSize: MainAxisSize.min,",
      "            children: [",
      "              TextFormField(",
      "                decoration: InputDecoration(",
      "                  labelText: loc.staffNameLabel,",
      "                ),",
      "                validator: (v) => (v == null || v.trim().isEmpty)",
      "                    ? loc.staffNameRequired",
      "                    : null,",
      "                onSaved: (v) => _name = v!.trim(),",
      "              ),",
      "              const SizedBox(height: 8),",
      "              TextFormField(",
      "                decoration: InputDecoration(",
      "                  labelText: loc.staffEmailLabel,",
      "                ),",
      "                validator: (v) => (v == null || v.trim().isEmpty)",
      "                    ? loc.staffEmailRequired",
      "                    : null,",
      "                onSaved: (v) => _email = v!.trim(),",
      "                keyboardType: TextInputType.emailAddress,",
      "              ),",
      "              const SizedBox(height: 8),",
      "              DropdownButtonFormField<String>(",
      "                value: _role,",
      "                decoration: InputDecoration(",
      "                  labelText: loc.staffRoleLabel,",
      "                ),",
      "                items: [",
      "                  DropdownMenuItem(",
      "                      value: 'owner', child: Text(loc.staffRoleOwner)),",
      "                  DropdownMenuItem(",
      "                      value: 'manager', child: Text(loc.staffRoleManager)),",
      "                  DropdownMenuItem(",
      "                      value: 'staff', child: Text(loc.staffRoleStaff)),",
      "                ],",
      "                onChanged: (v) => setState(() => _role = v!),",
      "              ),",
      "            ],",
      "          ),",
      "        ),",
      "      ),",
      "      actions: [",
      "        TextButton(",
      "          onPressed: () => Navigator.of(context).pop(),",
      "          child: Text(",
      "            loc.cancelButton,",
      "            style: TextStyle(color: colorScheme.secondary),",
      "          ),",
      "        ),",
      "        ElevatedButton(",
      "          style: ElevatedButton.styleFrom(",
      "            backgroundColor: colorScheme.primary,",
      "            foregroundColor: colorScheme.onPrimary,",
      "          ),",
      "          onPressed: () async {",
      "            if (_formKey.currentState!.validate()) {",
      "              _formKey.currentState!.save();",
      "              try {",
      "                await service.addStaffUser(",
      "                  name: _name,",
      "                  email: _email,",
      "                  roles: [_role],",
      "                  franchiseIds: [franchiseId],",
      "                );",
      "                if (!mounted) return;",
      "                Navigator.of(context).pop();",
      "              } catch (e, stack) {",
      "                await ErrorLogger.log(",
      "                  message: e.toString(),",
      "                  stack: stack.toString(),",
      "                  source: 'staff_access_screen',",
      "                  screen: 'AddStaffDialog',",
      "                  severity: 'error',",
      "                  contextData: {",
      "                    'franchiseId': franchiseId,",
      "                    'name': _name,",
      "                    'email': _email,",
      "                    'role': _role,",
      "                    'operation': 'add_staff',",
      "                  },",
      "                );",
      "              }",
      "            }",
      "          },",
      "          child: Text(loc.staffAddButton),",
      "        ),",
      "      ],",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 152,
      "file_size": 5275,
      "file_type": ".dart",
      "parse_status": "success"
    }
  },
  {
    "file_path": "C:/Users/jying/franchise_platform/admin_portal/lib\\widgets\\subscription\\grace_period_banner.dart",
    "content": [
      "import 'package:flutter/material.dart';",
      "import 'package:flutter_gen/gen_l10n/app_localizations.dart';",
      "import 'package:provider/provider.dart';",
      "import 'package:intl/intl.dart';",
      "",
      "import 'package:franchise_admin_portal/core/providers/franchise_subscription_provider.dart';",
      "import 'package:franchise_admin_portal/core/providers/role_guard.dart';",
      "",
      "/// A banner widget that alerts HQ owners or developers if their subscription is overdue or in grace period.",
      "class GracePeriodBanner extends StatelessWidget {",
      "  final bool forceElevated;",
      "",
      "  const GracePeriodBanner({Key? key, this.forceElevated = false})",
      "      : super(key: key);",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final loc = AppLocalizations.of(context)!;",
      "    final theme = Theme.of(context);",
      "    final subscription =",
      "        context.watch<FranchiseSubscriptionNotifier>().currentSubscription;",
      "",
      "    // Don't show anything if subscription is missing or valid",
      "    if (subscription == null || !subscription.hasOverdueInvoice) {",
      "      return const SizedBox.shrink();",
      "    }",
      "",
      "    final graceEndsAt = subscription.gracePeriodEndsAt;",
      "    final isInGracePeriod =",
      "        graceEndsAt != null && DateTime.now().isBefore(graceEndsAt);",
      "    final hasExpired =",
      "        graceEndsAt != null && DateTime.now().isAfter(graceEndsAt);",
      "",
      "    // Customize banner content",
      "    final bannerMessage = isInGracePeriod",
      "        ? loc.gracePeriodWarning(DateFormat.yMMMMd().format(graceEndsAt))",
      "        : loc.gracePeriodExpired;",
      "",
      "    final actionLabel = loc.manageSubscription;",
      "",
      "    return RoleGuard(",
      "      allowedRoles: const ['hq_owner', 'developer', 'platform_owner'],",
      "      child: MaterialBanner(",
      "        backgroundColor: theme.colorScheme.error.withOpacity(0.1),",
      "        contentTextStyle: theme.textTheme.bodyMedium?.copyWith(",
      "          color: theme.colorScheme.onErrorContainer,",
      "        ),",
      "        leading: Icon(Icons.warning_rounded, color: theme.colorScheme.error),",
      "        content: Text(bannerMessage),",
      "        actions: [",
      "          TextButton(",
      "            onPressed: () {",
      "              Navigator.of(context).pushNamed('/platform/plans');",
      "            },",
      "            child: Text(",
      "              actionLabel,",
      "              style: TextStyle(color: theme.colorScheme.primary),",
      "            ),",
      "          ),",
      "        ],",
      "        elevation: forceElevated ? 1 : 0,",
      "      ),",
      "    );",
      "  }",
      "}"
    ],
    "separator": "===FILE_BREAK===",
    "metadata": {
      "line_count": 65,
      "file_size": 2381,
      "file_type": ".dart",
      "parse_status": "success"
    }
  }
]